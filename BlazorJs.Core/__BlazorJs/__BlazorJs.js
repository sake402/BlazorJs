class BlazorJs_Core_BrowserApplicationBuilder extends object
{
    /*BrowserServiceProvider*/ _backingField_Services = null;
    /*BrowserServiceProvider*/ get Services()
    {
        return _backingField_Services;
    }
    /*DefaultComponentActivator*/ _backingField_ComponentActivator = null;
    /*DefaultComponentActivator*/ get ComponentActivator()
    {
        return _backingField_ComponentActivator;
    }
    /*BrowserNativeRenderer*/ _backingField_Renderer = null;
    /*BrowserNativeRenderer*/ get Renderer()
    {
        return _backingField_Renderer;
    }
    /*BrowserNativeNavigationManager*/ _backingField_NavigationManager = null;
    /*BrowserNativeNavigationManager*/ get NavigationManager()
    {
        return _backingField_NavigationManager;
    }
    /*BrowserNativeErrorBoundaryLogger*/ _backingField_ErrorBoundaryLogger = null;
    /*BrowserNativeErrorBoundaryLogger*/ get ErrorBoundaryLogger()
    {
        return _backingField_ErrorBoundaryLogger;
    }
    /*BrowserJavascriptRuntime*/ _backingField_JavascriptRuntime = null;
    /*BrowserJavascriptRuntime*/ get JavascriptRuntime()
    {
        return _backingField_JavascriptRuntime;
    }
    /*HttpClient*/ _backingField_Http = null;
    /*HttpClient*/ get Http()
    {
        return _backingField_Http;
    }
    constructor()
    {
        super();
        Services = new BrowserServiceProvider();
        NavigationManager = new BrowserNativeNavigationManager();
        Http = new HttpClient();
        ErrorBoundaryLogger = new BrowserNativeErrorBoundaryLogger();
        JavascriptRuntime = new BrowserJavascriptRuntime();
        Services.AddSingleton(IServiceProvider, Services);
        Services.AddSingleton(NavigationManager).AddSingleton(NavigationManager, NavigationManager).AddSingleton(INavigationInterception, NavigationManager);
        Services.AddSingleton(IErrorBoundaryLogger, ErrorBoundaryLogger);
        Services.AddSingleton(IJSRuntime, JavascriptRuntime);
        Services.AddSingleton(Http);
        ComponentActivator = new DefaultComponentActivator(Services);
        Renderer = new BrowserNativeRenderer(Services, ComponentActivator);
    }
    /*BrowserApplicationBuilder*/ static Create({ /*Action<BrowserApplicationBuilder>*/ build = null})
    {
        /*var*/ let app = new BrowserApplicationBuilder();
        build?.Invoke(app);
        return app;
    }
    /*BrowserApplicationBuilder*/ static Create(TRootComponent, { /*Action<BrowserApplicationBuilder>*/ build = null, /*Action<TRootComponent>*/ buildComponent = null})
    {
        /*var*/ let app = new BrowserApplicationBuilder();
        app.Renderer.Add(TRootComponent, buildComponent);
        build?.Invoke(app);
        return app;
    }
}

class BlazorJs_Core_BrowserJavascriptRuntime extends Microsoft_JSInterop_JSRuntime
{
    constructor()
    {
        super();
    }
    /*void*/ BeginInvokeJS(/*long*/ taskId, /*string*/ identifier, /*string*/ argsJson, /*JSCallResultType*/ resultType, /*long*/ targetInstanceId)
    {
        throw new NotImplementedException();
    }
    /*void*/ BeginInvokeJS(/*in JSInvocationInfo*/ invocationInfo)
    {
        throw new NotImplementedException();
    }
    /*void*/ EndInvokeDotNet(/*DotNetInvocationInfo*/ invocationInfo, /*in DotNetInvocationResult*/ invocationResult)
    {
        throw new NotImplementedException();
    }
}

class BlazorJs_Core_BrowserNativeDispatcher extends Microsoft_AspNetCore_Components_Dispatcher
{
    constructor()
    {
        super();
    }
    /*bool*/ CheckAccess()
    {
        return true;
    }
    /*Task*/ InvokeAsync(/*Action*/ workItem)
    {
        workItem();
        return Task.CompletedTask;
    }
    /*Task*/ InvokeAsync(/*Func<Task>*/ workItem)
    {
        return workItem();
    }
    /*Task<TResult>*/ InvokeAsync(TResult, /*Func<TResult>*/ workItem)
    {
        /*var*/ let t = workItem();
        return Task.FromResult(t);
    }
    /*Task<TResult>*/ InvokeAsync(TResult, /*Func<Task<TResult>>*/ workItem)
    {
        return workItem();
    }
}

class BlazorJs_Core_BrowserNativeErrorBoundaryLogger extends Microsoft_AspNetCore_Components_Web_IErrorBoundaryLogger(object)
{
    constructor()
    {
        super();
    }
    /*Task*/ LogErrorAsync(/*Exception*/ exception)
    {
        Console.Write(exception.Message);
        return Task.CompletedTask;
    }
}

class BlazorJs_Core_BrowserNativeNavigationManager extends Microsoft_AspNetCore_Components_Routing_INavigationInterception(Microsoft_AspNetCore_Components_NavigationManager)
{
    constructor()
    {
        super();
        Initialize("", window.location.pathname  + window.location.search  + window.location.hash);
        EnableNavigationInterceptionAsync().FireAndForget();
    }
    /*void*/ LinkClicked(/*Event*/ _event)
    {
        /*var*/ let href = (BlazorJs.Cast(_event.currentTarget, HTMLElement)).getAttribute("href");
        _event.preventDefault();
        /*var*/ let currentHRef = window.location.href  + window.location.search;
        if (currentHRef.Equals(href, StringComparison.InvariantCultureIgnoreCase))
        {
            NavigateToCore(href, BlazorJs.PopulateProperty(new NavigationOptions(), function(/*NavigationOptions*/ $obj)
            {
            }), { isIntercepted : true }).FireAndForget();
        }
    }
    /*void*/ LinkMutationCallback(/*MutationRecord[]*/ mutations, /*MutationObserver*/ observer)
    {
        for(/*int*/ let i = 0; i < mutations.Length; i++)
        {
            BlazorJs.forEach(mutations[i].addedNodes, function(item, $_i)
            {
                if (item.nodeName.Equals("A", StringComparison.InvariantCultureIgnoreCase))
                item.addEventListener("click", LinkClicked);
            });
        }
    }
    /*bool*/ enabledNavigationInterception = null;
    /*Task*/ EnableNavigationInterceptionAsync()
    {
        if (enabledNavigationInterception)
        {
            enabledNavigationInterception = true;
            /*var*/ let observer = new MutationObserver(LinkMutationCallback);
            observer.observe(document.body, BlazorJs.PopulateProperty(new MutationObserverInit(), function(/*MutationObserverInit*/ $obj)
            {
                $obj.childList = true;
                $obj.attributeFilter = [ "href" ];
                $obj.subtree = true;
            }));
            /*var*/ let links = document.querySelectorAll("*[href]");
            links.FirstOrDefault(function(/**/ link)
            {
                link.addEventListener("click", LinkClicked);
                return false;
            });
            window.addEventListener("popstate", function(/*Event*/ _event)
            {
                /*var*/ let popEvent = BlazorJs.Cast(_event, PopStateEvent);
                NavigateToCore(window.location.pathname  + window.location.search  + window.location.hash, BlazorJs.PopulateProperty(new NavigationOptions(), function(/*NavigationOptions*/ $obj)
                {
                    $obj.HistoryEntryState = popEvent.state ;
                }), { isIntercepted : false }).FireAndForget();
            });
        }
        return Task.CompletedTask;
    }
    /*void*/ NavigateToCore(/*string*/ uri, /*NavigationOptions*/ options)
    {
        NavigateToCore(uri, options, { isIntercepted : false }).FireAndForget();
    }
    /*Task*/ async NavigateToCore(/*string*/ uri, /*NavigationOptions*/ options, /*bool*/ isIntercepted)
    {
        /*var*/ let _continue = await NotifyLocationChangingAsync(uri, options.HistoryEntryState, isIntercepted);
        if (_continue)
        {
            if (options.ForceLoad)
            {
                window.location.href  = uri;
            }
            else 
            {
                if (options.ReplaceHistoryEntry)
                {
                    window.history.replaceState(null, "", uri);
                }
                else 
                {
                    window.history.pushState(null, "", uri);
                }
            }
            Uri = uri;
            NotifyLocationChanged(isIntercepted);
        }
    }
    /*bool*/ navigationLocked = null;
    /*void*/ SetNavigationLockState(/*bool*/ value)
    {
        navigationLocked = value;
    }
}

class BlazorJs_Core_BrowserNativeRenderer extends BlazorJs_Core_IRenderer(Microsoft_AspNetCore_Components_RenderTree_Renderer)
{
    /*//class RegistryEntry
        //{
        //    public Node.Interface element;
        //    public int id;
        //}

        UIFrame*/ rootFragment = null;
    /*object*/ registries = new object();
    /*Dispatcher*/ _dispatcher = null;
    constructor(/*IServiceProvider*/ services, /*IComponentActivator*/ componentActivator)
    {
        super();
        Services = services;
        rootFragment = new UIFrame(this);
        rootFragment.Elements  = document.body ;
        ComponentActivator = componentActivator;
    }
    /*IServiceProvider*/ _backingField_Services = null;
    /*IServiceProvider*/ get Services()
    {
        return _backingField_Services;
    }
    /*IComponentActivator*/ _backingField_ComponentActivator = null;
    /*IComponentActivator*/ get ComponentActivator()
    {
        return _backingField_ComponentActivator;
    }
    /*Dispatcher*/ get Dispatcher()
    {
        if (_dispatcher === null)
        _dispatcher = Dispatcher.CreateDefault();
        return _dispatcher;
    }
    /*void*/ Add(/*RenderFragment*/ fragment)
    {
        fragment(rootFragment);
    }
    /*void*/ Add(T, { /*Action<T>*/ attributeBuilder = null})
    {
        rootFragment.Component(T, attributeBuilder, { sequenceNumber : int.MaxValue });
    }
    /*int*/ static GetUID(/*IUIContent*/ content)
    {
        if (content === null)
        return 0;
        if (content.State.Key  === null)
        {
            return content.State.Id;
        }
        return content.State.Id  + 86438565 * content.State.Key.GetHashCode();
    }
    /*//Node Text(string txt, int id)
        //{
        //    var e = document.createTextNode(txt);
        //    return e;
        //}

        //HTMLElement Element(string tag, int id)
        //{
        //    var e = document.createElement(tag);
        //    return e;
        //}

        //ShadowRoot Component(string tag, int id, int parentId)
        //{
        //    //if (!definedComponents.includes(tag))
        //    //{
        //    //customElements.define(tag, Component, { extends: "div" });
        //    //}
        //    var parent = GetRegistry(parentId);
        //    ShadowRoot shadow;
        //    if (parent.element is ShadowRoot eshadow)
        //    {
        //        eshadow.
        //    }
        //    else
        //    {
        //        var shadow = ((HTMLElement)parent.element).attachShadow(new ShadowRootInit { mode = Literals.Options.mode.open });
        //    }
        //    //var e = document.createElement(tag);
        //    AddRegistry(id, new RegistryEntry { id = id, element = shadow });
        //    return shadow;
        //    //return e;
        //}

        //HTMLElement Region(int id)
        //{
        //    var e = document.createElement("region");
        //    AddRegistry(id, new RegistryEntry { id = id, element = e });
        //    return e;
        //}

        //void Update(IUIContent frame, string txt)
        //{
        //    //var registry = GetRegistry(id);
        //    //if (registry.element is HTMLElement element)
        //    //{
        //    frame.State.Element.textContent = txt;
        //    //}
        //}

        Node.Interface*/ GetParentElement(/*IUIContent*/ element)
    {
        /*var*/ let parentElement = element.State.ParentFrame;
        while(parentElement.State.Elements  === null)
        {
            parentElement = parentElement.State.ParentFrame;
            if (parentElement === null)
            {
                return rootFragment.Elements[0];
            }
        }
        return parentElement.State.Elements[0];
    }
    /*Node.Interface*/ GetFirstElementAfter(/*IUIContent*/ element)
    {
        /*var*/ let after = element.GetAfter();
        while(after !== null)
        {
            if (after.State.Elements  !== null)
            {
                return after.State.Elements[0];
            }
            if (after instanceof UIFrame, frame = after && frame.Children  !== null)
            {
                BlazorJs.forEach(frame.Children, function(c, $_i)
                {
                    /*var*/ let first = GetFirstElementAfter(c);
                    if (first !== null)
                    return first;
                });
            }
            if (after.State.Component  !== null && after.State.Children  !== null)
            {
                BlazorJs.forEach(after.State.Children, function(c, $_i)
                {
                    /*var*/ let first = GetFirstElementAfter(c);
                    if (first !== null)
                    return first;
                });
            }
            after = after.GetAfter();
        }
        return null;
    }
    /*void*/ Insert(/*IUIContent*/ frame, /*IUIContent*/ parent, /*IUIContent*/ before)
    {
        /*var*/ let useElement = parent.State.Elements?[0];
        /*var*/ let reference = before?.State.Elements?.Length > 0 ? before?.State.Elements[0] : null;
        if (parent.State.Elements  === null)
        {
            useElement = GetParentElement(parent);
            if (reference === null)
            {
                reference = GetFirstElementAfter(parent);
            }
        }
        if (reference !== null)
        {
            frame.State.Elements.ForEach(function(/**/ el)
            {
                useElement.insertBefore(el, BlazorJs.Cast(reference, Node));
            });
        }
        else 
        {
            frame.State.Elements.ForEach(function(/**/ el)
            {
                useElement.appendChild(el);
            });
        }
    }
    /*void*/ CreateElement(/*UIElement*/ element)
    {
        /*var*/ let insertBefore = element.GetAfter();
        /*var*/ let melement = document.createElement(element.Tag);
        element.Elements  = melement;
        Insert(element, element.State.ParentFrame, insertBefore);
    }
    /*void*/ CreateRegion(/*UIFrame*/ frame)
    {
    }
    /*void*/ RemoveRegion(/*UIFrame*/ frame)
    {
    }
    /*void*/ CreateComponent(/*IComponent*/ component)
    {
    }
    /*void*/ RemoveComponent(/*IComponent*/ component)
    {
    }
    /*void*/ CreateText(/*UIText*/ text)
    {
        /*var*/ let insertBefore = text.GetAfter();
        /*var*/ let element = document.createTextNode(text.Text?.ToString());
        text.Elements  = element;
        Insert(text, text.State.ParentFrame, insertBefore);
    }
    /*void*/ UpdateText(/*UIText*/ text)
    {
        text.State.Elements[0].textContent  = text.Text?.ToString();
    }
    /*void*/ RemoveElement(/*UIElement*/ element)
    {
        /*var*/ let parent = GetParentElement(element);
        parent.removeChild(element.State.Elements[0]);
    }
    /*void*/ RemoveText(/*UIText*/ text)
    {
        /*var*/ let parent = GetParentElement(text);
        parent.removeChild(text.State.Elements[0]);
    }
    /*void*/ SetElementAttribute(/*UIElement*/ element, /*string*/ key, /*object*/ value)
    {
        if (key.StartsWith("@on") && value instanceof IEventCallback, evc = value)
        {
            /*var*/ let eventName = key.Substring(3).Split(':')[0];
            /*var*/ let existingEvent = element.State.Elements[0]["__" + eventName + "__"];
            element.State.Elements[0].removeEventListener(eventName, BlazorJs.Cast(existingEvent, EventListener));
            /*EventListener*/ let evl = function(/**/ ev)
            {
                evc.InvokeAsync(ev).ContinueWith(function(/**/ t)
                {
                    if (t.Exception  !== null)
                    {
                        System.Console.WriteLine(t.Exception);
                    }
                }).FireAndForget();
                if (evc.Flags.HasFlag(EventCallbackFlags.StopPropagation))
                ev.stopPropagation();
                if (evc.Flags.HasFlag(EventCallbackFlags.PreventDefault))
                ev.preventDefault();
            };
            element.State.Elements[0].addEventListener(eventName, evl);
            element.State.Elements[0]["__" + eventName + "__"] = evl;
        }
        else 
        {
            /*bool*/ let isInput = H5.Script.InstanceOf(element.Elements[0], HTMLInputElement);
            if (isInput && key === "value")
            {
                (BlazorJs.Cast(element.Elements[0], HTMLInputElement)).value  = value?.ToString();
            }
            else if (isInput && key === "readonly")
            {
                (BlazorJs.Cast(element.Elements[0], HTMLInputElement)).readOnly  = value.As(bool);
            }
            else if (value)
            {
                if (element.State.Elements[0] instanceof HTMLElement)
                {
                    if (melement.attributes.getNamedItem(key) !== null)
                    melement.attributes.removeNamedItem(key);
                }
            }
            else 
            {
                /*var*/ let atr = document.createAttribute(key);
                atr.value  = value.ToString();
                if (element.State.Elements[0] instanceof HTMLElement)
                {
                    melement.attributes.setNamedItem(atr);
                }
            }
        }
    }
    /*void*/ CreateMarkup(/*UIMarkup*/ markup)
    {
        /*var*/ let insertBefore = markup.GetAfter();
        /*var*/ let template = BlazorJs.Cast(document.createElement("template"), HTMLTemplateElement);
        template.innerHTML  = markup.Markup;
        /*//make sure to clone the NodeList as insert into parent will remove it from the list
            var*/ let nodes = template.content.childNodes.As(BlazorJs.TypeArray(Node.Interface));
        /*var*/ let elements = new Array(nodes.Length);
        /*int*/ let i = 0;
        nodes.ForEach(function(/**/ n)
        {
            return elements[i++] = n;
        });
        markup.Elements  = elements;
        Insert(markup, markup.State.ParentFrame, insertBefore);
    }
    /*void*/ UpdateMarkup(/*UIMarkup*/ markup)
    {
        RemoveMarkup(markup);
        CreateMarkup(markup);
    }
    /*void*/ RemoveMarkup(/*UIMarkup*/ markup)
    {
        /*var*/ let parent = GetParentElement(markup);
        markup.Elements.ForEach(function(/**/ el)
        {
            parent.removeChild(el);
        });
    }
    /*void*/ Flush()
    {
    }
    /*void*/ Register(/*int*/ frameId, /*UIFrameState*/ state)
    {
        registries.SetValue(frameId, state);
    }
    /*void*/ Remove(/*int*/ frameId)
    {
        registries.Remove(frameId);
    }
    /*UIFrameState*/ GetState(/*int*/ frameId)
    {
        let state = null;
        let $ref1 = { set value(v){ state = v } };
        if (registries.TryGetValue(frameId, $ref1))
        {
            /*var*/ let mstate = BlazorJs.Cast(state, UIFrameState);
            return mstate;
        }
        return null;
    }
    /*UIFrameState*/ GetRequiredState(/*int*/ frameId)
    {
        return BlazorJs.FirstOf(GetState(frameId), function(){ throw new InvalidOperationException(`Component with id ${frameId} not found`) });
    }
    /*void*/ AddToRenderQueue(/*int*/ componentId, /*RenderFragment*/ renderFragment)
    {
        /*var*/ let mstate = GetRequiredState(componentId);
        mstate.TrackContents(function()
        {
            renderFragment(mstate);
        });
        /*var*/ let scope = (BlazorJs.Cast(renderFragment, object))["$scope"];
        if (scope instanceof IHandleAfterRender, haf = scope)
        {
            haf.OnAfterRenderAsync().FireAndForget();
        }
    }
    /*void*/ HandleComponentException(/*Exception*/ exception, /*int*/ componentId)
    {
        HandleExceptionViaErrorBoundary(exception, GetRequiredState(componentId));
    }
    /*void*/ HandleExceptionViaErrorBoundary(/*Exception*/ error, /*UIFrameState*/ errorSourceOrNull)
    {
        Dispatcher.AssertAccess();
        if (error instanceof NavigationException)
        {
            HandleException(error);
            return ;
        }
        /*// Find the closest error boundary, if any
            var*/ let candidate = errorSourceOrNull;
        while(candidate !== null)
        {
            if (candidate.Component  instanceof IErrorBoundary)
            {
                AddToRenderQueue(candidate.Id, function(/**/ _, /**/ __)
                {
                });
                try
                {
                    errorBoundary.HandleException(error);
                }
                catch(errorBoundaryException)
                {
                    HandleException(errorBoundaryException);
                }
                return ;
            }
            candidate = candidate.ParentFrame.State;
        }
        HandleException(error);
    }
}

class BlazorJs_Core_DisposableDelegate extends System_IDisposable(object)
{
    /*Action*/ dispose = null;
    constructor(/*Action*/ dispose)
    {
        super();
        this.dispose  = dispose;
    }
    /*void*/ Dispose()
    {
        dispose?.Invoke();
    }
}


const BlazorJs_Core_IRenderer = (Base) => class extends Base
{
    /*IServiceProvider*/ _backingField_Services = null;
    /*IServiceProvider*/ get Services()
    {
        return _backingField_Services;
    }
    /*IComponentActivator*/ _backingField_ComponentActivator = null;
    /*IComponentActivator*/ get ComponentActivator()
    {
        return _backingField_ComponentActivator;
    }
}

const BlazorJs_Core_IUIContent = (Base) => class extends Base
{
    /*UIFrameState*/ _backingField_State = null;
    /*UIFrameState*/ get State()
    {
        return _backingField_State;
    }
}


const BlazorJs_Core_IUIFrame = (Base) => class extends Base
{
}

static class BlazorJs_Core_IUIFrameExtension
{
    /*IUIContent*/ static GetBefore(/*this IUIContent*/ reference)
    {
        /*var*/ let siblings = reference.State.ParentFrame?.State.Children;
        if (siblings === null)
        return null;
        if (siblings.Any(function(/**/ s)
        {
            return s !== null && s.State.Id  < reference.State.Id;
        }))
        return null;
        /*var*/ let before = siblings.Where(function(/**/ s)
        {
            return s !== null && s.State.Id  < reference.State.Id;
        }).MaxBy(function(/**/ s)
        {
            return s.State.Id;
        });
        return before;
    }
    /*IUIContent*/ static GetAfter(/*this IUIContent*/ reference)
    {
        /*var*/ let siblings = reference.State.ParentFrame?.State.Children;
        if (siblings === null)
        return null;
        if (siblings.Any(function(/**/ s)
        {
            return s !== null && s.State.Id  > reference.State.Id;
        }))
        return null;
        /*var*/ let after = siblings.Where(function(/**/ s)
        {
            return s !== null && s.State.Id  > reference.State.Id;
        }).MinBy(function(/**/ s)
        {
            return s.State.Id;
        });
        return after;
    }
    /*HTMLElement*/ static Element(/*this IUIFrame*/ frame, /*string*/ tag, { /*ElementAttributeBuilder*/ attributeBuilder = null, /*RenderFragment*/ contentBuilder = null, /*object*/ key = null, /*int*/ sequenceNumber = 0})
    {
        do
        {
            /*var*/ let uiElement = frame.State.GetOrCreate(sequenceNumber, function(/**/ id)
            {
                /*var*/ let muiElement = new UIElement(frame.State.Renderer, frame, id, tag, key);
                return muiElement;
            }, key);
            if (uiElement.Tag  !== tag)
            {
                uiElement.Dispose();
            }
            uiElement.AttributeBuilder  = attributeBuilder;
            uiElement.ContentBuilder  = contentBuilder;
            uiElement.Build(key);
            return uiElement.Elements[0].As(HTMLElement);
        } while(true);
    }
    /*Node*/ static Text(/*this IUIFrame*/ frame, /*object*/ text, { /*object*/ key = null, /*int*/ sequenceNumber = 0})
    {
        /*var*/ let uiText = frame.State.GetOrCreate(sequenceNumber, function(/**/ id)
        {
            /*var*/ let muiText = new UIText(frame.State.Renderer, frame, id, key);
            return muiText;
        }, key);
        uiText.Text  = text;
        uiText.Build(key);
        return uiText.Elements[0].As(Node);
    }
    /*Node*/ static Text(/*this IUIFrame*/ frame, /*Func<object>*/ text, { /*object*/ key = null, /*int*/ sequenceNumber = 0})
    {
        /*var*/ let uiText = frame.State.GetOrCreate(sequenceNumber, function(/**/ id)
        {
            /*var*/ let muiText = new UIText(frame.State.Renderer, frame, id, key);
            return muiText;
        }, key);
        uiText.Text  = text;
        uiText.Build(key);
        return uiText.Elements[0].As(Node);
    }
    /*void*/ static Fragment(/*this IUIFrame*/ frame, /*RenderFragment*/ view)
    {
        view?.Invoke(frame);
    }
    /*void*/ static Frame(/*this IUIFrame*/ frame, /*RenderFragment*/ view, { /*object*/ key = null, /*int*/ sequenceNumber = 0})
    {
        /*var*/ let uiFrame = frame.State.GetOrCreate(sequenceNumber, function(/**/ id)
        {
            /*var*/ let muiFrame = new UIFrame(frame, view, key, id);
            return muiFrame;
        }, key);
        uiFrame.ContentBuilder  = view;
        uiFrame.Build(key);
    }
    /*Node[]*/ static Markup(/*this IUIFrame*/ frame, /*MarkupString*/ view, { /*object*/ key = null, /*int*/ sequenceNumber = 0})
    {
        /*var*/ let uiMarkup = frame.State.GetOrCreate(sequenceNumber, function(/**/ id)
        {
            /*var*/ let muiMarkup = new UIMarkup(frame.State.Renderer, frame, id, view.Html, key);
            return muiMarkup;
        }, key);
        uiMarkup.Markup  = view.Html;
        uiMarkup.Build(key);
        return uiMarkup.Elements.As(BlazorJs.TypeArray(Node));
    }
    /*void*/ static Content(T, /*this IUIFrame*/ frame, /*T*/ content, { /*object*/ key = null, /*int*/ sequenceNumber = 0})
    {
        if (T === RenderFragment)
        {
            Frame(frame, BlazorJs.Cast(BlazorJs.Cast(content, object), RenderFragment), { key : key, sequenceNumber : sequenceNumber });
        }
        else if (T === MarkupString)
        {
            Markup(frame, BlazorJs.Cast(BlazorJs.Cast(content, object), MarkupString), { key : key, sequenceNumber : sequenceNumber });
        }
        else 
        {
            Text(frame, content, { key : key, sequenceNumber : sequenceNumber });
        }
    }
    /*IComponent*/ static Component(/*this IUIFrame*/ frame, /*Type*/ componentType, /*Action<IComponent>*/ attributeBuilder, { /*object*/ key = null, /*int*/ sequenceNumber = 0})
    {
        do
        {
            /*var*/ let state = frame.State.GetOrCreate(sequenceNumber, function(/**/ id)
            {
                /*var*/ let renderer = BlazorJs.Cast(frame.State.Renderer, BrowserNativeRenderer);
                /*var*/ let mcomponent = renderer.ComponentActivator.CreateInstance(componentType);
                /*var*/ let mstate = new UIFrameState(renderer, frame, id, key);
                mstate.Component  = mcomponent;
                mstate.ComponentType  = componentType;
                mcomponent.Attach(new RenderHandle(renderer, id));
                renderer.Register(id, mstate);
                if (mcomponent instanceof ComponentBase, mcb = mcomponent)
                {
                    mcb.WithErrorHandling(function(/**/ icomponent)
                    {
                        icomponent.InjectServices(renderer.Services);
                        icomponent.CascadeParameters();
                    }, ComponentLifeCycle.OnInjectingService);
                }
                renderer.CreateComponent(mcomponent);
                return mstate;
            }, key);
            if (state.ComponentType  !== componentType)
            {
                state.Dispose();
            }
            attributeBuilder?.Invoke(state.Component);
            /*Task*/ let task = state.Component.SetParametersAsync(BlazorJs.getDefault());
            return state.Component;
        } while(true);
    }
    /*T*/ static Component(T, /*this IUIFrame*/ frame, /*Action<T>*/ attributeBuilder, { /*object*/ key = null, /*int*/ sequenceNumber = 0})
    {
        return BlazorJs.Cast(frame.Component(T, attributeBuilder !== null ? function(/**/ ab)
        {
            return attributeBuilder(BlazorJs.Cast(ab, T));
        } : BlazorJs.Cast(null, Action(IComponent)), key, sequenceNumber), T);
    }
    /*T*/ static InferType(TComponent, T, /*this IUIFrame*/ context, /*T*/ property, /*T*/ value, /*string*/ expression)
    {
        return value;
    }
}

static class BlazorJs_Core_ThrowHelperExtension
{
    /*void*/ static ThrowIfNull(/*this object*/ argument, { /*string*/ paramName = null})
    {
        if (argument === null)
        {
            Throw(paramName);
        }
    }
    /*void*/ static Throw(/*this string*/ paramName)
    {
        throw new ArgumentNullException(paramName);
    }
    /*string*/ static IfNullOrWhitespace(/*string*/ argument, { /*string*/ paramName = ""})
    {
        if (string.IsNullOrWhiteSpace(argument))
        {
            if (argument === null)
            {
                throw new ArgumentNullException(paramName);
            }
            throw new ArgumentException(paramName, "Argument is whitespace");
        }
        return argument;
    }
}

class BlazorJs_Core_UIElement extends System_IDisposable(BlazorJs_Core_IUIContent(BlazorJs_Core_IUIFrame(BlazorJs_Core_UIFrameState)))
{
    /*string*/ Tag = null;
    /*ElementAttributeBuilder*/ _backingField_AttributeBuilder = null;
    /*ElementAttributeBuilder*/ get AttributeBuilder()
    {
        return _backingField_AttributeBuilder;
    }
    /*ElementAttributeBuilder*/ set AttributeBuilder(value)
    {
        _backingField_AttributeBuilder = value;
    }
    /*RenderFragment*/ _backingField_ContentBuilder = null;
    /*RenderFragment*/ get ContentBuilder()
    {
        return _backingField_ContentBuilder;
    }
    /*RenderFragment*/ set ContentBuilder(value)
    {
        _backingField_ContentBuilder = value;
    }
    constructor(/*IRenderer*/ platformRenderer, /*IUIFrame*/ parent, /*int*/ id, /*string*/ tag, /*object*/ key)
    {
        super(platformRenderer, parent, id, key);
        Tag = tag;
        platformRenderer.CreateElement(this);
    }
    /*void*/ Build(/*object*/ key)
    {
        if (AttributeBuilder !== null)
        {
            let $ref0 = { set value(v){ attributes = v } };
            /*var*/ let attributes = new UIElementAttribute(this);
            AttributeBuilder.Invoke($ref0);
        }
        if (ContentBuilder !== null)
        {
            TrackContents(function()
            {
                ContentBuilder.Invoke(this, key);
            });
        }
    }
    /*void*/ Dispose()
    {
        super.Dispose();
        Renderer.RemoveElement(this);
    }
    /*string*/ ToString()
    {
        return `<${Tag}>${string.Join("", Children.Select(function(/**/ v)
        {
            return v.ToString() ?? "";
        }) ?? Enumerable.Empty(string))}</${Tag}>`;
    }
}

class BlazorJs_Core_UIElementAttribute extends System_ValueType
{
    /*UIElement*/ element = null;
    constructor(/*UIElement*/ _element)
    {
        super();
        this.element  = _element;
    }
    /*void*/ setItem(/*string*/ key, /*string*/ value)
    {
        element.State.Renderer.SetElementAttribute(element, key, value);
    }
    /*void*/ Set(/*string*/ key, /*object*/ value)
    {
        if (key === "@attributes")
        {
            if (value instanceof IReadOnlyDictionary(string, object), dic = value)
            {
                BlazorJs.forEach(dic, function(kv, $_i)
                {
                    element.State.Renderer.SetElementAttribute(element, kv.Key, kv.Value);
                });
            }
            else 
            {
                BlazorJs.forEach(object.GetOwnPropertyNames(value), function(mkey, $_i)
                {
                    if (mkey.Length  > 0 && char.IsLower(mkey[0]))
                    {
                        /*var*/ let val = value[mkey];
                        element.State.Renderer.SetElementAttribute(element, mkey, val);
                    }
                });
            }
        }
        else 
        {
            element.State.Renderer.SetElementAttribute(element, key, value);
        }
    }
    /*void*/ Set(T, /*string*/ key, /*Func<T>*/ value)
    {
        element.State.Renderer.SetElementAttribute(element, key, value());
    }
}

class BlazorJs_Core_UIFrame extends System_IDisposable(BlazorJs_Core_IUIContent(BlazorJs_Core_IUIFrame(BlazorJs_Core_UIFrameState)))
{
    /*RenderFragment*/ _backingField_ContentBuilder = null;
    /*RenderFragment*/ get ContentBuilder()
    {
        return _backingField_ContentBuilder;
    }
    /*RenderFragment*/ set ContentBuilder(value)
    {
        _backingField_ContentBuilder = value;
    }
    constructor(/*IRenderer*/ renderer)
    {
        super(renderer, null, 0, null);
        ContentBuilder = null;
    }
    constructor(/*IUIFrame*/ parent, /*RenderFragment*/ contentBuilder, /*object*/ key, /*int*/ id)
    {
        super(parent.State.Renderer, parent, id, key);
        ContentBuilder = contentBuilder;
        if (parent instanceof UIElement && key === null)
        {
        }
        else 
        {
            Renderer.CreateRegion(this);
        }
    }
    /*void*/ Build(/*object*/ key)
    {
        if (ContentBuilder !== null)
        {
            TrackContents(function()
            {
                ContentBuilder.Invoke(this, key);
            });
        }
    }
    /*void*/ Dispose()
    {
        super.Dispose();
    }
    /*string*/ ToString()
    {
        return `${string.Join("", Children.Select(function(/**/ v)
        {
            return v.ToString() ?? "";
        }) ?? Enumerable.Empty(string))}`;
    }
}

class BlazorJs_Core_UIKeyedGroup extends object
{
    constructor()
    {
        super();
    }
    /*Dictionary<object, IUIContent>*/ _backingField_Members = null;
    /*Dictionary<object, IUIContent>*/ get Members()
    {
        return _backingField_Members;
    }
}
class BlazorJs_Core_UIFrameState extends BlazorJs_Core_IUIContent(BlazorJs_Core_IUIFrame(System_IDisposable(object)))
{
    /*//Dictionary<string, object> contents;
        object*/ contents = null;
    /*IRenderer*/ _backingField_Renderer = null;
    /*IRenderer*/ get Renderer()
    {
        return _backingField_Renderer;
    }
    /*IUIFrame*/ parentFrame = null;
    /*int*/ id = null;
    /*object*/ key = null;
    /*Type*/ _backingField_ComponentType = null;
    /*Type*/ get ComponentType()
    {
        return _backingField_ComponentType;
    }
    /*Type*/ set ComponentType(value)
    {
        _backingField_ComponentType = value;
    }
    /*IComponent*/ _backingField_Component = null;
    /*IComponent*/ get Component()
    {
        return _backingField_Component;
    }
    /*IComponent*/ set Component(value)
    {
        _backingField_Component = value;
    }
    /*Node.Interface[]*/ _backingField_Elements = null;
    /*Node.Interface[]*/ get Elements()
    {
        return _backingField_Elements;
    }
    /*Node.Interface[]*/ set Elements(value)
    {
        _backingField_Elements = value;
    }
    /*int*/ _backingField_TrackedId = null;
    /*int*/ get TrackedId()
    {
        return _backingField_TrackedId;
    }
    /*int*/ set TrackedId(value)
    {
        _backingField_TrackedId = value;
    }
    constructor(/*IRenderer*/ renderer, /*IUIFrame*/ parent, /*int*/ id, /*object*/ key)
    {
        super();
        Renderer = renderer;
        this.parentFrame  = parent;
        this.id  = id;
        this.key  = key;
    }
    /*int*/ get Id()
    {
        return id;
    }
    /*object*/ get Key()
    {
        return key;
    }
    /*IUIFrame*/ get ParentFrame()
    {
        return parentFrame;
    }
    /*IEnumerable<IUIContent>*/ get Children()
    {
        return contents === null ? null : object.GetOwnPropertyNames(contents).SelectMany(string, IUIContent, function(/**/ pn)
        {
            /*var*/ let o = contents[pn];
            if (o instanceof UIKeyedGroup, g = o)
            {
                return g.Members.Values;
            }
            return BlazorJs.Cast(o, IUIContent);
        }).OrderBy(function(/**/ o)
        {
            return o.State?.id ?? 0;
        }) ?? Enumerable.Empty(IUIContent);
    }
    /*UIFrameState*/ get State()
    {
        return this;
    }
    /*int*/ trackingChildrenId = 1;
    /*T*/ SetContentTracked(T, /*T*/ content)
    {
        if (trackingChildrenId > 0 && content !== null)
        {
            content.State.TrackedId  = trackingChildrenId;
        }
        return content;
    }
    /*T*/ GetOrCreate(T, /*int*/ sequenceNumber, /*Func<int, T>*/ create, { /*object*/ key = null})
    {
        let t = null;
        let $ref1 = { set value(v){ t = v } };
        if (sequenceNumber === 0)
        throw new InvalidOperationException("Sequence number cannot be zero. Must be a unique number in a frame.");
        /*var*/ let sid = sequenceNumber.ToString();
        if (contents === null)
        contents = new object();
        if (contents.TryGetValue(sid, $ref1))
        {
            if (key !== null)
            {
                let member = null;
                let $ref1 = { set value(v){ member = v } };
                /*var*/ let group = BlazorJs.Cast(t, UIKeyedGroup);
                if (group.Members.TryGetValue(key, $ref1))
                {
                    member = create(sequenceNumber);
                    group.Members[key] = member;
                }
                return SetContentTracked(BlazorJs.Cast(member, T));
            }
            else 
            {
                return SetContentTracked(BlazorJs.Cast(t, T));
            }
        }
        /*var*/ let tt = create(sequenceNumber);
        if (key !== null)
        {
            /*var*/ let group = new UIKeyedGroup();
            group.Members[key] = tt;
            contents[sid] = group;
        }
        else 
        {
            contents[sid] = tt;
        }
        return SetContentTracked(BlazorJs.Cast(tt, T));
    }
    /*void*/ Remove(/*IUIContent*/ child)
    {
        let group = null;
        let $ref1 = { set value(v){ group = v } };
        if (child.State.Key  !== null && contents.TryGetValue(child.State.id, $ref1) && group instanceof UIKeyedGroup, kgroup = group)
        {
            kgroup.Members.Remove(child.State.Key);
        }
        else 
        {
            contents.Remove(child.State.id);
        }
    }
    /*void*/ TrackContents(/*Action*/ action)
    {
        trackingChildrenId++;
        try
        {
            action();
        }
        finally
        {
            {
                if (Children !== null)
                {
                    /*var*/ let disposedChildren = Children.Where(function(/**/ c)
                    {
                        return c.State.TrackedId  !== trackingChildrenId;
                    });
                    BlazorJs.forEach(disposedChildren, function(child, $_i)
                    {
                        if (child !== null)
                        {
                            child.Dispose();
                            contents.Remove(child.State.id);
                        }
                    });
                }
            }
        }
    }
    /*string*/ ToString()
    {
        return `${string.Join("", Children?.Select(function(/**/ v)
        {
            return v.ToString() ?? "";
        }) ?? Enumerable.Empty(string))}`;
    }
    /*string*/ CascadingValueKey = "__CascadingValueKey__";
    static BlazorJs_Core_UIFrameState_CascadingValueData = class extends object
    {
        constructor()
        {
            super();
        }
        /*object*/ _backingField_Value = null;
        /*object*/ get Value()
        {
            return _backingField_Value;
        }
        /*object*/ set Value(value)
        {
            _backingField_Value = value;
        }
        /*bool*/ _backingField_IsFixed = null;
        /*bool*/ get IsFixed()
        {
            return _backingField_IsFixed;
        }
        /*bool*/ set IsFixed(value)
        {
            _backingField_IsFixed = value;
        }
        /*string*/ _backingField_Name = null;
        /*string*/ get Name()
        {
            return _backingField_Name;
        }
        /*string*/ set Name(value)
        {
            _backingField_Name = value;
        }
        /*EventHandler<object>*/ _backingField_Handlers = null;
        /*EventHandler<object>*/ get Handlers()
        {
            return _backingField_Handlers;
        }
        /*EventHandler<object>*/ set Handlers(value)
        {
            _backingField_Handlers = value;
        }
    }
    /*void*/ SetCascadingValue(T, /*T*/ value, /*bool*/ isFixed, /*string*/ name)
    {
        /*var*/ let valueKey = CascadingValueKey + (name !== null ? "." + name : "");
        /*var*/ let cascadeValue = this[valueKey].As(CascadingValueData) ?? BlazorJs.PopulateProperty(new CascadingValueData(), function(/*CascadingValueData*/ $obj)
        {
            $obj.Name = name;
            $obj.Value = value;
            $obj.IsFixed = isFixed;
        });
        this[valueKey] = cascadeValue;
        if (isFixed)
        {
            if (cascadeValue.Handlers  !== null && Utility.Equal(cascadeValue, value))
            {
                cascadeValue.Handlers.Invoke(this, cascadeValue.Value);
            }
        }
    }
    /*bool*/ GetCascadingValueImpl(T, /*string*/ valueKey, /*out CascadingValueData*/ value)
    {
        /*var*/ let val = this[valueKey].As(CascadingValueData);
        if (val !== null && val.Value  instanceof T)
        {
            value = val;
            return true;
        }
        if (parentFrame !== null)
        {
            let $ref0 = { set value(v){ value = v } };
            return parentFrame.State.GetCascadingValueImpl(T, valueKey, $ref0);
        }
        value = BlazorJs.getDefault();
        return false;
    }
    /*IDisposable*/ SubscribeCascadingValue(T, /*EventHandler<T>*/ callback, { /*string*/ name = null})
    {
        let value = null;
        let $ref1 = { set value(v){ value = v } };
        /*var*/ let valueKey = CascadingValueKey + (name !== null ? "." + name : "");
        /*bool*/ let gotCurrentValue = GetCascadingValueImpl(T)(T, valueKey, $ref1);
        /*IDisposable*/ let dispose = null;
        if (gotCurrentValue)
        {
            if (value.IsFixed)
            {
                /*EventHandler<object>*/ let call = function(/**/ s, /**/ e)
                {
                    return callback(s, BlazorJs.Cast(e, T));
                };
                value.Handlers  += call;
                dispose = new DisposableDelegate(function()
                {
                    return value.Handlers  -= call;
                });
            }
            callback.Invoke(this, BlazorJs.Cast(value.Value, T));
        }
        return dispose;
    }
    /*void*/ Dispose()
    {
        if (Component instanceof IDisposable, disposable = Component)
        {
            disposable.Dispose();
        }
        if (Children !== null)
        {
            BlazorJs.forEach(Children, function(child, $_i)
            {
                child.Dispose();
            });
        }
        contents = null;
        ParentFrame.State.Remove(this);
        (BlazorJs.Cast(Renderer, BrowserNativeRenderer)).Remove(id);
    }
}

class BlazorJs_Core_UIMarkup extends System_IDisposable(BlazorJs_Core_IUIContent(BlazorJs_Core_IUIFrame(BlazorJs_Core_UIFrameState)))
{
    /*string*/ markup = null;
    /*string*/ oldMarkup = null;
    /*string*/ get Markup()
    {
        return markup;
    }
    /*string*/ set Markup(value)
    {
        if (value !== oldMarkup)
        {
            oldMarkup = markup;
            markup = value;
        }
    }
    constructor(/*IRenderer*/ platformRenderer, /*IUIFrame*/ parent, /*int*/ id, /*string*/ markup, /*object*/ key)
    {
        super(platformRenderer, parent, id, key);
        Markup = markup;
        platformRenderer.CreateMarkup(this);
    }
    /*void*/ Build(/*object*/ key)
    {
        if (markup !== oldMarkup)
        {
            Renderer.UpdateMarkup(this);
            oldMarkup = markup;
        }
    }
    /*void*/ Dispose()
    {
        super.Dispose();
        Renderer.RemoveMarkup(this);
    }
    /*string*/ ToString()
    {
        return `${Markup}`;
    }
}

class BlazorJs_Core_UIText extends System_IDisposable(BlazorJs_Core_IUIContent(BlazorJs_Core_UIFrameState))
{
    /*object*/ oldText = null;
    /*object*/ text = null;
    /*object*/ get Text()
    {
        return text;
    }
    /*object*/ set Text(value)
    {
        if (value === null && oldText === null)
        return ;
        if (Utility.Equal(value, oldText))
        {
            oldText = text;
            text = value;
        }
    }
    constructor(/*IRenderer*/ platformRenderer, /*IUIFrame*/ parent, /*int*/ id, /*object*/ key)
    {
        super(platformRenderer, parent, id, key);
        platformRenderer.CreateText(this);
    }
    /*void*/ Build(/*object*/ key)
    {
        if (Utility.Equal(text, oldText))
        {
            Renderer.UpdateText(this);
            oldText = text;
        }
    }
    /*void*/ Dispose()
    {
        super.Dispose();
        Renderer.RemoveText(this);
    }
    /*string*/ ToString()
    {
        return `${Text}`;
    }
}

static class BlazorJs_Core_Utility
{
    /*int*/ LiteRouter_Layout_SequenceNumber = 1;
    /*int*/ LiteRouter_Page_SequenceNumber = 2;
    /*int*/ DynamicComponent_SequenceNumber = 3;
    /*int*/ CascadingValue_SequenceNumber = 4;
    /*int*/ Router_View_SequenceNumber = 5;
    /*int*/ AuthorizeRouteView_LayoutView_SequenceNumber = 5;
    /*int*/ AuthorizeRouteView_AuthorizeRouteViewCore_SequenceNumber = 6;
    /*int*/ AuthorizeViewCore_Authorizing_SequenceNumber = 7;
    /*int*/ AuthorizeViewCore_Authorized_SequenceNumber = 8;
    /*int*/ AuthorizeViewCore_NotAuthorized_SequenceNumber = 9;
    /*int*/ LayoutView_Layout_SequenceNumber = 10;
    /*int*/ LayoutView_Fragment_SequenceNumber = 11;
    /*int*/ RouteView_LayoutView_SequenceNumber = 12;
    /*int*/ RouteView_Page_SequenceNumber = 13;
    /*int*/ Virtualize_DefaultPlaceholder_SequenceNumber = 14;
    /*int*/ Virtualize_SpacerElementBefore_SequenceNumber = 15;
    /*int*/ Virtualize_PlaceholderBefore_SequenceNumber = 16;
    /*int*/ Virtualize_EmptyContent_SequenceNumber = 17;
    /*int*/ Virtualize_Item_SequenceNumber = 18;
    /*int*/ Virtualize_PlaceholderAfter_SequenceNumber = 19;
    /*int*/ Virtualize_SpacerElementAfter_SequenceNumber = 20;
    /*int*/ ErrorBoundary_ChildContent_SequenceNumber = 21;
    /*int*/ ErrorBoundary_ErrorContent_SequenceNumber = 22;
    /*int*/ ErrorBoundary_DefaultContent_SequenceNumber = 23;
    /*void*/ static FireAndForget(/*this Task*/ task)
    {
        task.ContinueWith(function(/**/ t)
        {
            if (t.Exception  !== null)
            {
                Console.WriteLine(t.Exception);
            }
        });
    }
    /*bool*/ static Equal(/*object*/ t1, /*object*/ t2)
    {
        if (t1 === null && t2 === null)
        return true;
        if ((t1 === null && t2 !== null) || (t1 !== null && t2 === null) || t1.Equals(t2))
        {
            return false;
        }
        return true;
    }
    /*bool*/ static ContainsKey(/*this object*/ container, /*string*/ propertyName)
    {
        return container.HasOwnProperty(propertyName.As(object));
    }
    /*bool*/ static TryGetValue(/*this object*/ container, /*string*/ propertyName, /*out object*/ obj)
    {
        if (container.HasOwnProperty(propertyName.As(object)))
        {
            obj = container[propertyName.As(string)];
            return true;
        }
        obj = null;
        return false;
    }
    /*bool*/ static TryGetValue(/*this object*/ container, /*int*/ propertyName, /*out object*/ obj)
    {
        if (container.HasOwnProperty(propertyName.As(object)))
        {
            obj = container[propertyName.As(string)];
            return true;
        }
        obj = null;
        return false;
    }
    /*void*/ static SetValue(/*this object*/ container, /*string*/ propertyName, /*object*/ obj)
    {
        container[propertyName] = obj;
    }
    /*void*/ static SetValue(/*this object*/ container, /*int*/ propertyName, /*object*/ obj)
    {
        container[propertyName.As(string)] = obj;
    }
    /*void*/ static Remove(/*this object*/ container, /*int*/ propertyName)
    {
        H5.Script.Delete(container, propertyName.As(string));
    }
}

static class BlazorJs_Core_ValueConverter
{
    /*object*/ static converters = new object();
    /*int*/ static Convert(/*object*/ value, /*int*/ inferType)
    {
        return int.Parse(value.ToString());
    }
    /*int?*/ static Convert(/*object*/ value, /*int?*/ inferType)
    {
        if (value === null || value.ToString() === "")
        return null;
        return int.Parse(value.ToString());
    }
    /*double*/ static Convert(/*object*/ value, /*double*/ inferType)
    {
        return double.Parse(value.ToString());
    }
    /*double?*/ static Convert(/*object*/ value, /*double?*/ inferType)
    {
        if (value === null || value.ToString() === "")
        return null;
        return double.Parse(value.ToString());
    }
    /*string*/ static Convert(/*object*/ value, /*string*/ inferType)
    {
        return value.ToString();
    }
    /*object*/ static Convert(/*object*/ value, /*Type*/ type)
    {
        let converter = null;
        let $ref1 = { set value(v){ converter = v } };
        if (converters.TryGetValue(type.FullName, $ref1))
        {
            return (BlazorJs.Cast(converter, Delegate)).Call(null, value);
        }
        if (type.IsEnum)
        {
            if (value !== null)
            {
                /*var*/ let i = int.Parse(value.ToString());
                return i;
            }
            return BlazorJs.getDefault();
        }
        if (value instanceof string, str = value)
        {
            if (type === string)
            return value;
            /*MethodInfo*/ let method = type.GetMethod("Parse", string);
            if (method !== null)
            {
                return method.Invoke(null, value);
            }
        }
        throw new InvalidOperationException(`No converter is regietered for ${type.FullName}`);
    }
    /*T*/ static Convert(T, /*object*/ value, /*T*/ inferType)
    {
        return BlazorJs.Cast(Convert(value, T), T);
    }
    /*void*/ static Register(T, /*Func<object, T>*/ converter)
    {
        converters[T.FullName] = converter;
    }
}

class Microsoft_AspNetCore_Authorization_AssertionRequirement extends Microsoft_AspNetCore_Authorization_IAuthorizationRequirement(Microsoft_AspNetCore_Authorization_IAuthorizationHandler(object))
{
    /*Func<AuthorizationHandlerContext, Task<bool>>*/ _backingField_Handler = null;
    /*Func<AuthorizationHandlerContext, Task<bool>>*/ get Handler()
    {
        return _backingField_Handler;
    }
    constructor(/*Func<AuthorizationHandlerContext, bool>*/ handler)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(handler);
        Handler = function(/**/ context)
        {
            return Task.FromResult(handler(context));
        };
    }
    constructor(/*Func<AuthorizationHandlerContext, Task<bool>>*/ handler)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(handler);
        Handler = handler;
    }
    /*Task*/ async HandleAsync(/*AuthorizationHandlerContext*/ context)
    {
        if (await Handler(context))
        {
            context.Succeed(this);
        }
    }
    /*string*/ ToString()
    {
        return `${nameof(Handler)} assertion should evaluate to true.`;
    }
}

class Microsoft_AspNetCore_Authorization_AuthorizationFailure extends object
{
    /*AuthorizationFailure*/ static _explicitFailure = BlazorJs.PopulateProperty(new AuthorizationFailure(), function(/*AuthorizationFailure*/ $obj)
    {
        $obj.FailCalled = true;
    });
    constructor()
    {
        super();
    }
    /*bool*/ _backingField_FailCalled = null;
    /*bool*/ get FailCalled()
    {
        return _backingField_FailCalled;
    }
    /*bool*/ set FailCalled(value)
    {
        _backingField_FailCalled = value;
    }
    /*IEnumerable<IAuthorizationRequirement>*/ _backingField_FailedRequirements = null;
    /*IEnumerable<IAuthorizationRequirement>*/ get FailedRequirements()
    {
        return _backingField_FailedRequirements;
    }
    /*IEnumerable<IAuthorizationRequirement>*/ set FailedRequirements(value)
    {
        _backingField_FailedRequirements = value;
    }
    /*IEnumerable<AuthorizationFailureReason>*/ _backingField_FailureReasons = null;
    /*IEnumerable<AuthorizationFailureReason>*/ get FailureReasons()
    {
        return _backingField_FailureReasons;
    }
    /*IEnumerable<AuthorizationFailureReason>*/ set FailureReasons(value)
    {
        _backingField_FailureReasons = value;
    }
    /*AuthorizationFailure*/ static ExplicitFail()
    {
        return _explicitFailure;
    }
    /*AuthorizationFailure*/ static Failed(/*IEnumerable<AuthorizationFailureReason>*/ reasons)
    {
        return BlazorJs.PopulateProperty(new AuthorizationFailure(), function(/*AuthorizationFailure*/ $obj)
        {
            $obj.FailCalled = true;
            $obj.FailureReasons = reasons;
        });
    }
    /*AuthorizationFailure*/ static Failed(/*IEnumerable<IAuthorizationRequirement>*/ failed)
    {
        return BlazorJs.PopulateProperty(new AuthorizationFailure(), function(/*AuthorizationFailure*/ $obj)
        {
            $obj.FailedRequirements = failed;
        });
    }
}

class Microsoft_AspNetCore_Authorization_AuthorizationFailureReason extends object
{
    constructor(/*IAuthorizationHandler*/ handler, /*string*/ message)
    {
        super();
        Handler = handler;
        Message = message;
    }
    /*string*/ _backingField_Message = null;
    /*string*/ get Message()
    {
        return _backingField_Message;
    }
    /*IAuthorizationHandler*/ _backingField_Handler = null;
    /*IAuthorizationHandler*/ get Handler()
    {
        return _backingField_Handler;
    }
}

const Microsoft_AspNetCore_Authorization_AuthorizationHandler = (TRequirement) => class extends Microsoft_AspNetCore_Authorization_IAuthorizationHandler(object)
{
    constructor()
    {
        super();
    }
    /*Task*/ async HandleAsync(/*AuthorizationHandlerContext*/ context)
    {
        BlazorJs.forEach(context.Requirements.OfType(TRequirement), function(req, $_i)
        {
            await HandleRequirementAsync(context, req);
        });
    }
    /*Task*/ async HandleAsync(/*AuthorizationHandlerContext*/ context)
    {
        if (context.Resource  instanceof TResource)
        {
            BlazorJs.forEach(context.Requirements.OfType(TRequirement), function(req, $_i)
            {
                await HandleRequirementAsync(context, req, resource);
            });
        }
    }
}


class Microsoft_AspNetCore_Authorization_AuthorizationHandlerContext extends object
{
    /*HashSet<IAuthorizationRequirement>*/ _pendingRequirements = null;
    /*List<AuthorizationFailureReason>*/ _failedReasons = null;
    /*bool*/ _failCalled = null;
    /*bool*/ _succeedCalled = null;
    constructor(/*IEnumerable<IAuthorizationRequirement>*/ requirements, /*ClaimsPrincipal*/ user, /*object*/ resource)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(requirements);
        Requirements = requirements;
        User = user;
        Resource = resource;
        _pendingRequirements = new HashSet(IAuthorizationRequirement)(requirements);
    }
    /*IEnumerable<IAuthorizationRequirement>*/ _backingField_Requirements = null;
    /*IEnumerable<IAuthorizationRequirement>*/ get Requirements()
    {
        return _backingField_Requirements;
    }
    /*ClaimsPrincipal*/ _backingField_User = null;
    /*ClaimsPrincipal*/ get User()
    {
        return _backingField_User;
    }
    /*object*/ _backingField_Resource = null;
    /*object*/ get Resource()
    {
        return _backingField_Resource;
    }
    /*IEnumerable<IAuthorizationRequirement>*/ get PendingRequirements()
    {
        return _pendingRequirements;
    }
    /*IEnumerable<AuthorizationFailureReason>*/ get FailureReasons()
    {
        return BlazorJs.Cast(_failedReasons, IEnumerable(AuthorizationFailureReason)) ?? Array.Empty(AuthorizationFailureReason);
    }
    /*bool*/ get HasFailed()
    {
        return _failCalled;
    }
    /*bool*/ get HasSucceeded()
    {
        return _failCalled && _succeedCalled && PendingRequirements.Any();
    }
    /*void*/ Fail()
    {
        _failCalled = true;
    }
    /*void*/ Fail(/*AuthorizationFailureReason*/ reason)
    {
        Fail();
        if (reason !== null)
        {
            if (_failedReasons === null)
            {
                _failedReasons = new List(AuthorizationFailureReason)();
            }
            _failedReasons.Add(reason);
        }
    }
    /*void*/ Succeed(/*IAuthorizationRequirement*/ requirement)
    {
        _succeedCalled = true;
        _pendingRequirements.Remove(requirement);
    }
}

class Microsoft_AspNetCore_Authorization_AuthorizationPolicy extends object
{
    constructor(/*IEnumerable<IAuthorizationRequirement>*/ requirements, /*IEnumerable<string>*/ authenticationSchemes)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(requirements);
        ArgumentNullExceptionExtension.ThrowIfNull(authenticationSchemes);
        if (requirements.Any())
        {
            throw new InvalidOperationException("AuthorizationPolicyEmpty");
        }
        Requirements = new List(IAuthorizationRequirement)(requirements).AsReadOnly();
        AuthenticationSchemes = new List(string)(authenticationSchemes).AsReadOnly();
    }
    /*IReadOnlyList<IAuthorizationRequirement>*/ _backingField_Requirements = null;
    /*IReadOnlyList<IAuthorizationRequirement>*/ get Requirements()
    {
        return _backingField_Requirements;
    }
    /*IReadOnlyList<string>*/ _backingField_AuthenticationSchemes = null;
    /*IReadOnlyList<string>*/ get AuthenticationSchemes()
    {
        return _backingField_AuthenticationSchemes;
    }
    /*AuthorizationPolicy*/ static Combine(/*params AuthorizationPolicy[]*/ policies)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(policies);
        return Combine(BlazorJs.Cast(policies, IEnumerable(AuthorizationPolicy)));
    }
    /*AuthorizationPolicy*/ static Combine(/*IEnumerable<AuthorizationPolicy>*/ policies)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(policies);
        /*var*/ let builder = new AuthorizationPolicyBuilder();
        BlazorJs.forEach(policies, function(policy, $_i)
        {
            builder.Combine(policy);
        });
        return builder.Build();
    }
    /*Task<AuthorizationPolicy>*/ static CombineAsync(/*IAuthorizationPolicyProvider*/ policyProvider, /*IEnumerable<IAuthorizeData>*/ authorizeData)
    {
        return CombineAsync(policyProvider, authorizeData, Enumerable.Empty(AuthorizationPolicy));
    }
    /*Task<AuthorizationPolicy>*/ static async CombineAsync(/*IAuthorizationPolicyProvider*/ policyProvider, /*IEnumerable<IAuthorizeData>*/ authorizeData, /*IEnumerable<AuthorizationPolicy>*/ policies)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(policyProvider);
        ArgumentNullExceptionExtension.ThrowIfNull(authorizeData);
        /*var*/ let anyPolicies = policies.Any();
        /*// Avoid allocating enumerator if the data is known to be empty
            var*/ let skipEnumeratingData = false;
        if (authorizeData instanceof IList(IAuthorizeData), dataList = authorizeData)
        {
            skipEnumeratingData = dataList.Count  === 0;
        }
        /*AuthorizationPolicyBuilder*/ let policyBuilder = null;
        if (skipEnumeratingData)
        {
            BlazorJs.forEach(authorizeData, function(authorizeDatum, $_i)
            {
                if (policyBuilder === null)
                {
                    policyBuilder = new AuthorizationPolicyBuilder();
                }
                /*var*/ let useDefaultPolicy = (anyPolicies);
                if (string.IsNullOrWhiteSpace(authorizeDatum.Policy))
                {
                    /*var*/ let policy = await policyProvider.GetPolicyAsync(authorizeDatum.Policy);
                    if (policy === null)
                    {
                        throw new InvalidOperationException(`AuthorizationPolicyNotFound(${authorizeDatum.Policy})`);
                    }
                    policyBuilder.Combine(policy);
                    useDefaultPolicy = false;
                }
                /*var*/ let rolesSplit = authorizeDatum.Roles?.Split(',');
                if (rolesSplit?.Length > 0)
                {
                    /*var*/ let trimmedRolesSplit = rolesSplit.Where(function(/**/ r)
                    {
                        return string.IsNullOrWhiteSpace(r);
                    }).Select(function(/**/ r)
                    {
                        return r.Trim();
                    });
                    policyBuilder.RequireRole(trimmedRolesSplit);
                    useDefaultPolicy = false;
                }
                /*var*/ let authTypesSplit = authorizeDatum.AuthenticationSchemes?.Split(',');
                if (authTypesSplit?.Length > 0)
                {
                    BlazorJs.forEach(authTypesSplit, function(authType, $_i)
                    {
                        if (string.IsNullOrWhiteSpace(authType))
                        {
                            policyBuilder.AuthenticationSchemes.Add(authType.Trim());
                        }
                    });
                }
                if (useDefaultPolicy)
                {
                    policyBuilder.Combine(await policyProvider.GetDefaultPolicyAsync());
                }
            });
        }
        if (anyPolicies)
        {
            policyBuilder = policyBuilder ?? new AuthorizationPolicyBuilder();
            BlazorJs.forEach(policies, function(policy, $_i)
            {
                policyBuilder.Combine(policy);
            });
        }
        if (policyBuilder === null)
        {
            /*var*/ let fallbackPolicy = await policyProvider.GetFallbackPolicyAsync();
            if (fallbackPolicy !== null)
            {
                return fallbackPolicy;
            }
        }
        return policyBuilder?.Build();
    }
}

class Microsoft_AspNetCore_Authorization_AuthorizationPolicyBuilder extends object
{
    /*DenyAnonymousAuthorizationRequirement*/ static _denyAnonymousAuthorizationRequirement = new DenyAnonymousAuthorizationRequirement();
    constructor(/*string[]*/ authenticationSchemes)
    {
        super();
        AddAuthenticationSchemes(authenticationSchemes);
    }
    constructor(/*AuthorizationPolicy*/ policy)
    {
        super();
        Combine(policy);
    }
    /*IList<IAuthorizationRequirement>*/ _backingField_Requirements = null;
    /*IList<IAuthorizationRequirement>*/ get Requirements()
    {
        return _backingField_Requirements;
    }
    /*IList<IAuthorizationRequirement>*/ set Requirements(value)
    {
        _backingField_Requirements = value;
    }
    /*IList<string>*/ _backingField_AuthenticationSchemes = null;
    /*IList<string>*/ get AuthenticationSchemes()
    {
        return _backingField_AuthenticationSchemes;
    }
    /*IList<string>*/ set AuthenticationSchemes(value)
    {
        _backingField_AuthenticationSchemes = value;
    }
    /*AuthorizationPolicyBuilder*/ AddAuthenticationSchemes(/*params string[]*/ schemes)
    {
        return AddAuthenticationSchemesCore(schemes);
    }
    /*AuthorizationPolicyBuilder*/ AddAuthenticationSchemesCore(/*IEnumerable<string>*/ schemes)
    {
        BlazorJs.forEach(schemes, function(authType, $_i)
        {
            AuthenticationSchemes.Add(authType);
        });
        return this;
    }
    /*AuthorizationPolicyBuilder*/ AddRequirements(/*params IAuthorizationRequirement[]*/ requirements)
    {
        return AddRequirementsCore(requirements);
    }
    /*AuthorizationPolicyBuilder*/ AddRequirementsCore(/*IEnumerable<IAuthorizationRequirement>*/ requirements)
    {
        BlazorJs.forEach(requirements, function(req, $_i)
        {
            Requirements.Add(req);
        });
        return this;
    }
    /*AuthorizationPolicyBuilder*/ Combine(/*AuthorizationPolicy*/ policy)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(policy);
        AddAuthenticationSchemesCore(policy.AuthenticationSchemes);
        AddRequirementsCore(policy.Requirements);
        return this;
    }
    /*AuthorizationPolicyBuilder*/ RequireClaim(/*string*/ claimType, /*params string[]*/ allowedValues)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(claimType);
        return RequireClaim(claimType, BlazorJs.Cast(allowedValues, IEnumerable(string)));
    }
    /*AuthorizationPolicyBuilder*/ RequireClaim(/*string*/ claimType, /*IEnumerable<string>*/ allowedValues)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(claimType);
        Requirements.Add(new ClaimsAuthorizationRequirement(claimType, allowedValues));
        return this;
    }
    /*AuthorizationPolicyBuilder*/ RequireClaim(/*string*/ claimType)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(claimType);
        Requirements.Add(new ClaimsAuthorizationRequirement(claimType, { allowedValues : null }));
        return this;
    }
    /*AuthorizationPolicyBuilder*/ RequireRole(/*params string[]*/ roles)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(roles);
        return RequireRole(BlazorJs.Cast(roles, IEnumerable(string)));
    }
    /*AuthorizationPolicyBuilder*/ RequireRole(/*IEnumerable<string>*/ roles)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(roles);
        Requirements.Add(new RolesAuthorizationRequirement(roles));
        return this;
    }
    /*AuthorizationPolicyBuilder*/ RequireUserName(/*string*/ userName)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(userName);
        Requirements.Add(new NameAuthorizationRequirement(userName));
        return this;
    }
    /*AuthorizationPolicyBuilder*/ RequireAuthenticatedUser()
    {
        Requirements.Add(_denyAnonymousAuthorizationRequirement);
        return this;
    }
    /*AuthorizationPolicyBuilder*/ RequireAssertion(/*Func<AuthorizationHandlerContext, bool>*/ handler)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(handler);
        Requirements.Add(new AssertionRequirement(handler));
        return this;
    }
    /*AuthorizationPolicyBuilder*/ RequireAssertion(/*Func<AuthorizationHandlerContext, Task<bool>>*/ handler)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(handler);
        Requirements.Add(new AssertionRequirement(handler));
        return this;
    }
    /*AuthorizationPolicy*/ Build()
    {
        return new AuthorizationPolicy(Requirements, AuthenticationSchemes.Distinct());
    }
}

class Microsoft_AspNetCore_Authorization_AuthorizationResult extends object
{
    /*AuthorizationResult*/ static _succeededResult = BlazorJs.PopulateProperty(new AuthorizationResult(), function(/*AuthorizationResult*/ $obj)
    {
        $obj.Succeeded = true;
    });
    /*AuthorizationResult*/ static _failedResult = BlazorJs.PopulateProperty(new AuthorizationResult(), function(/*AuthorizationResult*/ $obj)
    {
        $obj.Failure = AuthorizationFailure.ExplicitFail();
    });
    constructor()
    {
        super();
    }
    /*bool*/ _backingField_Succeeded = null;
    /*bool*/ get Succeeded()
    {
        return _backingField_Succeeded;
    }
    /*bool*/ set Succeeded(value)
    {
        _backingField_Succeeded = value;
    }
    /*AuthorizationFailure*/ _backingField_Failure = null;
    /*AuthorizationFailure*/ get Failure()
    {
        return _backingField_Failure;
    }
    /*AuthorizationFailure*/ set Failure(value)
    {
        _backingField_Failure = value;
    }
    /*AuthorizationResult*/ static Success()
    {
        return _succeededResult;
    }
    /*AuthorizationResult*/ static Failed(/*AuthorizationFailure*/ failure)
    {
        return BlazorJs.PopulateProperty(new AuthorizationResult(), function(/*AuthorizationResult*/ $obj)
        {
            $obj.Failure = failure;
        });
    }
    /*AuthorizationResult*/ static Failed()
    {
        return _failedResult;
    }
}

class Microsoft_AspNetCore_Authorization_AuthorizeAttribute extends Microsoft_AspNetCore_Authorization_IAuthorizeData(System_Attribute)
{
    /*string*/ _backingField_Policy = null;
    /*string*/ get Policy()
    {
        return _backingField_Policy;
    }
    /*string*/ set Policy(value)
    {
        _backingField_Policy = value;
    }
    /*string*/ _backingField_Roles = null;
    /*string*/ get Roles()
    {
        return _backingField_Roles;
    }
    /*string*/ set Roles(value)
    {
        _backingField_Roles = value;
    }
    /*string*/ _backingField_AuthenticationSchemes = null;
    /*string*/ get AuthenticationSchemes()
    {
        return _backingField_AuthenticationSchemes;
    }
    /*string*/ set AuthenticationSchemes(value)
    {
        _backingField_AuthenticationSchemes = value;
    }
    constructor(/*string*/ policy)
    {
        super();
        Policy = policy;
    }
    constructor()
    {
        super();
    }
}

class Microsoft_AspNetCore_Authorization_ClaimsAuthorizationRequirement extends Microsoft_AspNetCore_Authorization_IAuthorizationRequirement(Microsoft_AspNetCore_Authorization_AuthorizationHandler(Microsoft_AspNetCore_Authorization_ClaimsAuthorizationRequirement))
{
    /*bool*/ _emptyAllowedValues = null;
    constructor(/*string*/ claimType, /*IEnumerable<string>*/ allowedValues)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(claimType);
        ClaimType = claimType;
        AllowedValues = allowedValues;
        _emptyAllowedValues = AllowedValues === null || AllowedValues.Any();
    }
    /*string*/ _backingField_ClaimType = null;
    /*string*/ get ClaimType()
    {
        return _backingField_ClaimType;
    }
    /*IEnumerable<string>*/ _backingField_AllowedValues = null;
    /*IEnumerable<string>*/ get AllowedValues()
    {
        return _backingField_AllowedValues;
    }
    /*Task*/ HandleRequirementAsync(/*AuthorizationHandlerContext*/ context, /*ClaimsAuthorizationRequirement*/ requirement)
    {
        if (context.User  !== null)
        {
            /*var*/ let found = false;
            if (requirement._emptyAllowedValues)
            {
                BlazorJs.forEach(context.User.Claims, function(claim, $_i)
                {
                    if (string.Equals(claim.Type, requirement.ClaimType, StringComparison.OrdinalIgnoreCase))
                    {
                        found = true;
                        break;
                    }
                });
            }
            else 
            {
                BlazorJs.forEach(context.User.Claims, function(claim, $_i)
                {
                    if (string.Equals(claim.Type, requirement.ClaimType, StringComparison.OrdinalIgnoreCase) && requirement.AllowedValues.Contains(claim.Value, StringComparer.Ordinal))
                    {
                        found = true;
                        break;
                    }
                });
            }
            if (found)
            {
                context.Succeed(requirement);
            }
        }
        return Task.CompletedTask;
    }
    /*string*/ ToString()
    {
        /*var*/ let value = (_emptyAllowedValues) ? string.Empty
 : ` and Claim.Value is one of the following values: (${string.Join("|", AllowedValues)})`;
        return `${nameof(ClaimsAuthorizationRequirement)}:Claim.Type=${ClaimType}${value}`;
    }
}

class Microsoft_AspNetCore_Authorization_DenyAnonymousAuthorizationRequirement extends Microsoft_AspNetCore_Authorization_IAuthorizationRequirement(Microsoft_AspNetCore_Authorization_AuthorizationHandler(Microsoft_AspNetCore_Authorization_DenyAnonymousAuthorizationRequirement))
{
    constructor()
    {
        super();
    }
    /*Task*/ HandleRequirementAsync(/*AuthorizationHandlerContext*/ context, /*DenyAnonymousAuthorizationRequirement*/ requirement)
    {
        /*var*/ let user = context.User;
        /*var*/ let userIsAnonymous = user?.Identity === null || user.Identities.Any(function(/**/ i)
        {
            return i.IsAuthenticated;
        });
        if (userIsAnonymous)
        {
            context.Succeed(requirement);
        }
        return Task.CompletedTask;
    }
    /*string*/ ToString()
    {
        return `${nameof(DenyAnonymousAuthorizationRequirement)}: Requires an authenticated user.`;
    }
}

const Microsoft_AspNetCore_Authorization_IAllowAnonymous = (Base) => class extends Base
{
}

const Microsoft_AspNetCore_Authorization_IAuthorizationHandler = (Base) => class extends Base
{
}

const Microsoft_AspNetCore_Authorization_IAuthorizationPolicyProvider = (Base) => class extends Base
{
}

const Microsoft_AspNetCore_Authorization_IAuthorizationRequirement = (Base) => class extends Base
{
}

const Microsoft_AspNetCore_Authorization_IAuthorizationService = (Base) => class extends Base
{
}

const Microsoft_AspNetCore_Authorization_IAuthorizeData = (Base) => class extends Base
{
    /*//
        // Summary:
        //     Gets or sets the policy name that determines access to the resource.
        string*/ _backingField_Policy = null;
    /*//
        // Summary:
        //     Gets or sets the policy name that determines access to the resource.
        string*/ get Policy()
    {
        return _backingField_Policy;
    }
    /*//
        // Summary:
        //     Gets or sets the policy name that determines access to the resource.
        string*/ set Policy(value)
    {
        _backingField_Policy = value;
    }
    /*//
        // Summary:
        //     Gets or sets a comma delimited list of roles that are allowed to access the resource.
        string*/ _backingField_Roles = null;
    /*//
        // Summary:
        //     Gets or sets a comma delimited list of roles that are allowed to access the resource.
        string*/ get Roles()
    {
        return _backingField_Roles;
    }
    /*//
        // Summary:
        //     Gets or sets a comma delimited list of roles that are allowed to access the resource.
        string*/ set Roles(value)
    {
        _backingField_Roles = value;
    }
    /*//
        // Summary:
        //     Gets or sets a comma delimited list of schemes from which user information is
        //     constructed.
        string*/ _backingField_AuthenticationSchemes = null;
    /*//
        // Summary:
        //     Gets or sets a comma delimited list of schemes from which user information is
        //     constructed.
        string*/ get AuthenticationSchemes()
    {
        return _backingField_AuthenticationSchemes;
    }
    /*//
        // Summary:
        //     Gets or sets a comma delimited list of schemes from which user information is
        //     constructed.
        string*/ set AuthenticationSchemes(value)
    {
        _backingField_AuthenticationSchemes = value;
    }
}

class Microsoft_AspNetCore_Authorization_NameAuthorizationRequirement extends Microsoft_AspNetCore_Authorization_IAuthorizationRequirement(Microsoft_AspNetCore_Authorization_AuthorizationHandler(Microsoft_AspNetCore_Authorization_NameAuthorizationRequirement))
{
    constructor(/*string*/ requiredName)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(requiredName);
        RequiredName = requiredName;
    }
    /*string*/ _backingField_RequiredName = null;
    /*string*/ get RequiredName()
    {
        return _backingField_RequiredName;
    }
    /*Task*/ HandleRequirementAsync(/*AuthorizationHandlerContext*/ context, /*NameAuthorizationRequirement*/ requirement)
    {
        if (context.User  !== null)
        {
            /*var*/ let succeed = false;
            BlazorJs.forEach(context.User.Identities, function(identity, $_i)
            {
                if (string.Equals(identity.Name, requirement.RequiredName, StringComparison.Ordinal))
                {
                    succeed = true;
                    break;
                }
            });
            if (succeed)
            {
                context.Succeed(requirement);
            }
        }
        return Task.CompletedTask;
    }
    /*string*/ ToString()
    {
        return `${nameof(NameAuthorizationRequirement)}:Requires a user identity with Name equal to ${RequiredName}`;
    }
}

class Microsoft_AspNetCore_Authorization_RolesAuthorizationRequirement extends Microsoft_AspNetCore_Authorization_IAuthorizationRequirement(Microsoft_AspNetCore_Authorization_AuthorizationHandler(Microsoft_AspNetCore_Authorization_RolesAuthorizationRequirement))
{
    constructor(/*IEnumerable<string>*/ allowedRoles)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(allowedRoles);
        if (allowedRoles.Any())
        {
            throw new InvalidOperationException("RoleRequirementEmpty");
        }
        AllowedRoles = allowedRoles;
    }
    /*IEnumerable<string>*/ _backingField_AllowedRoles = null;
    /*IEnumerable<string>*/ get AllowedRoles()
    {
        return _backingField_AllowedRoles;
    }
    /*Task*/ HandleRequirementAsync(/*AuthorizationHandlerContext*/ context, /*RolesAuthorizationRequirement*/ requirement)
    {
        if (context.User  !== null)
        {
            /*var*/ let found = false;
            BlazorJs.forEach(requirement.AllowedRoles, function(role, $_i)
            {
                if (context.User.IsInRole(role))
                {
                    found = true;
                    break;
                }
            });
            if (found)
            {
                context.Succeed(requirement);
            }
        }
        return Task.CompletedTask;
    }
    /*string*/ ToString()
    {
        /*var*/ let roles = `User.IsInRole must be true for one of the following roles: (${string.Join("|", AllowedRoles)})`;
        return `${nameof(RolesAuthorizationRequirement)}:${roles}`;
    }
}

static class Microsoft_AspNetCore_Components_BindConverter
{
    /*object*/ static BoxedTrue = true;
    /*object*/ static BoxedFalse = false;
    /*string*/ static FormatValue(/*string*/ value, { /*CultureInfo*/ culture = null})
    {
        return FormatStringValueCore(value, culture);
    }
    /*string*/ static FormatStringValueCore(/*string*/ value, /*CultureInfo*/ _)
    {
        return value;
    }
    /*bool*/ static FormatValue(/*bool*/ value, { /*CultureInfo*/ culture = null})
    {
        return value;
    }
    /*object*/ static FormatBoolValueCore(/*bool*/ value, /*CultureInfo*/ _)
    {
        return value ? BoxedTrue : BoxedFalse;
    }
    /*bool?*/ static FormatValue(/*bool?*/ value, { /*CultureInfo*/ culture = null})
    {
        return value === null ? BlazorJs.Cast(null, bool) : value.Value;
    }
    /*object*/ static FormatNullableBoolValueCore(/*bool?*/ value, /*CultureInfo*/ _)
    {
        return value === null ? null : value.Value  ? BoxedTrue : BoxedFalse;
    }
    /*string*/ static FormatValue(/*int*/ value, { /*CultureInfo*/ culture = null})
    {
        return FormatIntValueCore(value, culture);
    }
    /*string*/ static FormatIntValueCore(/*int*/ value, /*CultureInfo*/ culture)
    {
        return value.ToString();
    }
    /*string*/ static FormatValue(/*int?*/ value, { /*CultureInfo*/ culture = null})
    {
        return FormatNullableIntValueCore(value, culture);
    }
    /*string*/ static FormatNullableIntValueCore(/*int?*/ value, /*CultureInfo*/ culture)
    {
        if (value === null)
        {
            return null;
        }
        return value.Value.ToString();
    }
    /*string*/ static FormatValue(/*long*/ value, { /*CultureInfo*/ culture = null})
    {
        return FormatLongValueCore(value, culture);
    }
    /*string*/ static FormatLongValueCore(/*long*/ value, /*CultureInfo*/ culture)
    {
        return value.ToString();
    }
    /*string*/ static FormatValue(/*long?*/ value, { /*CultureInfo*/ culture = null})
    {
        return FormatNullableLongValueCore(value, culture);
    }
    /*string*/ static FormatNullableLongValueCore(/*long?*/ value, /*CultureInfo*/ culture)
    {
        if (value === null)
        {
            return null;
        }
        return value.Value.ToString();
    }
    /*string*/ static FormatValue(/*short*/ value, { /*CultureInfo*/ culture = null})
    {
        return FormatShortValueCore(value, culture);
    }
    /*string*/ static FormatShortValueCore(/*short*/ value, /*CultureInfo*/ culture)
    {
        return value.ToString();
    }
    /*string*/ static FormatValue(/*short?*/ value, { /*CultureInfo*/ culture = null})
    {
        return FormatNullableShortValueCore(value, culture);
    }
    /*string*/ static FormatNullableShortValueCore(/*short?*/ value, /*CultureInfo*/ culture)
    {
        if (value === null)
        {
            return null;
        }
        return value.Value.ToString();
    }
    /*string*/ static FormatValue(/*float*/ value, { /*CultureInfo*/ culture = null})
    {
        return FormatFloatValueCore(value, culture);
    }
    /*string*/ static FormatFloatValueCore(/*float*/ value, /*CultureInfo*/ culture)
    {
        return value.ToString();
    }
    /*string*/ static FormatValue(/*float?*/ value, { /*CultureInfo*/ culture = null})
    {
        return FormatNullableFloatValueCore(value, culture);
    }
    /*string*/ static FormatNullableFloatValueCore(/*float?*/ value, /*CultureInfo*/ culture)
    {
        if (value === null)
        {
            return null;
        }
        return value.Value.ToString();
    }
    /*string*/ static FormatValue(/*double*/ value, { /*CultureInfo*/ culture = null})
    {
        return FormatDoubleValueCore(value, culture);
    }
    /*string*/ static FormatDoubleValueCore(/*double*/ value, /*CultureInfo*/ culture)
    {
        return value.ToString();
    }
    /*string*/ static FormatValue(/*double?*/ value, { /*CultureInfo*/ culture = null})
    {
        return FormatNullableDoubleValueCore(value, culture);
    }
    /*string*/ static FormatNullableDoubleValueCore(/*double?*/ value, /*CultureInfo*/ culture)
    {
        if (value === null)
        {
            return null;
        }
        return value.Value.ToString();
    }
    /*string*/ static FormatValue(/*decimal*/ value, { /*CultureInfo*/ culture = null})
    {
        return FormatDecimalValueCore(value, culture);
    }
    /*string*/ static FormatDecimalValueCore(/*decimal*/ value, /*CultureInfo*/ culture)
    {
        return value.ToString();
    }
    /*string*/ static FormatValue(/*decimal?*/ value, { /*CultureInfo*/ culture = null})
    {
        return FormatNullableDecimalValueCore(value, culture);
    }
    /*string*/ static FormatNullableDecimalValueCore(/*decimal?*/ value, /*CultureInfo*/ culture)
    {
        if (value === null)
        {
            return null;
        }
        return value.Value.ToString();
    }
    /*string*/ static FormatValue(/*DateTime*/ value, { /*CultureInfo*/ culture = null})
    {
        return FormatDateTimeValueCore(value, null, culture);
    }
    /*string*/ static FormatValue(/*DateTime*/ value, /*string*/ format, { /*CultureInfo*/ culture = null})
    {
        return FormatDateTimeValueCore(value, format, culture);
    }
    /*string*/ static FormatDateTimeValueCore(/*DateTime*/ value, /*string*/ format, /*CultureInfo*/ culture)
    {
        if (format !== null)
        {
            return value.ToString(format);
        }
        return value.ToString();
    }
    /*string*/ static FormatDateTimeValueCore(/*DateTime*/ value, /*CultureInfo*/ culture)
    {
        return value.ToString();
    }
    /*string*/ static FormatValue(/*DateTime?*/ value, { /*CultureInfo*/ culture = null})
    {
        return FormatNullableDateTimeValueCore(value, null, culture);
    }
    /*string*/ static FormatValue(/*DateTime?*/ value, /*string*/ format, { /*CultureInfo*/ culture = null})
    {
        return FormatNullableDateTimeValueCore(value, format, culture);
    }
    /*string*/ static FormatNullableDateTimeValueCore(/*DateTime?*/ value, /*string*/ format, /*CultureInfo*/ culture)
    {
        if (value === null)
        {
            return null;
        }
        if (format !== null)
        {
            return value.Value.ToString(format);
        }
        return value.Value.ToString();
    }
    /*string*/ static FormatNullableDateTimeValueCore(/*DateTime?*/ value, /*CultureInfo*/ culture)
    {
        if (value === null)
        {
            return null;
        }
        return value.Value.ToString();
    }
    /*string*/ static FormatValue(/*DateTimeOffset*/ value, { /*CultureInfo*/ culture = null})
    {
        return FormatDateTimeOffsetValueCore(value, null, culture);
    }
    /*string*/ static FormatValue(/*DateTimeOffset*/ value, /*string*/ format, { /*CultureInfo*/ culture = null})
    {
        return FormatDateTimeOffsetValueCore(value, format, culture);
    }
    /*string*/ static FormatDateTimeOffsetValueCore(/*DateTimeOffset*/ value, /*string*/ format, /*CultureInfo*/ culture)
    {
        if (format !== null)
        {
            return value.ToString(format);
        }
        return value.ToString();
    }
    /*string*/ static FormatDateTimeOffsetValueCore(/*DateTimeOffset*/ value, /*CultureInfo*/ culture)
    {
        return value.ToString();
    }
    /*string*/ static FormatValue(/*DateTimeOffset?*/ value, { /*CultureInfo*/ culture = null})
    {
        return FormatNullableDateTimeOffsetValueCore(value, null, culture);
    }
    /*string*/ static FormatValue(/*DateTimeOffset?*/ value, /*string*/ format, { /*CultureInfo*/ culture = null})
    {
        return FormatNullableDateTimeOffsetValueCore(value, format, culture);
    }
    /*string*/ static FormatNullableDateTimeOffsetValueCore(/*DateTimeOffset?*/ value, /*string*/ format, /*CultureInfo*/ culture)
    {
        if (value === null)
        {
            return null;
        }
        if (format !== null)
        {
            return value.Value.ToString(format);
        }
        return value.Value.ToString();
    }
    /*string*/ static FormatNullableDateTimeOffsetValueCore(/*DateTimeOffset?*/ value, /*CultureInfo*/ culture)
    {
        if (value === null)
        {
            return null;
        }
        return value.Value.ToString();
    }
    /*string*/ static FormatEnumValueCore(T, /*T*/ value, /*CultureInfo*/ _)
    {
        if (value === null)
        {
            return null;
        }
        return value.ToString();
    }
    /*object*/ static FormatValue(T, /*T*/ value, { /*CultureInfo*/ culture = null})
    {
        /*var*/ let formatter = FormatterDelegateCache.Get(T);
        return formatter(value, culture);
    }
    /*bool*/ static TryConvertToString(/*object*/ obj, /*CultureInfo*/ culture, /*out string*/ value)
    {
        let $ref0 = { set value(v){ value = v } };
        return ConvertToStringCore(obj, culture, $ref0);
    }
    /*BindParser<string>*/ static ConvertToString = ConvertToStringCore;
    /*bool*/ static ConvertToStringCore(/*object*/ obj, /*CultureInfo*/ culture, /*out string*/ value)
    {
        value = BlazorJs.Cast(obj, string);
        return true;
    }
    /*bool*/ static TryConvertToBool(/*object*/ obj, /*CultureInfo*/ culture, /*out bool*/ value)
    {
        let $ref0 = { set value(v){ value = v } };
        return ConvertToBoolCore(obj, culture, $ref0);
    }
    /*bool*/ static TryConvertToNullableBool(/*object*/ obj, /*CultureInfo*/ culture, /*out bool?*/ value)
    {
        let $ref0 = { set value(v){ value = v } };
        return ConvertToNullableBoolCore(obj, culture, $ref0);
    }
    /*BindParser<bool>*/ static ConvertToBool = ConvertToBoolCore;
    /*BindParser<bool?>*/ static ConvertToNullableBool = ConvertToNullableBoolCore;
    /*bool*/ static ConvertToBoolCore(/*object*/ obj, /*CultureInfo*/ culture, /*out bool*/ value)
    {
        value = BlazorJs.Cast(obj, bool);
        return true;
    }
    /*bool*/ static ConvertToNullableBoolCore(/*object*/ obj, /*CultureInfo*/ culture, /*out bool?*/ value)
    {
        value = BlazorJs.Cast(obj, bool);
        return true;
    }
    /*bool*/ static TryConvertToInt(/*object*/ obj, /*CultureInfo*/ culture, /*out int*/ value)
    {
        let $ref0 = { set value(v){ value = v } };
        return ConvertToIntCore(obj, culture, $ref0);
    }
    /*bool*/ static TryConvertToNullableInt(/*object*/ obj, /*CultureInfo*/ culture, /*out int?*/ value)
    {
        let $ref0 = { set value(v){ value = v } };
        return ConvertToNullableIntCore(obj, culture, $ref0);
    }
    /*BindParser<int>*/ static ConvertToInt = ConvertToIntCore;
    /*BindParser<int?>*/ static ConvertToNullableInt = ConvertToNullableIntCore;
    /*bool*/ static ConvertToIntCore(/*object*/ obj, /*CultureInfo*/ culture, /*out int*/ value)
    {
        let converted = null;
        let $ref1 = { set value(v){ converted = v } };
        /*var*/ let text = BlazorJs.Cast(obj, string);
        if (string.IsNullOrEmpty(text))
        {
            value = BlazorJs.getDefault();
            return false;
        }
        if (int.TryParse(text, $ref1))
        {
            value = BlazorJs.getDefault();
            return false;
        }
        value = converted;
        return true;
    }
    /*bool*/ static ConvertToNullableIntCore(/*object*/ obj, /*CultureInfo*/ culture, /*out int?*/ value)
    {
        let converted = null;
        let $ref1 = { set value(v){ converted = v } };
        /*var*/ let text = BlazorJs.Cast(obj, string);
        if (string.IsNullOrEmpty(text))
        {
            value = BlazorJs.getDefault();
            return true;
        }
        if (int.TryParse(text, $ref1))
        {
            value = BlazorJs.getDefault();
            return false;
        }
        value = converted;
        return true;
    }
    /*bool*/ static TryConvertToLong(/*object*/ obj, /*CultureInfo*/ culture, /*out long*/ value)
    {
        let $ref0 = { set value(v){ value = v } };
        return ConvertToLongCore(obj, culture, $ref0);
    }
    /*bool*/ static TryConvertToNullableLong(/*object*/ obj, /*CultureInfo*/ culture, /*out long?*/ value)
    {
        let $ref0 = { set value(v){ value = v } };
        return ConvertToNullableLongCore(obj, culture, $ref0);
    }
    /*BindParser<long>*/ static ConvertToLong = ConvertToLongCore;
    /*BindParser<long?>*/ static ConvertToNullableLong = ConvertToNullableLongCore;
    /*bool*/ static ConvertToLongCore(/*object*/ obj, /*CultureInfo*/ culture, /*out long*/ value)
    {
        let converted = null;
        let $ref1 = { set value(v){ converted = v } };
        /*var*/ let text = BlazorJs.Cast(obj, string);
        if (string.IsNullOrEmpty(text))
        {
            value = BlazorJs.getDefault();
            return false;
        }
        if (long.TryParse(text, $ref1))
        {
            value = BlazorJs.getDefault();
            return false;
        }
        value = converted;
        return true;
    }
    /*bool*/ static ConvertToNullableLongCore(/*object*/ obj, /*CultureInfo*/ culture, /*out long?*/ value)
    {
        let converted = null;
        let $ref1 = { set value(v){ converted = v } };
        /*var*/ let text = BlazorJs.Cast(obj, string);
        if (string.IsNullOrEmpty(text))
        {
            value = BlazorJs.getDefault();
            return true;
        }
        if (long.TryParse(text, $ref1))
        {
            value = BlazorJs.getDefault();
            return false;
        }
        value = converted;
        return true;
    }
    /*bool*/ static TryConvertToShort(/*object*/ obj, /*CultureInfo*/ culture, /*out short*/ value)
    {
        let $ref0 = { set value(v){ value = v } };
        return ConvertToShortCore(obj, culture, $ref0);
    }
    /*bool*/ static TryConvertToNullableShort(/*object*/ obj, /*CultureInfo*/ culture, /*out short?*/ value)
    {
        let $ref0 = { set value(v){ value = v } };
        return ConvertToNullableShort(obj, culture, $ref0);
    }
    /*BindParser<short>*/ static ConvertToShort = ConvertToShortCore;
    /*BindParser<short?>*/ static ConvertToNullableShort = ConvertToNullableShortCore;
    /*bool*/ static ConvertToShortCore(/*object*/ obj, /*CultureInfo*/ culture, /*out short*/ value)
    {
        let converted = null;
        let $ref1 = { set value(v){ converted = v } };
        /*var*/ let text = BlazorJs.Cast(obj, string);
        if (string.IsNullOrEmpty(text))
        {
            value = BlazorJs.getDefault();
            return false;
        }
        if (short.TryParse(text, $ref1))
        {
            value = BlazorJs.getDefault();
            return false;
        }
        value = converted;
        return true;
    }
    /*bool*/ static ConvertToNullableShortCore(/*object*/ obj, /*CultureInfo*/ culture, /*out short?*/ value)
    {
        let converted = null;
        let $ref1 = { set value(v){ converted = v } };
        /*var*/ let text = BlazorJs.Cast(obj, string);
        if (string.IsNullOrEmpty(text))
        {
            value = BlazorJs.getDefault();
            return true;
        }
        if (short.TryParse(text, $ref1))
        {
            value = BlazorJs.getDefault();
            return false;
        }
        value = converted;
        return true;
    }
    /*bool*/ static TryConvertToFloat(/*object*/ obj, /*CultureInfo*/ culture, /*out float*/ value)
    {
        let $ref0 = { set value(v){ value = v } };
        return ConvertToFloatCore(obj, culture, $ref0);
    }
    /*bool*/ static TryConvertToNullableFloat(/*object*/ obj, /*CultureInfo*/ culture, /*out float?*/ value)
    {
        let $ref0 = { set value(v){ value = v } };
        return ConvertToNullableFloatCore(obj, culture, $ref0);
    }
    /*BindParser<float>*/ static ConvertToFloat = ConvertToFloatCore;
    /*BindParser<float?>*/ static ConvertToNullableFloat = ConvertToNullableFloatCore;
    /*bool*/ static ConvertToFloatCore(/*object*/ obj, /*CultureInfo*/ culture, /*out float*/ value)
    {
        let converted = null;
        let $ref1 = { set value(v){ converted = v } };
        /*var*/ let text = BlazorJs.Cast(obj, string);
        if (string.IsNullOrEmpty(text))
        {
            value = BlazorJs.getDefault();
            return false;
        }
        if (float.TryParse(text, $ref1))
        {
            value = BlazorJs.getDefault();
            return false;
        }
        if (float.IsInfinity(converted) || float.IsNaN(converted))
        {
            value = BlazorJs.getDefault();
            return false;
        }
        value = converted;
        return true;
    }
    /*bool*/ static ConvertToNullableFloatCore(/*object*/ obj, /*CultureInfo*/ culture, /*out float?*/ value)
    {
        let converted = null;
        let $ref1 = { set value(v){ converted = v } };
        /*var*/ let text = BlazorJs.Cast(obj, string);
        if (string.IsNullOrEmpty(text))
        {
            value = BlazorJs.getDefault();
            return true;
        }
        if (float.TryParse(text, $ref1))
        {
            value = BlazorJs.getDefault();
            return false;
        }
        if (float.IsInfinity(converted) || float.IsNaN(converted))
        {
            value = BlazorJs.getDefault();
            return false;
        }
        value = converted;
        return true;
    }
    /*bool*/ static TryConvertToDouble(/*object*/ obj, /*CultureInfo*/ culture, /*out double*/ value)
    {
        let $ref0 = { set value(v){ value = v } };
        return ConvertToDoubleCore(obj, culture, $ref0);
    }
    /*bool*/ static TryConvertToNullableDouble(/*object*/ obj, /*CultureInfo*/ culture, /*out double?*/ value)
    {
        let $ref0 = { set value(v){ value = v } };
        return ConvertToNullableDoubleCore(obj, culture, $ref0);
    }
    /*BindParser<double>*/ static ConvertToDoubleDelegate = ConvertToDoubleCore;
    /*BindParser<double?>*/ static ConvertToNullableDoubleDelegate = ConvertToNullableDoubleCore;
    /*bool*/ static ConvertToDoubleCore(/*object*/ obj, /*CultureInfo*/ culture, /*out double*/ value)
    {
        let converted = null;
        let $ref1 = { set value(v){ converted = v } };
        /*var*/ let text = BlazorJs.Cast(obj, string);
        if (string.IsNullOrEmpty(text))
        {
            value = BlazorJs.getDefault();
            return false;
        }
        if (double.TryParse(text, $ref1))
        {
            value = BlazorJs.getDefault();
            return false;
        }
        if (double.IsInfinity(converted) || double.IsNaN(converted))
        {
            value = BlazorJs.getDefault();
            return false;
        }
        value = converted;
        return true;
    }
    /*bool*/ static ConvertToNullableDoubleCore(/*object*/ obj, /*CultureInfo*/ culture, /*out double?*/ value)
    {
        let converted = null;
        let $ref1 = { set value(v){ converted = v } };
        /*var*/ let text = BlazorJs.Cast(obj, string);
        if (string.IsNullOrEmpty(text))
        {
            value = BlazorJs.getDefault();
            return true;
        }
        if (double.TryParse(text, $ref1))
        {
            value = BlazorJs.getDefault();
            return false;
        }
        if (double.IsInfinity(converted) || double.IsNaN(converted))
        {
            value = BlazorJs.getDefault();
            return false;
        }
        value = converted;
        return true;
    }
    /*bool*/ static TryConvertToDecimal(/*object*/ obj, /*CultureInfo*/ culture, /*out decimal*/ value)
    {
        let $ref0 = { set value(v){ value = v } };
        return ConvertToDecimalCore(obj, culture, $ref0);
    }
    /*bool*/ static TryConvertToNullableDecimal(/*object*/ obj, /*CultureInfo*/ culture, /*out decimal?*/ value)
    {
        let $ref0 = { set value(v){ value = v } };
        return ConvertToNullableDecimalCore(obj, culture, $ref0);
    }
    /*BindParser<decimal>*/ static ConvertToDecimal = ConvertToDecimalCore;
    /*BindParser<decimal?>*/ static ConvertToNullableDecimal = ConvertToNullableDecimalCore;
    /*bool*/ static ConvertToDecimalCore(/*object*/ obj, /*CultureInfo*/ culture, /*out decimal*/ value)
    {
        let converted = null;
        let $ref1 = { set value(v){ converted = v } };
        /*var*/ let text = BlazorJs.Cast(obj, string);
        if (string.IsNullOrEmpty(text))
        {
            value = BlazorJs.getDefault();
            return false;
        }
        if (decimal.TryParse(text, $ref1))
        {
            value = BlazorJs.getDefault();
            return false;
        }
        value = converted;
        return true;
    }
    /*bool*/ static ConvertToNullableDecimalCore(/*object*/ obj, /*CultureInfo*/ culture, /*out decimal?*/ value)
    {
        let converted = null;
        let $ref1 = { set value(v){ converted = v } };
        /*var*/ let text = BlazorJs.Cast(obj, string);
        if (string.IsNullOrEmpty(text))
        {
            value = BlazorJs.getDefault();
            return true;
        }
        if (decimal.TryParse(text, $ref1))
        {
            value = BlazorJs.getDefault();
            return false;
        }
        value = converted;
        return true;
    }
    /*bool*/ static TryConvertToDateTime(/*object*/ obj, /*CultureInfo*/ culture, /*out DateTime*/ value)
    {
        let $ref0 = { set value(v){ value = v } };
        return ConvertToDateTimeCore(obj, culture, $ref0);
    }
    /*bool*/ static TryConvertToDateTime(/*object*/ obj, /*CultureInfo*/ culture, /*string*/ format, /*out DateTime*/ value)
    {
        let $ref0 = { set value(v){ value = v } };
        return ConvertToDateTimeCore(obj, culture, format, $ref0);
    }
    /*bool*/ static TryConvertToNullableDateTime(/*object*/ obj, /*CultureInfo*/ culture, /*out DateTime?*/ value)
    {
        let $ref0 = { set value(v){ value = v } };
        return ConvertToNullableDateTimeCore(obj, culture, $ref0);
    }
    /*bool*/ static TryConvertToNullableDateTime(/*object*/ obj, /*CultureInfo*/ culture, /*string*/ format, /*out DateTime?*/ value)
    {
        let $ref0 = { set value(v){ value = v } };
        return ConvertToNullableDateTimeCore(obj, culture, format, $ref0);
    }
    /*BindParser<DateTime>*/ static ConvertToDateTime = ConvertToDateTimeCore;
    /*BindParserWithFormat<DateTime>*/ static ConvertToDateTimeWithFormat = ConvertToDateTimeCore;
    /*BindParser<DateTime?>*/ static ConvertToNullableDateTime = ConvertToNullableDateTimeCore;
    /*BindParserWithFormat<DateTime?>*/ static ConvertToNullableDateTimeWithFormat = ConvertToNullableDateTimeCore;
    /*bool*/ static ConvertToDateTimeCore(/*object*/ obj, /*CultureInfo*/ culture, /*out DateTime*/ value)
    {
        let $ref0 = { set value(v){ value = v } };
        return ConvertToDateTimeCore(obj, culture, null, $ref0);
    }
    /*bool*/ static ConvertToDateTimeCore(/*object*/ obj, /*CultureInfo*/ culture, /*string*/ format, /*out DateTime*/ value)
    {
        let converted = null;
        let $ref1 = { set value(v){ converted = v } };
        let $ref2 = { set value(v){ converted = v } };
        /*var*/ let text = BlazorJs.Cast(obj, string);
        if (string.IsNullOrEmpty(text))
        {
            value = BlazorJs.getDefault();
            return false;
        }
        if (format !== null && DateTime.TryParseExact(text, format, null, $ref1))
        {
            value = converted;
            return true;
        }
        else if (format === null && DateTime.TryParse(text, $ref2))
        {
            value = converted;
            return true;
        }
        value = BlazorJs.getDefault();
        return false;
    }
    /*bool*/ static ConvertToNullableDateTimeCore(/*object*/ obj, /*CultureInfo*/ culture, /*out DateTime?*/ value)
    {
        let $ref0 = { set value(v){ value = v } };
        return ConvertToNullableDateTimeCore(obj, culture, null, $ref0);
    }
    /*bool*/ static ConvertToNullableDateTimeCore(/*object*/ obj, /*CultureInfo*/ culture, /*string*/ format, /*out DateTime?*/ value)
    {
        let converted = null;
        let $ref1 = { set value(v){ converted = v } };
        let $ref2 = { set value(v){ converted = v } };
        /*var*/ let text = BlazorJs.Cast(obj, string);
        if (string.IsNullOrEmpty(text))
        {
            value = BlazorJs.getDefault();
            return true;
        }
        if (format !== null && DateTime.TryParseExact(text, format, null, $ref1))
        {
            value = converted;
            return true;
        }
        else if (format === null && DateTime.TryParse(text, $ref2))
        {
            value = converted;
            return true;
        }
        value = BlazorJs.getDefault();
        return false;
    }
    /*bool*/ static TryConvertToDateTimeOffset(/*object*/ obj, /*CultureInfo*/ culture, /*out DateTimeOffset*/ value)
    {
        let $ref0 = { set value(v){ value = v } };
        return ConvertToDateTimeOffsetCore(obj, culture, $ref0);
    }
    /*bool*/ static TryConvertToDateTimeOffset(/*object*/ obj, /*CultureInfo*/ culture, /*string*/ format, /*out DateTimeOffset*/ value)
    {
        let $ref0 = { set value(v){ value = v } };
        return ConvertToDateTimeOffsetCore(obj, culture, format, $ref0);
    }
    /*bool*/ static TryConvertToNullableDateTimeOffset(/*object*/ obj, /*CultureInfo*/ culture, /*out DateTimeOffset?*/ value)
    {
        let $ref0 = { set value(v){ value = v } };
        return ConvertToNullableDateTimeOffsetCore(obj, culture, $ref0);
    }
    /*bool*/ static TryConvertToNullableDateTimeOffset(/*object*/ obj, /*CultureInfo*/ culture, /*string*/ format, /*out DateTimeOffset?*/ value)
    {
        let $ref0 = { set value(v){ value = v } };
        return ConvertToNullableDateTimeOffsetCore(obj, culture, format, $ref0);
    }
    /*BindParser<DateTimeOffset>*/ static ConvertToDateTimeOffset = ConvertToDateTimeOffsetCore;
    /*BindParserWithFormat<DateTimeOffset>*/ static ConvertToDateTimeOffsetWithFormat = ConvertToDateTimeOffsetCore;
    /*BindParser<DateTimeOffset?>*/ static ConvertToNullableDateTimeOffset = ConvertToNullableDateTimeOffsetCore;
    /*BindParserWithFormat<DateTimeOffset?>*/ static ConvertToNullableDateTimeOffsetWithFormat = ConvertToNullableDateTimeOffsetCore;
    /*bool*/ static ConvertToDateTimeOffsetCore(/*object*/ obj, /*CultureInfo*/ culture, /*out DateTimeOffset*/ value)
    {
        let $ref0 = { set value(v){ value = v } };
        return ConvertToDateTimeOffsetCore(obj, culture, null, $ref0);
    }
    /*bool*/ static ConvertToDateTimeOffsetCore(/*object*/ obj, /*CultureInfo*/ culture, /*string*/ format, /*out DateTimeOffset*/ value)
    {
        let converted = null;
        let $ref1 = { set value(v){ converted = v } };
        /*var*/ let text = BlazorJs.Cast(obj, string);
        if (string.IsNullOrEmpty(text))
        {
            value = BlazorJs.getDefault();
            return false;
        }
        if (format === null && DateTimeOffset.TryParse(text, $ref1))
        {
            value = converted;
            return true;
        }
        value = BlazorJs.getDefault();
        return false;
    }
    /*bool*/ static ConvertToNullableDateTimeOffsetCore(/*object*/ obj, /*CultureInfo*/ culture, /*out DateTimeOffset?*/ value)
    {
        let $ref0 = { set value(v){ value = v } };
        return ConvertToNullableDateTimeOffsetCore(obj, culture, null, $ref0);
    }
    /*bool*/ static ConvertToNullableDateTimeOffsetCore(/*object*/ obj, /*CultureInfo*/ culture, /*string*/ format, /*out DateTimeOffset?*/ value)
    {
        let converted = null;
        let $ref1 = { set value(v){ converted = v } };
        /*var*/ let text = BlazorJs.Cast(obj, string);
        if (string.IsNullOrEmpty(text))
        {
            value = BlazorJs.getDefault();
            return true;
        }
        if (format === null && DateTimeOffset.TryParse(text, $ref1))
        {
            value = converted;
            return true;
        }
        value = BlazorJs.getDefault();
        return false;
    }
    /*BindParser<Guid>*/ static ConvertToGuid = ConvertToGuidCore;
    /*BindParser<Guid?>*/ static ConvertToNullableGuid = ConvertToNullableGuidCore;
    /*bool*/ static ConvertToGuidCore(/*object*/ obj, /*CultureInfo*/ culture, /*out Guid*/ value)
    {
        let converted = null;
        let $ref1 = { set value(v){ converted = v } };
        ConvertToNullableGuidCore(obj, culture, $ref1);
        value = converted.GetValueOrDefault();
        return converted.HasValue;
    }
    /*bool*/ static ConvertToNullableGuidCore(/*object*/ obj, /*CultureInfo*/ culture, /*out Guid?*/ value)
    {
        let converted = null;
        let $ref1 = { set value(v){ converted = v } };
        /*var*/ let text = BlazorJs.Cast(obj, string);
        if (string.IsNullOrEmpty(text))
        {
            value = BlazorJs.getDefault();
            return true;
        }
        if (Guid.TryParse(text, $ref1))
        {
            value = BlazorJs.getDefault();
            return false;
        }
        value = converted;
        return true;
    }
    /*bool*/ static ConvertToEnum(T, /*object*/ obj, /*CultureInfo*/ _, /*out T*/ value)
    {
        let converted = null;
        let $ref1 = { set value(v){ converted = v } };
        /*var*/ let text = BlazorJs.Cast(obj, string);
        if (string.IsNullOrEmpty(text))
        {
            value = BlazorJs.getDefault();
            return true;
        }
        if (Enum.TryParse(T, text, $ref1))
        {
            value = BlazorJs.getDefault();
            return false;
        }
        if (Enum.IsDefined(T, converted))
        {
            value = BlazorJs.getDefault();
            return false;
        }
        value = converted;
        return true;
    }
    /*bool*/ static ConvertToNullableEnum(T, /*object*/ obj, /*CultureInfo*/ _, /*out T?*/ value)
    {
        let converted = null;
        let $ref1 = { set value(v){ converted = v } };
        /*var*/ let text = BlazorJs.Cast(obj, string);
        if (string.IsNullOrEmpty(text))
        {
            value = BlazorJs.getDefault();
            return true;
        }
        if (Enum.TryParse(T, text, $ref1))
        {
            value = BlazorJs.getDefault();
            return false;
        }
        if (Enum.IsDefined(T, converted))
        {
            value = BlazorJs.getDefault();
            return false;
        }
        value = converted;
        return true;
    }
    /*bool*/ static TryConvertTo(T, /*object*/ obj, /*CultureInfo*/ culture, /*out T*/ value)
    {
        let $ref0 = { set value(v){ value = v } };
        /*var*/ let converter = ParserDelegateCache.Get(T);
        return converter(obj, culture, $ref0);
    }
    static Microsoft_AspNetCore_Components_BindConverter_FormatterDelegateCache = class
    {
        /*Dictionary<Type, Delegate>*/ static _cache = new Dictionary(Type, Delegate)();
        /*MethodInfo*/ static _makeArrayFormatter = null;
        /*BindFormatter<T>*/ static Get(T)
        {
            let formatter = null;
            let $ref1 = { set value(v){ formatter = v } };
            if (_cache.TryGetValue(T, $ref1))
            {
                if (T === string)
                {
                    formatter = BlazorJs.Cast(FormatStringValueCore, BindFormatter(string));
                }
                else if (T === bool)
                {
                    formatter = BlazorJs.Cast(FormatBoolValueCore, BindFormatter(bool));
                }
                else if (T === bool)
                {
                    formatter = BlazorJs.Cast(FormatNullableBoolValueCore, BindFormatter(bool));
                }
                else if (T === int)
                {
                    formatter = BlazorJs.Cast(FormatIntValueCore, BindFormatter(int));
                }
                else if (T === int)
                {
                    formatter = BlazorJs.Cast(FormatNullableIntValueCore, BindFormatter(int));
                }
                else if (T === long)
                {
                    formatter = BlazorJs.Cast(FormatLongValueCore, BindFormatter(long));
                }
                else if (T === long)
                {
                    formatter = BlazorJs.Cast(FormatNullableLongValueCore, BindFormatter(long));
                }
                else if (T === short)
                {
                    formatter = BlazorJs.Cast(FormatShortValueCore, BindFormatter(short));
                }
                else if (T === short)
                {
                    formatter = BlazorJs.Cast(FormatNullableShortValueCore, BindFormatter(short));
                }
                else if (T === float)
                {
                    formatter = BlazorJs.Cast(FormatFloatValueCore, BindFormatter(float));
                }
                else if (T === float)
                {
                    formatter = BlazorJs.Cast(FormatNullableFloatValueCore, BindFormatter(float));
                }
                else if (T === double)
                {
                    formatter = BlazorJs.Cast(FormatDoubleValueCore, BindFormatter(double));
                }
                else if (T === double)
                {
                    formatter = BlazorJs.Cast(FormatNullableDoubleValueCore, BindFormatter(double));
                }
                else if (T === decimal)
                {
                    formatter = BlazorJs.Cast(FormatDecimalValueCore, BindFormatter(decimal));
                }
                else if (T === decimal)
                {
                    formatter = BlazorJs.Cast(FormatNullableDecimalValueCore, BindFormatter(decimal));
                }
                else if (T === DateTime)
                {
                    formatter = BlazorJs.Cast(FormatDateTimeValueCore, BindFormatter(DateTime));
                }
                else if (T === DateTime)
                {
                    formatter = BlazorJs.Cast(FormatNullableDateTimeValueCore, BindFormatter(DateTime));
                }
                else if (T === DateTimeOffset)
                {
                    formatter = BlazorJs.Cast(FormatDateTimeOffsetValueCore, BindFormatter(DateTimeOffset));
                }
                else if (T === DateTimeOffset)
                {
                    formatter = BlazorJs.Cast(FormatNullableDateTimeOffsetValueCore, BindFormatter(DateTimeOffset));
                }
                else if (T.IsEnum  || Nullable.GetUnderlyingType(T) instanceof Type && innerType.IsEnum)
                {
                    formatter = BlazorJs.Cast(FormatEnumValueCore(T), BindFormatter(T));
                }
                else if (T.IsArray)
                {
                    /*var*/ let method = _makeArrayFormatter = _makeArrayFormatter ?? FormatterDelegateCache.GetMethod(nameof(MakeArrayFormatter), BindingFlags.NonPublic  | BindingFlags.Static);
                    /*var*/ let elementType = T.GetElementType();
                    formatter = BlazorJs.Cast(method.MakeGenericMethod(elementType).Invoke(null, null), Delegate);
                }
                else 
                {
                    formatter = MakeTypeConverterFormatter(T)(T);
                }
                _cache.TryAdd(T, formatter);
            }
            return BlazorJs.Cast(formatter, BindFormatter(T));
        }
        /*string*/ static FormatArrayValue(T, /*T[]*/ value, /*CultureInfo*/ culture)
        {
            /*var*/ let elementFormatter = Get(T)(T);
            if (value.Length  === 0)
            {
                return "[]";
            }
            /*var*/ let builder = new StringBuilder("[\"");
            builder.Append((elementFormatter(value[0], culture)?.ToString() ?? string.Empty));
            builder.Append('\"');
            for(/*var*/ let i = 1; i < value.Length; i++)
            {
                builder.Append(", \"");
                builder.Append((elementFormatter(value[i], culture)?.ToString() ?? string.Empty));
                builder.Append('\"');
            }
            builder.Append(']');
            return builder.ToString();
        }
        /*BindFormatter<T[]>*/ static MakeArrayFormatter(T)
        {
            /*var*/ let elementFormatter = Get(T)(T);
            return FormatArrayValue(T);
        }
        /*BindFormatter<T>*/ static MakeTypeConverterFormatter(T)
        {
            {
                throw new InvalidOperationException(`No converter is defined for ${T.FullName}`);
            }
        }
    }
    static Microsoft_AspNetCore_Components_BindConverter_ParserDelegateCache = class
    {
        /*Dictionary<Type, Delegate>*/ static _cache = new Dictionary(Type, Delegate)();
        /*MethodInfo*/ static _convertToEnum = null;
        /*MethodInfo*/ static _convertToNullableEnum = null;
        /*MethodInfo*/ static _makeArrayTypeConverter = null;
        /*BindParser<T>*/ static Get(T)
        {
            let parser = null;
            let $ref1 = { set value(v){ parser = v } };
            if (_cache.TryGetValue(T, $ref1))
            {
                if (T === string)
                {
                    parser = ConvertToString;
                }
                else if (T === bool)
                {
                    parser = ConvertToBool;
                }
                else if (T === bool)
                {
                    parser = ConvertToNullableBool;
                }
                else if (T === int)
                {
                    parser = ConvertToInt;
                }
                else if (T === int)
                {
                    parser = ConvertToNullableInt;
                }
                else if (T === long)
                {
                    parser = ConvertToLong;
                }
                else if (T === long)
                {
                    parser = ConvertToNullableLong;
                }
                else if (T === short)
                {
                    parser = ConvertToShort;
                }
                else if (T === short)
                {
                    parser = ConvertToNullableShort;
                }
                else if (T === float)
                {
                    parser = ConvertToFloat;
                }
                else if (T === float)
                {
                    parser = ConvertToNullableFloat;
                }
                else if (T === double)
                {
                    parser = ConvertToDoubleDelegate;
                }
                else if (T === double)
                {
                    parser = ConvertToNullableDoubleDelegate;
                }
                else if (T === decimal)
                {
                    parser = ConvertToDecimal;
                }
                else if (T === decimal)
                {
                    parser = ConvertToNullableDecimal;
                }
                else if (T === DateTime)
                {
                    parser = ConvertToDateTime;
                }
                else if (T === DateTime)
                {
                    parser = ConvertToNullableDateTime;
                }
                else if (T === DateTimeOffset)
                {
                    parser = ConvertToDateTimeOffset;
                }
                else if (T === DateTimeOffset)
                {
                    parser = ConvertToNullableDateTimeOffset;
                }
                else if (T === Guid)
                {
                    parser = ConvertToGuid;
                }
                else if (T === Guid)
                {
                    parser = ConvertToNullableGuid;
                }
                else if (T.IsEnum)
                {
                    /*// We have to deal invoke this dynamically to work around the type constraint on Enum.TryParse.
                        var*/ let method = _convertToEnum = _convertToEnum ?? BindConverter.GetMethod(nameof(ConvertToEnum), BindingFlags.NonPublic  | BindingFlags.Static);
                    parser = method.MakeGenericMethod(T).CreateDelegate(BindParser(T), { target : null });
                }
                else if (Nullable.GetUnderlyingType(T) instanceof Type && innerType.IsEnum)
                {
                    /*// We have to deal invoke this dynamically to work around the type constraint on Enum.TryParse.
                        var*/ let method = _convertToNullableEnum = _convertToNullableEnum ?? BindConverter.GetMethod(nameof(ConvertToNullableEnum), BindingFlags.NonPublic  | BindingFlags.Static);
                    parser = method.MakeGenericMethod(innerType).CreateDelegate(BindParser(T), { target : null });
                }
                else if (T.IsArray)
                {
                    /*var*/ let method = _makeArrayTypeConverter = _makeArrayTypeConverter ?? ParserDelegateCache.GetMethod(nameof(MakeArrayTypeConverter), BindingFlags.NonPublic  | BindingFlags.Static);
                    /*var*/ let elementType = T.GetElementType();
                    parser = BlazorJs.Cast(method.MakeGenericMethod(elementType).Invoke(null, null), Delegate);
                }
                else 
                {
                    parser = MakeTypeConverterConverter(T)(T);
                }
                _cache.TryAdd(T, parser);
            }
            return BlazorJs.Cast(parser, BindParser(T));
        }
        /*BindParser<T[]>*/ static MakeArrayTypeConverter(T)
        {
            /*var*/ let elementParser = Get(T)(T);
            return ConvertToArray;
            /*bool*/ function ConvertToArray(/*object*/ obj, /*CultureInfo*/ culture, /*out T[]*/ value)
            {
                if ((obj instanceof Array, initialArray = obj))
                {
                    value = BlazorJs.getDefault();
                    return false;
                }
                /*var*/ let convertedArray = new Array(initialArray.Length);
                for(/*var*/ let i = 0; i < initialArray.Length; i++)
                {
                    let $ref0 = { set value(v){ convertedArray[i] = v } };
                    if (elementParser(initialArray.GetValue(i), culture, $ref0))
                    {
                        value = BlazorJs.getDefault();
                        return false;
                    }
                }
                value = convertedArray;
                return true;
            }
        }
        /*BindParser<T>*/ static MakeTypeConverterConverter(T)
        {
            throw new InvalidOperationException(`No converter for ${T.FullName}`);
        }
    }
}

class Microsoft_AspNetCore_Components_CascadingParameterAttribute extends System_Attribute
{
    constructor()
    {
        super();
    }
    constructor(/*string*/ name)
    {
        super();
        Name = name;
    }
    /*string*/ _backingField_Name = null;
    /*string*/ get Name()
    {
        return _backingField_Name;
    }
    /*string*/ set Name(value)
    {
        _backingField_Name = value;
    }
}

const Microsoft_AspNetCore_Components_CascadingValue = (TValue) => class extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
    }
    /*string*/ _backingField_Name = null;
    /*string*/ get Name()
    {
        return _backingField_Name;
    }
    /*string*/ set Name(value)
    {
        _backingField_Name = value;
    }
    /*TValue*/ _backingField_Value = null;
    /*TValue*/ get Value()
    {
        return _backingField_Value;
    }
    /*TValue*/ set Value(value)
    {
        _backingField_Value = value;
    }
    /*bool*/ _backingField_IsFixed = null;
    /*bool*/ get IsFixed()
    {
        return _backingField_IsFixed;
    }
    /*bool*/ set IsFixed(value)
    {
        _backingField_IsFixed = value;
    }
    /*RenderFragment*/ _backingField_ChildContent = null;
    /*RenderFragment*/ get ChildContent()
    {
        return _backingField_ChildContent;
    }
    /*RenderFragment*/ set ChildContent(value)
    {
        _backingField_ChildContent = value;
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ frame, { /*object*/ key = null})
    {
        frame.State.SetCascadingValue(Value, IsFixed, Name);
        frame.Content(ChildContent, { sequenceNumber : Utility.CascadingValue_SequenceNumber });
    }
}


class Microsoft_AspNetCore_Components_EventTarget extends object
{
    constructor()
    {
        super();
    }
    /*object*/ _backingField_Value = null;
    /*object*/ get Value()
    {
        return _backingField_Value;
    }
    /*object*/ set Value(value)
    {
        _backingField_Value = value;
    }
}
class Microsoft_AspNetCore_Components_ChangeEventArgs extends System_EventArgs
{
    constructor()
    {
        super();
    }
    /*EventTarget*/ _backingField_Target = null;
    /*EventTarget*/ get Target()
    {
        return _backingField_Target;
    }
    /*EventTarget*/ set Target(value)
    {
        _backingField_Target = value;
    }
}

class Microsoft_AspNetCore_Components_ComponentBase extends System_IDisposable(Microsoft_AspNetCore_Components_IHandleAfterRender(Microsoft_AspNetCore_Components_IHandleEvent(Microsoft_AspNetCore_Components_IComponent(object))))
{
    /*string*/ get ShadowName()
    {
        return GetType().Name;
    }
    /*RenderFragment*/ _renderFragment = null;
    /*RenderHandle*/ _renderHandle = null;
    /*bool*/ _initialized = null;
    /*bool*/ _hasNeverRendered = true;
    /*bool*/ _hasPendingQueuedRender = null;
    /*bool*/ _hasCalledOnAfterRender = null;
    constructor()
    {
        super();
        _renderFragment = function(/*IUIFrame*/ builder, /*object*/ key)
        {
            _hasPendingQueuedRender = false;
            _hasNeverRendered = false;
            BuildRenderTree(builder);
        };
    }
    /*Task*/ InvokeAsync(/*Action*/ workItem)
    {
        return _renderHandle.Dispatcher.InvokeAsync(workItem);
    }
    /*Task*/ InvokeAsync(/*Func<Task>*/ workItem)
    {
        return _renderHandle.Dispatcher.InvokeAsync(workItem);
    }
    /*void*/ BuildRenderTree(/*RenderTreeBuilder*/ builder)
    {
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ frame, { /*object*/ key = null})
    {
    }
    /*void*/ InjectServices(/*IServiceProvider*/ provider)
    {
    }
    /*void*/ CascadeParameters()
    {
    }
    /*void*/ OnInitialized()
    {
    }
    /*Task*/ OnInitializedAsync()
    {
        return Task.CompletedTask;
    }
    /*void*/ OnParametersSet()
    {
    }
    /*Task*/ OnParametersSetAsync()
    {
        return Task.CompletedTask;
    }
    /*void*/ OnAfterRender(/*bool*/ firstRender)
    {
    }
    /*Task*/ OnAfterRenderAsync(/*bool*/ firstRender)
    {
        return Task.CompletedTask;
    }
    /*bool*/ HandleError(/*Exception*/ exception, /*ComponentLifeCycle*/ lifeCycle)
    {
        return false;
    }
    /*void*/ WithErrorHandling(/*Action<ComponentBase>*/ action, /*ComponentLifeCycle*/ lifeCycle)
    {
        if (isDisposed)
        return ;
        try
        {
            action(this);
        }
        catch(e)
        {
            /*var*/ let handled = HandleError(e, lifeCycle);
            if (handled)
            throw e;
        }
    }
    /*void*/ RequestCascadingParameter(T, /*Action<T>*/ action, { /*string*/ cascadingParameterName = null})
    {
        /*var*/ let renderer = BlazorJs.Cast(_renderHandle._renderer, BrowserNativeRenderer);
        /*var*/ let state = renderer.GetRequiredState(_renderHandle._componentId);
        DisposeOnDispose(state.SubscribeCascadingValue(T, function(/**/ o, /**/ e)
        {
            return action(e);
        }, cascadingParameterName));
    }
    /*void*/ Set(/*string*/ key, /*object*/ value)
    {
        if (key === "@attributes")
        {
            if (value instanceof IReadOnlyDictionary(string, object), dic = value)
            {
                BlazorJs.forEach(dic, function(kv, $_i)
                {
                    this.SetValue(kv.Key, kv.Value);
                });
            }
            else 
            {
                BlazorJs.forEach(object.GetOwnPropertyNames(value), function(mkey, $_i)
                {
                    if (mkey.Length  > 0 && char.IsLower(mkey[0]))
                    {
                        /*var*/ let val = value[mkey];
                        this.SetValue(mkey, val);
                    }
                });
            }
        }
        else 
        {
            if (key.Length  > 0 && char.IsLower(key[0]))
            {
                this.SetValue(key, value);
            }
        }
    }
    /*EventHandler*/ OnDisposed = null;
    /*void*/ DisposeOnDispose(/*IDisposable*/ disposable)
    {
        if (disposable !== null)
        OnDisposed += function(/**/ s, /**/ e)
        {
            return disposable.Dispose();
        };
    }
    /*bool*/ isDisposed = null;
    /*void*/ Dispose()
    {
        if (isDisposed)
        return ;
        OnDisposed?.Invoke(this, EventArgs.Empty);
        isDisposed = true;
    }
    /*bool*/ ShouldRender()
    {
        return true;
    }
    /*void*/ StateHasChanged()
    {
        if (isDisposed)
        return ;
        if (_hasPendingQueuedRender || (_hasNeverRendered && ShouldRender() && _renderHandle.IsRenderingOnMetadataUpdate))
        {
            return ;
        }
        _hasPendingQueuedRender = true;
        try
        {
            _renderHandle.Render(_renderFragment);
        }
        catch($e)
        {
            _hasPendingQueuedRender = false;
            throw $e;
        }
    }
    /*Task*/ DispatchExceptionAsync(/*Exception*/ exception)
    {
        return _renderHandle.DispatchExceptionAsync(exception);
    }
    /*void*/ Attach(/*RenderHandle*/ renderHandle)
    {
        if (_renderHandle.IsInitialized)
        {
            throw new InvalidOperationException("The render handle is already set. Cannot initialize a ComponentBase more than once.");
        }
        _renderHandle = renderHandle;
    }
    /*Task*/ SetParametersAsync(/*ParameterView*/ parameters)
    {
        parameters.SetParameterProperties(this);
        if (_initialized)
        {
            _initialized = true;
            return RunInitAndSetParametersAsync();
        }
        return CallOnParametersSetAsync();
    }
    /*Task*/ async RunInitAndSetParametersAsync()
    {
        WithErrorHandling(function(/**/ icomponent)
        {
            OnInitialized();
        }, ComponentLifeCycle.OnInitializing);
        /*Task*/ let task = Task.CompletedTask;
        WithErrorHandling(function(/**/ icomponent)
        {
            task = OnInitializedAsync();
        }, ComponentLifeCycle.OnInitializingAsync);
        if (task.Status  !== TaskStatus.RanToCompletion  && task.Status  !== TaskStatus.Canceled)
        {
            StateHasChanged();
            try
            {
                await task;
            }
            catch($e)
            {
                if (task.IsCanceled)
                {
                    throw $e;
                }
            }
        }
        await CallOnParametersSetAsync();
    }
    /*Task*/ CallOnParametersSetAsync()
    {
        WithErrorHandling(function(/**/ icomponent)
        {
            OnParametersSet();
        }, ComponentLifeCycle.OnParametersSetting);
        /*Task*/ let task = Task.CompletedTask;
        WithErrorHandling(function(/**/ icomponent)
        {
            task = OnParametersSetAsync();
        }, ComponentLifeCycle.OnParametersSettingAsnc);
        /*bool*/ let num = task.Status  !== TaskStatus.RanToCompletion  && task.Status  !== TaskStatus.Canceled;
        StateHasChanged();
        if (num)
        {
            return Task.CompletedTask;
        }
        return CallStateHasChangedOnAsyncCompletion(task);
    }
    /*Task*/ async CallStateHasChangedOnAsyncCompletion(/*Task*/ task)
    {
        try
        {
            await task;
        }
        catch($e)
        {
            if (task.IsCanceled)
            {
                return ;
            }
            throw $e;
        }
        StateHasChanged();
    }
    /*Task*/ HandleEventAsync(/*EventCallbackWorkItem*/ callback, /*object*/ arg)
    {
        /*Task*/ let task = callback.InvokeAsync(arg);
        /*bool*/ let num = task.Status  !== TaskStatus.RanToCompletion  && task.Status  !== TaskStatus.Canceled;
        StateHasChanged();
        if (num)
        {
            return Task.CompletedTask;
        }
        return CallStateHasChangedOnAsyncCompletion(task);
    }
    /*Task*/ OnAfterRenderAsync()
    {
        /*bool*/ let firstRender = _hasCalledOnAfterRender;
        _hasCalledOnAfterRender = true;
        WithErrorHandling(function(/**/ icomponent)
        {
            icomponent.OnAfterRender(firstRender);
        }, ComponentLifeCycle.OnAfterRender);
        /*Task*/ let task = Task.CompletedTask;
        WithErrorHandling(function(/**/ icomponent)
        {
            task = OnAfterRenderAsync(firstRender);
        }, ComponentLifeCycle.OnAfterRenderAsnyc);
        return task;
    }
    /*string*/ ToString()
    {
        /*var*/ let renderer = BlazorJs.Cast(_renderHandle._renderer, BrowserNativeRenderer);
        /*var*/ let state = renderer.GetState(_renderHandle._componentId);
        return state?.ToString() ?? super.ToString();
    }
}

static class Microsoft_AspNetCore_Components_ComponentLifeCycle
{
    Unknown = 0;
    OnInjectingService = 1;
    OnParametersSetting = 2;
    OnParametersSettingAsnc = 3;
    OnInitializing = 4;
    OnInitializingAsync = 5;
    OnRendering = 6;
    OnAfterRender = 7;
    OnAfterRenderAsnyc = 8;
    OnEventHandling = 9;
}

class Microsoft_AspNetCore_Components_DefaultComponentActivator extends Microsoft_AspNetCore_Components_IComponentActivator(object)
{
    /*IServiceProvider*/ serviceProvider = null;
    constructor(/*IServiceProvider*/ serviceProvider)
    {
        super();
        this.serviceProvider  = serviceProvider;
    }
    /*IComponent*/ CreateInstance(/*Type*/ componentType)
    {
        if (IComponent.IsAssignableFrom(componentType))
        {
            throw new ArgumentException(`The type ${componentType.FullName} does not implement ${nameof(IComponent)}.`, nameof(componentType));
        }
        return BlazorJs.Cast((serviceProvider.GetService(componentType) ?? Activator.CreateInstance(componentType)), IComponent);
    }
}

class Microsoft_AspNetCore_Components_Dispatcher extends object
{
    constructor()
    {
        super();
    }
    /*SectionRegistry*/ _sectionRegistry = null;
    /*Dispatcher*/ static CreateDefault()
    {
        return new BrowserNativeDispatcher();
    }
    /*UnhandledExceptionEventHandler*/ UnhandledException = null;
    /*SectionRegistry*/ get SectionRegistry()
    {
        if (_sectionRegistry === null)
        _sectionRegistry = new SectionRegistry();
        return _sectionRegistry;
    }
    /*void*/ AssertAccess()
    {
        if (CheckAccess())
        {
            throw new InvalidOperationException("The current thread is not associated with the Dispatcher. " + "Use InvokeAsync() to switch execution to the Dispatcher when " + "triggering rendering or component state.");
        }
    }
    /*void*/ OnUnhandledException(/*UnhandledExceptionEventArgs*/ e)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(e);
        UnhandledException?.Invoke(this, e);
    }
}

class Microsoft_AspNetCore_Components_DynamicComponent extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
    }
    /*Type*/ _backingField_Type = null;
    /*Type*/ get Type()
    {
        return _backingField_Type;
    }
    /*Type*/ set Type(value)
    {
        _backingField_Type = value;
    }
    /*Dictionary<string, object>*/ _backingField_Properties = null;
    /*Dictionary<string, object>*/ get Properties()
    {
        return _backingField_Properties;
    }
    /*Dictionary<string, object>*/ set Properties(value)
    {
        _backingField_Properties = value;
    }
    /*Action<IComponent>*/ _backingField_ParameterSetter = null;
    /*Action<IComponent>*/ get ParameterSetter()
    {
        return _backingField_ParameterSetter;
    }
    /*Action<IComponent>*/ set ParameterSetter(value)
    {
        _backingField_ParameterSetter = value;
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ frame, { /*object*/ key = null})
    {
        if (Type !== null)
        {
            frame.Component(Type, function(/**/ component)
            {
                if (Properties !== null)
                {
                    BlazorJs.forEach(Properties, function(kv, $_i)
                    {
                        component[kv.Key] = kv.Value;
                    });
                }
                ParameterSetter?.Invoke(component);
            }, { sequenceNumber : Utility.DynamicComponent_SequenceNumber  + Type.GetHashCode() });
        }
    }
}
const Microsoft_AspNetCore_Components_DynamicComponentT = (TComponent) => class extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
    }
    /*Dictionary<string, object>*/ _backingField_Properties = null;
    /*Dictionary<string, object>*/ get Properties()
    {
        return _backingField_Properties;
    }
    /*Dictionary<string, object>*/ set Properties(value)
    {
        _backingField_Properties = value;
    }
    /*Action<TComponent>*/ _backingField_ParameterSetter = null;
    /*Action<TComponent>*/ get ParameterSetter()
    {
        return _backingField_ParameterSetter;
    }
    /*Action<TComponent>*/ set ParameterSetter(value)
    {
        _backingField_ParameterSetter = value;
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ frame, { /*object*/ key = null})
    {
        frame.Component(TComponent, function(/**/ component)
        {
            if (Properties !== null)
            {
                BlazorJs.forEach(Properties, function(kv, $_i)
                {
                    component[kv.Key] = kv.Value;
                });
            }
            ParameterSetter?.Invoke(component);
        }, { sequenceNumber : Utility.DynamicComponent_SequenceNumber  + TComponent.GetHashCode() });
    }
}

class Microsoft_AspNetCore_Components_EditorRequiredAttribute extends System_Attribute
{
    constructor()
    {
        super();
    }
}

class Microsoft_AspNetCore_Components_ElementReference extends System_ValueType
{
    constructor()
    {
        super();
    }
    /*HTMLElement*/ _backingField_Element = null;
    /*HTMLElement*/ get Element()
    {
        return _backingField_Element;
    }
    /*HTMLElement*/ set Element(value)
    {
        _backingField_Element = value;
    }
    /*ElementReference*/ static $op_Implicit_ElementReference(/*HTMLElement*/ element)
    {
        return BlazorJs.PopulateProperty(new ElementReference(), function(/*ElementReference*/ $obj)
        {
            $obj.Element = element;
        });
    }
}

class Microsoft_AspNetCore_Components_ErrorBoundaryBase extends Microsoft_AspNetCore_Components_IErrorBoundary(Microsoft_AspNetCore_Components_ComponentBase)
{
    constructor()
    {
        super();
    }
    /*int*/ _errorCount = null;
    /*RenderFragment*/ _backingField_ChildContent = null;
    /*RenderFragment*/ get ChildContent()
    {
        return _backingField_ChildContent;
    }
    /*RenderFragment*/ set ChildContent(value)
    {
        _backingField_ChildContent = value;
    }
    /*RenderFragment<Exception>*/ _backingField_ErrorContent = null;
    /*RenderFragment<Exception>*/ get ErrorContent()
    {
        return _backingField_ErrorContent;
    }
    /*RenderFragment<Exception>*/ set ErrorContent(value)
    {
        _backingField_ErrorContent = value;
    }
    /*int*/ _backingField_MaximumErrorCount = null;
    /*int*/ get MaximumErrorCount()
    {
        return _backingField_MaximumErrorCount;
    }
    /*int*/ set MaximumErrorCount(value)
    {
        _backingField_MaximumErrorCount = value;
    }
    /*Exception*/ _backingField_CurrentException = null;
    /*Exception*/ get CurrentException()
    {
        return _backingField_CurrentException;
    }
    /*Exception*/ set CurrentException(value)
    {
        _backingField_CurrentException = value;
    }
    /*void*/ Recover()
    {
        if (CurrentException !== null)
        {
            _errorCount = 0;
            CurrentException = null;
            StateHasChanged();
        }
    }
    /*void*/ HandleException(/*Exception*/ exception)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(exception);
        if (_errorCount > MaximumErrorCount)
        {
            throw exception;
        }
        /*// Notify the subclass so it can begin any async operation even before we render, because (for example)
            // we want logs to be written before rendering in case the rendering throws. But there's no reason to
            // wait for the async operation to complete before we render.
            var*/ let onErrorTask = OnErrorAsync(exception);
        if (onErrorTask.IsCanceled  || onErrorTask.IsFaulted)
        {
            _ = HandleOnErrorExceptions(onErrorTask);
        }
        CurrentException = exception;
        StateHasChanged();
    }
    /*Task*/ async HandleOnErrorExceptions(/*Task*/ onExceptionTask)
    {
        if (onExceptionTask.IsFaulted)
        {
            throw onExceptionTask.Exception;
        }
        else 
        {
            try
            {
                await onExceptionTask;
            }
            catch(exception)
            {
                CurrentException = exception;
                ChildContent = function(/**/ _, /**/ __)
                {
                    throw exception;
                };
                ErrorContent = function(/**/ _)
                {
                    return function(/**/ __, /**/ ___)
                    {
                        throw exception;
                    };
                };
                StateHasChanged();
            }
        }
    }
}

const Microsoft_AspNetCore_Components_IEventCallback = (Base) => class extends Base
{
    /*EventCallbackFlags*/ _backingField_Flags = null;
    /*EventCallbackFlags*/ get Flags()
    {
        return _backingField_Flags;
    }
}
class Microsoft_AspNetCore_Components_EventCallback extends Microsoft_AspNetCore_Components_IEventCallback(System_ValueType)
{
    /*EventCallbackFactory*/ static Factory = new EventCallbackFactory();
    /*EventCallback<object>*/ internalCallback = null;
    constructor(/*EventCallback<object>*/ internalCallback)
    {
        super();
        this.internalCallback  = internalCallback;
    }
    /*Task*/ InvokeAsync()
    {
        return internalCallback.InvokeAsync(null);
    }
    /*Task*/ InvokeAsync(/*Event*/ eventData)
    {
        return internalCallback.InvokeAsync(eventData);
    }
    /*object*/ get Receiver()
    {
        return internalCallback.Receiver;
    }
    /*Delegate*/ get Delegate()
    {
        return internalCallback.Delegate;
    }
    /*bool*/ get HasDelegate()
    {
        return internalCallback.HasDelegate;
    }
    /*EventCallbackFlags*/ get Flags()
    {
        return internalCallback.Flags;
    }
    /*object*/ _backingField_Receiver = null;
    /*object*/ get Receiver()
    {
        return _backingField_Receiver;
    }
    /*MulticastDelegate*/ _backingField_Delegate = null;
    /*MulticastDelegate*/ get Delegate()
    {
        return _backingField_Delegate;
    }
    /*EventCallbackDelegateType*/ type = null;
    /*EventCallbackFlags*/ _backingField_Flags = null;
    /*EventCallbackFlags*/ get Flags()
    {
        return _backingField_Flags;
    }
    constructor(/*object*/ receiver, /*MulticastDelegate*/ target, /*EventCallbackDelegateType*/ type, /*EventCallbackFlags*/ eventFlags)
    {
        super();
        Receiver = receiver;
        Delegate = target;
        this.type  = type;
        Flags = eventFlags;
    }
    constructor(/*object*/ receiver, /*Action<T>*/ target, /*EventCallbackFlags*/ eventFlags)
    {
        super(receiver, target, EventCallbackDelegateType.ActionT, eventFlags);
    }
    constructor(/*object*/ receiver, /*Func<T, Task>*/ target, /*EventCallbackFlags*/ eventFlags)
    {
        super(receiver, target, EventCallbackDelegateType.FuncTTask, eventFlags);
    }
    /*Task*/ Callback(/*object*/ _eventData)
    {
        /*Task*/ let task = Task.CompletedTask;
        switch(type)
        {
            case EventCallbackDelegateType.Action:
            {
                Delegate.Call();
                break;
            }
            case EventCallbackDelegateType.FuncTask:
            {
                task = BlazorJs.Cast(Delegate.Call(), Task);
                break;
            }
            case EventCallbackDelegateType.ActionT:
            {
                Delegate.Call(null, _eventData);
                break;
            }
            case EventCallbackDelegateType.FuncTTask:
            {
                task = BlazorJs.Cast(Delegate.Call(null, _eventData), Task);
                break;
            }
        }
        return task;
    }
    /*Task*/ InvokeAsync(/*Event*/ eventData)
    {
        return InvokeAsync(eventData);
    }
    /*Task*/ async InvokeAsync(/*object*/ eventData)
    {
        if (Delegate !== null)
        {
            /*var*/ let scope = Receiver ?? Delegate["$scope"];
            if (scope instanceof IHandleEvent, he = scope)
            {
                await he.HandleEventAsync(new EventCallbackWorkItem(Delegate), eventData);
            }
            else 
            {
                await Callback(eventData);
            }
        }
    }
    /*Task*/ InvokeAsync(/*T*/ eventData)
    {
        return InvokeAsync(BlazorJs.Cast(eventData, object));
    }
    /*bool*/ get HasDelegate()
    {
        return Delegate !== null;
    }
}

static class Microsoft_AspNetCore_Components_EventCallbackDelegateType
{
    Action = 0;
    FuncTask = 1;
    ActionT = 2;
    FuncTTask = 3;
}

class Microsoft_AspNetCore_Components_EventCallbackFactory extends object
{
    constructor()
    {
        super();
    }
    /*EventCallback*/ Create(/*object*/ receiver, /*EventCallback*/ callback)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(receiver);
        return callback;
    }
    /*EventCallback*/ Create(/*object*/ receiver, /*Action*/ callback)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(receiver);
        return CreateCore(receiver, callback);
    }
    /*EventCallback*/ Create(/*object*/ receiver, /*Action<object>*/ callback)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(receiver);
        return CreateCore(receiver, callback);
    }
    /*EventCallback*/ Create(/*object*/ receiver, /*Func<Task>*/ callback)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(receiver);
        return CreateCore(receiver, callback);
    }
    /*EventCallback*/ Create(/*object*/ receiver, /*Func<object, Task>*/ callback)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(receiver);
        return CreateCore(receiver, callback);
    }
    /*EventCallback<TValue>*/ Create(TValue, /*object*/ receiver, /*EventCallback*/ callback)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(receiver);
        throw new NotImplementedException();
    }
    /*EventCallback<TValue>*/ Create(TValue, /*object*/ receiver, /*EventCallback<TValue>*/ callback)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(receiver);
        return callback;
    }
    /*EventCallback<TValue>*/ Create(TValue, /*object*/ receiver, /*Action*/ callback)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(receiver);
        return CreateCore(TValue)(TValue, receiver, callback);
    }
    /*EventCallback<TValue>*/ Create(TValue, /*object*/ receiver, /*Action<TValue>*/ callback)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(receiver);
        return CreateCore(TValue)(TValue, receiver, callback);
    }
    /*EventCallback<TValue>*/ Create(TValue, /*object*/ receiver, /*Func<Task>*/ callback)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(receiver);
        return CreateCore(TValue)(TValue, receiver, callback);
    }
    /*EventCallback<TValue>*/ Create(TValue, /*object*/ receiver, /*Func<TValue, Task>*/ callback)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(receiver);
        return CreateCore(TValue)(TValue, receiver, callback);
    }
    /*EventCallback<TValue>*/ CreateInferred(TValue, /*object*/ receiver, /*Action<TValue>*/ callback, /*TValue*/ value)
    {
        return Create(receiver, callback);
    }
    /*EventCallback<TValue>*/ CreateInferred(TValue, /*object*/ receiver, /*Func<TValue, Task>*/ callback, /*TValue*/ value)
    {
        return Create(receiver, callback);
    }
    /*EventCallback*/ static CreateCore(/*object*/ receiver, /*Action*/ callback)
    {
        return new EventCallback(new EventCallback(object)(receiver, callback, EventCallbackDelegateType.Action, EventCallbackFlags.None));
    }
    /*EventCallback*/ static CreateCore(/*object*/ receiver, /*Action<object>*/ callback)
    {
        return new EventCallback(new EventCallback(object)(receiver, callback, EventCallbackDelegateType.ActionT, EventCallbackFlags.None));
    }
    /*EventCallback*/ static CreateCore(/*object*/ receiver, /*Func<Task>*/ callback)
    {
        return new EventCallback(new EventCallback(object)(receiver, callback, EventCallbackDelegateType.FuncTask, EventCallbackFlags.None));
    }
    /*EventCallback*/ static CreateCore(/*object*/ receiver, /*Func<object, Task>*/ callback)
    {
        return new EventCallback(new EventCallback(object)(receiver, callback, EventCallbackDelegateType.FuncTTask, EventCallbackFlags.None));
    }
    /*EventCallback<TValue>*/ static CreateCore(TValue, /*object*/ receiver, /*Action*/ callback)
    {
        return new EventCallback(TValue)(receiver, callback, EventCallbackDelegateType.Action, EventCallbackFlags.None);
    }
    /*EventCallback<TValue>*/ static CreateCore(TValue, /*object*/ receiver, /*Func<Task>*/ callback)
    {
        return new EventCallback(TValue)(receiver, callback, EventCallbackDelegateType.FuncTask, EventCallbackFlags.None);
    }
    /*EventCallback<TValue>*/ static CreateCore(TValue, /*object*/ receiver, /*Action<TValue>*/ callback)
    {
        return new EventCallback(TValue)(receiver, callback, EventCallbackDelegateType.ActionT, EventCallbackFlags.None);
    }
    /*EventCallback<TValue>*/ static CreateCore(TValue, /*object*/ receiver, /*Func<TValue, Task>*/ callback)
    {
        return new EventCallback(TValue)(receiver, callback, EventCallbackDelegateType.FuncTTask, EventCallbackFlags.None);
    }
    /*EventCallback*/ Create(/*object*/ receiver, /*Action*/ action, { /*EventCallbackFlags*/ eventFlags = EventCallbackFlags.None})
    {
        return new EventCallback(new EventCallback(object)(receiver, action, EventCallbackDelegateType.Action, eventFlags));
    }
    /*EventCallback*/ Create(/*object*/ receiver, /*Func<Task>*/ action, { /*EventCallbackFlags*/ eventFlags = EventCallbackFlags.None})
    {
        return new EventCallback(new EventCallback(object)(receiver, action, EventCallbackDelegateType.FuncTask, eventFlags));
    }
    /*EventCallback<T>*/ Create(T, /*object*/ receiver, /*Action<T>*/ action, { /*EventCallbackFlags*/ eventFlags = EventCallbackFlags.None})
    {
        return new EventCallback(T)(receiver, action, eventFlags);
    }
    /*EventCallback<T>*/ static Create(T, /*object*/ receiver, /*Func<T, Task>*/ action, { /*EventCallbackFlags*/ eventFlags = EventCallbackFlags.None})
    {
        return new EventCallback(T)(receiver, action, eventFlags);
    }
}

static class Microsoft_AspNetCore_Components_EventCallbackFactoryBinderExtensions
{
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<string>*/ setter, /*string*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore(string)(string, factory, receiver, setter, culture, ConvertToString);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<string, Task>*/ setter, /*string*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync(string)(string, factory, receiver, setter, culture, ConvertToString);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<bool>*/ setter, /*bool*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore(bool)(bool, factory, receiver, setter, culture, ConvertToBool);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<bool, Task>*/ setter, /*bool*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync(bool)(bool, factory, receiver, setter, culture, ConvertToBool);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<bool?>*/ setter, /*bool*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore(bool)(bool, factory, receiver, setter, culture, ConvertToNullableBool);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<bool?, Task>*/ setter, /*bool?*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync(bool)(bool, factory, receiver, setter, culture, ConvertToNullableBool);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<int>*/ setter, /*int*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore(int)(int, factory, receiver, setter, culture, ConvertToInt);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<int, Task>*/ setter, /*int*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync(int)(int, factory, receiver, setter, culture, ConvertToInt);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<int?>*/ setter, /*int?*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore(int)(int, factory, receiver, setter, culture, ConvertToNullableInt);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<int?, Task>*/ setter, /*int?*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync(int)(int, factory, receiver, setter, culture, ConvertToNullableInt);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<long>*/ setter, /*long*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore(long)(long, factory, receiver, setter, culture, ConvertToLong);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<long, Task>*/ setter, /*long*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync(long)(long, factory, receiver, setter, culture, ConvertToLong);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<short>*/ setter, /*short*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore(short)(short, factory, receiver, setter, culture, ConvertToShort);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<short, Task>*/ setter, /*short*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync(short)(short, factory, receiver, setter, culture, ConvertToShort);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<long?>*/ setter, /*long?*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore(long)(long, factory, receiver, setter, culture, ConvertToNullableLong);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<long?, Task>*/ setter, /*long?*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync(long)(long, factory, receiver, setter, culture, ConvertToNullableLong);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<short?>*/ setter, /*short?*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore(short)(short, factory, receiver, setter, culture, ConvertToNullableShort);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<short?, Task>*/ setter, /*short?*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync(short)(short, factory, receiver, setter, culture, ConvertToNullableShort);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<float>*/ setter, /*float*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore(float)(float, factory, receiver, setter, culture, ConvertToFloat);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<float, Task>*/ setter, /*float*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync(float)(float, factory, receiver, setter, culture, ConvertToFloat);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<float?>*/ setter, /*float?*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore(float)(float, factory, receiver, setter, culture, ConvertToNullableFloat);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<float?, Task>*/ setter, /*float?*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync(float)(float, factory, receiver, setter, culture, ConvertToNullableFloat);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<double>*/ setter, /*double*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore(double)(double, factory, receiver, setter, culture, ConvertToDoubleDelegate);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<double, Task>*/ setter, /*double*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync(double)(double, factory, receiver, setter, culture, ConvertToDoubleDelegate);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<double?>*/ setter, /*double?*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore(double)(double, factory, receiver, setter, culture, ConvertToNullableDoubleDelegate);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<double?, Task>*/ setter, /*double?*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync(double)(double, factory, receiver, setter, culture, ConvertToNullableDoubleDelegate);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<decimal>*/ setter, /*decimal*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore(decimal)(decimal, factory, receiver, setter, culture, ConvertToDecimal);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<decimal, Task>*/ setter, /*decimal*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync(decimal)(decimal, factory, receiver, setter, culture, ConvertToDecimal);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<decimal?>*/ setter, /*decimal?*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore(decimal)(decimal, factory, receiver, setter, culture, ConvertToNullableDecimal);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<decimal?, Task>*/ setter, /*decimal?*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync(decimal)(decimal, factory, receiver, setter, culture, ConvertToNullableDecimal);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<DateTime>*/ setter, /*DateTime*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore(DateTime)(DateTime, factory, receiver, setter, culture, ConvertToDateTime);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<DateTime, Task>*/ setter, /*DateTime*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync(DateTime)(DateTime, factory, receiver, setter, culture, ConvertToDateTime);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<DateTime>*/ setter, /*DateTime*/ existingValue, /*string*/ format, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore(DateTime)(DateTime, factory, receiver, setter, culture, format, ConvertToDateTimeWithFormat);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<DateTime, Task>*/ setter, /*DateTime*/ existingValue, /*string*/ format, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync(DateTime)(DateTime, factory, receiver, setter, culture, format, ConvertToDateTimeWithFormat);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<DateTime?>*/ setter, /*DateTime?*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore(DateTime)(DateTime, factory, receiver, setter, culture, ConvertToNullableDateTime);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<DateTime?, Task>*/ setter, /*DateTime?*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync(DateTime)(DateTime, factory, receiver, setter, culture, ConvertToNullableDateTime);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<DateTime?>*/ setter, /*DateTime?*/ existingValue, /*string*/ format, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore(DateTime)(DateTime, factory, receiver, setter, culture, format, ConvertToNullableDateTimeWithFormat);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<DateTime?, Task>*/ setter, /*DateTime?*/ existingValue, /*string*/ format, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync(DateTime)(DateTime, factory, receiver, setter, culture, format, ConvertToNullableDateTimeWithFormat);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<DateTimeOffset>*/ setter, /*DateTimeOffset*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore(DateTimeOffset)(DateTimeOffset, factory, receiver, setter, culture, ConvertToDateTimeOffset);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<DateTimeOffset, Task>*/ setter, /*DateTimeOffset*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync(DateTimeOffset)(DateTimeOffset, factory, receiver, setter, culture, ConvertToDateTimeOffset);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<DateTimeOffset>*/ setter, /*DateTimeOffset*/ existingValue, /*string*/ format, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore(DateTimeOffset)(DateTimeOffset, factory, receiver, setter, culture, format, ConvertToDateTimeOffsetWithFormat);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<DateTimeOffset, Task>*/ setter, /*DateTimeOffset*/ existingValue, /*string*/ format, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync(DateTimeOffset)(DateTimeOffset, factory, receiver, setter, culture, format, ConvertToDateTimeOffsetWithFormat);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<DateTimeOffset?>*/ setter, /*DateTimeOffset?*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore(DateTimeOffset)(DateTimeOffset, factory, receiver, setter, culture, ConvertToNullableDateTimeOffset);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<DateTimeOffset?, Task>*/ setter, /*DateTimeOffset?*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync(DateTimeOffset)(DateTimeOffset, factory, receiver, setter, culture, ConvertToNullableDateTimeOffset);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<DateTimeOffset?>*/ setter, /*DateTimeOffset?*/ existingValue, /*string*/ format, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore(DateTimeOffset)(DateTimeOffset, factory, receiver, setter, culture, format, ConvertToNullableDateTimeOffsetWithFormat);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<DateTimeOffset?, Task>*/ setter, /*DateTimeOffset?*/ existingValue, /*string*/ format, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync(DateTimeOffset)(DateTimeOffset, factory, receiver, setter, culture, format, ConvertToNullableDateTimeOffsetWithFormat);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(T, /*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<T>*/ setter, /*T*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore(T)(T, factory, receiver, setter, culture, ParserDelegateCache.Get(T));
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinder(T, /*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<T, Task>*/ setter, /*T*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync(T)(T, factory, receiver, setter, culture, ParserDelegateCache.Get(T));
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinderCore(T, /*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<T>*/ setter, /*CultureInfo*/ culture, /*BindConverter.BindParser<T>*/ converter)
    {
        /*Action<ChangeEventArgs>*/ let callback = function(/**/ e)
        {
            /*T*/ let value = BlazorJs.getDefault();
            /*var*/ let converted = false;
            try
            {
                let $ref0 = { set value(v){ value = v } };
                converted = converter(e.Target.Value, culture, $ref0);
            }
            catch($e)
            {
            }
            if (converted)
            {
                setter(value);
            }
            else if (string.Empty.Equals(e.Target.Value))
            {
                setter(BlazorJs.getDefault());
            }
        };
        return factory.Create(ChangeEventArgs, receiver, callback);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinderCoreAsync(T, /*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<T, Task>*/ setter, /*CultureInfo*/ culture, /*BindConverter.BindParser<T>*/ converter)
    {
        /*Func<ChangeEventArgs, Task>*/ let callback = function(/**/ e)
        {
            /*T*/ let value = BlazorJs.getDefault();
            /*var*/ let converted = false;
            try
            {
                let $ref0 = { set value(v){ value = v } };
                converted = converter(e.Target.Value, culture, $ref0);
            }
            catch($e)
            {
            }
            if (converted)
            {
                await setter(value);
            }
            else if (string.Empty.Equals(e.Target.Value))
            {
                await setter(BlazorJs.getDefault());
            }
        };
        return factory.Create(ChangeEventArgs, receiver, callback);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinderCore(T, /*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<T>*/ setter, /*CultureInfo*/ culture, /*string*/ format, /*BindConverter.BindParserWithFormat<T>*/ converter)
    {
        /*Action<ChangeEventArgs>*/ let callback = function(/**/ e)
        {
            /*T*/ let value = BlazorJs.getDefault();
            /*var*/ let converted = false;
            try
            {
                let $ref0 = { set value(v){ value = v } };
                converted = converter(e.Target.Value, culture, format, $ref0);
            }
            catch($e)
            {
            }
            if (converted)
            {
                setter(value);
            }
            else if (string.Empty.Equals(e.Target.Value))
            {
                setter(BlazorJs.getDefault());
            }
        };
        return factory.Create(ChangeEventArgs, receiver, callback);
    }
    /*EventCallback<ChangeEventArgs>*/ static CreateBinderCoreAsync(T, /*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<T, Task>*/ setter, /*CultureInfo*/ culture, /*string*/ format, /*BindConverter.BindParserWithFormat<T>*/ converter)
    {
        /*Func<ChangeEventArgs, Task>*/ let callback = function(/**/ e)
        {
            /*T*/ let value = BlazorJs.getDefault();
            /*var*/ let converted = false;
            try
            {
                let $ref0 = { set value(v){ value = v } };
                converted = converter(e.Target.Value, culture, format, $ref0);
            }
            catch($e)
            {
            }
            if (converted)
            {
                await setter(value);
            }
            else if (string.Empty.Equals(e.Target.Value))
            {
                await setter(BlazorJs.getDefault());
            }
        };
        return factory.Create(ChangeEventArgs, receiver, callback);
    }
}

static class Microsoft_AspNetCore_Components_EventCallbackFactoryEventArgsExtensions
{
    /*EventCallback<EventArgs>*/ static Create(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<EventArgs>*/ callback)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(factory);
        return factory.Create(EventArgs, receiver, callback);
    }
    /*EventCallback<EventArgs>*/ static Create(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<EventArgs, Task>*/ callback)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(factory);
        return factory.Create(EventArgs, receiver, callback);
    }
    /*EventCallback<ChangeEventArgs>*/ static Create(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<ChangeEventArgs>*/ callback)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(factory);
        return factory.Create(ChangeEventArgs, receiver, callback);
    }
    /*EventCallback<ChangeEventArgs>*/ static Create(/*this EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<ChangeEventArgs, Task>*/ callback)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(factory);
        return factory.Create(ChangeEventArgs, receiver, callback);
    }
}

static class Microsoft_AspNetCore_Components_EventCallbackFlags
{
    None = 0;
    StopPropagation = 1 << 0;
    PreventDefault = 1 << 1
;
}

class Microsoft_AspNetCore_Components_EventCallbackWorkItem extends System_ValueType
{
    /*EventCallbackWorkItem*/ static Empty = new EventCallbackWorkItem(null);
    /*MulticastDelegate*/ _delegate = null;
    constructor(/*MulticastDelegate*/ $delegate)
    {
        super();
        _delegate = $delegate;
    }
    /*Task*/ InvokeAsync(/*object*/ arg)
    {
        return InvokeAsync(object)(object, _delegate, arg);
    }
    /*Task*/ static InvokeAsync(T, /*MulticastDelegate*/ $delegate, /*T*/ arg)
    {
        switch($delegate?.GetType())
        {
            case null:
            {
                return Task.CompletedTask;
            }
            case funcEventArgs = Func(T, Task):
            {
                return funcEventArgs.Invoke(arg) ?? Task.CompletedTask;
            }
            case func = Func(Task):
            {
                return func.Invoke() ?? Task.CompletedTask;
            }
            case actionEventArgs = Action(T):
            {
                actionEventArgs.Invoke(arg);
                return Task.CompletedTask;
            }
            case action = Action:
            {
                action.Invoke();
                return Task.CompletedTask;
            }
            default:
            {
                {
                    try
                    {
                        return BlazorJs.As($delegate.Call(arg), Task) ?? Task.CompletedTask;
                    }
                    catch(e)
                    {
                        throw e.InnerException;
                    }
                }
            }
        }
    }
}


const Microsoft_AspNetCore_Components_IComponent = (Base) => class extends Base
{
}

const Microsoft_AspNetCore_Components_IComponentActivator = (Base) => class extends Base
{
}

const Microsoft_AspNetCore_Components_IComponentRenderMode = (Base) => class extends Base
{
}

const Microsoft_AspNetCore_Components_IErrorBoundary = (Base) => class extends Base
{
}

const Microsoft_AspNetCore_Components_IHandleAfterRender = (Base) => class extends Base
{
}

const Microsoft_AspNetCore_Components_IHandleEvent = (Base) => class extends Base
{
}

const Microsoft_AspNetCore_Components_ILayoutComponent = (Base) => class extends Base
{
    /*RenderFragment*/ _backingField_Body = null;
    /*RenderFragment*/ get Body()
    {
        return _backingField_Body;
    }
    /*RenderFragment*/ set Body(value)
    {
        _backingField_Body = value;
    }
}

class Microsoft_AspNetCore_Components_InjectAttribute extends System_Attribute
{
    constructor(/*bool*/ required)
    {
        super();
    }
}

class Microsoft_AspNetCore_Components_LayoutAttribute extends System_Attribute
{
    constructor(/*Type*/ layoutType)
    {
        super();
        LayoutType = BlazorJs.FirstOf(layoutType, function(){ throw new ArgumentNullException(nameof(layoutType)) });
        if (IComponent.IsAssignableFrom(layoutType))
        {
            throw new ArgumentException(`Invalid layout type: ${layoutType.FullName} ` + `does not implement ${IComponent.FullName}.`);
        }
    }
    /*Type*/ _backingField_LayoutType = null;
    /*Type*/ get LayoutType()
    {
        return _backingField_LayoutType;
    }
    /*Type*/ set LayoutType(value)
    {
        _backingField_LayoutType = value;
    }
}

class Microsoft_AspNetCore_Components_LayoutComponentBase extends Microsoft_AspNetCore_Components_IComponent(Microsoft_AspNetCore_Components_ILayoutComponent(Microsoft_AspNetCore_Components_ComponentBase))
{
    constructor()
    {
        super();
    }
    /*RenderFragment*/ _backingField_Body = null;
    /*RenderFragment*/ get Body()
    {
        return _backingField_Body;
    }
    /*RenderFragment*/ set Body(value)
    {
        _backingField_Body = value;
    }
}

class Microsoft_AspNetCore_Components_LayoutView extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
    }
    /*RenderFragment*/ static EmptyRenderFragment = function(/**/ builder, /**/ key)
    {
    };
    /*RenderFragment*/ _backingField_ChildContent = null;
    /*RenderFragment*/ get ChildContent()
    {
        return _backingField_ChildContent;
    }
    /*RenderFragment*/ set ChildContent(value)
    {
        _backingField_ChildContent = value;
    }
    /*Type*/ _backingField_Layout = null;
    /*Type*/ get Layout()
    {
        return _backingField_Layout;
    }
    /*Type*/ set Layout(value)
    {
        _backingField_Layout = value;
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ frame, { /*object*/ key = null})
    {
        /*// In the middle goes the supplied content
            var*/ let fragment = ChildContent ?? EmptyRenderFragment;
        /*// Then repeatedly wrap that in each layer of nested layout until we get
            // to a layout that has no parent
            var*/ let layoutType = Layout;
        while(layoutType !== null)
        {
            fragment = WrapInLayout(layoutType, fragment);
            layoutType = GetParentLayoutType(layoutType);
        }
        frame.Content(fragment, { sequenceNumber : Utility.LayoutView_Fragment_SequenceNumber });
    }
    /*RenderFragment*/ static WrapInLayout(/*Type*/ layoutType, /*RenderFragment*/ bodyParam)
    {
        /*void*/ function Render(/*IUIFrame*/ builder, { /*object*/ key = null})
        {
            builder.Component(layoutType, function(/**/ component)
            {
                (BlazorJs.Cast(component, LayoutComponentBase)).Body  = bodyParam;
            }, { key : key, sequenceNumber : Utility.LayoutView_Layout_SequenceNumber });
        }
        return Render;
    }
    /*Type*/ static GetParentLayoutType(/*Type*/ type)
    {
        return type.GetCustomAttributes(LayoutAttribute, true).FirstOrDefault().As(LayoutAttribute)?.LayoutType;
    }
}


class Microsoft_AspNetCore_Components_LocationChangeException extends System_Exception
{
    constructor(/*string*/ message, /*Exception*/ innerException)
    {
        super(message, innerException);
    }
}

class Microsoft_AspNetCore_Components_MarkupString extends System_ValueType
{
    constructor(/*string*/ html)
    {
        super();
        Html = html;
    }
    /*string*/ _backingField_Html = null;
    /*string*/ get Html()
    {
        return _backingField_Html;
    }
    /*string*/ set Html(value)
    {
        _backingField_Html = value;
    }
    /*MarkupString*/ static $op_Implicit_MarkupString(/*string*/ str)
    {
        return new MarkupString(str);
    }
}

class Microsoft_AspNetCore_Components_NavigationException extends System_Exception
{
    constructor(/*string*/ uri)
    {
        super();
        Location = uri;
    }
    /*string*/ _backingField_Location = null;
    /*string*/ get Location()
    {
        return _backingField_Location;
    }
}

class Microsoft_AspNetCore_Components_NavigationManager extends object
{
    constructor()
    {
        super();
    }
    /*EventHandler(LocationChangedEventArgs)*/ $add_LocationChanged(value)
    {
        AssertInitialized();
        _locationChanged += value;
    }
    /*EventHandler(LocationChangedEventArgs)*/ $remove_LocationChanged(value)
    {
        AssertInitialized();
        _locationChanged -= value;
    }
    /*EventHandler<LocationChangedEventArgs>*/ _locationChanged = null;
    /*List<Func<LocationChangingContext, Task>>*/ _locationChangingHandlers = new List(Func(LocationChangingContext, Task))();
    /*CancellationTokenSource*/ _locationChangingCts = null;
    /*Uri*/ _baseUri = null;
    /*string*/ _uri = null;
    /*bool*/ _isInitialized = null;
    /*string*/ get BaseUri()
    {
        AssertInitialized();
        return _baseUri.OriginalString();
    }
    /*string*/ set BaseUri(value)
    {
        if (value !== null)
        {
            value = NormalizeBaseUri(value);
        }
        _baseUri = new Uri(value);
    }
    /*string*/ get Uri()
    {
        AssertInitialized();
        return _uri;
    }
    /*string*/ set Uri(value)
    {
        Validate(_baseUri, value);
        _uri = value;
    }
    /*string*/ _backingField_HistoryEntryState = null;
    /*string*/ get HistoryEntryState()
    {
        return _backingField_HistoryEntryState;
    }
    /*string*/ set HistoryEntryState(value)
    {
        _backingField_HistoryEntryState = value;
    }
    /*void*/ NavigateTo(/*string*/ uri, /*bool*/ forceLoad)
    {
        return NavigateTo(uri, forceLoad, { replace : false });
    }
    /*void*/ NavigateTo(/*string*/ uri, { /*bool*/ forceLoad = false, /*bool*/ replace = false})
    {
        AssertInitialized();
        if (replace)
        {
            NavigateToCore(uri, BlazorJs.PopulateProperty(new NavigationOptions(), function(/*NavigationOptions*/ $obj)
            {
                $obj.ForceLoad = forceLoad;
                $obj.ReplaceHistoryEntry = replace;
            }));
        }
        else 
        {
            NavigateToCore(uri, forceLoad);
        }
    }
    /*void*/ NavigateTo(/*string*/ uri, /*NavigationOptions*/ options)
    {
        AssertInitialized();
        NavigateToCore(uri, options);
    }
    /*void*/ NavigateToCore(/*string*/ uri, /*bool*/ forceLoad)
    {
        return NavigateToCore(uri, BlazorJs.PopulateProperty(new NavigationOptions(), function(/*NavigationOptions*/ $obj)
        {
            $obj.ForceLoad = forceLoad;
        }));
    }
    /*void*/ NavigateToCore(/*string*/ uri, /*NavigationOptions*/ options)
    {
        throw new NotImplementedException(`The type ${GetType().FullName} does not support supplying ${nameof(NavigationOptions)}. To add support, that type should override ${nameof(NavigateToCore)}(string uri, ${nameof(NavigationOptions)} options).`);
    }
    /*void*/ Refresh({ /*bool*/ forceReload = false})
    {
        return NavigateTo(Uri, { forceLoad : true, replace : true });
    }
    /*void*/ Initialize(/*string*/ baseUri, /*string*/ uri)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(uri);
        ArgumentNullExceptionExtension.ThrowIfNull(baseUri);
        if (_isInitialized)
        {
            throw new InvalidOperationException(`'${GetType().Name}' already initialized.`);
        }
        _isInitialized = true;
        BaseUri = baseUri;
        Uri = uri;
    }
    /*void*/ EnsureInitialized()
    {
    }
    /*Uri*/ ToAbsoluteUri(/*string*/ relativeUri)
    {
        AssertInitialized();
        return new Uri(_baseUri + relativeUri);
    }
    /*string*/ ToBaseRelativePath(/*string*/ uri)
    {
        if (uri === null)
        return null;
        if (uri.StartsWith(_baseUri.OriginalString(), StringComparison.Ordinal))
        {
            return uri.Substring(_baseUri.OriginalString().Length);
        }
        /*var*/ let pathEndIndex = uri.AsSpan().IndexOfAny('#', '?');
        /*var*/ let uriPathOnly = pathEndIndex < 0 ? uri : uri.AsSpan(0, pathEndIndex);
        if (_baseUri.OriginalString().EndsWith("/") && uriPathOnly.Equals(_baseUri.OriginalString().AsSpan(0, _baseUri.OriginalString().Length  - 1), StringComparison.Ordinal))
        {
            return uri.Substring(_baseUri.OriginalString().Length  - 1);
        }
        /*var*/ let message = `The URI '${uri}' is not contained by the base URI '${_baseUri}'.`;
        throw new ArgumentException(message);
    }
    /*ReadOnlySpan<char>*/ ToBaseRelativePath(/*ReadOnlySpan<char>*/ uri)
    {
        if (uri.StartsWith(_baseUri.OriginalString().AsSpan(), StringComparison.Ordinal))
        {
            return uri[new System_Range(_baseUri.OriginalString().Length, 1)];
        }
        /*var*/ let pathEndIndex = uri.IndexOfAny('#', '?');
        /*var*/ let uriPathOnly = pathEndIndex < 0 ? uri : uri[new System_Range(0, pathEndIndex)];
        if (_baseUri.OriginalString().EndsWith("/") && uriPathOnly.IsEqual(_baseUri.OriginalString().AsSpan(0, _baseUri.OriginalString().Length  - 1), StringComparison.Ordinal))
        {
            return uri[new System_Range((_baseUri.OriginalString().Length  - 1), 1)];
        }
        /*var*/ let message = `The URI '${uri}' is not contained by the base URI '${_baseUri}'.`;
        throw new ArgumentException(message);
    }
    /*string*/ static NormalizeBaseUri(/*string*/ baseUri)
    {
        /*var*/ let lastSlashIndex = baseUri.LastIndexOf('/');
        if (lastSlashIndex >= 0)
        {
            baseUri = baseUri.Substring(0, lastSlashIndex + 1);
        }
        return baseUri;
    }
    /*void*/ NotifyLocationChanged(/*bool*/ isInterceptedLink)
    {
        try
        {
            _locationChanged?.Invoke(this, BlazorJs.PopulateProperty(new LocationChangedEventArgs(_uri, isInterceptedLink), function(/*LocationChangedEventArgs*/ $obj)
            {
                $obj.HistoryEntryState = HistoryEntryState;
            }));
        }
        catch(ex)
        {
            throw new LocationChangeException("An exception occurred while dispatching a location changed event.", ex);
        }
    }
    /*Task<bool>*/ async NotifyLocationChangingAsync(/*string*/ uri, /*object*/ state, /*bool*/ isNavigationIntercepted)
    {
        _locationChangingCts?.Cancel();
        _locationChangingCts = null;
        /*var*/ let handlerCount = _locationChangingHandlers.Count;
        if (handlerCount === 0)
        {
            return true;
        }
        /*var*/ let cts = new CancellationTokenSource();
        _locationChangingCts = cts;
        /*var*/ let cancellationToken = cts.Token;
        /*var*/ let context = BlazorJs.PopulateProperty(new LocationChangingContext(), function(/*LocationChangingContext*/ $obj)
        {
            $obj.TargetLocation = uri;
            $obj.HistoryEntryState = state;
            $obj.IsNavigationIntercepted = isNavigationIntercepted;
            $obj.CancellationToken = cancellationToken;
        });
        try
        {
            if (handlerCount === 1)
            {
                /*var*/ let handlerTask = InvokeLocationChangingHandlerAsync(_locationChangingHandlers[0], context);
                if (handlerTask.IsFaulted)
                {
                    await handlerTask;
                    return false;
                }
                if (context.DidPreventNavigation)
                {
                    return false;
                }
                if (handlerTask.IsFaulted/* !handlerTask.IsCompletedSuccessfully*/)
                {
                    await handlerTask;
                }
            }
            else 
            {
                /*var*/ let locationChangingHandlersCopy = ArrayPool(Func(LocationChangingContext, Task)).Shared.Rent(handlerCount);
                try
                {
                    _locationChangingHandlers.CopyTo(locationChangingHandlersCopy);
                    /*var*/ let locationChangingTasks = new HashSet(Task)();
                    for(/*var*/ let i = 0; i < handlerCount; i++)
                    {
                        /*var*/ let handlerTask = InvokeLocationChangingHandlerAsync(locationChangingHandlersCopy[i], context);
                        if (handlerTask.IsFaulted)
                        {
                            await handlerTask;
                            return false;
                        }
                        if (context.DidPreventNavigation)
                        {
                            return false;
                        }
                        locationChangingTasks.Add(handlerTask);
                    }
                    while(locationChangingTasks.Count  !== 0)
                    {
                        /*var*/ let completedHandlerTask = await Task.WhenAny(locationChangingTasks);
                        if (completedHandlerTask.IsFaulted)
                        {
                            await completedHandlerTask;
                            return false;
                        }
                        if (context.DidPreventNavigation)
                        {
                            return false;
                        }
                        locationChangingTasks.Remove(completedHandlerTask);
                    }
                }
                finally
                {
                    {
                        ArrayPool(Func(LocationChangingContext, Task)).Shared.Return(locationChangingHandlersCopy);
                    }
                }
            }
            return context.DidPreventNavigation;
        }
        catch(ex)
        {
            if (ex.CancellationToken.Equals(cancellationToken))
            {
                return false;
            }
            throw ex;
        }
        finally
        {
            {
                cts.Cancel();
                cts.Dispose();
                if (_locationChangingCts === cts)
                {
                    _locationChangingCts = null;
                }
            }
        }
    }
    /*Task*/ async InvokeLocationChangingHandlerAsync(/*Func<LocationChangingContext, Task>*/ handler, /*LocationChangingContext*/ context)
    {
        try
        {
            await handler(context);
        }
        catch($e)
        {
            if($e instanceof OperationCanceledException)
            {
            }
            if($e instanceof Exception, ex = $e)
            {
                HandleLocationChangingHandlerException(ex, context);
            }
        }
    }
    /*void*/ HandleLocationChangingHandlerException(/*Exception*/ ex, /*LocationChangingContext*/ context)
    {
        throw new InvalidOperationException(`To support navigation locks, ${GetType().Name} must override ${nameof(HandleLocationChangingHandlerException)}`);
    }
    /*void*/ SetNavigationLockState(/*bool*/ value)
    {
        throw new NotSupportedException(`To support navigation locks, ${GetType().Name} must override ${nameof(SetNavigationLockState)}`);
    }
    /*IDisposable*/ RegisterLocationChangingHandler(/*Func<LocationChangingContext, Task>*/ locationChangingHandler)
    {
        AssertInitialized();
        /*var*/ let isFirstHandler = _locationChangingHandlers.Count  === 0;
        _locationChangingHandlers.Add(locationChangingHandler);
        if (isFirstHandler)
        {
            SetNavigationLockState(true);
        }
        return new LocationChangingRegistration(locationChangingHandler, this);
    }
    /*void*/ RemoveLocationChangingHandler(/*Func<LocationChangingContext, Task>*/ locationChangingHandler)
    {
        AssertInitialized();
        if (_locationChangingHandlers.Remove(locationChangingHandler) && _locationChangingHandlers.Count  === 0)
        {
            SetNavigationLockState(false);
        }
    }
    /*void*/ AssertInitialized()
    {
        if (_isInitialized)
        {
            EnsureInitialized();
        }
        if (_isInitialized)
        {
            throw new InvalidOperationException(`'${GetType().Name}' has not been initialized.`);
        }
    }
    /*bool*/ static TryGetLengthOfBaseUriPrefix(/*Uri*/ baseUri, /*string*/ uri, /*out int*/ length)
    {
        if (uri.StartsWith(baseUri.OriginalString(), StringComparison.Ordinal))
        {
            length = baseUri.OriginalString().Length;
            return true;
        }
        /*var*/ let pathEndIndex = uri.AsSpan().IndexOfAny('#', '?');
        /*var*/ let uriPathOnly = pathEndIndex < 0 ? uri : uri.AsSpan(0, pathEndIndex);
        if (baseUri.OriginalString().EndsWith("/") && uriPathOnly.Equals(baseUri.OriginalString().AsSpan(0, baseUri.OriginalString().Length  - 1), StringComparison.Ordinal))
        {
            length = baseUri.OriginalString().Length  - 1;
            return true;
        }
        length = 0;
        return false;
    }
    /*void*/ static Validate(/*Uri*/ baseUri, /*string*/ uri)
    {
        let $ref0 = { set value(v){ _ = v } };
        if (baseUri === null || uri === null)
        {
            return ;
        }
        if (TryGetLengthOfBaseUriPrefix(baseUri, uri, $ref0))
        {
            /*var*/ let message = `The URI '${uri}' is not contained by the base URI '${baseUri}'.`;
            throw new ArgumentException(message);
        }
    }
    static Microsoft_AspNetCore_Components_NavigationManager_LocationChangingRegistration = class extends System_IDisposable(object)
    {
        /*Func<LocationChangingContext, Task>*/ _handler = null;
        /*NavigationManager*/ _navigationManager = null;
        constructor(/*Func<LocationChangingContext, Task>*/ handler, /*NavigationManager*/ navigationManager)
        {
            super();
            _handler = handler;
            _navigationManager = navigationManager;
        }
        /*void*/ Dispose()
        {
            _navigationManager.RemoveLocationChangingHandler(_handler);
        }
    }
}

class Microsoft_AspNetCore_Components_NavigationOptions extends System_ValueType
{
    constructor()
    {
        super();
    }
    /*bool*/ _backingField_ForceLoad = null;
    /*bool*/ get ForceLoad()
    {
        return _backingField_ForceLoad;
    }
    /*bool*/ set ForceLoad(value)
    {
        _backingField_ForceLoad = value;
    }
    /*bool*/ _backingField_ReplaceHistoryEntry = null;
    /*bool*/ get ReplaceHistoryEntry()
    {
        return _backingField_ReplaceHistoryEntry;
    }
    /*bool*/ set ReplaceHistoryEntry(value)
    {
        _backingField_ReplaceHistoryEntry = value;
    }
    /*object*/ _backingField_HistoryEntryState = null;
    /*object*/ get HistoryEntryState()
    {
        return _backingField_HistoryEntryState;
    }
    /*object*/ set HistoryEntryState(value)
    {
        _backingField_HistoryEntryState = value;
    }
}

class Microsoft_AspNetCore_Components_PageTitle extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
    }
    /*HTMLElement*/ titleWrapper = null;
    /*RenderFragment*/ _backingField_ChildContent = null;
    /*RenderFragment*/ get ChildContent()
    {
        return _backingField_ChildContent;
    }
    /*RenderFragment*/ set ChildContent(value)
    {
        _backingField_ChildContent = value;
    }
    /*void*/ OnAfterRender(/*bool*/ firstRender)
    {
        document.title  = titleWrapper.innerText;
        super.OnAfterRender(firstRender);
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ __frame0, { /*object*/ __key = null})
    {
        titleWrapper = __frame0.Element("span", function(/*UIElementAttribute*/ __attribute)
        {
            __attribute.Set("style", "display:none");
        }, function(/**/ __frame1, /**/ __key1)
        {
            __frame1.Content(ChildContent, { key : __key1, sequenceNumber : 987110344 });
        }, { sequenceNumber : 987110343 });
    }
}

class Microsoft_AspNetCore_Components_ParameterAttribute extends System_Attribute
{
    constructor()
    {
        super();
    }
}

class Microsoft_AspNetCore_Components_ParameterView extends System_ValueType
{
    constructor()
    {
        super();
    }
    static Microsoft_AspNetCore_Components_ParameterView_ParameterViewValue = class extends System_ValueType
    {
        constructor()
        {
            super();
        }
        /*string*/ get Name()
        {
            return BlazorJs.getDefault();
        }
        /*object*/ get Value()
        {
            return BlazorJs.getDefault();
        }
    }
    static Microsoft_AspNetCore_Components_ParameterView_ParameterViewEnumerator = class extends System_ValueType
    {
        constructor()
        {
            super();
        }
        /*bool*/ MoveNext()
        {
            return false;
        }
        /*ParameterViewValue*/ get Current()
        {
            return BlazorJs.getDefault();
        }
    }
    /*ParameterViewEnumerator*/ GetEnumerator()
    {
        return BlazorJs.getDefault();
    }
    /*void*/ SetParameterProperties(/*IComponent*/ component)
    {
    }
}

class Microsoft_AspNetCore_Components_RendererInfo extends object
{
    /*string*/ _backingField_Name = null;
    /*string*/ get Name()
    {
        return _backingField_Name;
    }
    /*bool*/ _backingField_IsInteractive = null;
    /*bool*/ get IsInteractive()
    {
        return _backingField_IsInteractive;
    }
    constructor(/*string*/ rendererName, /*bool*/ isInteractive)
    {
        super();
        Name = rendererName;
        IsInteractive = isInteractive;
    }
}


class Microsoft_AspNetCore_Components_RenderHandle extends System_ValueType
{
    /*Renderer*/ _renderer = null;
    /*int*/ _componentId = null;
    constructor(/*Renderer*/ renderer, /*int*/ componentId)
    {
        super();
        _renderer = BlazorJs.FirstOf(renderer, function(){ throw new ArgumentNullException(nameof(renderer)) });
        _componentId = componentId;
    }
    /*Dispatcher*/ get Dispatcher()
    {
        if (_renderer === null)
        {
            ThrowNotInitialized();
        }
        return _renderer.Dispatcher;
    }
    /*bool*/ get IsRenderingOnMetadataUpdate()
    {
        return false;
    }
    /*bool*/ get IsInitialized()
    {
        return _renderer !== null;
    }
    /*bool*/ get IsRendererDisposed()
    {
        return BlazorJs.FirstOf(_renderer?.Disposed, function(){ throw new InvalidOperationException("No renderer has been initialized.") });
    }
    /*RendererInfo*/ get RendererInfo()
    {
        return BlazorJs.FirstOf(_renderer?.RendererInfo, function(){ throw new InvalidOperationException("No renderer has been initialized.") });
    }
    /*IComponentRenderMode*/ get RenderMode()
    {
        if (_renderer === null)
        {
            throw new InvalidOperationException("No renderer has been initialized.");
        }
        return _renderer.GetComponentRenderMode(_componentId);
    }
    /*ResourceAssetCollection*/ get Assets()
    {
        return BlazorJs.FirstOf(_renderer?.Assets, function(){ throw new InvalidOperationException("No renderer has been initialized.") });
    }
    /*void*/ Render(/*RenderFragment*/ renderFragment)
    {
        if (_renderer === null)
        {
            ThrowNotInitialized();
        }
        _renderer.AddToRenderQueue(_componentId, renderFragment);
    }
    /*Task*/ DispatchExceptionAsync(/*Exception*/ exception)
    {
        /*var*/ let renderer = _renderer;
        /*var*/ let componentId = _componentId;
        return Dispatcher.InvokeAsync(function()
        {
            return renderer.HandleComponentException(exception, componentId);
        });
    }
    /*void*/ static ThrowNotInitialized()
    {
        throw new InvalidOperationException("The render handle is not yet assigned.");
    }
}

class Microsoft_AspNetCore_Components_RenderModeServerAttribute extends System_Attribute
{
    constructor()
    {
        super();
    }
}

const Microsoft_AspNetCore_Components_Rendering_RenderTreeBuilder = (Base) => class extends Base
{
}
static class Microsoft_AspNetCore_Components_Rendering_RenderTreeBuilderExtension
{
    /*void*/ static AddAttribute(/*this IUIFrame*/ builder, /*int*/ sequenceNumber, /*string*/ name, /*object*/ value)
    {
    }
    /*void*/ static AddContent(/*this IUIFrame*/ builder, /*int*/ sequenceNumber, /*RenderFragment*/ content)
    {
    }
    /*void*/ static AddContent(/*this IUIFrame*/ builder, /*int*/ sequenceNumber, /*string*/ content)
    {
    }
    /*void*/ static AddMultipleAttributes(/*this IUIFrame*/ builder, /*int*/ sequenceNumber, /*IReadOnlyDictionary<string, object>*/ content)
    {
    }
    /*void*/ static SetKey(/*this IUIFrame*/ builder, /*int*/ sequenceNumber, /*string*/ key)
    {
    }
}

class Microsoft_AspNetCore_Components_ResourceAsset extends object
{
    constructor()
    {
        super();
    }
    /*string*/ _backingField_Url = null;
    /*string*/ get Url()
    {
        return _backingField_Url;
    }
    /*IReadOnlyList<ResourceAssetProperty>*/ _backingField_Properties = null;
    /*IReadOnlyList<ResourceAssetProperty>*/ get Properties()
    {
        return _backingField_Properties;
    }
}

class Microsoft_AspNetCore_Components_ResourceAssetCollection extends H5_IH5Class(System_Collections_IEnumerable(System_Collections_Generic_IEnumerable(Microsoft_AspNetCore_Components_ResourceAsset)(System_Collections_Generic_IReadOnlyCollection(Microsoft_AspNetCore_Components_ResourceAsset)(System_Collections_Generic_IReadOnlyList(Microsoft_AspNetCore_Components_ResourceAsset)(object)))))
{
    constructor()
    {
        super();
    }
    /*ResourceAssetCollection*/ static Empty = new ResourceAssetCollection();
    /*string*/ getItem(/*string*/ key)
    {
        return null;
    }
    /*bool*/ IsContentSpecificUrl(/*string*/ path)
    {
        return false;
    }
    /*// IReadOnlyList<ResourceAsset> implementation
        ResourceAsset*/ getItem(/*int*/ index)
    {
        return null;
    }
    /*int*/ get Count()
    {
        return 0;
    }
    /*IEnumerator<ResourceAsset>*/ GetEnumerator()
    {
        return Enumerable.Empty(ResourceAsset).GetEnumerator();
    }
    /*IEnumerator*/ GetEnumerator()
    {
        return Enumerable.Empty(ResourceAsset).GetEnumerator();
    }
}

class Microsoft_AspNetCore_Components_ResourceAssetProperty extends object
{
    constructor()
    {
        super();
    }
    /*string*/ _backingField_Name = null;
    /*string*/ get Name()
    {
        return _backingField_Name;
    }
    /*string*/ _backingField_Value = null;
    /*string*/ get Value()
    {
        return _backingField_Value;
    }
}

class Microsoft_AspNetCore_Components_RouteAttribute extends System_Attribute
{
    constructor(/*string*/ template)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(template);
        Template = template;
    }
    /*string*/ _backingField_Template = null;
    /*string*/ get Template()
    {
        return _backingField_Template;
    }
}

class Microsoft_AspNetCore_Components_RouteData extends object
{
    constructor(/*Type*/ pageType, /*IReadOnlyDictionary<string, object>*/ routeValues)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(pageType);
        if (IComponent.IsAssignableFrom(pageType))
        {
            throw new ArgumentException(`The value must implement ${nameof(IComponent)}.`, nameof(pageType));
        }
        PageType = pageType;
        RouteValues = BlazorJs.FirstOf(routeValues, function(){ throw new ArgumentNullException(nameof(routeValues)) });
    }
    /*Type*/ _backingField_PageType = null;
    /*Type*/ get PageType()
    {
        return _backingField_PageType;
    }
    /*IReadOnlyDictionary<string, object>*/ _backingField_RouteValues = null;
    /*IReadOnlyDictionary<string, object>*/ get RouteValues()
    {
        return _backingField_RouteValues;
    }
    /*string*/ _backingField_Template = null;
    /*string*/ get Template()
    {
        return _backingField_Template;
    }
    /*string*/ set Template(value)
    {
        _backingField_Template = value;
    }
}

class Microsoft_AspNetCore_Components_RouteView extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
    }
    /*Dictionary<Type, Type>*/ static _layoutAttributeCache = new Dictionary(Type, Type)();
    /*NavigationManager*/ _backingField_NavigationManager = null;
    /*NavigationManager*/ get NavigationManager()
    {
        return _backingField_NavigationManager;
    }
    /*NavigationManager*/ set NavigationManager(value)
    {
        _backingField_NavigationManager = value;
    }
    /*RouteData*/ _backingField_RouteData = null;
    /*RouteData*/ get RouteData()
    {
        return _backingField_RouteData;
    }
    /*RouteData*/ set RouteData(value)
    {
        _backingField_RouteData = value;
    }
    /*Type*/ _backingField_DefaultLayout = null;
    /*Type*/ get DefaultLayout()
    {
        return _backingField_DefaultLayout;
    }
    /*Type*/ set DefaultLayout(value)
    {
        _backingField_DefaultLayout = value;
    }
    /*void*/ OnParametersSet()
    {
        if (RouteData === null)
        {
            throw new InvalidOperationException(`The ${nameof(RouteView)} component requires a non-null value for the parameter ${nameof(RouteData)}.`);
        }
        super.OnParametersSet();
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ frame, { /*object*/ key = null})
    {
        let pageLayoutType = null;
        let $ref1 = { set value(v){ pageLayoutType = v } };
        if (_layoutAttributeCache.TryGetValue(RouteData.PageType, $ref1))
        {
            pageLayoutType = RouteData.PageType.GetCustomAttributes(LayoutAttribute, true)?.FirstOrDefault().As(LayoutAttribute)?.LayoutType;
            _layoutAttributeCache[RouteData.PageType] = pageLayoutType;
        }
        pageLayoutType = pageLayoutType ?? DefaultLayout;
        frame.Component(LayoutView, function(/**/ component)
        {
            component.Layout  = pageLayoutType;
            component.ChildContent  = BlazorJs.Cast(RenderPageWithParameters, RenderFragment);
        }, { sequenceNumber : Utility.RouteView_LayoutView_SequenceNumber  + pageLayoutType.GetHashCode() });
    }
    /*void*/ RenderPageWithParameters(/*IUIFrame*/ frame, { /*object*/ key = null})
    {
        frame.Component(RouteData.PageType, function(/**/ component)
        {
            BlazorJs.forEach(RouteData.RouteValues, function(kvp, $_i)
            {
                component[kvp.Key] = kvp.Value;
            });
        }, { key : key, sequenceNumber : Utility.RouteView_Page_SequenceNumber });
    }
    /*void*/ InjectServices(/*IServiceProvider*/ provider)
    {
        NavigationManager = provider.GetRequiredService(Microsoft.AspNetCore.Components.NavigationManager);
    }
}

class Microsoft_AspNetCore_Components_StreamRenderingAttribute extends System_Attribute
{
    constructor(/*bool*/ v)
    {
        super();
    }
}

class Microsoft_AspNetCore_Components_SupplyParameterFromQueryAttribute extends System_Attribute
{
    constructor()
    {
        super();
    }
}

static class Microsoft_AspNetCore_Components_Authorization_AttributeAuthorizeDataCache
{
    /*Dictionary<Type, IAuthorizeData[]>*/ static _cache = new Dictionary(Type, IAuthorizeData)();
    /*IAuthorizeData[]*/ static GetAuthorizeDataForType(/*Type*/ type)
    {
        let result = null;
        let $ref1 = { set value(v){ result = v } };
        if (_cache.TryGetValue(type, $ref1))
        {
            result = ComputeAuthorizeDataForType(type);
            _cache[type] = result;
        }
        return result;
    }
    /*IAuthorizeData[]*/ static ComputeAuthorizeDataForType(/*Type*/ type)
    {
        /*// Allow Anonymous skips all authorization
            var*/ let allAttributes = type.GetCustomAttributes({ inherit : true });
        /*List<IAuthorizeData>*/ let authorizeDatas = null;
        for(/*var*/ let i = 0; i < allAttributes.Length; i++)
        {
            if (allAttributes[i] instanceof IAllowAnonymous)
            {
                return null;
            }
            if (allAttributes[i] instanceof IAuthorizeData)
            {
                authorizeDatas = authorizeDatas ?? new List(IAuthorizeData)();
                authorizeDatas.Add(authorizeData);
            }
        }
        return authorizeDatas?.ToArray();
    }
}

class Microsoft_AspNetCore_Components_Authorization_AuthenticationState extends object
{
    constructor(/*ClaimsPrincipal*/ user)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(user);
        User = user;
    }
    /*ClaimsPrincipal*/ _backingField_User = null;
    /*ClaimsPrincipal*/ get User()
    {
        return _backingField_User;
    }
}

class Microsoft_AspNetCore_Components_Authorization_AuthenticationStateData extends object
{
    constructor()
    {
        super();
    }
    /*IList<ClaimData>*/ _backingField_Claims = null;
    /*IList<ClaimData>*/ get Claims()
    {
        return _backingField_Claims;
    }
    /*IList<ClaimData>*/ set Claims(value)
    {
        _backingField_Claims = value;
    }
    /*string*/ _backingField_NameClaimType = null;
    /*string*/ get NameClaimType()
    {
        return _backingField_NameClaimType;
    }
    /*string*/ set NameClaimType(value)
    {
        _backingField_NameClaimType = value;
    }
    /*string*/ _backingField_RoleClaimType = null;
    /*string*/ get RoleClaimType()
    {
        return _backingField_RoleClaimType;
    }
    /*string*/ set RoleClaimType(value)
    {
        _backingField_RoleClaimType = value;
    }
}

class Microsoft_AspNetCore_Components_Authorization_AuthenticationStateProvider extends object
{
    constructor()
    {
        super();
    }
    /*AuthenticationStateChangedHandler*/ AuthenticationStateChanged = null;
    /*void*/ NotifyAuthenticationStateChanged(/*Task<AuthenticationState>*/ task)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(task);
        AuthenticationStateChanged?.Invoke(task);
    }
}

class Microsoft_AspNetCore_Components_Authorization_AuthorizeDataAdapter extends Microsoft_AspNetCore_Authorization_IAuthorizeData(object)
{
    /*AuthorizeView*/ _component = null;
    constructor(/*AuthorizeView*/ component)
    {
        super();
        _component = BlazorJs.FirstOf(component, function(){ throw new ArgumentNullException(nameof(component)) });
    }
    /*string*/ get Policy()
    {
        return _component.Policy;
    }
    /*string*/ set Policy(value)
    {
        throw new NotSupportedException();
    }
    /*string*/ get Roles()
    {
        return _component.Roles;
    }
    /*string*/ set Roles(value)
    {
        throw new NotSupportedException();
    }
    /*string*/ get AuthenticationSchemes()
    {
        return null;
    }
    /*string*/ set AuthenticationSchemes(value)
    {
        throw new NotSupportedException();
    }
}

class Microsoft_AspNetCore_Components_Authorization_AuthorizeRouteView extends Microsoft_AspNetCore_Components_RouteView
{
    /*RenderFragment<AuthenticationState>*/ static _defaultNotAuthorizedContent = function(/**/ state)
    {
        return function(/**/ builder, /**/ key)
        {
            return builder.AddContent(0, "Not authorized");
        };
    };
    /*RenderFragment*/ static _defaultAuthorizingContent = function(/**/ builder, /**/ key)
    {
        return builder.AddContent(0, "Authorizing...");
    };
    /*RenderFragment*/ _renderAuthorizeRouteViewCoreDelegate = null;
    /*RenderFragment<AuthenticationState>*/ _renderAuthorizedDelegate = null;
    /*RenderFragment<AuthenticationState>*/ _renderNotAuthorizedDelegate = null;
    /*RenderFragment*/ _renderAuthorizingDelegate = null;
    constructor()
    {
        super();
        /*// Cache the rendering delegates so that we only construct new closure instances
            // when they are actually used (e.g., we never prepare a RenderFragment bound to
            // the NotAuthorized content except when you are displaying that particular state)
            RenderFragment*/ let renderBaseRouteViewDelegate = super.BuildRenderTree;
        _renderAuthorizedDelegate = function(/**/ authenticateState)
        {
            return renderBaseRouteViewDelegate;
        };
        _renderNotAuthorizedDelegate = function(/**/ authenticationState)
        {
            return function(/**/ builder, /**/ key)
            {
                return RenderNotAuthorizedInDefaultLayout(builder, key, authenticationState);
            };
        };
        _renderAuthorizingDelegate = RenderAuthorizingInDefaultLayout;
        _renderAuthorizeRouteViewCoreDelegate = RenderAuthorizeRouteViewCore;
    }
    /*RenderFragment<AuthenticationState>*/ _backingField_NotAuthorized = null;
    /*RenderFragment<AuthenticationState>*/ get NotAuthorized()
    {
        return _backingField_NotAuthorized;
    }
    /*RenderFragment<AuthenticationState>*/ set NotAuthorized(value)
    {
        _backingField_NotAuthorized = value;
    }
    /*RenderFragment*/ _backingField_Authorizing = null;
    /*RenderFragment*/ get Authorizing()
    {
        return _backingField_Authorizing;
    }
    /*RenderFragment*/ set Authorizing(value)
    {
        _backingField_Authorizing = value;
    }
    /*object*/ _backingField_Resource = null;
    /*object*/ get Resource()
    {
        return _backingField_Resource;
    }
    /*object*/ set Resource(value)
    {
        _backingField_Resource = value;
    }
    /*Task<AuthenticationState>*/ _backingField_ExistingCascadedAuthenticationState = null;
    /*Task<AuthenticationState>*/ get ExistingCascadedAuthenticationState()
    {
        return _backingField_ExistingCascadedAuthenticationState;
    }
    /*Task<AuthenticationState>*/ set ExistingCascadedAuthenticationState(value)
    {
        _backingField_ExistingCascadedAuthenticationState = value;
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ frame, { /*object*/ key = null})
    {
        if (ExistingCascadedAuthenticationState !== null)
        {
            _renderAuthorizeRouteViewCoreDelegate(frame, key);
        }
        else 
        {
            frame.Component(CascadingAuthenticationState, function(/**/ component)
            {
                component.ChildContent  = _renderAuthorizeRouteViewCoreDelegate;
            }, { sequenceNumber : 1 });
        }
    }
    /*void*/ RenderAuthorizeRouteViewCore(/*IUIFrame*/ frame, { /*object*/ key = null})
    {
        frame.Component(AuthorizeRouteViewCore, function(/**/ component)
        {
            component.RouteData  = RouteData;
            component.Authorized  = _renderAuthorizedDelegate;
            component.Authorizing  = _renderAuthorizingDelegate;
            component.NotAuthorized  = _renderNotAuthorizedDelegate;
            component.Resource  = Resource;
        }, { sequenceNumber : Utility.AuthorizeRouteView_AuthorizeRouteViewCore_SequenceNumber });
    }
    /*void*/ RenderContentInDefaultLayout(/*IUIFrame*/ frame, /*object*/ key, /*RenderFragment*/ content)
    {
        frame.Component(LayoutView, function(/**/ component)
        {
            component.Layout  = DefaultLayout;
            component.ChildContent  = content;
        }, { sequenceNumber : Utility.AuthorizeRouteView_LayoutView_SequenceNumber });
    }
    /*void*/ RenderNotAuthorizedInDefaultLayout(/*IUIFrame*/ builder, /*object*/ key, /*AuthenticationState*/ authenticationState)
    {
        /*var*/ let content = NotAuthorized ?? _defaultNotAuthorizedContent;
        RenderContentInDefaultLayout(builder, key, content(authenticationState));
    }
    /*void*/ RenderAuthorizingInDefaultLayout(/*IUIFrame*/ builder, { /*object*/ key = null})
    {
        /*var*/ let content = Authorizing ?? _defaultAuthorizingContent;
        RenderContentInDefaultLayout(builder, key, content);
    }
    static Microsoft_AspNetCore_Components_Authorization_AuthorizeRouteView_AuthorizeRouteViewCore = class extends Microsoft_AspNetCore_Components_Authorization_AuthorizeViewCore
    {
        constructor()
        {
            super();
        }
        /*RouteData*/ _backingField_RouteData = null;
        /*RouteData*/ get RouteData()
        {
            return _backingField_RouteData;
        }
        /*RouteData*/ set RouteData(value)
        {
            _backingField_RouteData = value;
        }
        /*IAuthorizeData[]*/ GetAuthorizeData()
        {
            return AttributeAuthorizeDataCache.GetAuthorizeDataForType(RouteData.PageType);
        }
    }
    /*void*/ CascadeParameters()
    {
        RequestCascadingParameter(System_Threading_Tasks_Task(Microsoft_AspNetCore_Components_Authorization_AuthenticationState))(System.Threading.Tasks.Task(Microsoft.AspNetCore.Components.Authorization.AuthenticationState), function(/**/ e)
        {
            return ExistingCascadedAuthenticationState = e;
        }, { cascadingParameterName : null });
        super.CascadeParameters();
    }
}

class Microsoft_AspNetCore_Components_Authorization_AuthorizeView extends Microsoft_AspNetCore_Components_Authorization_AuthorizeViewCore
{
    /*IAuthorizeData[]*/ selfAsAuthorizeData = null;
    constructor()
    {
        super();
        selfAsAuthorizeData = new AuthorizeDataAdapter(this);
    }
    /*string*/ _backingField_Policy = null;
    /*string*/ get Policy()
    {
        return _backingField_Policy;
    }
    /*string*/ set Policy(value)
    {
        _backingField_Policy = value;
    }
    /*string*/ _backingField_Roles = null;
    /*string*/ get Roles()
    {
        return _backingField_Roles;
    }
    /*string*/ set Roles(value)
    {
        _backingField_Roles = value;
    }
    /*IAuthorizeData[]*/ GetAuthorizeData()
    {
        return selfAsAuthorizeData;
    }
}


class Microsoft_AspNetCore_Components_Authorization_AuthorizeViewCore extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
    }
    /*AuthenticationState*/ currentAuthenticationState = null;
    /*bool?*/ isAuthorized = null;
    /*RenderFragment<AuthenticationState>*/ _backingField_ChildContent = null;
    /*RenderFragment<AuthenticationState>*/ get ChildContent()
    {
        return _backingField_ChildContent;
    }
    /*RenderFragment<AuthenticationState>*/ set ChildContent(value)
    {
        _backingField_ChildContent = value;
    }
    /*RenderFragment<AuthenticationState>*/ _backingField_NotAuthorized = null;
    /*RenderFragment<AuthenticationState>*/ get NotAuthorized()
    {
        return _backingField_NotAuthorized;
    }
    /*RenderFragment<AuthenticationState>*/ set NotAuthorized(value)
    {
        _backingField_NotAuthorized = value;
    }
    /*RenderFragment<AuthenticationState>*/ _backingField_Authorized = null;
    /*RenderFragment<AuthenticationState>*/ get Authorized()
    {
        return _backingField_Authorized;
    }
    /*RenderFragment<AuthenticationState>*/ set Authorized(value)
    {
        _backingField_Authorized = value;
    }
    /*RenderFragment*/ _backingField_Authorizing = null;
    /*RenderFragment*/ get Authorizing()
    {
        return _backingField_Authorizing;
    }
    /*RenderFragment*/ set Authorizing(value)
    {
        _backingField_Authorizing = value;
    }
    /*object*/ _backingField_Resource = null;
    /*object*/ get Resource()
    {
        return _backingField_Resource;
    }
    /*object*/ set Resource(value)
    {
        _backingField_Resource = value;
    }
    /*Task<AuthenticationState>*/ _backingField_AuthenticationState = null;
    /*Task<AuthenticationState>*/ get AuthenticationState()
    {
        return _backingField_AuthenticationState;
    }
    /*Task<AuthenticationState>*/ set AuthenticationState(value)
    {
        _backingField_AuthenticationState = value;
    }
    /*IAuthorizationPolicyProvider*/ _backingField_AuthorizationPolicyProvider = null;
    /*IAuthorizationPolicyProvider*/ get AuthorizationPolicyProvider()
    {
        return _backingField_AuthorizationPolicyProvider;
    }
    /*IAuthorizationPolicyProvider*/ set AuthorizationPolicyProvider(value)
    {
        _backingField_AuthorizationPolicyProvider = value;
    }
    /*IAuthorizationService*/ _backingField_AuthorizationService = null;
    /*IAuthorizationService*/ get AuthorizationService()
    {
        return _backingField_AuthorizationService;
    }
    /*IAuthorizationService*/ set AuthorizationService(value)
    {
        _backingField_AuthorizationService = value;
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ frame, { /*object*/ key = null})
    {
        if (isAuthorized === null)
        {
            frame.Content(Authorizing, { sequenceNumber : Utility.AuthorizeViewCore_Authorizing_SequenceNumber });
        }
        else if (isAuthorized === true)
        {
            /*var*/ let authorized = Authorized ?? ChildContent;
            frame.Content(authorized?.Invoke(currentAuthenticationState), { sequenceNumber : Utility.AuthorizeViewCore_Authorized_SequenceNumber });
        }
        else 
        {
            frame.Content(NotAuthorized?.Invoke(currentAuthenticationState), { sequenceNumber : Utility.AuthorizeViewCore_NotAuthorized_SequenceNumber });
        }
    }
    /*Task*/ async OnParametersSetAsync()
    {
        if (ChildContent !== null && Authorized !== null)
        {
            throw new InvalidOperationException(`Do not specify both '${nameof(Authorized)}' and '${nameof(ChildContent)}'.`);
        }
        if (AuthenticationState === null)
        {
            throw new InvalidOperationException(`Authorization requires a cascading parameter of type Task<${nameof(AuthenticationState)}>. Consider using ${CascadingAuthenticationState.Name} to supply this.`);
        }
        isAuthorized = null;
        currentAuthenticationState = await AuthenticationState;
        isAuthorized = await IsAuthorizedAsync(currentAuthenticationState.User);
    }
    /*Task<bool>*/ async IsAuthorizedAsync(/*ClaimsPrincipal*/ user)
    {
        /*var*/ let authorizeData = GetAuthorizeData();
        if (authorizeData === null)
        {
            return true;
        }
        EnsureNoAuthenticationSchemeSpecified(authorizeData);
        /*var*/ let policy = await AuthorizationPolicy.CombineAsync(AuthorizationPolicyProvider, authorizeData);
        /*var*/ let result = await AuthorizationService.AuthorizeAsync(user, Resource, policy.Requirements);
        return result.Succeeded;
    }
    /*void*/ static EnsureNoAuthenticationSchemeSpecified(/*IAuthorizeData[]*/ authorizeData)
    {
        for(/*var*/ let i = 0; i < authorizeData.Length; i++)
        {
            /*var*/ let entry = authorizeData[i];
            if (string.IsNullOrEmpty(entry.AuthenticationSchemes))
            {
                throw new NotSupportedException(`The authorization data specifies an authentication scheme with value '${entry.AuthenticationSchemes}'. Authentication schemes cannot be specified for components.`);
            }
        }
    }
    /*void*/ InjectServices(/*IServiceProvider*/ provider)
    {
        AuthorizationPolicyProvider = provider.GetRequiredService(Microsoft.AspNetCore.Authorization.IAuthorizationPolicyProvider);
        AuthorizationService = provider.GetRequiredService(Microsoft.AspNetCore.Authorization.IAuthorizationService);
    }
    /*void*/ CascadeParameters()
    {
        RequestCascadingParameter(System_Threading_Tasks_Task(Microsoft_AspNetCore_Components_Authorization_AuthenticationState))(System.Threading.Tasks.Task(Microsoft.AspNetCore.Components.Authorization.AuthenticationState), function(/**/ e)
        {
            return AuthenticationState = e;
        }, { cascadingParameterName : null });
        super.CascadeParameters();
    }
}

class Microsoft_AspNetCore_Components_Authorization_CascadingAuthenticationState extends System_IDisposable(Microsoft_AspNetCore_Components_ComponentBase)
{
    constructor()
    {
        super();
    }
    /*Task<AuthenticationState>*/ _currentAuthenticationStateTask = null;
    /*RenderFragment*/ _backingField_ChildContent = null;
    /*RenderFragment*/ get ChildContent()
    {
        return _backingField_ChildContent;
    }
    /*RenderFragment*/ set ChildContent(value)
    {
        _backingField_ChildContent = value;
    }
    /*AuthenticationStateProvider*/ _backingField_AuthenticationStateProvider = null;
    /*AuthenticationStateProvider*/ get AuthenticationStateProvider()
    {
        return _backingField_AuthenticationStateProvider;
    }
    /*AuthenticationStateProvider*/ set AuthenticationStateProvider(value)
    {
        _backingField_AuthenticationStateProvider = value;
    }
    /*void*/ OnInitialized()
    {
        AuthenticationStateProvider.AuthenticationStateChanged  += OnAuthenticationStateChanged;
        _currentAuthenticationStateTask = AuthenticationStateProvider.GetAuthenticationStateAsync();
    }
    /*void*/ OnAuthenticationStateChanged(/*Task<AuthenticationState>*/ newAuthStateTask)
    {
        InvokeAsync(function()
        {
            _currentAuthenticationStateTask = newAuthStateTask;
            StateHasChanged();
        }).FireAndForget();
    }
    /*void*/ Dispose()
    {
        AuthenticationStateProvider.AuthenticationStateChanged  -= OnAuthenticationStateChanged;
    }
    /*void*/ InjectServices(/*IServiceProvider*/ provider)
    {
        AuthenticationStateProvider = provider.GetRequiredService(Microsoft.AspNetCore.Components.Authorization.AuthenticationStateProvider);
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ __frame0, { /*object*/ __key = null})
    {
        __frame0.Component(CascadingValue(System.Threading.Tasks.Task(AuthenticationState)), function(/**/ __component0)
        {
            __component0.Value  = _currentAuthenticationStateTask;
            __component0.ChildContent  = ChildContent;
        }, { sequenceNumber : 617868881 });
    }
}


class Microsoft_AspNetCore_Components_Authorization_ClaimData extends System_ValueType
{
    constructor(/*string*/ type, /*string*/ value)
    {
        super();
        Type = type;
        Value = value;
    }
    constructor(/*Claim*/ claim)
    {
        super(claim.Type, claim.Value);
    }
    /*string*/ _backingField_Type = null;
    /*string*/ get Type()
    {
        return _backingField_Type;
    }
    /*string*/ _backingField_Value = null;
    /*string*/ get Value()
    {
        return _backingField_Value;
    }
}


static class Microsoft_AspNetCore_Components_Forms_AttributeUtilities
{
    /*string*/ static CombineClassNames(/*object*/ additionalAttributes, /*string*/ classNames)
    {
        let mclass = null;
        let $ref1 = { set value(v){ mclass = v } };
        if (additionalAttributes || additionalAttributes.TryGetValue("class", $ref1))
        {
            return classNames;
        }
        /*var*/ let classAttributeValue = Convert.ToString(mclass);
        if (string.IsNullOrEmpty(classAttributeValue))
        {
            return classNames;
        }
        if (string.IsNullOrEmpty(classNames))
        {
            return classAttributeValue;
        }
        return `${classAttributeValue} ${classNames}`;
    }
}

class Microsoft_AspNetCore_Components_Forms_DataAnnotationsValidator extends System_IDisposable(Microsoft_AspNetCore_Components_ComponentBase)
{
    constructor()
    {
        super();
    }
    /*IDisposable*/ _subscriptions = null;
    /*EditContext*/ _originalEditContext = null;
    /*EditContext*/ _backingField_CurrentEditContext = null;
    /*EditContext*/ get CurrentEditContext()
    {
        return _backingField_CurrentEditContext;
    }
    /*EditContext*/ set CurrentEditContext(value)
    {
        _backingField_CurrentEditContext = value;
    }
    /*IServiceProvider*/ _backingField_ServiceProvider = null;
    /*IServiceProvider*/ get ServiceProvider()
    {
        return _backingField_ServiceProvider;
    }
    /*IServiceProvider*/ set ServiceProvider(value)
    {
        _backingField_ServiceProvider = value;
    }
    /*void*/ OnInitialized()
    {
        if (CurrentEditContext === null)
        {
            throw new InvalidOperationException(`${nameof(DataAnnotationsValidator)} requires a cascading ` + `parameter of type ${nameof(EditContext)}. For example, you can use ${nameof(DataAnnotationsValidator)} ` + `inside an EditForm.`);
        }
        _subscriptions = CurrentEditContext.EnableDataAnnotationsValidation(ServiceProvider);
        _originalEditContext = CurrentEditContext;
    }
    /*void*/ OnParametersSet()
    {
        if (CurrentEditContext !== _originalEditContext)
        {
            throw new InvalidOperationException(`${GetType()} does not support changing the ` + `${nameof(EditContext)} dynamically.`);
        }
    }
    /*void*/ Dispose(/*bool*/ disposing)
    {
    }
    /*void*/ Dispose()
    {
        super.Dispose();
        _subscriptions?.Dispose();
        _subscriptions = null;
        Dispose({ disposing : true });
    }
    /*void*/ InjectServices(/*IServiceProvider*/ provider)
    {
        ServiceProvider = provider.GetRequiredService(System.IServiceProvider);
    }
    /*void*/ CascadeParameters()
    {
        RequestCascadingParameter(Microsoft_AspNetCore_Components_Forms_EditContext)(Microsoft.AspNetCore.Components.Forms.EditContext, function(/**/ e)
        {
            return CurrentEditContext = e;
        }, { cascadingParameterName : null });
        super.CascadeParameters();
    }
}

class Microsoft_AspNetCore_Components_Forms_EditContext extends object
{
    /*Dictionary<FieldIdentifier, FieldState>*/ _fieldStates = new Dictionary(FieldIdentifier, FieldState)();
    constructor(/*object*/ model)
    {
        super();
        Model = BlazorJs.FirstOf(model, function(){ throw new ArgumentNullException(nameof(model)) });
        Properties = new EditContextProperties();
    }
    /*EventHandler<FieldChangedEventArgs>*/ OnFieldChanged = null;
    /*EventHandler<ValidationRequestedEventArgs>*/ OnValidationRequested = null;
    /*EventHandler<ValidationStateChangedEventArgs>*/ OnValidationStateChanged = null;
    /*FieldIdentifier*/ Field(/*string*/ fieldName)
    {
        return new FieldIdentifier(Model, fieldName);
    }
    /*object*/ _backingField_Model = null;
    /*object*/ get Model()
    {
        return _backingField_Model;
    }
    /*EditContextProperties*/ _backingField_Properties = null;
    /*EditContextProperties*/ get Properties()
    {
        return _backingField_Properties;
    }
    /*bool*/ _backingField_ShouldUseFieldIdentifiers = null;
    /*bool*/ get ShouldUseFieldIdentifiers()
    {
        return _backingField_ShouldUseFieldIdentifiers;
    }
    /*bool*/ set ShouldUseFieldIdentifiers(value)
    {
        _backingField_ShouldUseFieldIdentifiers = value;
    }
    /*void*/ NotifyFieldChanged(/*in FieldIdentifier*/ fieldIdentifier)
    {
        GetOrAddFieldState(fieldIdentifier).IsModified  = true;
        OnFieldChanged?.Invoke(this, new FieldChangedEventArgs(fieldIdentifier));
    }
    /*void*/ NotifyValidationStateChanged()
    {
        OnValidationStateChanged?.Invoke(this, ValidationStateChangedEventArgs.Empty);
    }
    /*void*/ MarkAsUnmodified(/*in FieldIdentifier*/ fieldIdentifier)
    {
        let state = null;
        let $ref1 = { set value(v){ state = v } };
        if (_fieldStates.TryGetValue(fieldIdentifier, $ref1))
        {
            state.IsModified  = false;
        }
    }
    /*void*/ MarkAsUnmodified()
    {
        BlazorJs.forEach(_fieldStates, function(state, $_i)
        {
            state.Value.IsModified  = false;
        });
    }
    /*bool*/ IsModified()
    {
        BlazorJs.forEach(_fieldStates, function(state, $_i)
        {
            if (state.Value.IsModified)
            {
                return true;
            }
        });
        return false;
    }
    /*IEnumerable<string>*/ GetValidationMessages()
    {
        BlazorJs.forEach(_fieldStates, function(state, $_i)
        {
            BlazorJs.forEach(state.Value.GetValidationMessages(), function(message, $_i)
            {
message            });
        });
    }
    /*IEnumerable<string>*/ GetValidationMessages(/*FieldIdentifier*/ fieldIdentifier)
    {
        let state = null;
        let $ref1 = { set value(v){ state = v } };
        if (_fieldStates.TryGetValue(fieldIdentifier, $ref1))
        {
            BlazorJs.forEach(state.GetValidationMessages(), function(message, $_i)
            {
message            });
        }
    }
    /*IEnumerable<string>*/ GetValidationMessages(/*Expression<Func<object>>*/ accessor)
    {
        return GetValidationMessages(FieldIdentifier.Create(accessor));
    }
    /*bool*/ IsModified(/*in FieldIdentifier*/ fieldIdentifier)
    {
        let state = null;
        let $ref1 = { set value(v){ state = v } };
        return _fieldStates.TryGetValue(fieldIdentifier, $ref1) ? state.IsModified
 : false;
    }
    /*bool*/ IsModified(/*Expression<Func<object>>*/ accessor)
    {
        return IsModified(FieldIdentifier.Create(accessor));
    }
    /*bool*/ IsValid(/*in FieldIdentifier*/ fieldIdentifier)
    {
        return GetValidationMessages(fieldIdentifier).Any();
    }
    /*bool*/ IsValid(/*Expression<Func<object>>*/ accessor)
    {
        return IsValid(FieldIdentifier.Create(accessor));
    }
    /*bool*/ Validate()
    {
        OnValidationRequested?.Invoke(this, ValidationRequestedEventArgs.Empty);
        return GetValidationMessages().Any();
    }
    /*FieldState*/ GetFieldState(/*in FieldIdentifier*/ fieldIdentifier)
    {
        let state = null;
        let $ref1 = { set value(v){ state = v } };
        _fieldStates.TryGetValue(fieldIdentifier, $ref1);
        return state;
    }
    /*FieldState*/ GetOrAddFieldState(/*in FieldIdentifier*/ fieldIdentifier)
    {
        let state = null;
        let $ref1 = { set value(v){ state = v } };
        if (_fieldStates.TryGetValue(fieldIdentifier, $ref1))
        {
            state = new FieldState(fieldIdentifier);
            _fieldStates.Add(fieldIdentifier, state);
        }
        return state;
    }
}

static class Microsoft_AspNetCore_Components_Forms_EditContextDataAnnotationsExtensions
{
    /*IDisposable*/ static EnableDataAnnotationsValidation(/*this EditContext*/ editContext, /*IServiceProvider*/ serviceProvider)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(serviceProvider);
        return new DataAnnotationsEventSubscriptions(editContext, serviceProvider);
    }
    /*Action*/ static OnClearCache = null;
    /*void*/ static ClearCache(/*Type[]*/ _)
    {
        OnClearCache?.Invoke();
    }
    static Microsoft_AspNetCore_Components_Forms_EditContextDataAnnotationsExtensions_DataAnnotationsEventSubscriptions = class extends System_IDisposable(object)
    {
        /*Dictionary<(Type ModelType, string FieldName), PropertyInfo>*/ static _propertyInfoCache = new Dictionary(BlazorJs.TupleType(Type, string), PropertyInfo)();
        /*EditContext*/ _editContext = null;
        /*IServiceProvider*/ _serviceProvider = null;
        /*ValidationMessageStore*/ _messages = null;
        constructor(/*EditContext*/ editContext, /*IServiceProvider*/ serviceProvider)
        {
            super();
            _editContext = BlazorJs.FirstOf(editContext, function(){ throw new ArgumentNullException(nameof(editContext)) });
            _serviceProvider = serviceProvider;
            _messages = new ValidationMessageStore(_editContext);
            _editContext.OnFieldChanged  += OnFieldChanged;
            _editContext.OnValidationRequested  += OnValidationRequested;
        }
        /*void*/ OnFieldChanged(/*object*/ sender, /*FieldChangedEventArgs*/ eventArgs)
        {
            let propertyInfo = null;
            let $ref1 = { set value(v){ propertyInfo = v } };
            /*var*/ let fieldIdentifier = eventArgs.FieldIdentifier;
            if (TryGetValidatableProperty(fieldIdentifier, $ref1))
            {
                /*var*/ let propertyValue = propertyInfo.GetValue(fieldIdentifier.Model);
                /*var*/ let validationContext = BlazorJs.PopulateProperty(new ValidationContext(fieldIdentifier.Model, _serviceProvider, { items : null }), function(/*ValidationContext*/ $obj)
                {
                    $obj.MemberName = propertyInfo.Name
;
                });
                /*var*/ let results = new List(ValidationResult)();
                Validator.TryValidateProperty(propertyValue, validationContext, results);
                _messages.Clear(fieldIdentifier);
                BlazorJs.forEach(results, function(result, $_i)
                {
                    _messages.Add(fieldIdentifier, result.ErrorMessage);
                });
                _editContext.NotifyValidationStateChanged();
            }
        }
        /*void*/ OnValidationRequested(/*object*/ sender, /*ValidationRequestedEventArgs*/ e)
        {
            /*var*/ let validationContext = new ValidationContext(_editContext.Model, _serviceProvider, { items : null });
            /*var*/ let validationResults = new List(ValidationResult)();
            Validator.TryValidateObject(_editContext.Model, validationContext, validationResults, true);
            _messages.Clear();
            BlazorJs.forEach(validationResults, function(validationResult, $_i)
            {
                if (validationResult === null)
                {
                }
                /*var*/ let hasMemberNames = false;
                BlazorJs.forEach(validationResult.MemberNames, function(memberName, $_i)
                {
                    hasMemberNames = true;
                    _messages.Add(_editContext.Field(memberName), validationResult.ErrorMessage);
                });
                if (hasMemberNames)
                {
                    _messages.Add(new FieldIdentifier(_editContext.Model, { fieldName : string.Empty }), validationResult.ErrorMessage);
                }
            });
            _editContext.NotifyValidationStateChanged();
        }
        /*void*/ Dispose()
        {
            _messages.Clear();
            _editContext.OnFieldChanged  -= OnFieldChanged;
            _editContext.OnValidationRequested  -= OnValidationRequested;
            _editContext.NotifyValidationStateChanged();
        }
        /*bool*/ static TryGetValidatableProperty(/*in FieldIdentifier*/ fieldIdentifier, /*out PropertyInfo*/ propertyInfo)
        {
            let $ref0 = { set value(v){ propertyInfo = v } };
            /*var*/ let cacheKey = BlazorJs.TupleValue({ ModelType : fieldIdentifier.Model.GetType(), Item2: fieldIdentifier.FieldName });
            if (_propertyInfoCache.TryGetValue(cacheKey, $ref0))
            {
                propertyInfo = cacheKey.ModelType.GetProperty(cacheKey.FieldName);
                _propertyInfoCache[cacheKey] = propertyInfo;
            }
            return propertyInfo !== null;
        }
        /*void*/ ClearCache()
        {
            _propertyInfoCache.Clear();
        }
    }
}

class Microsoft_AspNetCore_Components_Forms_EditContextProperties extends object
{
    constructor()
    {
        super();
    }
    /*Dictionary<object, object>*/ _contents = null;
    /*object*/ getItem(/*object*/ key)
    {
        return _contents ? BlazorJs.Execute(function(){ throw new KeyNotFoundException() }) : _contents[key];
    }
    /*void*/ setItem(/*object*/ key, /*object*/ value)
    {
        _contents = _contents ?? new Dictionary(object, object)();
        _contents[key] = value;
    }
    /*bool*/ TryGetValue(/*object*/ key, /*out object*/ value)
    {
        if (_contents)
        {
            value = BlazorJs.getDefault();
            return false;
        }
        else 
        {
            let $ref0 = { set value(v){ value = v } };
            return _contents.TryGetValue(key, $ref0);
        }
    }
    /*bool*/ Remove(/*object*/ key)
    {
        return _contents?.Remove(key) ?? false;
    }
}

static class Microsoft_AspNetCore_Components_Forms_ExpressionFormatter
{
    constructor()
    {
        super();
    }
    /*int*/ StackAllocBufferSize = 128;
    /*Dictionary<MemberInfo, CapturedValueFormatter>*/ static s_capturedValueFormatterCache = new Dictionary(MemberInfo, CapturedValueFormatter)();
    /*Dictionary<MethodInfo, MethodInfoData>*/ static s_methodInfoDataCache = new Dictionary(MethodInfo, MethodInfoData)();
    /*void*/ static ClearCache()
    {
        s_capturedValueFormatterCache.Clear();
        s_methodInfoDataCache.Clear();
    }
    /*string*/ static FormatLambda(/*LambdaExpression*/ expression)
    {
        return FormatLambda(expression, { prefix : null });
    }
    /*string*/ static FormatLambda(/*LambdaExpression*/ expression, { /*string*/ prefix = null})
    {
        /*var*/ let builder = new ReverseStringBuilder(new Array(StackAllocBufferSize));
        /*var*/ let node = expression.Body;
        /*var*/ let wasLastExpressionMemberAccess = false;
        /*var*/ let wasLastExpressionIndexer = false;
        while((node))
        {
            switch(node.NodeType)
            {
                case ExpressionType.Constant:
                {
                    /*var*/ let constantExpression = BlazorJs.Cast(node, ConstantExpression);
                    node = null;
                    break;
                }
                case ExpressionType.Call:
                {
                    let $ref0 = { set value(v){ builder = v } };
                    /*var*/ let methodCallExpression = BlazorJs.Cast(node, MethodCallExpression);
                    if (IsSingleArgumentIndexer(methodCallExpression))
                    {
                        throw new InvalidOperationException("Method calls cannot be formatted.");
                    }
                    node = methodCallExpression.Object;
                    if (prefix !== null && node instanceof ConstantExpression)
                    {
                        break;
                    }
                    if (wasLastExpressionMemberAccess)
                    {
                        wasLastExpressionMemberAccess = false;
                        builder.InsertFront(".");
                    }
                    wasLastExpressionIndexer = true;
                    builder.InsertFront("]");
                    FormatIndexArgument(methodCallExpression.Arguments[0], $ref0);
                    builder.InsertFront("[");
                    break;
                }
                case ExpressionType.ArrayIndex:
                {
                    let $ref0 = { set value(v){ builder = v } };
                    /*var*/ let binaryExpression = BlazorJs.Cast(node, BinaryExpression);
                    node = binaryExpression.Left;
                    if (prefix !== null && node instanceof ConstantExpression)
                    {
                        break;
                    }
                    if (wasLastExpressionMemberAccess)
                    {
                        wasLastExpressionMemberAccess = false;
                        builder.InsertFront(".");
                    }
                    builder.InsertFront("]");
                    FormatIndexArgument(binaryExpression.Right, $ref0);
                    builder.InsertFront("[");
                    wasLastExpressionIndexer = true;
                    break;
                }
                case ExpressionType.MemberAccess:
                {
                    /*var*/ let memberExpression = BlazorJs.Cast(node, MemberExpression);
                    node = memberExpression.Expression;
                    if (prefix !== null && node instanceof ConstantExpression)
                    {
                        break;
                    }
                    if (wasLastExpressionMemberAccess)
                    {
                        builder.InsertFront(".");
                    }
                    wasLastExpressionMemberAccess = true;
                    wasLastExpressionIndexer = false;
                    /*var*/ let name = memberExpression.Member.GetCustomAttribute(DataMemberAttribute)?.Name ?? memberExpression.Member.Name;
                    builder.InsertFront(name);
                    break;
                }
                default:
                {
                    node = null;
                    break;
                }
            }
        }
        if (prefix !== null)
        {
            if (builder.Empty  && wasLastExpressionIndexer)
            {
                builder.InsertFront(".");
            }
            builder.InsertFront(prefix);
        }
        /*var*/ let result = builder.ToString();
        builder.Dispose();
        return result;
    }
    /*bool*/ static IsSingleArgumentIndexer(/*Expression*/ expression)
    {
        if ((expression instanceof MethodCallExpression, methodExpression = expression) || methodExpression.Arguments.Count  !== 1)
        {
            return false;
        }
        /*var*/ let methodInfoData = GetOrCreateMethodInfoData(methodExpression.Method);
        return methodInfoData.IsSingleArgumentIndexer;
    }
    /*MethodInfoData*/ static GetOrCreateMethodInfoData(/*MethodInfo*/ methodInfo)
    {
        let methodInfoData = null;
        let $ref1 = { set value(v){ methodInfoData = v } };
        if (s_methodInfoDataCache.TryGetValue(methodInfo, $ref1))
        {
            methodInfoData = GetMethodInfoData(methodInfo);
            s_methodInfoDataCache[methodInfo] = methodInfoData;
        }
        return methodInfoData;
        /*MethodInfoData*/ function GetMethodInfoData(/*MethodInfo*/ iMethodInfo)
        {
            /*var*/ let declaringType = iMethodInfo.DeclaringType;
            if (declaringType)
            {
                return new MethodInfoData({ isSingleArgumentIndexer : false });
            }
            return new MethodInfoData({ isSingleArgumentIndexer : false });
        }
    }
    /*void*/ static FormatIndexArgument(/*Expression*/ indexExpression, /*ref ReverseStringBuilder*/ builder)
    {
        switch(indexExpression?.GetType())
        {
            case memberExpression = MemberExpression:
            {
                let $ref0 = { set value(v){ builder = v } };
                FormatCapturedValue(memberExpression, constantExpression, $ref0);
                break;
            }
            case constantExpression2 = ConstantExpression:
            {
                let $ref0 = { set value(v){ builder = v } };
                FormatConstantValue(constantExpression2, $ref0);
                break;
            }
            default:
            {
                throw new InvalidOperationException(`Unable to evaluate index expressions of type '${indexExpression.GetType().Name}'.`);
            }
        }
    }
    /*string*/ static FormatIndexArgument(/*Expression*/ indexExpression)
    {
        /*var*/ let builder = new ReverseStringBuilder(new Array(StackAllocBufferSize));
        try
        {
            let $ref0 = { set value(v){ builder = v } };
            FormatIndexArgument(indexExpression, $ref0);
            /*var*/ let result = builder.ToString();
            return result;
        }
        finally
        {
            {
                builder.Dispose();
            }
        }
    }
    /*void*/ static FormatCapturedValue(/*MemberExpression*/ memberExpression, /*ConstantExpression*/ constantExpression, /*ref ReverseStringBuilder*/ builder)
    {
        let format = null;
        let $ref1 = { set value(v){ format = v } };
        let $ref2 = { set value(v){ builder = v } };
        /*var*/ let member = memberExpression.Member;
        if (s_capturedValueFormatterCache.TryGetValue(member, $ref1))
        {
            format = CreateCapturedValueFormatter(memberExpression);
            s_capturedValueFormatterCache[member] = format;
        }
        format(constantExpression.Value, $ref2);
    }
    /*Func<object, TResult>*/ static CompileMemberEvaluator(TResult, /*MemberExpression*/ imemberExpression)
    {
        /*var*/ let parameterExpression = Expression.Parameter(object);
        /*var*/ let convertExpression = Expression.Convert(parameterExpression, imemberExpression.Member.DeclaringType);
        /*var*/ let replacedMemberExpression = imemberExpression.Update(convertExpression);
        /*var*/ let replacedExpression = Expression.Lambda(Func(object, TResult), replacedMemberExpression, parameterExpression);
        return replacedExpression.Compile();
    }
    /*CapturedValueFormatter*/ static CreateCapturedValueFormatter(/*MemberExpression*/ memberExpression)
    {
        /*var*/ let memberType = memberExpression.Type;
        if (memberType === int)
        {
            /*var*/ let func = CompileMemberEvaluator(int)(int, memberExpression);
            return function(/*object*/ closure, /*ReverseStringBuilder*/ builder)
            {
                return builder.InsertFront(func.Invoke(closure));
            };
        }
        else if (memberType === string)
        {
            /*var*/ let func = CompileMemberEvaluator(string)(string, memberExpression);
            return function(/*object*/ closure, /*ReverseStringBuilder*/ builder)
            {
                return builder.InsertFront(func.Invoke(closure));
            };
        }
        else if (IFormattable.IsAssignableFrom(memberType))
        {
            /*var*/ let func = CompileMemberEvaluator(IFormattable)(IFormattable, memberExpression);
            return function(/*object*/ closure, /*ReverseStringBuilder*/ builder)
            {
                return builder.InsertFront(func.Invoke(closure));
            };
        }
        else 
        {
            throw new InvalidOperationException(`Cannot format an index argument of type '${memberType}'.`);
        }
    }
    /*void*/ static FormatConstantValue(/*ConstantExpression*/ constantExpression, /*ref ReverseStringBuilder*/ builder)
    {
        switch(constantExpression.Value?.GetType())
        {
            case s = string:
            {
                builder.InsertFront(s);
                break;
            }
            case formattable = IFormattable:
            {
                builder.InsertFront(formattable);
                break;
            }
            case null:
            {
                builder.InsertFront("null");
                break;
            }
        }
    }
    static Microsoft_AspNetCore_Components_Forms_ExpressionFormatter_MethodInfoData = class extends System_ValueType
    {
        /*bool*/ _backingField_IsSingleArgumentIndexer = null;
        /*bool*/ get IsSingleArgumentIndexer()
        {
            return _backingField_IsSingleArgumentIndexer;
        }
        constructor(/*bool*/ isSingleArgumentIndexer)
        {
            super();
            IsSingleArgumentIndexer = isSingleArgumentIndexer;
        }
    }
}

class Microsoft_AspNetCore_Components_Forms_FieldChangedEventArgs extends System_EventArgs
{
    constructor(/*FieldIdentifier*/ fieldIdentifier)
    {
        super();
        FieldIdentifier = fieldIdentifier;
    }
    /*FieldIdentifier*/ _backingField_FieldIdentifier = null;
    /*FieldIdentifier*/ get FieldIdentifier()
    {
        return _backingField_FieldIdentifier;
    }
}

class Microsoft_AspNetCore_Components_Forms_FieldIdentifier extends H5_IH5Class(System_IEquatable(Microsoft_AspNetCore_Components_Forms_FieldIdentifier)(System_ValueType))
{
    /*Dictionary<(Type ModelType, MemberInfo Member), Func<object, object>>*/ static _fieldAccessors = new Dictionary(BlazorJs.TupleType(Type, MemberInfo), Func(object, object))();
    constructor()
    {
        super();
    }
    /*FieldIdentifier*/ static Create(TField, /*Expression<Func<TField>>*/ accessor)
    {
        let model = null;
        let $ref1 = { set value(v){ model = v } };
        let fieldName = null;
        let $ref3 = { set value(v){ fieldName = v } };
        ArgumentNullExceptionExtension.ThrowIfNull(accessor);
        ParseAccessor(accessor, $ref1, $ref3);
        return new FieldIdentifier(model, fieldName);
    }
    constructor(/*object*/ model, /*string*/ fieldName)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(model);
        if (model.GetType().IsValueType)
        {
            throw new ArgumentException("The model must be a reference-typed object.", nameof(model));
        }
        Model = model;
        FieldName = BlazorJs.FirstOf(fieldName, function(){ throw new ArgumentNullException(nameof(fieldName)) });
    }
    /*object*/ _backingField_Model = null;
    /*object*/ get Model()
    {
        return _backingField_Model;
    }
    /*string*/ _backingField_FieldName = null;
    /*string*/ get FieldName()
    {
        return _backingField_FieldName;
    }
    /*int*/ GetHashCode()
    {
        /*// We want to compare Model instances by reference. RuntimeHelpers.GetHashCode returns identical hashes for equal object references (ignoring any `Equals`/`GetHashCode` overrides) which is what we want.
            var*/ let modelHash = RuntimeHelpers.GetHashCode(Model);
        /*var*/ let fieldHash = StringComparer.Ordinal.GetHashCode(FieldName);
        return BlazorJs.TupleValue({ Item1: modelHash, Item2: fieldHash }).GetHashCode();
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        return obj instanceof FieldIdentifier, otherIdentifier = obj && Equals(otherIdentifier);
    }
    /*bool*/ Equals(/*FieldIdentifier*/ otherIdentifier)
    {
        return ReferenceEquals(otherIdentifier.Model, Model) && string.Equals(otherIdentifier.FieldName, FieldName, StringComparison.Ordinal);
    }
    /*void*/ static ParseAccessor(T, /*Expression<Func<T>>*/ accessor, /*out object*/ model, /*out string*/ fieldName)
    {
        /*var*/ let accessorBody = accessor.Body;
        if (accessorBody instanceof UnaryExpression, unaryExpression = accessorBody && unaryExpression.NodeType  === ExpressionType.Convert
 && unaryExpression.Type  === object)
        {
            accessorBody = unaryExpression.Operand;
        }
        switch(accessorBody?.GetType())
        {
            case memberExpression = MemberExpression:
            {
                fieldName = memberExpression.Member.Name;
                switch(memberExpression.Expression?.GetType())
                {
                    case constant = ConstantExpression:
                    {
                        throw new ArgumentException("The provided expression must evaluate to a non-null value.");
                    }
                    case constant = ConstantExpression:
                    {
                        model = constant.Value;
                        break;
                    }
                    case member = MemberExpression:
                    {
                        model = GetModelFromMemberAccess(member);
                        break;
                    }
                    default:
                    {
                        if (memberExpression.Expression  !== null)
                        {
                            /*// It would be great to cache this somehow, but it's unclear there's a reasonable way to do
                                // so, given that it embeds captured values such as "this". We could consider special-casing
                                // for "() => something.Member" and building a cache keyed by "something.GetType()" with values
                                // of type Func<object, object> so we can cheaply map from "something" to "something.Member".
                                var*/ let modelLambda = Expression.Lambda(memberExpression.Expression);
                            /*var*/ let modelLambdaCompiled = BlazorJs.Cast(modelLambda.Compile(), Func(object));
                            /*var*/ let result = BlazorJs.FirstOf(modelLambdaCompiled(), function(){ throw new ArgumentException("The provided expression must evaluate to a non-null value.") });
                            model = result;
                            break;
                        }
                        else 
                        throw new ArgumentException(`The provided expression contains a ${accessorBody.GetType().Name} which is not supported. ${nameof(FieldIdentifier)} only supports simple member accessors (fields, properties) of an object.`);
                    }
                }
                break;
            }
            case methodCallExpression = MethodCallExpression:
            {
                fieldName = ExpressionFormatter.FormatIndexArgument(methodCallExpression.Arguments[0]);
                model = GetModelFromIndexer(methodCallExpression.Object);
                break;
            }
            case binaryExpression = BinaryExpression:
            {
                fieldName = ExpressionFormatter.FormatIndexArgument(binaryExpression.Right);
                model = GetModelFromIndexer(binaryExpression.Left);
                break;
            }
            default:
            {
                throw new ArgumentException(`The provided expression contains a ${accessorBody.GetType().Name} which is not supported. ${nameof(FieldIdentifier)} only supports simple member accessors (fields, properties) of an object.`);
            }
        }
    }
    /*object*/ static GetModelFromMemberAccess(/*MemberExpression*/ member, { /*Dictionary<(Type ModelType, MemberInfo Member), Func<object, object>>*/ cache = null})
    {
        cache = cache ?? _fieldAccessors;
        /*Func<object, object>*/ let accessor = null;
        /*object*/ let value = null;
        switch(member.Expression?.GetType())
        {
            case model = ConstantExpression:
            {
                value = BlazorJs.FirstOf(model.Value , function(){ throw new ArgumentException("The provided expression must evaluate to a non-null value.") });
                accessor = cache.GetOrAdd(BlazorJs.TupleValue({ Item1: value.GetType(), Item2: member.Member }), CreateAccessor);
                break;
            }
            default:
            {
                break;
            }
        }
        if (accessor === null)
        {
            throw new InvalidOperationException(`Unable to compile expression: ${member}`);
        }
        if (value === null)
        {
            throw new ArgumentException("The provided expression must evaluate to a non-null value.");
        }
        /*var*/ let result = accessor(value);
        return result;
        /*Func<object, object>*/ function CreateAccessor(/*(Type model, MemberInfo member)*/ arg)
        {
            /*var*/ let parameter = Expression.Parameter(object, "value");
            /*Expression*/ let expression = Expression.Convert(parameter, arg.model);
            expression = Expression.MakeMemberAccess(expression, arg.member);
            expression = Expression.Convert(expression, object);
            /*var*/ let lambda = Expression.Lambda(Func(object, object), expression, parameter);
            /*var*/ let func = lambda.Compile();
            return func;
        }
    }
    /*object*/ static GetModelFromIndexer(/*Expression*/ methodCallExpression)
    {
        /*object*/ let model;
        /*var*/ let methodCallObjectLambda = Expression.Lambda(methodCallExpression);
        /*var*/ let methodCallObjectLambdaCompiled = BlazorJs.Cast(methodCallObjectLambda.Compile(), Func(object));
        /*var*/ let result = methodCallObjectLambdaCompiled();
        if (result)
        {
            throw new ArgumentException("The provided expression must evaluate to a non-null value.");
        }
        model = result;
        return model;
    }
    /*void*/ static ClearCache()
    {
        _fieldAccessors.Clear();
    }
}

class Microsoft_AspNetCore_Components_Forms_FieldState extends object
{
    /*FieldIdentifier*/ _fieldIdentifier = null;
    /*HashSet<ValidationMessageStore>*/ _validationMessageStores = null;
    constructor(/*FieldIdentifier*/ fieldIdentifier)
    {
        super();
        _fieldIdentifier = fieldIdentifier;
    }
    /*bool*/ _backingField_IsModified = null;
    /*bool*/ get IsModified()
    {
        return _backingField_IsModified;
    }
    /*bool*/ set IsModified(value)
    {
        _backingField_IsModified = value;
    }
    /*IEnumerable<string>*/ GetValidationMessages()
    {
        if (_validationMessageStores !== null)
        {
            BlazorJs.forEach(_validationMessageStores, function(store, $_i)
            {
                BlazorJs.forEach(store[_fieldIdentifier], function(message, $_i)
                {
message                });
            });
        }
    }
    /*void*/ AssociateWithValidationMessageStore(/*ValidationMessageStore*/ validationMessageStore)
    {
        if (_validationMessageStores === null)
        {
            _validationMessageStores = new HashSet(ValidationMessageStore)();
        }
        _validationMessageStores.Add(validationMessageStore);
    }
    /*void*/ DissociateFromValidationMessageStore(/*ValidationMessageStore*/ validationMessageStore)
    {
        return _validationMessageStores?.Remove(validationMessageStore);
    }
}

class Microsoft_AspNetCore_Components_Forms_ReverseStringBuilder extends System_ValueType
{
    /*int*/ MinimumRentedArraySize = 1024;
    /*ArrayPool<char>*/ static s_arrayPool = ArrayPool(char).Shared;
    /*int*/ _nextEndIndex = null;
    /*Span<char>*/ _currentBuffer = null;
    constructor(/*int*/ conservativeEstimatedStringLength)
    {
        super();
        /*var*/ let array = s_arrayPool.Rent(conservativeEstimatedStringLength);
        _currentBuffer = array;
        _nextEndIndex = _currentBuffer.Length;
    }
    constructor(/*Span<char>*/ initialBuffer)
    {
        super();
        _currentBuffer = initialBuffer;
        _nextEndIndex = _currentBuffer.Length;
    }
    /*bool*/ get Empty()
    {
        return _nextEndIndex === _currentBuffer.Length;
    }
    /*void*/ InsertFront(/*ReadOnlySpan<char>*/ span)
    {
        /*var*/ let startIndex = _nextEndIndex - span.Length;
        if (startIndex >= 0)
        {
            span.CopyTo(_currentBuffer[new System_Range(startIndex, 1)]);
            _nextEndIndex = startIndex;
            return ;
        }
        throw new InvalidOperationException("Not enough space");
    }
    /*void*/ InsertFront(T, /*T*/ value)
    {
        /*// This is large enough for any integer value (10 digits plus the possible sign).
            // We won't try to optimize for anything larger.
            Span<char>*/ let result = new Span(char)(11);
        InsertFront(BlazorJs.Cast(value, IFormattable));
    }
    /*void*/ InsertFront(/*IFormattable*/ formattable)
    {
        return InsertFront(formattable.ToString(null, CultureInfo.InvariantCulture).AsSpan());
    }
    /*string*/ ToString()
    {
        return _currentBuffer[new System_Range(_nextEndIndex, 1)].AsString();
    }
    /*void*/ Dispose()
    {
    }
}

class Microsoft_AspNetCore_Components_Forms_ValidationMessageStore extends object
{
    /*EditContext*/ _editContext = null;
    /*Dictionary<FieldIdentifier, List<string>>*/ _messages = new Dictionary(FieldIdentifier, List(string))();
    constructor(/*EditContext*/ editContext)
    {
        super();
        _editContext = BlazorJs.FirstOf(editContext, function(){ throw new ArgumentNullException(nameof(editContext)) });
    }
    /*void*/ Add(/*in FieldIdentifier*/ fieldIdentifier, /*string*/ message)
    {
        return GetOrCreateMessagesListForField(fieldIdentifier).Add(message);
    }
    /*void*/ Add(/*Expression<Func<object>>*/ accessor, /*string*/ message)
    {
        return Add(FieldIdentifier.Create(accessor), message);
    }
    /*void*/ Add(/*in FieldIdentifier*/ fieldIdentifier, /*IEnumerable<string>*/ messages)
    {
        return GetOrCreateMessagesListForField(fieldIdentifier).AddRange(messages);
    }
    /*void*/ Add(/*Expression<Func<object>>*/ accessor, /*IEnumerable<string>*/ messages)
    {
        return Add(FieldIdentifier.Create(accessor), messages);
    }
    /*IEnumerable<string>*/ getItem(/*FieldIdentifier*/ fieldIdentifier)
    {
        let messages = null;
        let $ref1 = { set value(v){ messages = v } };
        return _messages.TryGetValue(fieldIdentifier, $ref1) ? BlazorJs.Cast(messages, IEnumerable(string)) : Array.Empty(string);
    }
    /*IEnumerable<string>*/ getItem(/*Expression<Func<object>>*/ accessor)
    {
        return this[FieldIdentifier.Create(accessor)];
    }
    /*void*/ Clear()
    {
        BlazorJs.forEach(_messages.Keys, function(fieldIdentifier, $_i)
        {
            DissociateFromField(fieldIdentifier);
        });
        _messages.Clear();
    }
    /*void*/ Clear(/*Expression<Func<object>>*/ accessor)
    {
        return Clear(FieldIdentifier.Create(accessor));
    }
    /*void*/ Clear(/*in FieldIdentifier*/ fieldIdentifier)
    {
        DissociateFromField(fieldIdentifier);
        _messages.Remove(fieldIdentifier);
    }
    /*List<string>*/ GetOrCreateMessagesListForField(/*in FieldIdentifier*/ fieldIdentifier)
    {
        let messagesForField = null;
        let $ref1 = { set value(v){ messagesForField = v } };
        if (_messages.TryGetValue(fieldIdentifier, $ref1))
        {
            messagesForField = new List(string)();
            _messages.Add(fieldIdentifier, messagesForField);
            AssociateWithField(fieldIdentifier);
        }
        return messagesForField;
    }
    /*void*/ AssociateWithField(/*in FieldIdentifier*/ fieldIdentifier)
    {
        return _editContext.GetOrAddFieldState(fieldIdentifier).AssociateWithValidationMessageStore(this);
    }
    /*void*/ DissociateFromField(/*in FieldIdentifier*/ fieldIdentifier)
    {
        return _editContext.GetFieldState(fieldIdentifier)?.DissociateFromValidationMessageStore(this);
    }
}

class Microsoft_AspNetCore_Components_Forms_ValidationRequestedEventArgs extends System_EventArgs
{
    /*ValidationRequestedEventArgs*/ static Empty = new ValidationRequestedEventArgs();
    constructor()
    {
        super();
    }
}

class Microsoft_AspNetCore_Components_Forms_ValidationStateChangedEventArgs extends System_EventArgs
{
    /*ValidationStateChangedEventArgs*/ static Empty = new ValidationStateChangedEventArgs();
    constructor()
    {
        super();
    }
}

class Microsoft_AspNetCore_Components_ExcludeFromInteractiveRoutingAttribute extends System_Attribute
{
    constructor()
    {
        super();
    }
}

class Microsoft_AspNetCore_Components_Routing_FocusOnNavigate extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
    }
    /*string*/ CustomElementName = "blazor-focus-on-navigate";
    /*Type*/ _lastNavigatedPageType = NonMatchingType;
    /*bool*/ _focusAfterRender = null;
    /*RouteData*/ _backingField_RouteData = null;
    /*RouteData*/ get RouteData()
    {
        return _backingField_RouteData;
    }
    /*RouteData*/ set RouteData(value)
    {
        _backingField_RouteData = value;
    }
    /*string*/ _backingField_Selector = null;
    /*string*/ get Selector()
    {
        return _backingField_Selector;
    }
    /*string*/ set Selector(value)
    {
        _backingField_Selector = value;
    }
    /*void*/ OnParametersSet()
    {
        if (RouteData)
        {
            throw new InvalidOperationException(`${nameof(FocusOnNavigate)} requires a non-null value for the parameter '${nameof(RouteData)}'.`);
        }
        if (string.IsNullOrWhiteSpace(Selector))
        {
            throw new InvalidOperationException(`${nameof(FocusOnNavigate)} requires a nonempty value for the parameter '${nameof(Selector)}'.`);
        }
        if (RouteData.PageType  !== _lastNavigatedPageType)
        {
            _lastNavigatedPageType = RouteData.PageType;
            _focusAfterRender = true;
        }
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ frame, { /*object*/ key = null})
    {
    }
    /*void*/ OnAfterRender(/*bool*/ firstRender)
    {
        if (_focusAfterRender)
        {
            _focusAfterRender = false;
            /*var*/ let element = document.querySelector(HTMLElement, Selector).As(HTMLElement);
            if (element !== null)
            element.scrollIntoView();
        }
        super.OnAfterRender(firstRender);
    }
    static Microsoft_AspNetCore_Components_Routing_FocusOnNavigate_NonMatchingType = class extends object
    {
        constructor()
        {
            super();
        }
    }
}


const Microsoft_AspNetCore_Components_Routing_INavigationInterception = (Base) => class extends Base
{
}



const Microsoft_AspNetCore_Components_Routing_IRoutingStateProvider = (Base) => class extends Base
{
    /*/// <summary>
        /// Gets RouteData
        /// </summary>
        RouteData*/ _backingField_RouteData = null;
    /*/// <summary>
        /// Gets RouteData
        /// </summary>
        RouteData*/ get RouteData()
    {
        return _backingField_RouteData;
    }
}

const Microsoft_AspNetCore_Components_Routing_IScrollToLocationHash = (Base) => class extends Base
{
}

class Microsoft_AspNetCore_Components_Routing_LocationChangedEventArgs extends System_EventArgs
{
    constructor(/*string*/ location, /*bool*/ isNavigationIntercepted)
    {
        super();
        Location = location;
        IsNavigationIntercepted = isNavigationIntercepted;
    }
    /*string*/ _backingField_Location = null;
    /*string*/ get Location()
    {
        return _backingField_Location;
    }
    /*bool*/ _backingField_IsNavigationIntercepted = null;
    /*bool*/ get IsNavigationIntercepted()
    {
        return _backingField_IsNavigationIntercepted;
    }
    /*object*/ _backingField_HistoryEntryState = null;
    /*object*/ get HistoryEntryState()
    {
        return _backingField_HistoryEntryState;
    }
    /*object*/ set HistoryEntryState(value)
    {
        _backingField_HistoryEntryState = value;
    }
}

class Microsoft_AspNetCore_Components_Routing_LocationChangingContext extends object
{
    constructor()
    {
        super();
    }
    /*bool*/ _backingField_DidPreventNavigation = null;
    /*bool*/ get DidPreventNavigation()
    {
        return _backingField_DidPreventNavigation;
    }
    /*bool*/ set DidPreventNavigation(value)
    {
        _backingField_DidPreventNavigation = value;
    }
    /*string*/ _backingField_TargetLocation = null;
    /*string*/ get TargetLocation()
    {
        return _backingField_TargetLocation;
    }
    /*string*/ set TargetLocation(value)
    {
        _backingField_TargetLocation = value;
    }
    /*object*/ _backingField_HistoryEntryState = null;
    /*object*/ get HistoryEntryState()
    {
        return _backingField_HistoryEntryState;
    }
    /*object*/ set HistoryEntryState(value)
    {
        _backingField_HistoryEntryState = value;
    }
    /*bool*/ _backingField_IsNavigationIntercepted = null;
    /*bool*/ get IsNavigationIntercepted()
    {
        return _backingField_IsNavigationIntercepted;
    }
    /*bool*/ set IsNavigationIntercepted(value)
    {
        _backingField_IsNavigationIntercepted = value;
    }
    /*CancellationToken*/ _backingField_CancellationToken = null;
    /*CancellationToken*/ get CancellationToken()
    {
        return _backingField_CancellationToken;
    }
    /*CancellationToken*/ set CancellationToken(value)
    {
        _backingField_CancellationToken = value;
    }
    /*void*/ PreventNavigation()
    {
        DidPreventNavigation = true;
    }
}

class Microsoft_AspNetCore_Components_Routing_NavigationContext extends object
{
    constructor(/*string*/ path, /*CancellationToken*/ cancellationToken)
    {
        super();
        Path = path;
        CancellationToken = cancellationToken;
    }
    /*string*/ _backingField_Path = null;
    /*string*/ get Path()
    {
        return _backingField_Path;
    }
    /*CancellationToken*/ _backingField_CancellationToken = null;
    /*CancellationToken*/ get CancellationToken()
    {
        return _backingField_CancellationToken;
    }
}

class Microsoft_AspNetCore_Components_Routing_NavigationLock extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
    }
    /*string*/ _id = Guid.NewGuid().ToString("D");
    /*IDisposable*/ _locationChangingRegistration = null;
    /*bool*/ _hasLocationChangingHandler = null;
    /*bool*/ _confirmExternalNavigation = null;
    /*bool*/ get HasLocationChangingHandler()
    {
        return OnBeforeInternalNavigation.HasDelegate;
    }
    /*NavigationManager*/ _backingField_NavigationManager = null;
    /*NavigationManager*/ get NavigationManager()
    {
        return _backingField_NavigationManager;
    }
    /*NavigationManager*/ set NavigationManager(value)
    {
        _backingField_NavigationManager = value;
    }
    /*EventCallback<LocationChangingContext>*/ _backingField_OnBeforeInternalNavigation = null;
    /*EventCallback<LocationChangingContext>*/ get OnBeforeInternalNavigation()
    {
        return _backingField_OnBeforeInternalNavigation;
    }
    /*EventCallback<LocationChangingContext>*/ set OnBeforeInternalNavigation(value)
    {
        _backingField_OnBeforeInternalNavigation = value;
    }
    /*bool*/ _backingField_ConfirmExternalNavigation = null;
    /*bool*/ get ConfirmExternalNavigation()
    {
        return _backingField_ConfirmExternalNavigation;
    }
    /*bool*/ set ConfirmExternalNavigation(value)
    {
        _backingField_ConfirmExternalNavigation = value;
    }
    /*void*/ OnParametersSet()
    {
        if (_hasLocationChangingHandler !== HasLocationChangingHandler || _confirmExternalNavigation !== ConfirmExternalNavigation)
        {
        }
        super.OnParametersSet();
    }
    /*int*/ static onBeforeUnloadSubscribed = null;
    /*void*/ static OnBeforeUnload(/*Event*/ e)
    {
        e.preventDefault();
        e.returnValue  = true;
    }
    /*void*/ static DisableNavigationPrompt()
    {
        onBeforeUnloadSubscribed--;
        if (onBeforeUnloadSubscribed === 0)
        {
            window.removeEventListener("beforeunload", OnBeforeUnload);
        }
    }
    /*void*/ static EnableNavigationPrompt()
    {
        if (onBeforeUnloadSubscribed === 0)
        {
            window.addEventListener("beforeunload", OnBeforeUnload);
        }
        onBeforeUnloadSubscribed++;
    }
    /*Task*/ OnAfterRenderAsync(/*bool*/ firstRender)
    {
        if (_hasLocationChangingHandler !== HasLocationChangingHandler)
        {
            _hasLocationChangingHandler = HasLocationChangingHandler;
            _locationChangingRegistration?.Dispose();
            _locationChangingRegistration = _hasLocationChangingHandler ? NavigationManager.RegisterLocationChangingHandler(OnLocationChanging) : null;
        }
        if (_confirmExternalNavigation !== ConfirmExternalNavigation)
        {
            _confirmExternalNavigation = ConfirmExternalNavigation;
            if (_confirmExternalNavigation)
            {
                EnableNavigationPrompt();
            }
            else 
            {
                DisableNavigationPrompt();
            }
        }
        return super.OnAfterRenderAsync(firstRender);
    }
    /*Task*/ async OnLocationChanging(/*LocationChangingContext*/ context)
    {
        await OnBeforeInternalNavigation.InvokeAsync(context);
    }
    /*void*/ Dispose()
    {
        _locationChangingRegistration?.Dispose();
        if (_confirmExternalNavigation)
        {
            DisableNavigationPrompt();
        }
        super.Dispose();
    }
    /*void*/ InjectServices(/*IServiceProvider*/ provider)
    {
        NavigationManager = provider.GetRequiredService(Microsoft.AspNetCore.Components.NavigationManager);
    }
}

class Microsoft_AspNetCore_Components_Routing_NavLink extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
    }
    /*string*/ DefaultActiveClass = "active";
    /*bool*/ _isActive = null;
    /*string*/ _hrefAbsolute = null;
    /*string*/ _class = null;
    /*string*/ _backingField_ActiveClass = null;
    /*string*/ get ActiveClass()
    {
        return _backingField_ActiveClass;
    }
    /*string*/ set ActiveClass(value)
    {
        _backingField_ActiveClass = value;
    }
    /*string*/ _backingField_CssClass = null;
    /*string*/ get CssClass()
    {
        return _backingField_CssClass;
    }
    /*string*/ set CssClass(value)
    {
        _backingField_CssClass = value;
    }
    /*RenderFragment*/ _backingField_ChildContent = null;
    /*RenderFragment*/ get ChildContent()
    {
        return _backingField_ChildContent;
    }
    /*RenderFragment*/ set ChildContent(value)
    {
        _backingField_ChildContent = value;
    }
    /*NavLinkMatch*/ _backingField_Match = null;
    /*NavLinkMatch*/ get Match()
    {
        return _backingField_Match;
    }
    /*NavLinkMatch*/ set Match(value)
    {
        _backingField_Match = value;
    }
    /*NavigationManager*/ _backingField_NavigationManager = null;
    /*NavigationManager*/ get NavigationManager()
    {
        return _backingField_NavigationManager;
    }
    /*NavigationManager*/ set NavigationManager(value)
    {
        _backingField_NavigationManager = value;
    }
    /*void*/ OnInitialized()
    {
        NavigationManager.LocationChanged  += OnLocationChanged;
    }
    /*void*/ OnParametersSet()
    {
        let obj = null;
        let $ref1 = { set value(v){ obj = v } };
        let $ref2 = { set value(v){ obj = v } };
        /*// Update computed state
            var*/ let href = BlazorJs.Cast(null, string);
        if (this.TryGetValue("href", $ref1))
        {
            href = Convert.ToString(obj);
        }
        _hrefAbsolute = href === null ? null : NavigationManager.ToAbsoluteUri(href).AbsoluteUri;
        _isActive = ShouldMatch(NavigationManager.Uri);
        _class = BlazorJs.Cast(null, string);
        if (this.TryGetValue("class", $ref2))
        {
            _class = Convert.ToString(obj);
        }
        UpdateCssClass();
    }
    /*void*/ Dispose()
    {
        NavigationManager.LocationChanged  -= OnLocationChanged;
    }
    /*void*/ UpdateCssClass()
    {
        CssClass = _isActive ? CombineWithSpace(_class, ActiveClass ?? DefaultActiveClass) : _class;
    }
    /*void*/ OnLocationChanged(/*object*/ sender, /*LocationChangedEventArgs*/ args)
    {
        /*// We could just re-render always, but for this component we know the
            // only relevant state change is to the _isActive property.
            var*/ let shouldBeActiveNow = ShouldMatch(args.Location);
        if (shouldBeActiveNow !== _isActive)
        {
            _isActive = shouldBeActiveNow;
            UpdateCssClass();
            StateHasChanged();
        }
    }
    /*bool*/ ShouldMatch(/*string*/ currentUriAbsolute)
    {
        if (_hrefAbsolute === null)
        {
            return false;
        }
        if (EqualsHrefExactlyOrIfTrailingSlashAdded(currentUriAbsolute))
        {
            return true;
        }
        if (Match === NavLinkMatch.Prefix
 && IsStrictlyPrefixWithSeparator(currentUriAbsolute, _hrefAbsolute))
        {
            return true;
        }
        return false;
    }
    /*bool*/ EqualsHrefExactlyOrIfTrailingSlashAdded(/*string*/ currentUriAbsolute)
    {
        Debug.Assert(_hrefAbsolute !== null);
        if (string.Equals(currentUriAbsolute, _hrefAbsolute, StringComparison.OrdinalIgnoreCase))
        {
            return true;
        }
        if (currentUriAbsolute.Length  === _hrefAbsolute.Length  - 1)
        {
            if (_hrefAbsolute[_hrefAbsolute.Length  - 1] === '/' && _hrefAbsolute.StartsWith(currentUriAbsolute, StringComparison.OrdinalIgnoreCase))
            {
                return true;
            }
        }
        return false;
    }
    /*string*/ static CombineWithSpace(/*string*/ str1, /*string*/ str2)
    {
        return str1 === null ? str2 : `${str1} ${str2}`;
    }
    /*bool*/ static IsStrictlyPrefixWithSeparator(/*string*/ value, /*string*/ prefix)
    {
        /*var*/ let prefixLength = prefix.Length;
        if (value.Length  > prefixLength)
        {
            return value.StartsWith(prefix, StringComparison.OrdinalIgnoreCase) && (prefixLength === 0 || IsUnreservedCharacter(prefix[prefixLength - 1]) || IsUnreservedCharacter(value[prefixLength]));
        }
        else 
        {
            return false;
        }
    }
    /*bool*/ static IsUnreservedCharacter(/*char*/ c)
    {
        return char.IsLetterOrDigit(c) || c === '-' || c === '.' || c === '_' || c === '~';
    }
    /*void*/ InjectServices(/*IServiceProvider*/ provider)
    {
        NavigationManager = provider.GetRequiredService(Microsoft.AspNetCore.Components.NavigationManager);
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ __frame0, { /*object*/ __key = null})
    {
        __frame0.Element("a", function(/*UIElementAttribute*/ __attribute)
        {
            __attribute.Set("href", (this["href"]));
            __attribute.Set("class", CssClass);
            __attribute.Set("aria-current", (_isActive ? "page" : null));
        }, function(/**/ __frame1, /**/ __key1)
        {
            __frame1.Content(ChildContent, { key : __key1, sequenceNumber : 939697809 });
        }, { sequenceNumber : 939697808 });
    }
}

static class Microsoft_AspNetCore_Components_Routing_NavLinkMatch
{
    Prefix = 0;
    All = 1;
}







class Microsoft_AspNetCore_Components_Routing_RouteKey extends H5_IH5Class(System_IEquatable(Microsoft_AspNetCore_Components_Routing_RouteKey)(System_ValueType))
{
    /*Assembly*/ AppAssembly = null;
    /*HashSet<Assembly>*/ AdditionalAssemblies = null;
    constructor(/*Assembly*/ appAssembly, /*IEnumerable<Assembly>*/ additionalAssemblies)
    {
        super();
        AppAssembly = appAssembly;
        AdditionalAssemblies = additionalAssemblies ? null : new HashSet(Assembly)(additionalAssemblies);
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        return obj instanceof RouteKey, other = obj && Equals(other);
    }
    /*bool*/ Equals(/*RouteKey*/ other)
    {
        if (Equals(AppAssembly, other.AppAssembly))
        {
            return false;
        }
        if (AdditionalAssemblies && other.AdditionalAssemblies )
        {
            return true;
        }
        if (AdditionalAssemblies || other.AdditionalAssemblies )
        {
            return false;
        }
        return AdditionalAssemblies.Count  === other.AdditionalAssemblies.Count  && AdditionalAssemblies.SetEquals(other.AdditionalAssemblies);
    }
    /*int*/ GetHashCode()
    {
        if (AppAssembly)
        {
            return 0;
        }
        if (AdditionalAssemblies)
        {
            return AppAssembly.GetHashCode();
        }
        return HashCode.Combine(AppAssembly, AdditionalAssemblies.Count);
    }
}

class Microsoft_AspNetCore_Components_Routing_Router extends System_IDisposable(Microsoft_AspNetCore_Components_ComponentBase)
{
    constructor()
    {
        super();
    }
    /*//// Dictionary is intentionally used instead of ReadOnlyDictionary to reduce Blazor size
        //static readonly IReadOnlyDictionary<string, object> _emptyParametersDictionary
        //    = new Dictionary<string, object>();

        string*/ _baseUri = null;
    /*string*/ _locationAbsolute = null;
    /*bool*/ _navigationInterceptionEnabled = null;
    /*string*/ _updateScrollPositionForHashLastLocation = null;
    /*bool*/ _updateScrollPositionForHash = null;
    /*CancellationTokenSource*/ _onNavigateCts = null;
    /*Task*/ _previousOnNavigateTask = Task.CompletedTask;
    /*RouteKey*/ _routeTableLastBuiltForRouteKey = null;
    /*bool*/ _onNavigateCalled = null;
    /*NavigationManager*/ _backingField_NavigationManager = null;
    /*NavigationManager*/ get NavigationManager()
    {
        return _backingField_NavigationManager;
    }
    /*NavigationManager*/ set NavigationManager(value)
    {
        _backingField_NavigationManager = value;
    }
    /*INavigationInterception*/ _backingField_NavigationInterception = null;
    /*INavigationInterception*/ get NavigationInterception()
    {
        return _backingField_NavigationInterception;
    }
    /*INavigationInterception*/ set NavigationInterception(value)
    {
        _backingField_NavigationInterception = value;
    }
    /*IScrollToLocationHash*/ _backingField_ScrollToLocationHash = null;
    /*IScrollToLocationHash*/ get ScrollToLocationHash()
    {
        return _backingField_ScrollToLocationHash;
    }
    /*IScrollToLocationHash*/ set ScrollToLocationHash(value)
    {
        _backingField_ScrollToLocationHash = value;
    }
    /*IServiceProvider*/ _backingField_ServiceProvider = null;
    /*IServiceProvider*/ get ServiceProvider()
    {
        return _backingField_ServiceProvider;
    }
    /*IServiceProvider*/ set ServiceProvider(value)
    {
        _backingField_ServiceProvider = value;
    }
    /*IRoutingStateProvider*/ _backingField_RoutingStateProvider = null;
    /*IRoutingStateProvider*/ get RoutingStateProvider()
    {
        return _backingField_RoutingStateProvider;
    }
    /*IRoutingStateProvider*/ set RoutingStateProvider(value)
    {
        _backingField_RoutingStateProvider = value;
    }
    /*Assembly*/ _backingField_AppAssembly = null;
    /*Assembly*/ get AppAssembly()
    {
        return _backingField_AppAssembly;
    }
    /*Assembly*/ set AppAssembly(value)
    {
        _backingField_AppAssembly = value;
    }
    /*IEnumerable<Assembly>*/ _backingField_AdditionalAssemblies = null;
    /*IEnumerable<Assembly>*/ get AdditionalAssemblies()
    {
        return _backingField_AdditionalAssemblies;
    }
    /*IEnumerable<Assembly>*/ set AdditionalAssemblies(value)
    {
        _backingField_AdditionalAssemblies = value;
    }
    /*RenderFragment*/ _backingField_NotFound = null;
    /*RenderFragment*/ get NotFound()
    {
        return _backingField_NotFound;
    }
    /*RenderFragment*/ set NotFound(value)
    {
        _backingField_NotFound = value;
    }
    /*RenderFragment<RouteData>*/ _backingField_Found = null;
    /*RenderFragment<RouteData>*/ get Found()
    {
        return _backingField_Found;
    }
    /*RenderFragment<RouteData>*/ set Found(value)
    {
        _backingField_Found = value;
    }
    /*RenderFragment*/ _backingField_Navigating = null;
    /*RenderFragment*/ get Navigating()
    {
        return _backingField_Navigating;
    }
    /*RenderFragment*/ set Navigating(value)
    {
        _backingField_Navigating = value;
    }
    /*EventCallback<NavigationContext>*/ _backingField_OnNavigateAsync = null;
    /*EventCallback<NavigationContext>*/ get OnNavigateAsync()
    {
        return _backingField_OnNavigateAsync;
    }
    /*EventCallback<NavigationContext>*/ set OnNavigateAsync(value)
    {
        _backingField_OnNavigateAsync = value;
    }
    /*RouteTable*/ _backingField_Routes = null;
    /*RouteTable*/ get Routes()
    {
        return _backingField_Routes;
    }
    /*RouteTable*/ set Routes(value)
    {
        _backingField_Routes = value;
    }
    /*void*/ OnInitialized()
    {
        super.OnInitialized();
        _baseUri = NavigationManager.BaseUri;
        _locationAbsolute = NavigationManager.Uri;
        NavigationManager.LocationChanged  += OnLocationChanged;
        RoutingStateProvider = ServiceProvider.GetService(IRoutingStateProvider);
    }
    /*Task*/ async OnParametersSetAsync()
    {
        await super.OnParametersSetAsync();
        if (AppAssembly === null)
        {
            throw new InvalidOperationException(`The ${nameof(Router)} component requires a value for the parameter ${nameof(AppAssembly)}.`);
        }
        if (Found === null)
        {
            throw new InvalidOperationException(`The ${nameof(Router)} component requires a value for the parameter ${nameof(Found)}.`);
        }
        if (_onNavigateCalled)
        {
            _onNavigateCalled = true;
            await RunOnNavigateAsync(NavigationManager.ToBaseRelativePath(_locationAbsolute), { isNavigationIntercepted : false });
        }
        else 
        {
            Refresh({ isNavigationIntercepted : false });
        }
    }
    /*void*/ Dispose()
    {
        super.Dispose();
        NavigationManager.LocationChanged  -= OnLocationChanged;
    }
    /*ReadOnlySpan<char>*/ static TrimQueryOrHash(/*ReadOnlySpan<char>*/ str)
    {
        /*var*/ let firstIndex = str.IndexOfAny('?', '#');
        return firstIndex < 0 ? str : str[new Range(0, firstIndex)];
    }
    /*void*/ RefreshRouteTable()
    {
        /*var*/ let routeKey = new RouteKey(AppAssembly, AdditionalAssemblies);
        if (routeKey.Equals(_routeTableLastBuiltForRouteKey))
        {
            Routes = RouteTableFactory.Instance.Create(routeKey, ServiceProvider);
            _routeTableLastBuiltForRouteKey = routeKey;
        }
    }
    /*void*/ ClearRouteCaches()
    {
        RouteTableFactory.Instance.ClearCaches();
        _routeTableLastBuiltForRouteKey = BlazorJs.getDefault();
    }
    /*RenderFragment*/ _viewFragment = null;
    /*void*/ BuildRenderTree(/*IUIFrame*/ frame, { /*object*/ key = null})
    {
        frame.Content(_viewFragment, { sequenceNumber : Utility.Router_View_SequenceNumber });
    }
    /*void*/ Render(/*RenderFragment*/ fragment)
    {
        _viewFragment = fragment;
        StateHasChanged();
    }
    /*void*/ Refresh(/*bool*/ isNavigationIntercepted)
    {
        if (_previousOnNavigateTask.Status  !== TaskStatus.RanToCompletion)
        {
            if (Navigating !== null)
            {
                Render(Navigating);
            }
            return ;
        }
        /*var*/ let relativePath = NavigationManager.ToBaseRelativePath(_locationAbsolute);
        /*var*/ let locationPathSpan = TrimQueryOrHash(relativePath.AsSpan());
        /*var*/ let locationPath = `/${locationPathSpan}`;
        RefreshRouteTable();
        /*//var context = new RouteContext(locationPath);
            var*/ let routeData = Routes.Route(locationPath);
        if (routeData?.PageType !== null)
        {
            if (IComponent.IsAssignableFrom(routeData.PageType))
            {
                throw new InvalidOperationException(`The type ${routeData.PageType.FullName} ` + `does not implement ${IComponent.FullName}.`);
            }
            Render(Found(routeData));
            if (relativePath !== _updateScrollPositionForHashLastLocation)
            {
                _updateScrollPositionForHashLastLocation = relativePath.ToString();
                _updateScrollPositionForHash = true;
            }
        }
        else 
        {
            if (isNavigationIntercepted)
            {
                Render(NotFound ?? DefaultNotFoundContent);
            }
            else 
            {
                NavigationManager.NavigateTo(_locationAbsolute, { forceLoad : true });
            }
        }
    }
    /*void*/ static DefaultNotFoundContent(/*IUIFrame*/ builder, { /*object*/ key = null})
    {
        builder.AddContent(0, "Not found");
    }
    /*Task*/ async RunOnNavigateAsync(/*string*/ path, /*bool*/ isNavigationIntercepted)
    {
        _onNavigateCts?.Cancel();
        await _previousOnNavigateTask;
        /*var*/ let tcs = new TaskCompletionSource(object)();
        _previousOnNavigateTask = tcs.Task;
        if (OnNavigateAsync.HasDelegate)
        {
            Refresh(isNavigationIntercepted);
        }
        _onNavigateCts = new CancellationTokenSource();
        /*var*/ let navigateContext = new NavigationContext(path, _onNavigateCts.Token);
        /*var*/ let cancellationTcs = new TaskCompletionSource(object)();
        navigateContext.CancellationToken.Register(function(/**/ state)
        {
            return (BlazorJs.Cast(state, TaskCompletionSource(object))).SetResult(null);
        }, cancellationTcs);
        /*//try
            //{
            // Task.WhenAny returns a Task<Task> so we need to await twice to unwrap the exception
            var*/ let task = await Task.WhenAny(OnNavigateAsync.InvokeAsync(navigateContext), cancellationTcs.Task);
        await task;
        tcs.SetResult(null);
        Refresh(isNavigationIntercepted);
    }
    /*void*/ OnLocationChanged(/*object*/ sender, /*LocationChangedEventArgs*/ args)
    {
        _locationAbsolute = args.Location;
        if (Routes !== null)
        {
            RunOnNavigateAsync(NavigationManager.ToBaseRelativePath(_locationAbsolute), args.IsNavigationIntercepted).FireAndForget();
        }
    }
    /*Task*/ async OnAfterRenderAsync(/*bool*/ firstRender)
    {
        await super.OnAfterRenderAsync(firstRender);
        if (_navigationInterceptionEnabled)
        {
            _navigationInterceptionEnabled = true;
            await NavigationInterception.EnableNavigationInterceptionAsync();
        }
        if (_updateScrollPositionForHash)
        {
            _updateScrollPositionForHash = false;
            if (ScrollToLocationHash !== null)
            await ScrollToLocationHash.RefreshScrollPositionForHash(_locationAbsolute);
        }
    }
    /*void*/ InjectServices(/*IServiceProvider*/ provider)
    {
        NavigationManager = provider.GetRequiredService(Microsoft.AspNetCore.Components.NavigationManager);
        NavigationInterception = provider.GetRequiredService(Microsoft.AspNetCore.Components.Routing.INavigationInterception);
        ScrollToLocationHash = provider.GetService(Microsoft.AspNetCore.Components.Routing.IScrollToLocationHash);
        ServiceProvider = provider.GetRequiredService(System.IServiceProvider);
    }
}

class Microsoft_AspNetCore_Components_Routing_RouteRegistration extends Microsoft_AspNetCore_Components_RouteData
{
    /*IReadOnlyDictionary<string, object>*/ static _emptyParametersDictionary = new Dictionary(string, object)();
    constructor(/*Type*/ pageType)
    {
        super(pageType, _emptyParametersDictionary);
    }
    /*Type*/ _backingField_Layout = null;
    /*Type*/ get Layout()
    {
        return _backingField_Layout;
    }
    /*Type*/ set Layout(value)
    {
        _backingField_Layout = value;
    }
    /*Action<object, string, string>*/ _backingField_ParameterSetter = null;
    /*Action<object, string, string>*/ get ParameterSetter()
    {
        return _backingField_ParameterSetter;
    }
    /*Action<object, string, string>*/ set ParameterSetter(value)
    {
        _backingField_ParameterSetter = value;
    }
}

class Microsoft_AspNetCore_Components_Routing_RouteTable extends object
{
    /*//private readonly TreeRouter _router = treeRouter;
        //private static readonly Dictionary<(Type, string), InboundRouteEntry> _routeEntryCache = new Dictionary<(Type, string), InboundRouteEntry>();

        //public TreeRouter? TreeRouter => _router;
        Dictionary<Type, string[]>*/ _templatesByHandler = null;
    constructor(/*Dictionary<Type, string[]>*/ templatesByHandler)
    {
        super();
        _templatesByHandler = templatesByHandler;
    }
    /*RouteData*/ Route(/*string*/ locationPath)
    {
        let $ref0 = { set value(v){ _ = v } };
        let parameter = null;
        let $ref2 = { set value(v){ parameter = v } };
        /*var*/ let registeredRoute = RouteTableFactory.Match(locationPath, $ref0, $ref2);
        if (registeredRoute !== null)
        {
            return new RouteData(registeredRoute.PageType, parameter !== null ? object.GetOwnPropertyNames(parameter).ToDictionary(function(/**/ name)
            {
                return name;
            }, function(/**/ name)
            {
                return parameter[name];
            }) : new Dictionary(string, object)());
        }
        /*var*/ let found = _templatesByHandler.SelectMany(function(/**/ t)
        {
            return t.Value.Select(function(/**/ pattern)
            {
                /*object*/ let iparameter = new object();
                /*var*/ let weight = RouteTableFactory.MatchPath(pattern, locationPath, iparameter);
                return BlazorJs.TupleValue({ Item1: t.Key, Item2: pattern, Item3: weight, Item4: iparameter });
            });
        }).MaxBy(function(/**/ t)
        {
            return t.weight;
        });
        if (found.Key  !== null)
        {
            return new RouteData(found.Key, found.iparameter  !== null ? object.GetOwnPropertyNames(found.iparameter).ToDictionary(function(/**/ name)
            {
                return name;
            }, function(/**/ name)
            {
                return found.iparameter[name];
            }) : new Dictionary(string, object)());
        }
        return null;
    }
}

class Microsoft_AspNetCore_Components_RouteTableFactory extends object
{
    constructor()
    {
        super();
    }
    /*RouteTableFactory*/ static Instance = new RouteTableFactory();
    /*Dictionary<string, RouteRegistration>*/ static routeRegistrations = new Dictionary(string, RouteRegistration)();
    /*void*/ static Register(T, /*string*/ route, { /*Type*/ layout = null, /*Action<T, string, string>*/ routeParameterSetter = null})
    {
        routeRegistrations[route] = BlazorJs.PopulateProperty(new RouteRegistration(T), function(/*RouteRegistration*/ $obj)
        {
            $obj.Layout = layout;
            $obj.ParameterSetter = routeParameterSetter !== null ? function(/**/ o, /**/ n, /**/ v)
            {
                return routeParameterSetter(BlazorJs.Cast(o, T), n, v);
            } : BlazorJs.Cast(null, Action(object, string, string));
        });
    }
    /*int*/ static MatchPath(/*string*/ pathPattern, /*string*/ path, /*object*/ routeParameter)
    {
        /*var*/ let splitPattern = pathPattern.Trim('/').Split('/');
        /*var*/ let splitPath = path.Trim('/').Split('/');
        /*int*/ let weight = 0;
        for(/*int*/ let i = 0; i < splitPattern.Length; i++)
        {
            /*var*/ let t1 = splitPattern[i];
            /*var*/ let t2 = i < splitPath.Length  ? splitPath[i] : null;
            if (t1.StartsWith("*"))
            weight += 10;
            else if (t1.Equals(t2, StringComparison.InvariantCultureIgnoreCase))
            weight += 1000;
            else if (t1.StartsWith("{") && t1.EndsWith("}") && t2 !== null)
            {
                weight += 100;
                routeParameter[t1.Substring(1, t1.Length  - 2)] = t2;
            }
        }
        return weight;
    }
    /*RouteRegistration*/ static Match(/*string*/ uri, /*out int*/ routeIndexSequenceNumber, /*out object*/ routeParameter)
    {
        /*var*/ let split = uri.Split('?');
        /*var*/ let path = split[0].Trim('/');
        /*var*/ let query = split.Length  > 1 ? split[1] : null;
        /*RouteRegistration*/ let registration = null;
        /*int*/ let maxWeight = 0;
        /*int*/ let index = 0;
        routeIndexSequenceNumber = 0;
        routeParameter = null;
        BlazorJs.forEach(routeRegistrations, function(route, $_i)
        {
            /*object*/ let dic = new object();
            /*var*/ let w = MatchPath(route.Key, path, dic);
            if (w > 0 && w > maxWeight)
            {
                registration = route.Value;
                routeParameter = dic;
                routeIndexSequenceNumber = index;
                maxWeight = w;
            }
            index++;
        });
        if (registration !== null && query !== null)
        {
            if (routeParameter === null)
            routeParameter = new object();
            /*var*/ let querySplit = query.Split('&');
            BlazorJs.forEach(querySplit, function(kv, $_i)
            {
                /*var*/ let split2 = kv.Split('=');
                routeParameter[split2[0]] = H5.Script.DecodeURI(split2[1]);
            });
        }
        return registration;
    }
    /*Dictionary<RouteKey, RouteTable>*/ _cache = new Dictionary(RouteKey, RouteTable)();
    /*RouteTable*/ Create(/*RouteKey*/ routeKey, /*IServiceProvider*/ serviceProvider)
    {
        let resolvedComponents = null;
        let $ref1 = { set value(v){ resolvedComponents = v } };
        if (_cache.TryGetValue(routeKey, $ref1))
        {
            return resolvedComponents;
        }
        /*var*/ let componentTypes = GetRouteableComponents(routeKey);
        /*var*/ let routeTable = Create(componentTypes, serviceProvider);
        _cache.TryAdd(routeKey, routeTable);
        return routeTable;
    }
    /*void*/ ClearCaches()
    {
        return _cache.Clear();
    }
    /*List<Type>*/ static GetRouteableComponents(/*RouteKey*/ routeKey)
    {
        /*var*/ let routeableComponents = new List(Type)();
        if ((routeKey.AppAssembly ))
        {
            GetRouteableComponents(routeableComponents, routeKey.AppAssembly);
        }
        if ((routeKey.AdditionalAssemblies ))
        {
            BlazorJs.forEach(routeKey.AdditionalAssemblies, function(assembly, $_i)
            {
                if (assembly !== routeKey.AppAssembly)
                {
                    GetRouteableComponents(routeableComponents, assembly);
                }
            });
        }
        return routeableComponents;
        /*void*/ function GetRouteableComponents(/*List<Type>*/ routeableComponents1, /*Assembly*/ assembly)
        {
            BlazorJs.forEach(assembly.GetTypes(), function(type, $_i)
            {
                if (IComponent.IsAssignableFrom(type) && type.IsDefined(RouteAttribute) && type.IsDefined(ExcludeFromInteractiveRoutingAttribute))
                {
                    routeableComponents1.Add(type);
                }
            });
        }
    }
    /*RouteTable*/ static Create(/*List<Type>*/ componentTypes, /*IServiceProvider*/ serviceProvider)
    {
        /*var*/ let templatesByHandler = new Dictionary(Type, string)();
        BlazorJs.forEach(componentTypes, function(componentType, $_i)
        {
            /*// We're deliberately using inherit = false here.
                //
                // RouteAttribute is defined as non-inherited, because inheriting a route attribute always causes an
                // ambiguity. You end up with two components (base class and derived class) with the same route.
                var*/ let templates = GetTemplates(componentType);
            templatesByHandler.Add(componentType, templates);
        });
        return Create(templatesByHandler, serviceProvider);
    }
    /*string[]*/ static GetTemplates(/*Type*/ componentType)
    {
        /*var*/ let routeAttributes = componentType.GetCustomAttributes(RouteAttribute, { inherit : false });
        /*var*/ let templates = new Array(routeAttributes.Length);
        for(/*var*/ let i = 0; i < routeAttributes.Length; i++)
        {
            /*var*/ let attribute = BlazorJs.Cast(routeAttributes[i], RouteAttribute);
            templates[i] = attribute.Template;
        }
        return templates;
    }
    /*RouteTable*/ static Create(/*Dictionary<Type, string[]>*/ templatesByHandler, /*IServiceProvider*/ serviceProvider)
    {
        return new RouteTable(templatesByHandler);
    }
}




class Microsoft_AspNetCore_Components_Web_ErrorBoundary extends Microsoft_AspNetCore_Components_ErrorBoundaryBase
{
    constructor()
    {
        super();
    }
    /*IErrorBoundaryLogger*/ _backingField_ErrorBoundaryLogger = null;
    /*IErrorBoundaryLogger*/ get ErrorBoundaryLogger()
    {
        return _backingField_ErrorBoundaryLogger;
    }
    /*IErrorBoundaryLogger*/ set ErrorBoundaryLogger(value)
    {
        _backingField_ErrorBoundaryLogger = value;
    }
    /*Task*/ async OnErrorAsync(/*Exception*/ exception)
    {
        await ErrorBoundaryLogger.LogErrorAsync(exception);
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ frame, { /*object*/ key = null})
    {
        if (CurrentException === null)
        {
            frame.Content(ChildContent, { sequenceNumber : Utility.ErrorBoundary_ChildContent_SequenceNumber });
        }
        else if (ErrorContent !== null)
        {
            frame.Content(ErrorContent(CurrentException), { sequenceNumber : Utility.ErrorBoundary_ErrorContent_SequenceNumber });
        }
        else 
        {
            frame.Element("div", { attributeBuilder : function(/*UIElementAttribute*/ attribute)
            {
                attribute.Set("class", "blazor-error-boundary");
            }, sequenceNumber : Utility.ErrorBoundary_DefaultContent_SequenceNumber });
        }
    }
    /*void*/ InjectServices(/*IServiceProvider*/ provider)
    {
        ErrorBoundaryLogger = provider.GetRequiredService(Microsoft.AspNetCore.Components.Web.IErrorBoundaryLogger);
    }
}

const Microsoft_AspNetCore_Components_Web_IErrorBoundaryLogger = (Base) => class extends Base
{
}

class Microsoft_AspNetCore_Components_Forms_AntiforgeryRequestToken extends object
{
    constructor(/*string*/ value, /*string*/ formFieldName)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(value);
        ArgumentNullExceptionExtension.ThrowIfNull(formFieldName);
        Value = value;
        FormFieldName = formFieldName;
    }
    /*string*/ _backingField_Value = null;
    /*string*/ get Value()
    {
        return _backingField_Value;
    }
    /*string*/ _backingField_FormFieldName = null;
    /*string*/ get FormFieldName()
    {
        return _backingField_FormFieldName;
    }
}

class Microsoft_AspNetCore_Components_Forms_AntiforgeryStateProvider extends object
{
    constructor()
    {
        super();
    }
}

class Microsoft_AspNetCore_Components_Forms_AntiforgeryToken extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
    }
    /*bool*/ _hasRendered = null;
    /*AntiforgeryRequestToken*/ _requestToken = null;
    /*IServiceProvider*/ _backingField_Services = null;
    /*IServiceProvider*/ get Services()
    {
        return _backingField_Services;
    }
    /*IServiceProvider*/ set Services(value)
    {
        _backingField_Services = value;
    }
    /*void*/ OnInitialized()
    {
        _requestToken = Services.GetService(AntiforgeryStateProvider)?.GetAntiforgeryToken();
        super.OnInitialized();
    }
    /*void*/ InjectServices(/*IServiceProvider*/ provider)
    {
        Services = provider.GetRequiredService(System.IServiceProvider);
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ __frame0, { /*object*/ __key = null})
    {
        if (_requestToken !== null)
        {
            __frame0.Element("input", function(/*UIElementAttribute*/ __attribute)
            {
                __attribute.Set("type", "hidden");
                __attribute.Set("name", _requestToken.FormFieldName);
                __attribute.Set("value", _requestToken.Value);
            }, null, { sequenceNumber : 826633741 });
        }
    }
}

static class Microsoft_AspNetCore_Components_Forms_EditContextFieldClassExtensions
{
    /*object*/ static FieldCssClassProviderKey = new object();
    /*string*/ static FieldCssClass(TField, /*this EditContext*/ editContext, /*Expression<Func<TField>>*/ accessor)
    {
        return FieldCssClass(editContext, FieldIdentifier.Create(accessor));
    }
    /*string*/ static FieldCssClass(/*this EditContext*/ editContext, /*in FieldIdentifier*/ fieldIdentifier)
    {
        let customProvider = null;
        let $ref1 = { set value(v){ customProvider = v } };
        /*var*/ let provider = editContext.Properties.TryGetValue(FieldCssClassProviderKey, $ref1) ? BlazorJs.Cast(customProvider, FieldCssClassProvider) : FieldCssClassProvider.Instance;
        return provider.GetFieldCssClass(editContext, fieldIdentifier);
    }
    /*void*/ static SetFieldCssClassProvider(/*this EditContext*/ editContext, /*FieldCssClassProvider*/ fieldCssClassProvider)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(fieldCssClassProvider);
        editContext.Properties[FieldCssClassProviderKey] = fieldCssClassProvider;
    }
}

class Microsoft_AspNetCore_Components_Forms_EditForm extends Microsoft_AspNetCore_Components_ComponentBase
{
    /*Func<Task>*/ _handleSubmitDelegate = null;
    /*EditContext*/ _editContext = null;
    /*bool*/ _hasSetEditContextExplicitly = null;
    constructor()
    {
        super();
        _handleSubmitDelegate = HandleSubmitAsync;
    }
    /*EditContext*/ get EditContext()
    {
        return _editContext;
    }
    /*EditContext*/ set EditContext(value)
    {
        _editContext = value;
        _hasSetEditContextExplicitly = value !== null;
    }
    /*bool*/ _backingField_Enhance = null;
    /*bool*/ get Enhance()
    {
        return _backingField_Enhance;
    }
    /*bool*/ set Enhance(value)
    {
        _backingField_Enhance = value;
    }
    /*object*/ _backingField_Model = null;
    /*object*/ get Model()
    {
        return _backingField_Model;
    }
    /*object*/ set Model(value)
    {
        _backingField_Model = value;
    }
    /*RenderFragment<EditContext>*/ _backingField_ChildContent = null;
    /*RenderFragment<EditContext>*/ get ChildContent()
    {
        return _backingField_ChildContent;
    }
    /*RenderFragment<EditContext>*/ set ChildContent(value)
    {
        _backingField_ChildContent = value;
    }
    /*EventCallback<EditContext>*/ _backingField_OnSubmit = null;
    /*EventCallback<EditContext>*/ get OnSubmit()
    {
        return _backingField_OnSubmit;
    }
    /*EventCallback<EditContext>*/ set OnSubmit(value)
    {
        _backingField_OnSubmit = value;
    }
    /*EventCallback<EditContext>*/ _backingField_OnValidSubmit = null;
    /*EventCallback<EditContext>*/ get OnValidSubmit()
    {
        return _backingField_OnValidSubmit;
    }
    /*EventCallback<EditContext>*/ set OnValidSubmit(value)
    {
        _backingField_OnValidSubmit = value;
    }
    /*EventCallback<EditContext>*/ _backingField_OnInvalidSubmit = null;
    /*EventCallback<EditContext>*/ get OnInvalidSubmit()
    {
        return _backingField_OnInvalidSubmit;
    }
    /*EventCallback<EditContext>*/ set OnInvalidSubmit(value)
    {
        _backingField_OnInvalidSubmit = value;
    }
    /*FormMappingContext*/ _backingField_MappingContext = null;
    /*FormMappingContext*/ get MappingContext()
    {
        return _backingField_MappingContext;
    }
    /*FormMappingContext*/ set MappingContext(value)
    {
        _backingField_MappingContext = value;
    }
    /*string*/ _backingField_FormName = null;
    /*string*/ get FormName()
    {
        return _backingField_FormName;
    }
    /*string*/ set FormName(value)
    {
        _backingField_FormName = value;
    }
    /*void*/ OnParametersSet()
    {
        if (_hasSetEditContextExplicitly && Model !== null)
        {
            throw new InvalidOperationException(`${nameof(EditForm)} requires a ${nameof(Model)} ` + `parameter, or an ${nameof(EditContext)} parameter, but not both.`);
        }
        else if (_hasSetEditContextExplicitly && Model === null)
        {
            throw new InvalidOperationException(`${nameof(EditForm)} requires either a ${nameof(Model)} ` + `parameter, or an ${nameof(EditContext)} parameter, please provide one of these.`);
        }
        if (OnSubmit.HasDelegate  && (OnValidSubmit.HasDelegate  || OnInvalidSubmit.HasDelegate))
        {
            throw new InvalidOperationException(`When supplying an ${nameof(OnSubmit)} parameter to ` + `${nameof(EditForm)}, do not also supply ${nameof(OnValidSubmit)} or ${nameof(OnInvalidSubmit)}.`);
        }
        if (Model !== null && Model !== _editContext?.Model)
        {
            _editContext = new EditContext(Model);
        }
    }
    /*Task*/ async HandleSubmitAsync()
    {
        Debug.Assert(_editContext !== null);
        if (OnSubmit.HasDelegate)
        {
            await OnSubmit.InvokeAsync(_editContext);
        }
        else 
        {
            /*// Otherwise, the system implicitly runs validation on form submission
                var*/ let isValid = _editContext.Validate();
            if (isValid && OnValidSubmit.HasDelegate)
            {
                await OnValidSubmit.InvokeAsync(_editContext);
            }
            if (isValid && OnInvalidSubmit.HasDelegate)
            {
                await OnInvalidSubmit.InvokeAsync(_editContext);
            }
        }
    }
    /*void*/ CascadeParameters()
    {
        RequestCascadingParameter(Microsoft_AspNetCore_Components_Forms_FormMappingContext)(Microsoft.AspNetCore.Components.Forms.FormMappingContext, function(/**/ e)
        {
            return MappingContext = e;
        }, { cascadingParameterName : null });
        super.CascadeParameters();
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ __frame0, { /*object*/ __key = null})
    {
        __frame0.Element("form", function(/*UIElementAttribute*/ __attribute)
        {
            __attribute.Set("method", (MappingContext !== null ? "post" : null));
            __attribute.Set("data-enhance", (Enhance ? "" : null));
            __attribute.Set("@attributes", (this.As(IReadOnlyDictionary(string, object))));
            __attribute.Set("@onsubmit", EventCallback.Factory.Create(this, _handleSubmitDelegate));
        }, null, { key : _editContext.GetHashCode(), sequenceNumber : 808443956 });
        __frame0.Component(CascadingValue(EditContext), function(/**/ __component0)
        {
            __component0.IsFixed  = true;
            __component0.Value  = _editContext;
            __component0.ChildContent  = function(/**/ __frame1, /**/ __key1)
            {
                __frame1.Content(ChildContent?.Invoke(_editContext), { key : __key1, sequenceNumber : 808443955 });
            };
        }, { sequenceNumber : 808443954 });
    }
}


class Microsoft_AspNetCore_Components_Forms_FieldCssClassProvider extends object
{
    constructor()
    {
        super();
    }
    /*FieldCssClassProvider*/ static Instance = new FieldCssClassProvider();
    /*string*/ GetFieldCssClass(/*EditContext*/ editContext, /*in FieldIdentifier*/ fieldIdentifier)
    {
        /*var*/ let isValid = editContext.GetValidationMessages(fieldIdentifier).Any();
        if (editContext.IsModified(fieldIdentifier))
        {
            return isValid ? "modified valid" : "modified invalid";
        }
        else 
        {
            return isValid ? "valid" : "invalid";
        }
    }
}

class Microsoft_AspNetCore_Components_Forms_HtmlFieldPrefix extends object
{
    /*LambdaExpression*/ initial = null;
    constructor(/*LambdaExpression*/ initial)
    {
        super();
        this.initial = initial;
    }
    /*LambdaExpression[]*/ _rest = Array.Empty(LambdaExpression);
    constructor(/*LambdaExpression*/ expression, /*LambdaExpression[]*/ rest)
    {
        super(expression);
        _rest = rest;
    }
    /*HtmlFieldPrefix*/ Combine(/*LambdaExpression*/ other)
    {
        /*var*/ let restLength = _rest?.Length ?? 0;
        /*var*/ let length = restLength + 1;
        /*var*/ let expressions = new Array(length);
        for(/*var*/ let i = 0; i < restLength - 1; i++)
        {
            expressions[i] = _rest[i];
        }
        expressions[length - 1] = other;
        return new HtmlFieldPrefix(initial, expressions);
    }
    /*string*/ GetFieldName(/*LambdaExpression*/ expression)
    {
        /*var*/ let prefix = ExpressionFormatter.FormatLambda(initial);
        /*var*/ let restLength = _rest?.Length ?? 0;
        for(/*var*/ let i = 0; i < restLength; i++)
        {
            prefix = ExpressionFormatter.FormatLambda(_rest[i], prefix);
        }
        return ExpressionFormatter.FormatLambda(expression, prefix);
    }
}

const Microsoft_AspNetCore_Components_IInputRadioValueProvider = (Base) => class extends Base
{
    /*object*/ _backingField_CurrentValue = null;
    /*object*/ get CurrentValue()
    {
        return _backingField_CurrentValue;
    }
}

const Microsoft_AspNetCore_Components_Forms_InputBase = (TValue) => class extends Microsoft_AspNetCore_Components_ComponentBase
{
    /*EventHandler<ValidationStateChangedEventArgs>*/ _validationStateChangedHandler = null;
    /*bool*/ _hasInitializedParameters = null;
    /*bool*/ _parsingFailed = null;
    /*string*/ _incomingValueBeforeParsing = null;
    /*string*/ _formattedValueExpression = null;
    /*bool*/ _previousParsingAttemptFailed = null;
    /*ValidationMessageStore*/ _parsingValidationMessages = null;
    /*Type*/ _nullableUnderlyingType = null;
    /*bool*/ _shouldGenerateFieldNames = null;
    /*EditContext*/ _backingField_CascadedEditContext = null;
    /*EditContext*/ get CascadedEditContext()
    {
        return _backingField_CascadedEditContext;
    }
    /*EditContext*/ set CascadedEditContext(value)
    {
        _backingField_CascadedEditContext = value;
    }
    /*HtmlFieldPrefix*/ _backingField_FieldPrefix = null;
    /*HtmlFieldPrefix*/ get FieldPrefix()
    {
        return _backingField_FieldPrefix;
    }
    /*HtmlFieldPrefix*/ set FieldPrefix(value)
    {
        _backingField_FieldPrefix = value;
    }
    /*TValue*/ _backingField_Value = null;
    /*TValue*/ get Value()
    {
        return _backingField_Value;
    }
    /*TValue*/ set Value(value)
    {
        _backingField_Value = value;
    }
    /*EventCallback<TValue>*/ _backingField_ValueChanged = null;
    /*EventCallback<TValue>*/ get ValueChanged()
    {
        return _backingField_ValueChanged;
    }
    /*EventCallback<TValue>*/ set ValueChanged(value)
    {
        _backingField_ValueChanged = value;
    }
    /*Expression<Func<TValue>>*/ _backingField_ValueExpression = null;
    /*Expression<Func<TValue>>*/ get ValueExpression()
    {
        return _backingField_ValueExpression;
    }
    /*Expression<Func<TValue>>*/ set ValueExpression(value)
    {
        _backingField_ValueExpression = value;
    }
    /*string*/ _backingField_DisplayName = null;
    /*string*/ get DisplayName()
    {
        return _backingField_DisplayName;
    }
    /*string*/ set DisplayName(value)
    {
        _backingField_DisplayName = value;
    }
    /*EditContext*/ _backingField_EditContext = null;
    /*EditContext*/ get EditContext()
    {
        return _backingField_EditContext;
    }
    /*EditContext*/ set EditContext(value)
    {
        _backingField_EditContext = value;
    }
    /*FieldIdentifier*/ _backingField_FieldIdentifier = null;
    /*FieldIdentifier*/ get FieldIdentifier()
    {
        return _backingField_FieldIdentifier;
    }
    /*FieldIdentifier*/ set FieldIdentifier(value)
    {
        _backingField_FieldIdentifier = value;
    }
    /*TValue*/ get CurrentValue()
    {
        return Value;
    }
    /*TValue*/ set CurrentValue(value)
    {
        /*var*/ let hasChanged = EqualityComparer(TValue).Default.Equals(value, Value);
        if (hasChanged)
        {
            _parsingFailed = false;
            Value = value;
            ValueChanged.InvokeAsync(Value).FireAndForget();
            EditContext?.NotifyFieldChanged(FieldIdentifier);
        }
    }
    /*string*/ get CurrentValueAsString()
    {
        return _parsingFailed ? _incomingValueBeforeParsing : FormatValueAsString(CurrentValue);
    }
    /*string*/ set CurrentValueAsString(value)
    {
        let parsedValue = null;
        let $ref1 = { set value(v){ parsedValue = v } };
        let validationErrorMessage = null;
        let $ref3 = { set value(v){ validationErrorMessage = v } };
        _incomingValueBeforeParsing = value;
        _parsingValidationMessages?.Clear();
        if (_nullableUnderlyingType !== null && string.IsNullOrEmpty(value))
        {
            _parsingFailed = false;
            CurrentValue = BlazorJs.getDefault();
        }
        else if (TryParseValueFromString(value, $ref1, $ref3))
        {
            _parsingFailed = false;
            CurrentValue = parsedValue;
        }
        else 
        {
            _parsingFailed = true;
            if ((EditContext))
            {
                _parsingValidationMessages = _parsingValidationMessages ?? new ValidationMessageStore(EditContext);
                _parsingValidationMessages.Add(FieldIdentifier, validationErrorMessage);
                EditContext.NotifyFieldChanged(FieldIdentifier);
            }
        }
        if (_parsingFailed || _previousParsingAttemptFailed)
        {
            EditContext?.NotifyValidationStateChanged();
            _previousParsingAttemptFailed = _parsingFailed;
        }
    }
    constructor()
    {
        super();
        _validationStateChangedHandler = OnValidateStateChanged;
    }
    /*string*/ FormatValueAsString(/*TValue*/ value)
    {
        return value?.ToString();
    }
    /*string*/ get CssClass()
    {
        /*var*/ let fieldClass = EditContext?.FieldCssClass(FieldIdentifier);
        return AttributeUtilities.CombineClassNames(this, fieldClass) ?? string.Empty;
    }
    /*string*/ get NameAttributeValue()
    {
        let nameAttributeValue = null;
        let $ref1 = { set value(v){ nameAttributeValue = v } };
        if (this.TryGetValue("name", $ref1))
        {
            return Convert.ToString(nameAttributeValue) ?? string.Empty;
        }
        if (_shouldGenerateFieldNames)
        {
            if (_formattedValueExpression && (ValueExpression))
            {
                _formattedValueExpression = FieldPrefix !== null ? FieldPrefix.GetFieldName(ValueExpression) : ExpressionFormatter.FormatLambda(ValueExpression);
            }
            return _formattedValueExpression ?? string.Empty;
        }
        return string.Empty;
    }
    /*void*/ OnParametersSet()
    {
        super.OnParametersSet();
        if (_hasInitializedParameters)
        {
            if (ValueExpression === null)
            {
                throw new InvalidOperationException(`${GetType()} requires a value for the 'ValueExpression' ` + `parameter. Normally this is provided automatically when using 'bind-Value'.`);
            }
            FieldIdentifier = FieldIdentifier.Create(ValueExpression);
            if (CascadedEditContext !== null)
            {
                EditContext = CascadedEditContext;
                EditContext.OnValidationStateChanged  += _validationStateChangedHandler;
                _shouldGenerateFieldNames = EditContext.ShouldUseFieldIdentifiers;
            }
            else 
            {
                _shouldGenerateFieldNames = false;
            }
            _nullableUnderlyingType = Nullable.GetUnderlyingType(TValue);
            _hasInitializedParameters = true;
        }
        else if (CascadedEditContext !== EditContext)
        {
            throw new InvalidOperationException(`${GetType()} does not support changing the ` + `${nameof(Forms.EditContext)} dynamically.`);
        }
        UpdateAdditionalValidationAttributes();
    }
    /*void*/ OnValidateStateChanged(/*object*/ sender, /*ValidationStateChangedEventArgs*/ eventArgs)
    {
        UpdateAdditionalValidationAttributes();
        StateHasChanged();
    }
    /*void*/ UpdateAdditionalValidationAttributes()
    {
        if (EditContext)
        {
            return ;
        }
        /*var*/ let hasAriaInvalidAttribute = this.ContainsKey("aria-invalid");
        if (EditContext.GetValidationMessages(FieldIdentifier).Any())
        {
            /*// If this input is associated with an incoming value from an HTTP form post (via model binding),
                // retain the attempted value even if it's unparseable
                var*/ let attemptedValue = EditContext.GetAttemptedValue(NameAttributeValue);
            if (attemptedValue !== null)
            {
                _parsingFailed = true;
                _incomingValueBeforeParsing = attemptedValue;
            }
            if (hasAriaInvalidAttribute)
            {
                return ;
            }
            this["aria-invalid"] = "true";
        }
        else if (hasAriaInvalidAttribute)
        {
        }
    }
    /*bool*/ static ConvertToDictionary(/*IReadOnlyDictionary<string, object>*/ source, /*out Dictionary<string, object>*/ result)
    {
        /*var*/ let newDictionaryCreated = true;
        if (source === null)
        {
            result = new Dictionary(string, object)();
        }
        else if (source instanceof Dictionary(string, object), currentDictionary = source)
        {
            result = currentDictionary;
            newDictionaryCreated = false;
        }
        else 
        {
            result = new Dictionary(string, object)();
            BlazorJs.forEach(source, function(item, $_i)
            {
                result.Add(item.Key, item.Value);
            });
        }
        return newDictionaryCreated;
    }
    /*void*/ Dispose(/*bool*/ disposing)
    {
    }
    /*void*/ Dispose()
    {
        super.Dispose();
        if ((EditContext))
        {
            EditContext.OnValidationStateChanged  -= _validationStateChangedHandler;
        }
        if (_parsingValidationMessages !== null)
        {
            _parsingValidationMessages.Clear();
            EditContext.NotifyValidationStateChanged();
        }
        Dispose({ disposing : true });
    }
    /*void*/ CascadeParameters()
    {
        RequestCascadingParameter(Microsoft_AspNetCore_Components_Forms_EditContext)(Microsoft.AspNetCore.Components.Forms.EditContext, function(/**/ e)
        {
            return CascadedEditContext = e;
        }, { cascadingParameterName : null });
        RequestCascadingParameter(Microsoft_AspNetCore_Components_Forms_HtmlFieldPrefix)(Microsoft.AspNetCore.Components.Forms.HtmlFieldPrefix, function(/**/ e)
        {
            return FieldPrefix = e;
        }, { cascadingParameterName : null });
        super.CascadeParameters();
    }
}

class Microsoft_AspNetCore_Components_Forms_InputCheckbox extends Microsoft_AspNetCore_Components_Forms_InputBase(bool)(bool)
{
    constructor()
    {
        super();
    }
    /*ElementReference*/ _backingField_Element = null;
    /*ElementReference*/ get Element()
    {
        return _backingField_Element;
    }
    /*ElementReference*/ set Element(value)
    {
        _backingField_Element = value;
    }
    /*bool*/ TryParseValueFromString(/*string*/ value, /*out bool*/ result, /*out string*/ validationErrorMessage)
    {
        throw new NotSupportedException(`This component does not parse string inputs. Bind to the '${nameof(CurrentValue)}' property, not '${nameof(CurrentValueAsString)}'.`);
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ __frame0, { /*object*/ __key = null})
    {
        Element = __frame0.Element("input", function(/*UIElementAttribute*/ __attribute)
        {
            __attribute.Set("type", "checkbox");
            __attribute.Set("@attributes", this.As(IDictionary(string, object)));
            __attribute.Set("name", NameAttributeValue);
            __attribute.Set("class", CssClass);
            __attribute.Set("checked", BindConverter.FormatValue(CurrentValue));
            __attribute.Set("value", bool.TrueString);
            /*var*/ let bindGetValue1 = CurrentValue;
            __attribute.Set("value", bindGetValue1);
            __attribute.Set("@onchange", EventCallback.Factory.CreateBinder(this, function(/**/ __value)
            {
                return CurrentValue = __value;
            }, bindGetValue1));
        }, null, { sequenceNumber : 2095240427 });
    }
}

const Microsoft_AspNetCore_Components_Forms_InputDate = (TValue) => class extends Microsoft_AspNetCore_Components_Forms_InputBase(TValue)(TValue)
{
    /*string*/ DateFormat = "yyyy-MM-dd";
    /*string*/ DateTimeLocalFormat = "yyyy-MM-ddTHH:mm:ss";
    /*string*/ MonthFormat = "yyyy-MM";
    /*string*/ TimeFormat = "HH:mm:ss";
    /*string*/ _typeAttributeValue = null;
    /*string*/ _format = null;
    /*string*/ _parsingErrorMessage = null;
    /*InputDateType*/ _backingField_Type = null;
    /*InputDateType*/ get Type()
    {
        return _backingField_Type;
    }
    /*InputDateType*/ set Type(value)
    {
        _backingField_Type = value;
    }
    /*string*/ _backingField_ParsingErrorMessage = null;
    /*string*/ get ParsingErrorMessage()
    {
        return _backingField_ParsingErrorMessage;
    }
    /*string*/ set ParsingErrorMessage(value)
    {
        _backingField_ParsingErrorMessage = value;
    }
    /*ElementReference*/ _backingField_Element = null;
    /*ElementReference*/ get Element()
    {
        return _backingField_Element;
    }
    /*ElementReference*/ set Element(value)
    {
        _backingField_Element = value;
    }
    constructor()
    {
        super();
        /*var*/ let type = Nullable.GetUnderlyingType(TValue) ?? TValue;
        if (type !== DateTime && type !== DateTimeOffset)
        {
            throw new InvalidOperationException(`Unsupported ${this.GetType()} type param '${type}'.`);
        }
    }
    /*void*/ OnParametersSet()
    {
        /*string*/ let formatDescription = null;
        switch(Type)
        {
            case InputDateType.Date:
            {
                _typeAttributeValue = "date";
                _format = DateFormat;
                formatDescription = "date";
                break;
            }
            case InputDateType.DateTimeLocal:
            {
                _typeAttributeValue = "datetime-local";
                _format = DateTimeLocalFormat;
                formatDescription = "date and time";
                break;
            }
            case InputDateType.Month:
            {
                _typeAttributeValue = "month";
                _format = MonthFormat;
                formatDescription = "year and month";
                break;
            }
            case InputDateType.Time:
            {
                _typeAttributeValue = "time";
                _format = TimeFormat;
                formatDescription = "time";
                break;
            }
            default:
            {
                throw new InvalidOperationException(`Unsupported ${nameof(InputDateType)} '${Type}'.`);
            }
        }
        _parsingErrorMessage = string.IsNullOrEmpty(ParsingErrorMessage) ? `The {{0}} field must be a ${formatDescription}.` : ParsingErrorMessage;
    }
    /*string*/ FormatValueAsString(/*TValue*/ value)
    {
        switch(value?.GetType())
        {
            case dateTimeValue = DateTime:
            {
                return BindConverter.FormatValue(dateTimeValue, _format, CultureInfo.InvariantCulture);
            }
            case dateTimeOffsetValue = DateTimeOffset:
            {
                return BindConverter.FormatValue(dateTimeOffsetValue, _format, CultureInfo.InvariantCulture);
            }
        }
        return string.Empty;
    }
    /*bool*/ TryParseValueFromString(/*string*/ value, /*out TValue*/ result, /*out string*/ validationErrorMessage)
    {
        let $ref0 = { set value(v){ result = v } };
        if (BindConverter.TryConvertTo(value, CultureInfo.InvariantCulture, $ref0))
        {
            Debug.Assert(result !== null);
            validationErrorMessage = null;
            return true;
        }
        else 
        {
            validationErrorMessage = string.Format(CultureInfo.InvariantCulture, _parsingErrorMessage, DisplayName ?? FieldIdentifier.FieldName);
            return false;
        }
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ __frame0, { /*object*/ __key = null})
    {
        Element = __frame0.Element("input", function(/*UIElementAttribute*/ __attribute)
        {
            __attribute.Set("type", _typeAttributeValue);
            __attribute.Set("@attributes", this.As(IDictionary(string, object)));
            __attribute.Set("name", NameAttributeValue);
            __attribute.Set("class", CssClass);
            /*var*/ let bindGetValue1 = CurrentValueAsString;
            __attribute.Set("value", bindGetValue1);
            __attribute.Set("@onchange", EventCallback.Factory.CreateBinder(this, function(/**/ __value)
            {
                return CurrentValueAsString = __value;
            }, bindGetValue1));
        }, null, { sequenceNumber : 2045579596 });
    }
}

static class Microsoft_AspNetCore_Components_Forms_InputDateType
{
    Date = 0;
    DateTimeLocal = 1;
    Month = 2;
    Time = 3;
}

static class Microsoft_AspNetCore_Components_Forms_InputExtensions
{
    /*bool*/ static TryParseSelectableValueFromString(TValue, /*this InputBase<TValue>*/ input, /*string*/ value, /*out TValue*/ result, /*out string*/ validationErrorMessage)
    {
        try
        {
            let parsedValue = null;
            let $ref1 = { set value(v){ parsedValue = v } };
            if (TValue === bool)
            {
                let $ref0 = { set value(v){ result = v } };
                if (TryConvertToBool(value, $ref0))
                {
                    validationErrorMessage = null;
                    return true;
                }
            }
            else if (TValue === bool)
            {
                let $ref0 = { set value(v){ result = v } };
                if (TryConvertToNullableBool(value, $ref0))
                {
                    validationErrorMessage = null;
                    return true;
                }
            }
            else if (BindConverter.TryConvertTo(TValue, value, CultureInfo.CurrentCulture, $ref1))
            {
                result = parsedValue;
                validationErrorMessage = null;
                return true;
            }
            result = BlazorJs.getDefault();
            validationErrorMessage = `The ${input.DisplayName  ?? input.FieldIdentifier.FieldName} field is not valid.`;
            return false;
        }
        catch(ex)
        {
            throw new InvalidOperationException(`${input.GetType()} does not support the type '${TValue}'.`, ex);
        }
    }
    /*bool*/ static TryConvertToBool(TValue, /*string*/ value, /*out TValue*/ result)
    {
        let mbool = null;
        let $ref1 = { set value(v){ mbool = v } };
        if (bool.TryParse(value, $ref1))
        {
            result = BlazorJs.Cast(BlazorJs.Cast(mbool, object), TValue);
            return true;
        }
        result = BlazorJs.getDefault();
        return false;
    }
    /*bool*/ static TryConvertToNullableBool(TValue, /*string*/ value, /*out TValue*/ result)
    {
        let $ref0 = { set value(v){ result = v } };
        if (string.IsNullOrEmpty(value))
        {
            result = BlazorJs.getDefault();
            return true;
        }
        return TryConvertToBool(value, $ref0);
    }
}

class Microsoft_AspNetCore_Components_Forms_InputFile extends Microsoft_AspNetCore_Components_Forms_IInputFileJsCallbacks(Microsoft_AspNetCore_Components_ComponentBase)
{
    constructor()
    {
        super();
    }
    /*ElementReference*/ _inputFileElement = null;
    /*EventCallback<InputFileChangeEventArgs>*/ _backingField_OnChange = null;
    /*EventCallback<InputFileChangeEventArgs>*/ get OnChange()
    {
        return _backingField_OnChange;
    }
    /*EventCallback<InputFileChangeEventArgs>*/ set OnChange(value)
    {
        _backingField_OnChange = value;
    }
    /*ElementReference*/ get Element()
    {
        return _inputFileElement;
    }
    /*ElementReference*/ set Element(value)
    {
        _inputFileElement = value;
    }
    /*void*/ OnAfterRender(/*bool*/ firstRender)
    {
        if (firstRender)
        {
            InputFileInterop.Init(this, _inputFileElement.Element.As(HTMLInputElement));
        }
        super.OnAfterRender(firstRender);
    }
    /*Stream*/ OpenReadStream(/*BrowserFile*/ file, /*long*/ maxAllowedSize, /*CancellationToken*/ cancellationToken)
    {
        return new BrowserFileStream(_inputFileElement.Element.As(HTMLInputElement), file, maxAllowedSize, cancellationToken);
    }
    /*Task<IBrowserFile>*/ async ConvertToImageFileAsync(/*BrowserFile*/ file, /*string*/ format, /*int*/ maxWidth, /*int*/ maxHeight)
    {
        /*var*/ let imageFile = await InputFileInterop.ToImageFile(_inputFileElement.Element.As(HTMLInputElement), file.Id, format, maxWidth, maxHeight);
        if (imageFile)
        {
            throw new InvalidOperationException("ToImageFile returned an unexpected null result.");
        }
        imageFile.Owner  = this;
        return imageFile;
    }
    /*Task*/ NotifyChange(/*BrowserFile[]*/ files)
    {
        BlazorJs.forEach(files, function(file, $_i)
        {
            file.Owner  = this;
        });
        return OnChange.InvokeAsync(new InputFileChangeEventArgs(files));
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ __frame0, { /*object*/ __key = null})
    {
        Element = __frame0.Element("input", function(/*UIElementAttribute*/ __attribute)
        {
            __attribute.Set("type", "file");
            __attribute.Set("@attributes", (this.As(IReadOnlyDictionary(string, object))));
        }, null, { sequenceNumber : 767529758 });
    }
}

const Microsoft_AspNetCore_Components_Forms_InputNumber = (TValue) => class extends Microsoft_AspNetCore_Components_Forms_InputBase(TValue)(TValue)
{
    constructor()
    {
        super();
    }
    /*string*/ static _stepAttributeValue = GetStepAttributeValue();
    /*string*/ static GetStepAttributeValue()
    {
        /*// Unwrap Nullable<T>, because InputBase already deals with the Nullable aspect
            // of it for us. We will only get asked to parse the T for nonempty inputs.
            var*/ let targetType = Nullable.GetUnderlyingType(TValue) ?? TValue;
        if (targetType === int || targetType === long || targetType === short || targetType === float || targetType === double || targetType === decimal)
        {
            return "any";
        }
        else 
        {
            throw new InvalidOperationException(`The type '${targetType}' is not a supported numeric type.`);
        }
    }
    /*string*/ _backingField_ParsingErrorMessage = null;
    /*string*/ get ParsingErrorMessage()
    {
        return _backingField_ParsingErrorMessage;
    }
    /*string*/ set ParsingErrorMessage(value)
    {
        _backingField_ParsingErrorMessage = value;
    }
    /*ElementReference*/ _backingField_Element = null;
    /*ElementReference*/ get Element()
    {
        return _backingField_Element;
    }
    /*ElementReference*/ set Element(value)
    {
        _backingField_Element = value;
    }
    /*bool*/ TryParseValueFromString(/*string*/ value, /*out TValue*/ result, /*out string*/ validationErrorMessage)
    {
        let $ref0 = { set value(v){ result = v } };
        if (BindConverter.TryConvertTo(TValue, value, CultureInfo.InvariantCulture, $ref0))
        {
            validationErrorMessage = null;
            return true;
        }
        else 
        {
            validationErrorMessage = string.Format(CultureInfo.InvariantCulture, ParsingErrorMessage, DisplayName ?? FieldIdentifier.FieldName);
            return false;
        }
    }
    /*string*/ FormatValueAsString(/*TValue*/ value)
    {
        switch(value?.GetType())
        {
            case mint = int:
            {
                return BindConverter.FormatValue(mint, CultureInfo.InvariantCulture);
            }
            case mlong = long:
            {
                return BindConverter.FormatValue(mlong, CultureInfo.InvariantCulture);
            }
            case mshort = short:
            {
                return BindConverter.FormatValue(mshort, CultureInfo.InvariantCulture);
            }
            case mfloat = float:
            {
                return BindConverter.FormatValue(mfloat, CultureInfo.InvariantCulture);
            }
            case mdouble = double:
            {
                return BindConverter.FormatValue(mdouble, CultureInfo.InvariantCulture);
            }
            case mdecimal = decimal:
            {
                return BindConverter.FormatValue(mdecimal, CultureInfo.InvariantCulture);
            }
            default:
            {
                if (value === null)
                return null;
                throw new InvalidOperationException(`Unsupported type ${value.GetType()}`);
            }
        }
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ __frame0, { /*object*/ __key = null})
    {
        Element = __frame0.Element("input", function(/*UIElementAttribute*/ __attribute)
        {
            __attribute.Set("type", "number");
            __attribute.Set("step", _stepAttributeValue);
            __attribute.Set("@attributes", (this.As(IReadOnlyDictionary(string, object))));
            __attribute.Set("name", NameAttributeValue);
            __attribute.Set("class", CssClass);
            /*var*/ let bindGetValue1 = CurrentValueAsString;
            __attribute.Set("value", bindGetValue1);
            __attribute.Set("@onchange", EventCallback.Factory.CreateBinder(this, function(/**/ __value)
            {
                return CurrentValueAsString = __value;
            }, bindGetValue1));
        }, null, { sequenceNumber : 1008087671 });
    }
}

const Microsoft_AspNetCore_Components_Forms_InputRadio = (TValue) => class extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
    }
    /*bool*/ _trueValueToggle = null;
    /*InputRadioContext*/ _backingField_Context = null;
    /*InputRadioContext*/ get Context()
    {
        return _backingField_Context;
    }
    /*InputRadioContext*/ set Context(value)
    {
        _backingField_Context = value;
    }
    /*TValue*/ _backingField_Value = null;
    /*TValue*/ get Value()
    {
        return _backingField_Value;
    }
    /*TValue*/ set Value(value)
    {
        _backingField_Value = value;
    }
    /*string*/ _backingField_Name = null;
    /*string*/ get Name()
    {
        return _backingField_Name;
    }
    /*string*/ set Name(value)
    {
        _backingField_Name = value;
    }
    /*ElementReference*/ _backingField_Element = null;
    /*ElementReference*/ get Element()
    {
        return _backingField_Element;
    }
    /*ElementReference*/ set Element(value)
    {
        _backingField_Element = value;
    }
    /*InputRadioContext*/ _backingField_CascadedContext = null;
    /*InputRadioContext*/ get CascadedContext()
    {
        return _backingField_CascadedContext;
    }
    /*InputRadioContext*/ set CascadedContext(value)
    {
        _backingField_CascadedContext = value;
    }
    /*void*/ OnParametersSet()
    {
        Context = string.IsNullOrEmpty(Name) ? CascadedContext : CascadedContext?.FindContextInAncestors(Name);
        if (Context === null)
        {
            throw new InvalidOperationException(`${this.GetType()} must have an ancestor ${InputRadioGroup(TValue)} ` + `with a matching 'Name' property, if specified.`);
        }
    }
    /*string*/ GetToggledTrueValue()
    {
        _trueValueToggle = _trueValueToggle;
        return _trueValueToggle ? "a" : "b";
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ __frame0, { /*object*/ __key = null})
    {
        Debug.Assert(Context !== null);
        Element = __frame0.Element("input", function(/*UIElementAttribute*/ __attribute)
        {
            __attribute.Set("type", "ratio");
            __attribute.Set("@attributes", (this.As(IReadOnlyDictionary(string, object))));
            __attribute.Set("checked", (Context.CurrentValue?.Equals(Value) === true ? GetToggledTrueValue() : null));
            __attribute.Set("class", AttributeUtilities.CombineClassNames(this, Context.FieldClass));
            __attribute.Set("value", BindConverter.FormatValue(Value?.ToString()));
            __attribute.Set("@onchange", EventCallback.Factory.Create(this, Context.ChangeEventCallback));
        }, null, { sequenceNumber : 38014783 });
    }
}

class Microsoft_AspNetCore_Components_Forms_InputRadioContext extends object
{
    /*IInputRadioValueProvider*/ _valueProvider = null;
    /*InputRadioContext*/ _backingField_ParentContext = null;
    /*InputRadioContext*/ get ParentContext()
    {
        return _backingField_ParentContext;
    }
    /*EventCallback<ChangeEventArgs>*/ _backingField_ChangeEventCallback = null;
    /*EventCallback<ChangeEventArgs>*/ get ChangeEventCallback()
    {
        return _backingField_ChangeEventCallback;
    }
    /*object*/ get CurrentValue()
    {
        return _valueProvider.CurrentValue;
    }
    /*string*/ _backingField_GroupName = null;
    /*string*/ get GroupName()
    {
        return _backingField_GroupName;
    }
    /*string*/ set GroupName(value)
    {
        _backingField_GroupName = value;
    }
    /*string*/ _backingField_FieldClass = null;
    /*string*/ get FieldClass()
    {
        return _backingField_FieldClass;
    }
    /*string*/ set FieldClass(value)
    {
        _backingField_FieldClass = value;
    }
    constructor(/*IInputRadioValueProvider*/ valueProvider, /*InputRadioContext*/ parentContext, /*EventCallback<ChangeEventArgs>*/ changeEventCallback)
    {
        super();
        _valueProvider = valueProvider;
        ParentContext = parentContext;
        ChangeEventCallback = changeEventCallback;
    }
    /*InputRadioContext*/ FindContextInAncestors(/*string*/ groupName)
    {
        return string.Equals(GroupName, groupName) ? this : ParentContext?.FindContextInAncestors(groupName);
    }
}

const Microsoft_AspNetCore_Components_Forms_InputRadioGroup = (TValue) => class extends Microsoft_AspNetCore_Components_IInputRadioValueProvider(Microsoft_AspNetCore_Components_Forms_InputBase(TValue))
{
    constructor()
    {
        super();
    }
    /*string*/ _defaultGroupName = Guid.NewGuid().ToString("N");
    /*InputRadioContext*/ _context = null;
    /*RenderFragment*/ _backingField_ChildContent = null;
    /*RenderFragment*/ get ChildContent()
    {
        return _backingField_ChildContent;
    }
    /*RenderFragment*/ set ChildContent(value)
    {
        _backingField_ChildContent = value;
    }
    /*string*/ _backingField_Name = null;
    /*string*/ get Name()
    {
        return _backingField_Name;
    }
    /*string*/ set Name(value)
    {
        _backingField_Name = value;
    }
    /*InputRadioContext*/ _backingField_CascadedContext = null;
    /*InputRadioContext*/ get CascadedContext()
    {
        return _backingField_CascadedContext;
    }
    /*InputRadioContext*/ set CascadedContext(value)
    {
        _backingField_CascadedContext = value;
    }
    /*object*/ get CurrentValue()
    {
        return CurrentValue;
    }
    /*void*/ OnParametersSet()
    {
        if (_context)
        {
            /*var*/ let changeEventCallback = EventCallback.Factory.CreateBinder(string, this, function(/**/ __value)
            {
                return CurrentValueAsString = __value;
            }, CurrentValueAsString);
            _context = new InputRadioContext(this, CascadedContext, changeEventCallback);
        }
        else if (_context.ParentContext  !== CascadedContext)
        {
            throw new InvalidOperationException("An InputRadioGroup cannot change context after creation");
        }
        if (string.IsNullOrEmpty(Name))
        {
            _context.GroupName  = Name;
        }
        else if (string.IsNullOrEmpty(NameAttributeValue))
        {
            _context.GroupName  = NameAttributeValue;
        }
        else 
        {
            _context.GroupName  = _defaultGroupName;
        }
        _context.FieldClass  = EditContext?.FieldCssClass(FieldIdentifier);
    }
    /*bool*/ TryParseValueFromString(/*string*/ value, /*out TValue*/ result, /*out string*/ validationErrorMessage)
    {
        let $ref0 = { set value(v){ result = v } };
        let $ref1 = { set value(v){ validationErrorMessage = v } };
        return this.TryParseSelectableValueFromString(value, $ref0, $ref1);
    }
    /*void*/ CascadeParameters()
    {
        RequestCascadingParameter(Microsoft_AspNetCore_Components_Forms_InputRadioContext)(Microsoft.AspNetCore.Components.Forms.InputRadioContext, function(/**/ e)
        {
            return CascadedContext = e;
        }, { cascadingParameterName : null });
        super.CascadeParameters();
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ __frame0, { /*object*/ __key = null})
    {
        Debug.Assert(_context !== null);
        __frame0.Component(CascadingValue(InputRadioContext), function(/**/ __component0)
        {
            __component0.Value  = _context;
            __component0.ChildContent  = function(/**/ __frame1, /**/ __key1)
            {
                __frame1.Content(ChildContent, { key : __key1, sequenceNumber : 334392485 });
            };
        }, { sequenceNumber : 334392486 });
    }
}

const Microsoft_AspNetCore_Components_Forms_InputSelect = (TValue) => class extends Microsoft_AspNetCore_Components_Forms_InputBase(TValue)(TValue)
{
    /*bool*/ _isMultipleSelect = null;
    constructor()
    {
        super();
        _isMultipleSelect = TValue.IsArray;
    }
    /*RenderFragment*/ _backingField_ChildContent = null;
    /*RenderFragment*/ get ChildContent()
    {
        return _backingField_ChildContent;
    }
    /*RenderFragment*/ set ChildContent(value)
    {
        _backingField_ChildContent = value;
    }
    /*ElementReference*/ _backingField_Element = null;
    /*ElementReference*/ get Element()
    {
        return _backingField_Element;
    }
    /*ElementReference*/ set Element(value)
    {
        _backingField_Element = value;
    }
    /*bool*/ TryParseValueFromString(/*string*/ value, /*out TValue*/ result, /*out string*/ validationErrorMessage)
    {
        let $ref0 = { set value(v){ result = v } };
        let $ref1 = { set value(v){ validationErrorMessage = v } };
        return this.TryParseSelectableValueFromString(value, $ref0, $ref1);
    }
    /*string*/ FormatValueAsString(/*TValue*/ value)
    {
        if (TValue === bool)
        {
            return BlazorJs.Cast(BlazorJs.Cast(value, object), bool) ? "true" : "false";
        }
        else if (TValue === bool)
        {
            return (value === null) && BlazorJs.Cast(BlazorJs.Cast(value, object), bool) ? "true" : "false";
        }
        return super.FormatValueAsString(value);
    }
    /*void*/ SetCurrentValueAsStringArray(/*string[]*/ value)
    {
        let result = null;
        let $ref1 = { set value(v){ result = v } };
        CurrentValue = BindConverter.TryConvertTo(TValue, value, CultureInfo.CurrentCulture, $ref1) ? result : BlazorJs.getDefault();
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ __frame0, { /*object*/ __key = null})
    {
        if (_isMultipleSelect)
        {
            Element = __frame0.Element("select", function(/*UIElementAttribute*/ __attribute)
            {
                __attribute.Set("@attributes", (this.As(IReadOnlyDictionary(string, object))));
                __attribute.Set("name", NameAttributeValue);
                __attribute.Set("class", CssClass);
                __attribute.Set("multiple", _isMultipleSelect);
                __attribute.Set("value", $BindConverter.FormatValue(CurrentValue)?.ToString());
                __attribute.Set("@onchange", EventCallback.Factory.CreateBinder(this, BlazorJs.Cast(SetCurrentValueAsStringArray, Action(string)), BlazorJs.getDefault()));
            }, null, { sequenceNumber : 663613510 });
        }
        else 
        {
            Element = __frame0.Element("select", function(/*UIElementAttribute*/ __attribute)
            {
                __attribute.Set("@attributes", (this.As(IReadOnlyDictionary(string, object))));
                __attribute.Set("name", NameAttributeValue);
                __attribute.Set("class", CssClass);
                __attribute.Set("multiple", _isMultipleSelect);
                /*var*/ let bindGetValue1 = $CurrentValueAsString;
                __attribute.Set("value", bindGetValue1);
                __attribute.Set("@onchange", EventCallback.Factory.CreateBinder(this, function(/**/ __value)
                {
                    return $CurrentValueAsString = __value;
                }, bindGetValue1));
            }, null, { sequenceNumber : 663613511 });
        }
    }
}

class Microsoft_AspNetCore_Components_Forms_InputText extends Microsoft_AspNetCore_Components_Forms_InputBase(string)(string)
{
    constructor()
    {
        super();
    }
    /*ElementReference*/ _backingField_Element = null;
    /*ElementReference*/ get Element()
    {
        return _backingField_Element;
    }
    /*ElementReference*/ set Element(value)
    {
        _backingField_Element = value;
    }
    /*bool*/ TryParseValueFromString(/*string*/ value, /*out string*/ result, /*out string*/ validationErrorMessage)
    {
        result = value;
        validationErrorMessage = null;
        return true;
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ __frame0, { /*object*/ __key = null})
    {
        Element = __frame0.Element("input", function(/*UIElementAttribute*/ __attribute)
        {
            __attribute.Set("@attributes", (this.As(IReadOnlyDictionary(string, object))));
            __attribute.Set("name", NameAttributeValue);
            __attribute.Set("class", CssClass);
            /*var*/ let bindGetValue1 = $CurrentValueAsString;
            __attribute.Set("value", bindGetValue1);
            __attribute.Set("@onchange", EventCallback.Factory.CreateBinder(this, function(/**/ __value)
            {
                return $CurrentValueAsString = __value;
            }, bindGetValue1));
        }, null, { sequenceNumber : 2073832348 });
    }
}

class Microsoft_AspNetCore_Components_Forms_InputTextArea extends Microsoft_AspNetCore_Components_Forms_InputBase(string)(string)
{
    constructor()
    {
        super();
    }
    /*ElementReference*/ _backingField_Element = null;
    /*ElementReference*/ get Element()
    {
        return _backingField_Element;
    }
    /*ElementReference*/ set Element(value)
    {
        _backingField_Element = value;
    }
    /*bool*/ TryParseValueFromString(/*string*/ value, /*out string*/ result, /*out string*/ validationErrorMessage)
    {
        result = value;
        validationErrorMessage = null;
        return true;
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ __frame0, { /*object*/ __key = null})
    {
        Element = __frame0.Element("textarea", function(/*UIElementAttribute*/ __attribute)
        {
            __attribute.Set("@attributes", (this.As(IReadOnlyDictionary(string, object))));
            __attribute.Set("name", NameAttributeValue);
            __attribute.Set("class", CssClass);
            /*var*/ let bindGetValue1 = $CurrentValueAsString;
            __attribute.Set("value", bindGetValue1);
            __attribute.Set("@onchange", EventCallback.Factory.CreateBinder(this, function(/**/ __value)
            {
                return $CurrentValueAsString = __value;
            }, bindGetValue1));
        }, null, { sequenceNumber : 1039164928 });
    }
}

static class Microsoft_AspNetCore_Components_Rendering_RenderTreeBuilderExtensions
{
    /*void*/ static AddAttributeIfNotNullOrEmpty(/*this RenderTreeBuilder*/ builder, /*int*/ sequence, /*string*/ name, /*string*/ value)
    {
        if (string.IsNullOrEmpty(value))
        {
            builder.AddAttribute(sequence, name, value);
        }
    }
}

const Microsoft_AspNetCore_Components_Forms_ValidationMessage = (TValue) => class extends Microsoft_AspNetCore_Components_ComponentBase
{
    /*EditContext*/ _previousEditContext = null;
    /*Expression<Func<TValue>>*/ _previousFieldAccessor = null;
    /*EventHandler<ValidationStateChangedEventArgs>*/ _validationStateChangedHandler = null;
    /*FieldIdentifier*/ _fieldIdentifier = null;
    /*EditContext*/ _backingField_CurrentEditContext = null;
    /*EditContext*/ get CurrentEditContext()
    {
        return _backingField_CurrentEditContext;
    }
    /*EditContext*/ set CurrentEditContext(value)
    {
        _backingField_CurrentEditContext = value;
    }
    /*Expression<Func<TValue>>*/ _backingField_For = null;
    /*Expression<Func<TValue>>*/ get For()
    {
        return _backingField_For;
    }
    /*Expression<Func<TValue>>*/ set For(value)
    {
        _backingField_For = value;
    }
    constructor()
    {
        super();
        _validationStateChangedHandler = function(/**/ sender, /**/ eventArgs)
        {
            return StateHasChanged();
        };
    }
    /*void*/ OnParametersSet()
    {
        if (CurrentEditContext === null)
        {
            throw new InvalidOperationException(`${GetType()} requires a cascading parameter ` + `of type ${nameof(EditContext)}. For example, you can use ${GetType()} inside ` + `an ${nameof(EditForm)}.`);
        }
        if (For === null)
        {
            throw new InvalidOperationException(`${GetType()} requires a value for the ` + `${nameof(For)} parameter.`);
        }
        else if (For !== _previousFieldAccessor)
        {
            _fieldIdentifier = FieldIdentifier.Create(For);
            _previousFieldAccessor = For;
        }
        if (CurrentEditContext !== _previousEditContext)
        {
            DetachValidationStateChangedListener();
            CurrentEditContext.OnValidationStateChanged  += _validationStateChangedHandler;
            _previousEditContext = CurrentEditContext;
        }
    }
    /*void*/ Dispose(/*bool*/ disposing)
    {
    }
    /*void*/ Dispose()
    {
        super.Dispose();
        DetachValidationStateChangedListener();
        Dispose({ disposing : true });
    }
    /*void*/ DetachValidationStateChangedListener()
    {
        if (_previousEditContext !== null)
        {
            _previousEditContext.OnValidationStateChanged  -= _validationStateChangedHandler;
        }
    }
    /*void*/ CascadeParameters()
    {
        RequestCascadingParameter(Microsoft_AspNetCore_Components_Forms_EditContext)(Microsoft.AspNetCore.Components.Forms.EditContext, function(/**/ e)
        {
            return CurrentEditContext = e;
        }, { cascadingParameterName : null });
        super.CascadeParameters();
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ __frame0, { /*object*/ __key = null})
    {
        BlazorJs.forEach(CurrentEditContext.GetValidationMessages(_fieldIdentifier), function(message, $_i)
        {
            __frame0.Element("div", function(/*UIElementAttribute*/ __attribute)
            {
                __attribute.Set("class", "validation-message");
                __attribute.Set("@attributes", (this.As(IReadOnlyDictionary(string, object))));
            }, function(/**/ __frame1, /**/ __key1)
            {
                __frame1.Content(message, { key : __key1, sequenceNumber : 1251274529 });
            }, { key : message, sequenceNumber : 1251274528 });
        });
    }
}

class Microsoft_AspNetCore_Components_Forms_ValidationSummary extends Microsoft_AspNetCore_Components_ComponentBase
{
    /*EditContext*/ _previousEditContext = null;
    /*EventHandler<ValidationStateChangedEventArgs>*/ _validationStateChangedHandler = null;
    /*object*/ _backingField_Model = null;
    /*object*/ get Model()
    {
        return _backingField_Model;
    }
    /*object*/ set Model(value)
    {
        _backingField_Model = value;
    }
    /*EditContext*/ _backingField_CurrentEditContext = null;
    /*EditContext*/ get CurrentEditContext()
    {
        return _backingField_CurrentEditContext;
    }
    /*EditContext*/ set CurrentEditContext(value)
    {
        _backingField_CurrentEditContext = value;
    }
    constructor()
    {
        super();
        _validationStateChangedHandler = function(/**/ sender, /**/ eventArgs)
        {
            return StateHasChanged();
        };
    }
    /*void*/ OnParametersSet()
    {
        if (CurrentEditContext === null)
        {
            throw new InvalidOperationException(`${nameof(ValidationSummary)} requires a cascading parameter ` + `of type ${nameof(EditContext)}. For example, you can use ${nameof(ValidationSummary)} inside ` + `an ${nameof(EditForm)}.`);
        }
        if (CurrentEditContext !== _previousEditContext)
        {
            DetachValidationStateChangedListener();
            CurrentEditContext.OnValidationStateChanged  += _validationStateChangedHandler;
            _previousEditContext = CurrentEditContext;
        }
    }
    /*void*/ Dispose(/*bool*/ disposing)
    {
    }
    /*void*/ Dispose()
    {
        super.Dispose();
        DetachValidationStateChangedListener();
        Dispose({ disposing : true });
    }
    /*void*/ DetachValidationStateChangedListener()
    {
        if (_previousEditContext !== null)
        {
            _previousEditContext.OnValidationStateChanged  -= _validationStateChangedHandler;
        }
    }
    /*void*/ CascadeParameters()
    {
        RequestCascadingParameter(Microsoft_AspNetCore_Components_Forms_EditContext)(Microsoft.AspNetCore.Components.Forms.EditContext, function(/**/ e)
        {
            return CurrentEditContext = e;
        }, { cascadingParameterName : null });
        super.CascadeParameters();
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ __frame0, { /*object*/ __key = null})
    {
        /*var*/ let validationMessages = Model ? CurrentEditContext.GetValidationMessages() : CurrentEditContext.GetValidationMessages(new FieldIdentifier(Model, string.Empty));
        if (validationMessages.Any())
        {
            __frame0.Element("ul", function(/*UIElementAttribute*/ __attribute)
            {
                __attribute.Set("class", "validation-errors");
                __attribute.Set("@attributes", (this.As(IReadOnlyDictionary(string, object))));
            }, function(/**/ __frame1, /**/ __key1)
            {
                BlazorJs.forEach(validationMessages, function(error, $_i)
                {
                    __frame1.Element("li", function(/*UIElementAttribute*/ __attribute)
                    {
                        __attribute.Set("class", "validation-message");
                    }, function(/**/ __frame2, /**/ __key2)
                    {
                        __frame2.Content(error, { key : __key2, sequenceNumber : 1161265520 });
                    }, { key : error, sequenceNumber : 1161265521 });
                });
            }, { sequenceNumber : 1161265522 });
        }
    }
}


class Microsoft_AspNetCore_Components_Web_Virtualization_ItemsProviderRequest extends System_ValueType
{
    /*int*/ _backingField_StartIndex = null;
    /*int*/ get StartIndex()
    {
        return _backingField_StartIndex;
    }
    /*int*/ _backingField_Count = null;
    /*int*/ get Count()
    {
        return _backingField_Count;
    }
    /*CancellationToken*/ _backingField_CancellationToken = null;
    /*CancellationToken*/ get CancellationToken()
    {
        return _backingField_CancellationToken;
    }
    constructor(/*int*/ startIndex, /*int*/ count, /*CancellationToken*/ cancellationToken)
    {
        super();
        StartIndex = startIndex;
        Count = count;
        CancellationToken = cancellationToken;
    }
}

const Microsoft_AspNetCore_Components_Web_Virtualization_ItemsProviderResult = (TItem) => class extends System_ValueType
{
    /*IEnumerable<TItem>*/ _backingField_Items = null;
    /*IEnumerable<TItem>*/ get Items()
    {
        return _backingField_Items;
    }
    /*int*/ _backingField_TotalItemCount = null;
    /*int*/ get TotalItemCount()
    {
        return _backingField_TotalItemCount;
    }
    constructor(/*IEnumerable<TItem>*/ items, /*int*/ totalItemCount)
    {
        super();
        Items = items;
        TotalItemCount = totalItemCount;
    }
}

const Microsoft_AspNetCore_Components_Web_Virtualization_IVirtualizeJsCallbacks = (Base) => class extends Base
{
}

class Microsoft_AspNetCore_Components_Web_Virtualization_PlaceholderContext extends System_ValueType
{
    /*int*/ _backingField_Index = null;
    /*int*/ get Index()
    {
        return _backingField_Index;
    }
    /*float*/ _backingField_Size = null;
    /*float*/ get Size()
    {
        return _backingField_Size;
    }
    constructor(/*int*/ index, /*float*/ size)
    {
        super();
        Index = index;
        Size = size;
    }
}

const Microsoft_AspNetCore_Components_Web_Virtualization_Virtualize = (TItem) => class extends Microsoft_AspNetCore_Components_Web_Virtualization_IVirtualizeJsCallbacks(Microsoft_AspNetCore_Components_ComponentBase)
{
    constructor()
    {
        super();
    }
    /*HTMLElement*/ _spacerBefore = null;
    /*HTMLElement*/ _spacerAfter = null;
    /*int*/ _itemsBefore = null;
    /*int*/ _visibleItemCapacity = null;
    /*int*/ _unusedItemCapacity = null;
    /*int*/ _itemCount = null;
    /*int*/ _loadedItemsStartIndex = null;
    /*int*/ _lastRenderedItemCount = null;
    /*int*/ _lastRenderedPlaceholderCount = null;
    /*float*/ _itemSize = null;
    /*IEnumerable<TItem>*/ _loadedItems = null;
    /*CancellationTokenSource*/ _refreshCts = null;
    /*Exception*/ _refreshException = null;
    /*ItemsProviderDelegate<TItem>*/ _itemsProvider = null;
    /*RenderFragment<TItem>*/ _itemTemplate = null;
    /*RenderFragment<PlaceholderContext>*/ _placeholder = null;
    /*RenderFragment*/ _emptyContent = null;
    /*bool*/ _loading = null;
    /*RenderFragment<TItem>*/ _backingField_ChildContent = null;
    /*RenderFragment<TItem>*/ get ChildContent()
    {
        return _backingField_ChildContent;
    }
    /*RenderFragment<TItem>*/ set ChildContent(value)
    {
        _backingField_ChildContent = value;
    }
    /*RenderFragment<TItem>*/ _backingField_ItemContent = null;
    /*RenderFragment<TItem>*/ get ItemContent()
    {
        return _backingField_ItemContent;
    }
    /*RenderFragment<TItem>*/ set ItemContent(value)
    {
        _backingField_ItemContent = value;
    }
    /*RenderFragment<PlaceholderContext>*/ _backingField_Placeholder = null;
    /*RenderFragment<PlaceholderContext>*/ get Placeholder()
    {
        return _backingField_Placeholder;
    }
    /*RenderFragment<PlaceholderContext>*/ set Placeholder(value)
    {
        _backingField_Placeholder = value;
    }
    /*RenderFragment*/ _backingField_EmptyContent = null;
    /*RenderFragment*/ get EmptyContent()
    {
        return _backingField_EmptyContent;
    }
    /*RenderFragment*/ set EmptyContent(value)
    {
        _backingField_EmptyContent = value;
    }
    /*float*/ _backingField_ItemSize = null;
    /*float*/ get ItemSize()
    {
        return _backingField_ItemSize;
    }
    /*float*/ set ItemSize(value)
    {
        _backingField_ItemSize = value;
    }
    /*ItemsProviderDelegate<TItem>*/ _backingField_ItemsProvider = null;
    /*ItemsProviderDelegate<TItem>*/ get ItemsProvider()
    {
        return _backingField_ItemsProvider;
    }
    /*ItemsProviderDelegate<TItem>*/ set ItemsProvider(value)
    {
        _backingField_ItemsProvider = value;
    }
    /*ICollection<TItem>*/ _backingField_Items = null;
    /*ICollection<TItem>*/ get Items()
    {
        return _backingField_Items;
    }
    /*ICollection<TItem>*/ set Items(value)
    {
        _backingField_Items = value;
    }
    /*int*/ _backingField_OverscanCount = null;
    /*int*/ get OverscanCount()
    {
        return _backingField_OverscanCount;
    }
    /*int*/ set OverscanCount(value)
    {
        _backingField_OverscanCount = value;
    }
    /*string*/ _backingField_SpacerElement = null;
    /*string*/ get SpacerElement()
    {
        return _backingField_SpacerElement;
    }
    /*string*/ set SpacerElement(value)
    {
        _backingField_SpacerElement = value;
    }
    /*int*/ _backingField_MaxItemCount = null;
    /*int*/ get MaxItemCount()
    {
        return _backingField_MaxItemCount;
    }
    /*int*/ set MaxItemCount(value)
    {
        _backingField_MaxItemCount = value;
    }
    /*Task*/ async RefreshDataAsync()
    {
        await RefreshDataCoreAsync({ renderOnSuccess : false });
    }
    /*void*/ OnParametersSet()
    {
        if (ItemSize <= 0)
        {
            throw new InvalidOperationException(`${GetType()} requires a positive value for parameter '${nameof(ItemSize)}'.`);
        }
        if (_itemSize <= 0)
        {
            _itemSize = ItemSize;
        }
        if (ItemsProvider !== null)
        {
            if (Items !== null)
            {
                throw new InvalidOperationException(`${GetType()} can only accept one item source from its parameters. ` + `Do not supply both '${nameof(Items)}' and '${nameof(ItemsProvider)}'.`);
            }
            _itemsProvider = ItemsProvider;
        }
        else if (Items !== null)
        {
            _itemsProvider = DefaultItemsProvider;
            /*// When we have a fixed set of in-memory data, it doesn't cost anything to
                // re-query it on each cycle, so do that. This means the developer can add/remove
                // items in the collection and see the UI update without having to call RefreshDataAsync.
                var*/ let refreshTask = RefreshDataCoreAsync({ renderOnSuccess : false });
            Debug.Assert(refreshTask.IsCompleted  && refreshTask.IsFaulted);
        }
        else 
        {
            throw new InvalidOperationException(`${GetType()} requires either the '${nameof(Items)}' or '${nameof(ItemsProvider)}' parameters to be specified ` + `and non-null.`);
        }
        _itemTemplate = ItemContent ?? ChildContent;
        _placeholder = Placeholder ?? DefaultPlaceholder;
        _emptyContent = EmptyContent;
    }
    /*void*/ OnAfterRender(/*bool*/ firstRender)
    {
        if (firstRender)
        {
            VirtualizeJs.InitializeAsync(this, _spacerBefore, _spacerAfter);
        }
        super.OnAfterRender(firstRender);
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ builder, /*object*/ key)
    {
        if (_refreshException !== null)
        {
            /*var*/ let oldRefreshException = _refreshException;
            _refreshException = null;
            throw oldRefreshException;
        }
        _spacerBefore = builder.Element(SpacerElement, function(/*UIElementAttribute*/ attribute)
        {
            attribute.Set("style", GetSpacerStyle(_itemsBefore));
        }, { sequenceNumber : Utility.Virtualize_SpacerElementBefore_SequenceNumber });
        /*var*/ let lastItemIndex = Math.Min(_itemsBefore + _visibleItemCapacity, _itemCount);
        /*var*/ let renderIndex = _itemsBefore;
        /*var*/ let placeholdersBeforeCount = Math.Min(_loadedItemsStartIndex, lastItemIndex);
        for(; renderIndex < placeholdersBeforeCount; renderIndex++)
        {
            builder.Content(_placeholder(new PlaceholderContext(renderIndex, _itemSize)), { sequenceNumber : Utility.Virtualize_PlaceholderBefore_SequenceNumber });
        }
        _lastRenderedItemCount = 0;
        if (_loadedItems !== null && _loading && _itemCount === 0 && _emptyContent !== null)
        {
            builder.Content(_emptyContent, { sequenceNumber : Utility.Virtualize_EmptyContent_SequenceNumber });
        }
        else if (_loadedItems !== null && _itemTemplate !== null)
        {
            /*var*/ let itemsToShow = _loadedItems.Skip(_itemsBefore - _loadedItemsStartIndex).Take(lastItemIndex - _loadedItemsStartIndex);
            BlazorJs.forEach(itemsToShow, function(item, $_i)
            {
                builder.Content(_itemTemplate(item), { key : item, sequenceNumber : Utility.Virtualize_Item_SequenceNumber });
                _lastRenderedItemCount++;
            });
            renderIndex += _lastRenderedItemCount;
        }
        _lastRenderedPlaceholderCount = Math.Max(0, lastItemIndex - _itemsBefore - _lastRenderedItemCount);
        for(; renderIndex < lastItemIndex; renderIndex++)
        {
            builder.Content(_placeholder(new PlaceholderContext(renderIndex, _itemSize)), { sequenceNumber : Utility.Virtualize_PlaceholderAfter_SequenceNumber });
        }
        /*var*/ let itemsAfter = Math.Max(0, _itemCount - _visibleItemCapacity - _itemsBefore);
        _spacerAfter = builder.Element(SpacerElement, function(/*UIElementAttribute*/ attribute)
        {
            attribute.Set("style", GetSpacerStyle(itemsAfter, _unusedItemCapacity));
        }, { sequenceNumber : Utility.Virtualize_SpacerElementAfter_SequenceNumber });
    }
    /*string*/ GetSpacerStyle(/*int*/ itemsInSpacer, /*int*/ numItemsGapAbove)
    {
        return numItemsGapAbove === 0 ? GetSpacerStyle(itemsInSpacer) : `height: ${(itemsInSpacer * _itemSize).ToString(CultureInfo.InvariantCulture)}px; flex-shrink: 0; transform: translateY(${(numItemsGapAbove * _itemSize).ToString(CultureInfo.InvariantCulture)}px);`;
    }
    /*string*/ GetSpacerStyle(/*int*/ itemsInSpacer)
    {
        return `height: ${(itemsInSpacer * _itemSize).ToString(CultureInfo.InvariantCulture)}px; flex-shrink: 0;`;
    }
    /*void*/ OnBeforeSpacerVisible(/*float*/ spacerSize, /*float*/ spacerSeparation, /*float*/ containerSize)
    {
        let itemsBefore = null;
        let $ref1 = { set value(v){ itemsBefore = v } };
        let visibleItemCapacity = null;
        let $ref3 = { set value(v){ visibleItemCapacity = v } };
        let unusedItemCapacity = null;
        let $ref5 = { set value(v){ unusedItemCapacity = v } };
        CalcualteItemDistribution(spacerSize, spacerSeparation, containerSize, $ref1, $ref3, $ref5);
        if (itemsBefore === _itemsBefore && itemsBefore > 0)
        {
            itemsBefore--;
        }
        UpdateItemDistribution(itemsBefore, visibleItemCapacity, unusedItemCapacity);
    }
    /*void*/ OnAfterSpacerVisible(/*float*/ spacerSize, /*float*/ spacerSeparation, /*float*/ containerSize)
    {
        let itemsAfter = null;
        let $ref1 = { set value(v){ itemsAfter = v } };
        let visibleItemCapacity = null;
        let $ref3 = { set value(v){ visibleItemCapacity = v } };
        let unusedItemCapacity = null;
        let $ref5 = { set value(v){ unusedItemCapacity = v } };
        CalcualteItemDistribution(spacerSize, spacerSeparation, containerSize, $ref1, $ref3, $ref5);
        /*var*/ let itemsBefore = Math.Max(0, _itemCount - itemsAfter - visibleItemCapacity);
        if (itemsBefore === _itemsBefore && itemsBefore < _itemCount - visibleItemCapacity)
        {
            itemsBefore++;
        }
        UpdateItemDistribution(itemsBefore, visibleItemCapacity, unusedItemCapacity);
    }
    /*void*/ CalcualteItemDistribution(/*float*/ spacerSize, /*float*/ spacerSeparation, /*float*/ containerSize, /*out int*/ itemsInSpacer, /*out int*/ visibleItemCapacity, /*out int*/ unusedItemCapacity)
    {
        if (_lastRenderedItemCount > 0)
        {
            _itemSize = (spacerSeparation - (_lastRenderedPlaceholderCount * _itemSize)) / _lastRenderedItemCount;
        }
        if (_itemSize <= 0)
        {
            _itemSize = ItemSize;
        }
        /*// This AppContext data was added as a stopgap for .NET 8 and earlier, since it was added in a patch
            // where we couldn't add new public API. For backcompat we still support the AppContext setting, but
            // new applications should use the much more convenient MaxItemCount parameter.
            var*/ let maxItemCount = MaxItemCount;
        itemsInSpacer = Math.Max(0, BlazorJs.Cast(Math.Floor(spacerSize / _itemSize), int) - OverscanCount);
        visibleItemCapacity = BlazorJs.Cast(Math.Ceiling(containerSize / _itemSize), int) + 2 * OverscanCount;
        unusedItemCapacity = Math.Max(0, visibleItemCapacity - maxItemCount);
        visibleItemCapacity -= unusedItemCapacity;
    }
    /*void*/ UpdateItemDistribution(/*int*/ itemsBefore, /*int*/ visibleItemCapacity, /*int*/ unusedItemCapacity)
    {
        if (itemsBefore + visibleItemCapacity > _itemCount)
        {
            itemsBefore = Math.Max(0, _itemCount - visibleItemCapacity);
        }
        if (itemsBefore !== _itemsBefore || visibleItemCapacity !== _visibleItemCapacity || unusedItemCapacity !== _unusedItemCapacity)
        {
            _itemsBefore = itemsBefore;
            _visibleItemCapacity = visibleItemCapacity;
            _unusedItemCapacity = unusedItemCapacity;
            /*var*/ let refreshTask = RefreshDataCoreAsync({ renderOnSuccess : true });
            if (refreshTask.IsCompleted)
            {
                StateHasChanged();
            }
        }
    }
    /*Task*/ async RefreshDataCoreAsync(/*bool*/ renderOnSuccess)
    {
        _refreshCts?.Cancel();
        /*CancellationToken*/ let cancellationToken;
        if (_itemsProvider === DefaultItemsProvider)
        {
            _refreshCts = null;
            cancellationToken = CancellationToken.None;
        }
        else 
        {
            _refreshCts = new CancellationTokenSource();
            cancellationToken = _refreshCts.Token;
            _loading = true;
        }
        /*var*/ let request = new ItemsProviderRequest(_itemsBefore, _visibleItemCapacity, cancellationToken);
        try
        {
            /*var*/ let result = await _itemsProvider(request);
            if (cancellationToken.IsCancellationRequested)
            {
                _itemCount = result.TotalItemCount;
                _loadedItems = result.Items;
                _loadedItemsStartIndex = request.StartIndex;
                _loading = false;
                if (renderOnSuccess)
                {
                    StateHasChanged();
                }
            }
        }
        catch(e)
        {
            if (e instanceof OperationCanceledException, oce = e && oce.CancellationToken.Equals(cancellationToken))
            {
            }
            else 
            {
                _refreshException = e;
                StateHasChanged();
            }
        }
    }
    /*Task<ItemsProviderResult<TItem>>*/ DefaultItemsProvider(/*ItemsProviderRequest*/ request)
    {
        return Task.FromResult(new ItemsProviderResult(TItem)(Items.Skip(request.StartIndex).Take(request.Count), Items.Count));
    }
    /*RenderFragment*/ DefaultPlaceholder(/*PlaceholderContext*/ context)
    {
        return function(/**/ builder, /**/ key)
        {
            builder.Element("div", function(/*UIElementAttribute*/ attribute)
            {
                attribute.Set("style", `height: ${_itemSize.ToString(CultureInfo.InvariantCulture)}px; flex-shrink: 0;`);
            }, { sequenceNumber : Utility.Virtualize_DefaultPlaceholder_SequenceNumber });
        };
    }
    /*void*/ Dispose()
    {
        _refreshCts?.Cancel();
        super.Dispose();
    }
}


static class Microsoft_AspNetCore_Components_Web_Virtualization_VirtualizeJs
{
    /*HTMLElement*/ static FindClosestScrollContainer(/*HTMLElement*/ element)
    {
        if (element === null || element === document.body  || element === document.documentElement)
        {
            return null;
        }
        /*var*/ let style = getComputedStyle(element);
        if (style.overflowY  !== "visible")
        {
            return element;
        }
        return FindClosestScrollContainer(element.parentElement);
    }
    /*void*/ static InitializeAsync(/*IVirtualizeJsCallbacks*/ virtualize, /*HTMLElement*/ spacerBefore, /*HTMLElement*/ spacerAfter, { /*int*/ rootMargin = 50})
    {
        /*// Overflow anchoring can cause an ongoing scroll loop, because when we resize the spacers, the browser
            // would update the scroll position to compensate. Then the spacer would remain visible and we'd keep on
            // trying to resize it.
            var*/ let scrollContainer = FindClosestScrollContainer(spacerBefore);
        (scrollContainer ?? document.documentElement).style["overflowAnchor"] = "none";
        /*var*/ let rangeBetweenSpacers = document.createRange();
        if (isValidTableElement(spacerAfter.parentElement))
        {
            spacerBefore.style.display  = "table-row";
            spacerAfter.style.display  = "table-row";
        }
        /*var*/ let intersectionObserver = new IntersectionObserver(IntersectionCallback, BlazorJs.PopulateProperty(new IntersectionObserverInit(), function(/*IntersectionObserverInit*/ $obj)
        {
            $obj.root = scrollContainer;
            $obj.rootMargin = `${rootMargin}px`;
        }));
        intersectionObserver.observe(spacerBefore);
        intersectionObserver.observe(spacerAfter);
        /*var*/ let mutationObserverBefore = CreateSpacerMutationObserver(spacerBefore);
        /*var*/ let mutationObserverAfter = CreateSpacerMutationObserver(spacerAfter);
        /*//          const {
            //              observersByDotNetObjectId, id
            //          } = getObserversMapEntry(dotNetHelper);
            //          observersByDotNetObjectId[id] = {
            //              intersectionObserver,
            //  mutationObserverBefore,
            //  mutationObserverAfter,
            //};
            MutationObserver*/ function CreateSpacerMutationObserver(/*HTMLElement*/ spacer)
        {
            /*// Without the use of thresholds, IntersectionObserver only detects binary changes in visibility,
                // so if a spacer gets resized but remains visible, no additional callbacks will occur. By unobserving
                // and reobserving spacers when they get resized, the intersection callback will re-run if they remain visible.
                var*/ let observerOptions = BlazorJs.PopulateProperty(new MutationObserverInit(), function(/*MutationObserverInit*/ $obj)
            {
                $obj.attributes = true;
            });
            /*var*/ let mutationObserver = new MutationObserver(function(/**/ mutations, /**/ observer)
            {
                if (isValidTableElement(spacer.parentElement))
                {
                    observer.disconnect();
                    spacer.style.display  = "table-row";
                    observer.observe(spacer, observerOptions);
                }
                intersectionObserver.unobserve(spacer);
                intersectionObserver.observe(spacer);
            });
            mutationObserver.observe(spacer, observerOptions);
            return mutationObserver;
        }
        /*void*/ function IntersectionCallback(/*IntersectionObserverEntry[]*/ entries, /*IntersectionObserver*/ observer)
        {
            entries.ForEach(function(/**/ entry)
            {
                if (entry.isIntersecting)
                {
                    return ;
                }
                rangeBetweenSpacers.setStartAfter(spacerBefore);
                rangeBetweenSpacers.setEndBefore(spacerAfter);
                /*var*/ let spacerSeparation = rangeBetweenSpacers.getBoundingClientRect().As(ClientRect).height;
                /*var*/ let containerSize = entry.rootBounds.As(ClientRect)?.height;
                if (entry.target  === spacerBefore)
                {
                    virtualize.OnBeforeSpacerVisible(BlazorJs.Cast((entry.intersectionRect.As(ClientRect).top  - entry.boundingClientRect.As(ClientRect).top), float), BlazorJs.Cast(spacerSeparation, float), BlazorJs.Cast(containerSize, float));
                }
                else if (entry.target  === spacerAfter && spacerAfter.offsetHeight  > 0)
                {
                    virtualize.OnAfterSpacerVisible(BlazorJs.Cast((entry.boundingClientRect.As(ClientRect).bottom  - entry.intersectionRect.As(ClientRect).bottom), float), BlazorJs.Cast(spacerSeparation, float), BlazorJs.Cast(containerSize, float));
                }
            });
        }
        /*bool*/ function isValidTableElement(/*HTMLElement*/ element)
        {
            if (element === null)
            {
                return false;
            }
            return ((H5.Script.InstanceOf(element, HTMLTableElement) && element.style.display  === "") || element.style.display  === "table") || ((H5.Script.InstanceOf(element, HTMLTableSectionElement) && element.style.display  === "") || element.style.display  === "table-row-group");
        }
    }
}





















static class Microsoft_Extensions_Configuration_ConfigurationExtension
{
    /*void*/ static AddJsonStream(/*this IConfigurationBuilder*/ configuration, /*Stream*/ stream)
    {
        throw new NotImplementedException();
    }
    /*bool*/ static Exists(/*this IConfiguration*/ configuration)
    {
        throw new NotImplementedException();
    }
    /*T*/ static Get(T, /*this IConfiguration*/ configuration)
    {
        throw new NotImplementedException();
    }
}

const Microsoft_Extensions_Configuration_IConfiguration = (Base) => class extends Base
{
    /*//
        // Summary:
        //     Gets or sets a configuration value.
        //
        // Parameters:
        //   key:
        //     The configuration key.
        //
        // Returns:
        //     The configuration value.
        string*/ getItem(/*string*/ key)
    {
    }
    /*void*/ setItem(/*string*/ key, /*//
        // Summary:
        //     Gets or sets a configuration value.
        //
        // Parameters:
        //   key:
        //     The configuration key.
        //
        // Returns:
        //     The configuration value.
        string*/ value)
    {
    }
}

const Microsoft_Extensions_Configuration_IConfigurationBuilder = (Base) => class extends Base
{
    /*IDictionary<string, object>*/ _backingField_Properties = null;
    /*IDictionary<string, object>*/ get Properties()
    {
        return _backingField_Properties;
    }
    /*IList<IConfigurationSource>*/ _backingField_Sources = null;
    /*IList<IConfigurationSource>*/ get Sources()
    {
        return _backingField_Sources;
    }
}

const Microsoft_Extensions_Configuration_IConfigurationSection = (Base) => class extends Base
{
    /*//
        // Summary:
        //     Gets the key this section occupies in its parent.
        string*/ _backingField_Key = null;
    /*//
        // Summary:
        //     Gets the key this section occupies in its parent.
        string*/ get Key()
    {
        return _backingField_Key;
    }
    /*//
        // Summary:
        //     Gets the full path to this section within the Microsoft.Extensions.Configuration.IConfiguration.
        string*/ _backingField_Path = null;
    /*//
        // Summary:
        //     Gets the full path to this section within the Microsoft.Extensions.Configuration.IConfiguration.
        string*/ get Path()
    {
        return _backingField_Path;
    }
    /*//
        // Summary:
        //     Gets or sets the section value.
        string*/ _backingField_Value = null;
    /*//
        // Summary:
        //     Gets or sets the section value.
        string*/ get Value()
    {
        return _backingField_Value;
    }
    /*//
        // Summary:
        //     Gets or sets the section value.
        string*/ set Value(value)
    {
        _backingField_Value = value;
    }
}

const Microsoft_Extensions_DependencyInjection_IServiceCollection = (Base) => class extends Base
{
}

static class Microsoft_Extensions_DependencyInjection_ServiceCollectionServiceExtensions
{
    /*IServiceCollection*/ static AddTransient(/*this IServiceCollection*/ services, /*Type*/ serviceType, /*Type*/ implementationType)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(implementationType, "implementationType");
        return Add(services, serviceType, implementationType, ServiceLifetime.Transient);
    }
    /*IServiceCollection*/ static AddTransient(/*this IServiceCollection*/ services, /*Type*/ serviceType, /*Func<IServiceProvider, object>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return Add(services, serviceType, implementationFactory, ServiceLifetime.Transient);
    }
    /*IServiceCollection*/ static AddTransient(TService, TImplementation, /*this IServiceCollection*/ services)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        return services.AddTransient(TService, TImplementation);
    }
    /*IServiceCollection*/ static AddTransient(/*this IServiceCollection*/ services, /*Type*/ serviceType)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        return services.AddTransient(serviceType, serviceType);
    }
    /*IServiceCollection*/ static AddTransient(TService, /*this IServiceCollection*/ services)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        return services.AddTransient(TService);
    }
    /*IServiceCollection*/ static AddTransient(TService, /*this IServiceCollection*/ services, /*Func<IServiceProvider, TService>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return services.AddTransient(TService, function(/**/ sp)
        {
            return implementationFactory(sp);
        });
    }
    /*IServiceCollection*/ static AddTransient(TService, TImplementation, /*this IServiceCollection*/ services, /*Func<IServiceProvider, TImplementation>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return services.AddTransient(TService, function(/**/ sp)
        {
            return implementationFactory(sp);
        });
    }
    /*IServiceCollection*/ static AddScoped(/*this IServiceCollection*/ services, /*Type*/ serviceType, /*Type*/ implementationType)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(implementationType, "implementationType");
        return Add(services, serviceType, implementationType, ServiceLifetime.Scoped);
    }
    /*IServiceCollection*/ static AddScoped(/*this IServiceCollection*/ services, /*Type*/ serviceType, /*Func<IServiceProvider, object>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return Add(services, serviceType, implementationFactory, ServiceLifetime.Scoped);
    }
    /*IServiceCollection*/ static AddScoped(TService, TImplementation, /*this IServiceCollection*/ services)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        return services.AddScoped(TService, TImplementation);
    }
    /*IServiceCollection*/ static AddScoped(/*this IServiceCollection*/ services, /*Type*/ serviceType)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        return services.AddScoped(serviceType, serviceType);
    }
    /*IServiceCollection*/ static AddScoped(TService, /*this IServiceCollection*/ services)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        return services.AddScoped(TService);
    }
    /*IServiceCollection*/ static AddScoped(TService, /*this IServiceCollection*/ services, /*Func<IServiceProvider, TService>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return services.AddScoped(TService, function(/**/ sp)
        {
            return implementationFactory(sp);
        });
    }
    /*IServiceCollection*/ static AddScoped(TService, TImplementation, /*this IServiceCollection*/ services, /*Func<IServiceProvider, TImplementation>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return services.AddScoped(TService, function(/**/ sp)
        {
            return implementationFactory(sp);
        });
    }
    /*IServiceCollection*/ static AddSingleton(/*this IServiceCollection*/ services, /*Type*/ serviceType, /*Type*/ implementationType)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(implementationType, "implementationType");
        return Add(services, serviceType, implementationType, ServiceLifetime.Singleton);
    }
    /*IServiceCollection*/ static AddSingleton(/*this IServiceCollection*/ services, /*Type*/ serviceType, /*Func<IServiceProvider, object>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return Add(services, serviceType, implementationFactory, ServiceLifetime.Singleton);
    }
    /*IServiceCollection*/ static AddSingleton(TService, TImplementation, /*this IServiceCollection*/ services)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        return services.AddSingleton(TService, TImplementation);
    }
    /*IServiceCollection*/ static AddSingleton(/*this IServiceCollection*/ services, /*Type*/ serviceType)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        return services.AddSingleton(serviceType, serviceType);
    }
    /*IServiceCollection*/ static AddSingleton(TService, /*this IServiceCollection*/ services)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        return services.AddSingleton(TService);
    }
    /*IServiceCollection*/ static AddSingleton(TService, /*this IServiceCollection*/ services, /*Func<IServiceProvider, TService>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return services.AddSingleton(TService, implementationFactory);
    }
    /*IServiceCollection*/ static AddSingleton(TService, TImplementation, /*this IServiceCollection*/ services, /*Func<IServiceProvider, TImplementation>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return services.AddSingleton(TService, implementationFactory);
    }
    /*IServiceCollection*/ static AddSingleton(/*this IServiceCollection*/ services, /*Type*/ serviceType, /*object*/ implementationInstance)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(implementationInstance, "implementationInstance");
        /*ServiceDescriptor*/ let item = new ServiceDescriptor(serviceType, implementationInstance);
        services.Add(item);
        return services;
    }
    /*IServiceCollection*/ static AddSingleton(TService, /*this IServiceCollection*/ services, /*TService*/ implementationInstance)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(implementationInstance, "implementationInstance");
        return services.AddSingleton(TService, implementationInstance);
    }
    /*IServiceCollection*/ static Add(/*IServiceCollection*/ collection, /*Type*/ serviceType, /*Type*/ implementationType, /*ServiceLifetime*/ lifetime)
    {
        /*ServiceDescriptor*/ let item = new ServiceDescriptor(serviceType, implementationType, lifetime);
        collection.Add(item);
        return collection;
    }
    /*IServiceCollection*/ static Add(/*IServiceCollection*/ collection, /*Type*/ serviceType, /*Func<IServiceProvider, object>*/ implementationFactory, /*ServiceLifetime*/ lifetime)
    {
        /*ServiceDescriptor*/ let item = new ServiceDescriptor(serviceType, implementationFactory, lifetime);
        collection.Add(item);
        return collection;
    }
    /*IServiceCollection*/ static AddKeyedTransient(/*this IServiceCollection*/ services, /*Type*/ serviceType, /*object*/ serviceKey, /*Type*/ implementationType)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(implementationType, "implementationType");
        return AddKeyed(services, serviceType, serviceKey, implementationType, ServiceLifetime.Transient);
    }
    /*IServiceCollection*/ static AddKeyedTransient(/*this IServiceCollection*/ services, /*Type*/ serviceType, /*object*/ serviceKey, /*Func<IServiceProvider, object, object>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return AddKeyed(services, serviceType, serviceKey, implementationFactory, ServiceLifetime.Transient);
    }
    /*IServiceCollection*/ static AddKeyedTransient(TService, TImplementation, /*this IServiceCollection*/ services, /*object*/ serviceKey)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        return services.AddKeyedTransient(TService, serviceKey, TImplementation);
    }
    /*IServiceCollection*/ static AddKeyedTransient(/*this IServiceCollection*/ services, /*Type*/ serviceType, /*object*/ serviceKey)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        return services.AddKeyedTransient(serviceType, serviceKey, serviceType);
    }
    /*IServiceCollection*/ static AddKeyedTransient(TService, /*this IServiceCollection*/ services, /*object*/ serviceKey)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        return services.AddKeyedTransient(TService, serviceKey);
    }
    /*IServiceCollection*/ static AddKeyedTransient(TService, /*this IServiceCollection*/ services, /*object*/ serviceKey, /*Func<IServiceProvider, object, TService>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return services.AddKeyedTransient(TService, serviceKey, function(/**/ sp, /**/ key)
        {
            return implementationFactory(sp, key);
        });
    }
    /*IServiceCollection*/ static AddKeyedTransient(TService, TImplementation, /*this IServiceCollection*/ services, /*object*/ serviceKey, /*Func<IServiceProvider, object, TImplementation>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return services.AddKeyedTransient(TService, serviceKey, function(/**/ sp, /**/ key)
        {
            return implementationFactory(sp, key);
        });
    }
    /*IServiceCollection*/ static AddKeyedScoped(/*this IServiceCollection*/ services, /*Type*/ serviceType, /*object*/ serviceKey, /*Type*/ implementationType)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(implementationType, "implementationType");
        return AddKeyed(services, serviceType, serviceKey, implementationType, ServiceLifetime.Scoped);
    }
    /*IServiceCollection*/ static AddKeyedScoped(/*this IServiceCollection*/ services, /*Type*/ serviceType, /*object*/ serviceKey, /*Func<IServiceProvider, object, object>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return AddKeyed(services, serviceType, serviceKey, implementationFactory, ServiceLifetime.Scoped);
    }
    /*IServiceCollection*/ static AddKeyedScoped(TService, TImplementation, /*this IServiceCollection*/ services, /*object*/ serviceKey)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        return services.AddKeyedScoped(TService, serviceKey, TImplementation);
    }
    /*IServiceCollection*/ static AddKeyedScoped(/*this IServiceCollection*/ services, /*Type*/ serviceType, /*object*/ serviceKey)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        return services.AddKeyedScoped(serviceType, serviceKey, serviceType);
    }
    /*IServiceCollection*/ static AddKeyedScoped(TService, /*this IServiceCollection*/ services, /*object*/ serviceKey)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        return services.AddKeyedScoped(TService, serviceKey);
    }
    /*IServiceCollection*/ static AddKeyedScoped(TService, /*this IServiceCollection*/ services, /*object*/ serviceKey, /*Func<IServiceProvider, object, TService>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return services.AddKeyedScoped(TService, serviceKey, function(/**/ sp, /**/ key)
        {
            return implementationFactory(sp, key);
        });
    }
    /*IServiceCollection*/ static AddKeyedScoped(TService, TImplementation, /*this IServiceCollection*/ services, /*object*/ serviceKey, /*Func<IServiceProvider, object, TImplementation>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return services.AddKeyedScoped(TService, serviceKey, function(/**/ sp, /**/ key)
        {
            return implementationFactory(sp, key);
        });
    }
    /*IServiceCollection*/ static AddKeyedSingleton(/*this IServiceCollection*/ services, /*Type*/ serviceType, /*object*/ serviceKey, /*Type*/ implementationType)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(implementationType, "implementationType");
        return AddKeyed(services, serviceType, serviceKey, implementationType, ServiceLifetime.Singleton);
    }
    /*IServiceCollection*/ static AddKeyedSingleton(/*this IServiceCollection*/ services, /*Type*/ serviceType, /*object*/ serviceKey, /*Func<IServiceProvider, object, object>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return AddKeyed(services, serviceType, serviceKey, implementationFactory, ServiceLifetime.Singleton);
    }
    /*IServiceCollection*/ static AddKeyedSingleton(TService, TImplementation, /*this IServiceCollection*/ services, /*object*/ serviceKey)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        return services.AddKeyedSingleton(TService, serviceKey, TImplementation);
    }
    /*IServiceCollection*/ static AddKeyedSingleton(/*this IServiceCollection*/ services, /*Type*/ serviceType, /*object*/ serviceKey)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        return services.AddKeyedSingleton(serviceType, serviceKey, serviceType);
    }
    /*IServiceCollection*/ static AddKeyedSingleton(TService, /*this IServiceCollection*/ services, /*object*/ serviceKey)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        return services.AddKeyedSingleton(TService, serviceKey, TService);
    }
    /*IServiceCollection*/ static AddKeyedSingleton(TService, /*this IServiceCollection*/ services, /*object*/ serviceKey, /*Func<IServiceProvider, object, TService>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return services.AddKeyedSingleton(TService, serviceKey, implementationFactory);
    }
    /*IServiceCollection*/ static AddKeyedSingleton(TService, TImplementation, /*this IServiceCollection*/ services, /*object*/ serviceKey, /*Func<IServiceProvider, object, TImplementation>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return services.AddKeyedSingleton(TService, serviceKey, implementationFactory);
    }
    /*IServiceCollection*/ static AddKeyedSingleton(/*this IServiceCollection*/ services, /*Type*/ serviceType, /*object*/ serviceKey, /*object*/ implementationInstance)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(implementationInstance, "implementationInstance");
        /*ServiceDescriptor*/ let item = new ServiceDescriptor(serviceType, serviceKey, implementationInstance);
        services.Add(item);
        return services;
    }
    /*IServiceCollection*/ static AddKeyedSingleton(TService, /*this IServiceCollection*/ services, /*object*/ serviceKey, /*TService*/ implementationInstance)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(implementationInstance, "implementationInstance");
        return services.AddKeyedSingleton(TService, serviceKey, implementationInstance);
    }
    /*IServiceCollection*/ static AddKeyed(/*IServiceCollection*/ collection, /*Type*/ serviceType, /*object*/ serviceKey, /*Type*/ implementationType, /*ServiceLifetime*/ lifetime)
    {
        /*ServiceDescriptor*/ let item = new ServiceDescriptor(serviceType, serviceKey, implementationType, lifetime);
        collection.Add(item);
        return collection;
    }
    /*IServiceCollection*/ static AddKeyed(/*IServiceCollection*/ collection, /*Type*/ serviceType, /*object*/ serviceKey, /*Func<IServiceProvider, object, object>*/ implementationFactory, /*ServiceLifetime*/ lifetime)
    {
        /*ServiceDescriptor*/ let item = new ServiceDescriptor(serviceType, serviceKey, implementationFactory, lifetime);
        collection.Add(item);
        return collection;
    }
}

static class Microsoft_JSInterop_DotNetObjectReference
{
    /*DotNetObjectReference<TValue>*/ static Create(TValue, /*TValue*/ value)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(value);
        return new DotNetObjectReference(TValue)(value);
    }
}

const Microsoft_JSInterop_DotNetObjectReference = (TValue) => class extends System_IDisposable(Microsoft_JSInterop_Infrastructure_IDotNetObjectReference(object))
{
    /*TValue*/ _value = null;
    /*long*/ _objectId = null;
    /*JSRuntime*/ _jsRuntime = null;
    constructor(/*TValue*/ value)
    {
        super();
        _value = value;
    }
    /*TValue*/ get Value()
    {
        ThrowIfDisposed();
        return _value;
    }
    /*long*/ get ObjectId()
    {
        ThrowIfDisposed();
        Debug.Assert(_objectId !== 0, "Accessing ObjectId without tracking is always incorrect.");
        return _objectId;
    }
    /*long*/ set ObjectId(value)
    {
        ThrowIfDisposed();
        _objectId = value;
    }
    /*JSRuntime*/ get JSRuntime()
    {
        ThrowIfDisposed();
        return _jsRuntime;
    }
    /*JSRuntime*/ set JSRuntime(value)
    {
        ThrowIfDisposed();
        _jsRuntime = value;
    }
    /*object*/ get Value()
    {
        return Value;
    }
    /*bool*/ _backingField_Disposed = null;
    /*bool*/ get Disposed()
    {
        return _backingField_Disposed;
    }
    /*bool*/ set Disposed(value)
    {
        _backingField_Disposed = value;
    }
    /*void*/ Dispose()
    {
        if (Disposed)
        {
            Disposed = true;
            _jsRuntime?.ReleaseObjectReference(_objectId);
        }
    }
    /*void*/ ThrowIfDisposed()
    {
        if (Disposed)
        throw new ObjectDisposedException("disposed");
    }
}

class Microsoft_JSInterop_DotNetStreamReference extends System_IDisposable(object)
{
    constructor(/*Stream*/ stream, /*bool*/ leaveOpen)
    {
        super();
        Stream = BlazorJs.FirstOf(stream, function(){ throw new ArgumentNullException(nameof(stream)) });
        LeaveOpen = leaveOpen;
    }
    /*Stream*/ _backingField_Stream = null;
    /*Stream*/ get Stream()
    {
        return _backingField_Stream;
    }
    /*bool*/ _backingField_LeaveOpen = null;
    /*bool*/ get LeaveOpen()
    {
        return _backingField_LeaveOpen;
    }
    /*void*/ Dispose()
    {
        if (LeaveOpen)
        {
            Stream.Dispose();
        }
    }
}

const Microsoft_JSInterop_IJSInProcessObjectReference = (Base) => class extends Base
{
}

const Microsoft_JSInterop_IJSInProcessRuntime = (Base) => class extends Base
{
}

const Microsoft_JSInterop_IJSObjectReference = (Base) => class extends Base
{
}

const Microsoft_JSInterop_IJSRuntime = (Base) => class extends Base
{
}

const Microsoft_JSInterop_IJSStreamReference = (Base) => class extends Base
{
    /*/// <summary>
        /// Length of the <see cref="Stream"/> provided by JavaScript.
        /// </summary>
        long*/ _backingField_Length = null;
    /*/// <summary>
        /// Length of the <see cref="Stream"/> provided by JavaScript.
        /// </summary>
        long*/ get Length()
    {
        return _backingField_Length;
    }
}

static class Microsoft_JSInterop_JSCallResultType
{
    Default = 0;
    JSObjectReference = 1;
    JSStreamReference = 2;
    JSVoidResult = 3;
}

static class Microsoft_JSInterop_JSCallResultTypeHelper
{
    /*Assembly*/ static _currentAssembly = JSCallResultType.Assembly;
    /*JSCallResultType*/ static FromGeneric(TResult)
    {
        if (TResult.Assembly  === _currentAssembly)
        {
            if (TResult === IJSObjectReference || TResult === IJSInProcessObjectReference)
            {
                return JSCallResultType.JSObjectReference;
            }
            else if (TResult === IJSStreamReference)
            {
                return JSCallResultType.JSStreamReference;
            }
            else if (TResult === IJSVoidResult)
            {
                return JSCallResultType.JSVoidResult;
            }
        }
        return JSCallResultType.Default;
    }
}

class Microsoft_JSInterop_JSDisconnectedException extends System_Exception
{
    constructor(/*string*/ message)
    {
        super(message);
    }
}

class Microsoft_JSInterop_JSException extends System_Exception
{
    constructor(/*string*/ message)
    {
        super(message);
    }
    constructor(/*string*/ message, /*Exception*/ innerException)
    {
        super(message, innerException);
    }
}

static class Microsoft_JSInterop_JSInProcessObjectReferenceExtensions
{
    /*void*/ static InvokeVoid(/*this IJSInProcessObjectReference*/ jsObjectReference, /*string*/ identifier, /*params object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsObjectReference);
        jsObjectReference.Invoke(IJSVoidResult, identifier, args);
    }
}

class Microsoft_JSInterop_JSInProcessRuntime extends Microsoft_JSInterop_IJSRuntime(Microsoft_JSInterop_IJSInProcessRuntime(Microsoft_JSInterop_JSRuntime))
{
    constructor()
    {
        super();
    }
    /*long*/ SyncCallIndicator = 0;
    /*TValue*/ Invoke(TValue, /*string*/ identifier, /*params object[]*/ args)
    {
        return Invoke(TValue)(TValue, identifier, WindowObjectId, JSCallType.FunctionCall, args);
    }
    /*IJSInProcessObjectReference*/ InvokeNew(/*string*/ identifier, /*params object[]*/ args)
    {
        return Invoke(IJSInProcessObjectReference)(IJSInProcessObjectReference, identifier, WindowObjectId, JSCallType.NewCall, args);
    }
    /*TValue*/ GetValue(TValue, /*string*/ identifier)
    {
        return Invoke(TValue)(TValue, identifier, WindowObjectId, JSCallType.GetValue);
    }
    /*void*/ SetValue(TValue, /*string*/ identifier, /*TValue*/ value)
    {
        return Invoke(IJSVoidResult)(IJSVoidResult, identifier, WindowObjectId, JSCallType.SetValue, value);
    }
    /*TValue*/ Invoke(TValue, /*string*/ identifier, /*long*/ targetInstanceId, /*JSCallType*/ callType, /*params object[]*/ args)
    {
        /*var*/ let argsJson = args !== null && args.Length  !== 0 ? JsonSerializer.Serialize(args, JsonSerializerOptions) : "[]";
        /*var*/ let resultType = JSCallResultTypeHelper.FromGeneric(TValue);
        /*var*/ let invocationInfo = BlazorJs.PopulateProperty(new JSInvocationInfo(), function(/*JSInvocationInfo*/ $obj)
        {
            $obj.AsyncHandle = SyncCallIndicator;
            $obj.TargetInstanceId = targetInstanceId;
            $obj.Identifier = identifier;
            $obj.CallType = callType;
            $obj.ResultType = resultType;
            $obj.ArgsJson = argsJson;
        });
        /*var*/ let resultJson = InvokeJS(invocationInfo);
        if (resultJson === null)
        {
            return BlazorJs.getDefault();
        }
        /*var*/ let result = JsonSerializer.Deserialize(TValue, resultJson, JsonSerializerOptions);
        ByteArraysToBeRevived.Clear();
        return result;
    }
    /*string*/ InvokeJS(/*string*/ identifier, /*string*/ argsJson)
    {
        return InvokeJS(identifier, argsJson, JSCallResultType.Default, WindowObjectId);
    }
}

static class Microsoft_JSInterop_JSInProcessRuntimeExtensions
{
    /*void*/ static InvokeVoid(/*this IJSInProcessRuntime*/ jsRuntime, /*string*/ identifier, /*params object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsRuntime);
        jsRuntime.Invoke(IJSVoidResult, identifier, args);
    }
}

class Microsoft_JSInterop_JSInvokableAttribute extends System_Attribute
{
    /*string*/ _backingField_Identifier = null;
    /*string*/ get Identifier()
    {
        return _backingField_Identifier;
    }
    constructor()
    {
        super();
    }
    constructor(/*string*/ identifier)
    {
        super();
        ArgumentExceptionExtension.ThrowIfNullOrEmpty(identifier);
        Identifier = identifier;
    }
}

static class Microsoft_JSInterop_JSObjectReferenceExtensions
{
    /*Task*/ static async InvokeVoidAsync(/*this IJSObjectReference*/ jsObjectReference, /*string*/ identifier, /*params object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsObjectReference);
        await jsObjectReference.InvokeAsync(IJSVoidResult, identifier, args);
    }
    /*Task<TValue>*/ static InvokeAsync(TValue, /*this IJSObjectReference*/ jsObjectReference, /*string*/ identifier, /*params object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsObjectReference);
        return jsObjectReference.InvokeAsync(TValue, identifier, args);
    }
    /*Task<TValue>*/ static InvokeAsync(TValue, /*this IJSObjectReference*/ jsObjectReference, /*string*/ identifier, /*CancellationToken*/ cancellationToken, /*params object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsObjectReference);
        return jsObjectReference.InvokeAsync(TValue, identifier, cancellationToken, args);
    }
    /*Task*/ static async InvokeVoidAsync(/*this IJSObjectReference*/ jsObjectReference, /*string*/ identifier, /*CancellationToken*/ cancellationToken, /*params object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsObjectReference);
        await jsObjectReference.InvokeAsync(IJSVoidResult, identifier, cancellationToken, args);
    }
    /*Task<TValue>*/ static async InvokeAsync(TValue, /*this IJSObjectReference*/ jsObjectReference, /*string*/ identifier, /*TimeSpan*/ timeout, /*params object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsObjectReference);
        /*var*/ let cancellationTokenSource = timeout === TimeSpan.MaxValue  ? null : new CancellationTokenSource(timeout);
        /*var*/ let cancellationToken = cancellationTokenSource?.Token ?? CancellationToken.None;
        try
        {
            return await jsObjectReference.InvokeAsync(TValue, identifier, cancellationToken, args);
        }
        finally
        {
            {
                cancellationTokenSource?.Dispose();
            }
        }
    }
    /*Task*/ static async InvokeVoidAsync(/*this IJSObjectReference*/ jsObjectReference, /*string*/ identifier, /*TimeSpan*/ timeout, /*params object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsObjectReference);
        /*var*/ let cancellationTokenSource = timeout === TimeSpan.MaxValue  ? null : new CancellationTokenSource(timeout);
        /*var*/ let cancellationToken = cancellationTokenSource?.Token ?? CancellationToken.None;
        try
        {
            await jsObjectReference.InvokeAsync(IJSVoidResult, identifier, cancellationToken, args);
        }
        finally
        {
            {
                cancellationTokenSource?.Dispose();
            }
        }
    }
    /*Task<IJSObjectReference>*/ static InvokeNewAsync(/*this IJSObjectReference*/ jsObjectReference, /*string*/ identifier, /*params object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsObjectReference);
        return jsObjectReference.InvokeNewAsync(identifier, args);
    }
    /*Task<IJSObjectReference>*/ static InvokeNewAsync(/*this IJSObjectReference*/ jsObjectReference, /*string*/ identifier, /*CancellationToken*/ cancellationToken, /*object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsObjectReference);
        return jsObjectReference.InvokeNewAsync(identifier, cancellationToken, args);
    }
    /*Task<IJSObjectReference>*/ static InvokeNewAsync(/*this IJSObjectReference*/ jsObjectReference, /*string*/ identifier, /*TimeSpan*/ timeout, /*object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsObjectReference);
        /*var*/ let cancellationTokenSource = timeout === TimeSpan.MaxValue  ? null : new CancellationTokenSource(timeout);
        /*var*/ let cancellationToken = cancellationTokenSource?.Token ?? CancellationToken.None;
        try
        {
            return jsObjectReference.InvokeNewAsync(identifier, cancellationToken, args);
        }
        finally
        {
            {
                cancellationTokenSource?.Dispose();
            }
        }
    }
}

class Microsoft_JSInterop_JSRuntime extends System_IDisposable(Microsoft_JSInterop_IJSRuntime(object))
{
    /*long*/ WindowObjectId = 0;
    /*long*/ _nextObjectReferenceId = null;
    /*long*/ _nextPendingTaskId = 1;
    /*ConcurrentDictionary<long, object>*/ _pendingTasks = new ConcurrentDictionary(long, object)();
    /*ConcurrentDictionary<long, IDotNetObjectReference>*/ _trackedRefsById = new ConcurrentDictionary(long, IDotNetObjectReference)();
    /*ConcurrentDictionary<long, CancellationTokenRegistration>*/ _cancellationRegistrations = new ConcurrentDictionary(long, CancellationTokenRegistration)();
    /*List<byte[]>*/ ByteArraysToBeRevived = new List(byte)();
    constructor()
    {
        super();
        JsonSerializerOptions = BlazorJs.PopulateProperty(new JsonSerializerOptions(), function(/*JsonSerializerOptions*/ $obj)
        {
        });
    }
    /*JsonSerializerOptions*/ _backingField_JsonSerializerOptions = null;
    /*JsonSerializerOptions*/ get JsonSerializerOptions()
    {
        return _backingField_JsonSerializerOptions;
    }
    /*TimeSpan?*/ _backingField_DefaultAsyncTimeout = null;
    /*TimeSpan?*/ get DefaultAsyncTimeout()
    {
        return _backingField_DefaultAsyncTimeout;
    }
    /*TimeSpan?*/ set DefaultAsyncTimeout(value)
    {
        _backingField_DefaultAsyncTimeout = value;
    }
    /*Task<TValue>*/ InvokeAsync(TValue, /*string*/ identifier, /*object[]*/ args)
    {
        return InvokeAsync(TValue)(TValue, WindowObjectId, identifier, JSCallType.FunctionCall, args);
    }
    /*Task<TValue>*/ InvokeAsync(TValue, /*string*/ identifier, /*CancellationToken*/ cancellationToken, /*object[]*/ args)
    {
        return InvokeAsync(TValue)(TValue, WindowObjectId, identifier, JSCallType.FunctionCall, cancellationToken, args);
    }
    /*Task<IJSObjectReference>*/ InvokeNewAsync(/*string*/ identifier, /*object[]*/ args)
    {
        return InvokeAsync(IJSObjectReference)(IJSObjectReference, WindowObjectId, identifier, JSCallType.NewCall, args);
    }
    /*Task<IJSObjectReference>*/ InvokeNewAsync(/*string*/ identifier, /*CancellationToken*/ cancellationToken, /*object[]*/ args)
    {
        return InvokeAsync(IJSObjectReference)(IJSObjectReference, WindowObjectId, identifier, JSCallType.NewCall, cancellationToken, args);
    }
    /*Task<TValue>*/ GetValueAsync(TValue, /*string*/ identifier)
    {
        return InvokeAsync(TValue)(TValue, WindowObjectId, identifier, JSCallType.GetValue, null);
    }
    /*Task<TValue>*/ GetValueAsync(TValue, /*string*/ identifier, /*CancellationToken*/ cancellationToken)
    {
        return InvokeAsync(TValue)(TValue, WindowObjectId, identifier, JSCallType.GetValue, cancellationToken, null);
    }
    /*Task*/ async SetValueAsync(TValue, /*string*/ identifier, /*TValue*/ value)
    {
        return await InvokeAsync(IJSVoidResult)(IJSVoidResult, WindowObjectId, identifier, JSCallType.SetValue, [ value ]);
    }
    /*Task*/ async SetValueAsync(TValue, /*string*/ identifier, /*TValue*/ value, /*CancellationToken*/ cancellationToken)
    {
        return await InvokeAsync(IJSVoidResult)(IJSVoidResult, WindowObjectId, identifier, JSCallType.SetValue, cancellationToken, [ value ]);
    }
    /*Task<TValue>*/ async InvokeAsync(TValue, /*long*/ targetInstanceId, /*string*/ identifier, /*JSCallType*/ callType, /*object[]*/ args)
    {
        if (DefaultAsyncTimeout.HasValue)
        {
            /*var*/ let cts = new CancellationTokenSource(DefaultAsyncTimeout.Value);
            try
            {
                return await InvokeAsync(TValue)(TValue, targetInstanceId, identifier, callType, cts.Token, args);
            }
            finally
            {
                {
                    cts.Dispose();
                }
            }
        }
        return await InvokeAsync(TValue)(TValue, targetInstanceId, identifier, callType, CancellationToken.None, args);
    }
    /*Task<TValue>*/ InvokeAsync(TValue, /*long*/ targetInstanceId, /*string*/ identifier, /*JSCallType*/ callType, /*CancellationToken*/ cancellationToken, /*object[]*/ args)
    {
        /*var*/ let taskId = _nextPendingTaskId++;
        /*var*/ let tcs = new TaskCompletionSource(TValue)();
        if (cancellationToken.CanBeCanceled)
        {
            _cancellationRegistrations[taskId] = cancellationToken.Register(function()
            {
                tcs.TrySetCanceled(cancellationToken);
                CleanupTasksAndRegistrations(taskId);
            });
        }
        _pendingTasks[taskId] = tcs;
        try
        {
            if (cancellationToken.IsCancellationRequested)
            {
                tcs.TrySetCanceled(cancellationToken);
                CleanupTasksAndRegistrations(taskId);
                return tcs.Task;
            }
            /*var*/ let argsJson = args !== null && args.Length  !== 0 ? JsonSerializer.Serialize(args, JsonSerializerOptions) : "[]";
            /*var*/ let resultType = JSCallResultTypeHelper.FromGeneric(TValue);
            /*var*/ let invocationInfo = BlazorJs.PopulateProperty(new JSInvocationInfo(), function(/*JSInvocationInfo*/ $obj)
            {
                $obj.AsyncHandle = taskId;
                $obj.TargetInstanceId = targetInstanceId;
                $obj.Identifier = identifier;
                $obj.CallType = callType;
                $obj.ResultType = resultType;
                $obj.ArgsJson = argsJson;
            });
            BeginInvokeJS(invocationInfo);
            return tcs.Task;
        }
        catch($e)
        {
            CleanupTasksAndRegistrations(taskId);
            throw $e;
        }
    }
    /*void*/ CleanupTasksAndRegistrations(/*long*/ taskId)
    {
        let $ref0 = { set value(v){ _ = v } };
        let registration = null;
        let $ref2 = { set value(v){ registration = v } };
        _pendingTasks.TryRemove(taskId, $ref0);
        if (_cancellationRegistrations.TryRemove(taskId, $ref2))
        {
            registration.Dispose();
        }
    }
    /*void*/ BeginInvokeJS(/*long*/ taskId, /*string*/ identifier, /*string*/ argsJson)
    {
        return BeginInvokeJS(taskId, identifier, argsJson, JSCallResultType.Default, WindowObjectId);
    }
    /*void*/ SendByteArray(/*int*/ id, /*byte[]*/ data)
    {
        throw new NotSupportedException("JSRuntime subclasses are responsible for implementing byte array transfer to JS.");
    }
    /*void*/ ReceiveByteArray(/*int*/ id, /*byte[]*/ data)
    {
        if (id === 0)
        {
            ByteArraysToBeRevived.Clear();
        }
        if (id !== ByteArraysToBeRevived.Count)
        {
            throw new ArgumentOutOfRangeException(`Element id '${id}' cannot be added to the byte arrays to be revived with length '${ByteArraysToBeRevived.Count}'.`, { innerException : null });
        }
        ByteArraysToBeRevived.Add(data);
    }
    /*Task<Stream>*/ ReadJSDataAsStreamAsync(/*IJSStreamReference*/ jsStreamReference, /*long*/ totalLength, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        throw new NotSupportedException("The current JavaScript runtime does not support reading data streams.");
    }
    /*bool*/ EndInvokeJS(/*long*/ taskId, /*bool*/ succeeded, /*object*/ jsResult)
    {
        let tcs = null;
        let $ref1 = { set value(v){ tcs = v } };
        if (_pendingTasks.TryRemove(taskId, $ref1))
        {
            return false;
        }
        CleanupTasksAndRegistrations(taskId);
        try
        {
            if (succeeded)
            {
                /*var*/ let resultType = TaskGenericsUtil.GetTaskCompletionSourceResultType(tcs);
                /*//var result = JsonSerializer.Deserialize(ref jsonReader, resultType, JsonSerializerOptions);
                    var*/ let result = JsonSerializer.Convert(jsResult, resultType);
                ByteArraysToBeRevived.Clear();
                TaskGenericsUtil.SetTaskCompletionSourceResult(tcs, result);
            }
            else 
            {
                /*var*/ let exceptionText = jsResult.As(string) ?? string.Empty;
                TaskGenericsUtil.SetTaskCompletionSourceException(tcs, new JSException(exceptionText));
            }
            return true;
        }
        catch(exception)
        {
            /*var*/ let message = `An exception occurred executing JS interop: ${exception.Message}. See InnerException for more details.`;
            TaskGenericsUtil.SetTaskCompletionSourceException(tcs, new JSException(message, exception));
            return false;
        }
    }
    /*Task*/ TransmitStreamAsync(/*long*/ streamId, /*DotNetStreamReference*/ dotNetStreamReference)
    {
        if (dotNetStreamReference.LeaveOpen)
        {
            dotNetStreamReference.Stream.Dispose();
        }
        throw new NotSupportedException("The current JS runtime does not support sending streams from .NET to JS.");
    }
    /*long*/ BeginTransmittingStream(/*DotNetStreamReference*/ dotNetStreamReference)
    {
        /*// It's fine to share the ID sequence
            var*/ let streamId = _nextObjectReferenceId++;
        _ = TransmitStreamAsync(streamId, dotNetStreamReference);
        return streamId;
    }
    /*long*/ TrackObjectReference(TValue, /*DotNetObjectReference<TValue>*/ dotNetObjectReference)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(dotNetObjectReference);
        dotNetObjectReference.ThrowIfDisposed();
        /*var*/ let jsRuntime = dotNetObjectReference.JSRuntime;
        if (jsRuntime)
        {
            /*var*/ let dotNetObjectId = _nextObjectReferenceId++;
            dotNetObjectReference.JSRuntime  = this;
            dotNetObjectReference.ObjectId  = dotNetObjectId;
            _trackedRefsById[dotNetObjectId] = dotNetObjectReference;
        }
        else if (ReferenceEquals(this, jsRuntime))
        {
            throw new InvalidOperationException(`${dotNetObjectReference.GetType().Name} is already being tracked by a different instance of ${nameof(JSRuntime)}.` + ` A common cause is caching an instance of ${nameof(DotNetObjectReference(TValue))} globally. Consider creating instances of ${nameof(DotNetObjectReference(TValue))} at the JSInterop callsite.`);
        }
        Debug.Assert(dotNetObjectReference.ObjectId  !== 0);
        return dotNetObjectReference.ObjectId;
    }
    /*IDotNetObjectReference*/ GetObjectReference(/*long*/ dotNetObjectId)
    {
        let dotNetObjectRef = null;
        let $ref1 = { set value(v){ dotNetObjectRef = v } };
        return _trackedRefsById.TryGetValue(dotNetObjectId, $ref1) ? dotNetObjectRef : BlazorJs.Execute(function(){ throw new ArgumentException(`There is no tracked object with id '${dotNetObjectId}'. Perhaps the DotNetObjectReference instance was already disposed.`, nameof(dotNetObjectId)) });
    }
    /*void*/ ReleaseObjectReference(/*long*/ dotNetObjectId)
    {
        let $ref0 = { set value(v){ _ = v } };
        return _trackedRefsById.TryRemove(dotNetObjectId, $ref0);
    }
    /*void*/ Dispose()
    {
        return ByteArraysToBeRevived.Clear();
    }
}

static class Microsoft_JSInterop_JSRuntimeExtensions
{
    /*Task*/ static async InvokeVoidAsync(/*this IJSRuntime*/ jsRuntime, /*string*/ identifier, /*params object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsRuntime);
        await jsRuntime.InvokeAsync(IJSVoidResult, identifier, args);
    }
    /*Task<TValue>*/ static InvokeAsync(TValue, /*this IJSRuntime*/ jsRuntime, /*string*/ identifier, /*params object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsRuntime);
        return jsRuntime.InvokeAsync(TValue, identifier, args);
    }
    /*Task<TValue>*/ static InvokeAsync(TValue, /*this IJSRuntime*/ jsRuntime, /*string*/ identifier, /*CancellationToken*/ cancellationToken, /*params object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsRuntime);
        return jsRuntime.InvokeAsync(TValue, identifier, cancellationToken, args);
    }
    /*Task*/ static async InvokeVoidAsync(/*this IJSRuntime*/ jsRuntime, /*string*/ identifier, /*CancellationToken*/ cancellationToken, /*params object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsRuntime);
        await jsRuntime.InvokeAsync(IJSVoidResult, identifier, cancellationToken, args);
    }
    /*Task<TValue>*/ static async InvokeAsync(TValue, /*this IJSRuntime*/ jsRuntime, /*string*/ identifier, /*TimeSpan*/ timeout, /*params object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsRuntime);
        /*var*/ let cancellationTokenSource = timeout === TimeSpan.MaxValue  ? null : new CancellationTokenSource(timeout);
        /*var*/ let cancellationToken = cancellationTokenSource?.Token ?? CancellationToken.None;
        try
        {
            return await jsRuntime.InvokeAsync(TValue, identifier, cancellationToken, args);
        }
        finally
        {
            {
                cancellationTokenSource?.Dispose();
            }
        }
    }
    /*Task*/ static async InvokeVoidAsync(/*this IJSRuntime*/ jsRuntime, /*string*/ identifier, /*TimeSpan*/ timeout, /*params object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsRuntime);
        /*var*/ let cancellationTokenSource = timeout === TimeSpan.MaxValue  ? null : new CancellationTokenSource(timeout);
        /*var*/ let cancellationToken = cancellationTokenSource?.Token ?? CancellationToken.None;
        try
        {
            await jsRuntime.InvokeAsync(IJSVoidResult, identifier, cancellationToken, args);
        }
        finally
        {
            {
                cancellationTokenSource?.Dispose();
            }
        }
    }
    /*Task<IJSObjectReference>*/ static InvokeNewAsync(/*this IJSRuntime*/ jsRuntime, /*string*/ identifier, /*params object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsRuntime);
        return jsRuntime.InvokeNewAsync(identifier, args);
    }
    /*Task<IJSObjectReference>*/ static InvokeNewAsync(/*this IJSRuntime*/ jsRuntime, /*string*/ identifier, /*CancellationToken*/ cancellationToken, /*object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsRuntime);
        return jsRuntime.InvokeNewAsync(identifier, cancellationToken, args);
    }
    /*Task<IJSObjectReference>*/ static InvokeNewAsync(/*this IJSRuntime*/ jsRuntime, /*string*/ identifier, /*TimeSpan*/ timeout, /*object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsRuntime);
        /*var*/ let cancellationTokenSource = timeout === TimeSpan.MaxValue  ? null : new CancellationTokenSource(timeout);
        /*var*/ let cancellationToken = cancellationTokenSource?.Token ?? CancellationToken.None;
        try
        {
            return jsRuntime.InvokeNewAsync(identifier, cancellationToken, args);
        }
        finally
        {
            {
                cancellationTokenSource?.Dispose();
            }
        }
    }
}

class BlazorJs_ServiceProvider_BrowserServiceProvider extends H5_IH5Class(System_Collections_IEnumerable(System_Collections_Generic_IEnumerable(System_ServiceDescriptor)(System_Collections_Generic_ICollection(System_ServiceDescriptor)(System_Collections_Generic_IList(System_ServiceDescriptor)(Microsoft_Extensions_DependencyInjection_IServiceCollection(System_IServiceProvider(System_Collections_Generic_List(System_ServiceDescriptor))))))))
{
    /*//List<ServiceDescriptor> serviceDescriptors = new List<ServiceDescriptor>();

        List<IServiceResolver>*/ _resolvers = new List(IServiceResolver)();
    /*Dictionary<(Type, object), object>*/ _resolvedServices = new Dictionary(BlazorJs.TupleType(Type, object), object)();
    constructor()
    {
        super();
        _resolvers.Add(new ServiceCollectionResolver(this));
    }
    /*object*/ ResolveSingle(/*Type*/ serviceType, /*object*/ serviceKey, /*ServiceLifetime*/ currentScope)
    {
        BlazorJs.forEach(_resolvers, function(_resolver, $_i)
        {
            /*var*/ let service = _resolver.TryResolve(this, serviceType, serviceKey, false, currentScope);
            if (service !== null)
            return service;
        });
        return null;
    }
    /*//MethodInfo? castToServiceType;
        IEnumerable<object>*/ ResolveMany(/*Type*/ serviceType, /*object*/ serviceKey, /*ServiceLifetime*/ currentScope)
    {
        /*List<object>*/ let services = new List(object)();
        BlazorJs.forEach(_resolvers, function(_resolver, $_i)
        {
            /*var*/ let service = _resolver.TryResolve(this, serviceType, serviceKey, true, currentScope);
            if (service !== null)
            services.AddRange(BlazorJs.Cast(service, IEnumerable(object)));
        });
        /*var*/ let castToServiceType = Enumerable.GetMethod("Cast").MakeGenericMethod(serviceType);
        /*var*/ let resolvedServices = castToServiceType.Invoke(null, [ services ]);
        return BlazorJs.Cast(resolvedServices, IEnumerable(object));
    }
    /*object*/ Resolve(/*Type*/ serviceType, /*object*/ serviceKey, /*ServiceLifetime*/ currentScope)
    {
        if (serviceType.IsGenericType  && serviceType.GetGenericTypeDefinition() === IEnumerable() && true)
        {
            /*var*/ let innerType = serviceType.GetGenericArguments()[0];
            return ResolveMany(innerType, serviceKey, currentScope);
        }
        return ResolveSingle(serviceType, serviceKey, currentScope);
    }
    /*object*/ GetServiceInternal(/*Type*/ serviceType, /*object*/ serviceKey)
    {
        //lock
        {
            let service = null;
            let $ref1 = { set value(v){ service = v } };
            if (_resolvedServices.TryGetValue(BlazorJs.TupleValue({ Item1: serviceType, Item2: serviceKey }), $ref1))
            return service;
            service = Resolve(serviceType, serviceKey, ServiceLifetime.Singleton);
            if (service !== null)
            _resolvedServices.Add(BlazorJs.TupleValue({ Item1: serviceType, Item2: serviceKey }), service);
            return service;
        }
    }
    /*object*/ GetService(/*Type*/ serviceType)
    {
        return GetServiceInternal(serviceType, null);
    }
    /*object*/ GetKeyedService(/*Type*/ serviceType, /*object*/ serviceKey)
    {
        return GetServiceInternal(serviceType, serviceKey);
    }
    /*object*/ GetRequiredKeyedService(/*Type*/ serviceType, /*object*/ serviceKey)
    {
        return BlazorJs.FirstOf(GetServiceInternal(serviceType, serviceKey), function(){ throw new InvalidOperationException(`Cannot resolve ${serviceType.FullName}`) });
    }
}

const BlazorJs_ServiceProvider_IServiceResolver = (Base) => class extends Base
{
}

class BlazorJs_ServiceProvider_ServiceCollectionResolver extends BlazorJs_ServiceProvider_IServiceResolver(object)
{
    /*IServiceCollection*/ _services = null;
    /*Dictionary<(Type, object), Dictionary<ServiceDescriptor, ServiceInstanceActivator>>*/ _activators = new Dictionary(BlazorJs.TupleType(Type, object), Dictionary(ServiceDescriptor, ServiceInstanceActivator))();
    constructor(/*IServiceCollection*/ services)
    {
        super();
        _services = services;
    }
    /*Dictionary<ServiceDescriptor, ServiceInstanceActivator>*/ GetActivators(/*Type*/ serviceType, /*object*/ serviceKey, /*IServiceProvider*/ serviceProvider)
    {
        let activatorsForSeviceDescriptors = null;
        let $ref1 = { set value(v){ activatorsForSeviceDescriptors = v } };
        if (_activators.TryGetValue(BlazorJs.TupleValue({ Item1: serviceType, Item2: serviceKey }), $ref1))
        {
            activatorsForSeviceDescriptors = new Dictionary(ServiceDescriptor, ServiceInstanceActivator)();
            _activators[BlazorJs.TupleValue({ Item1: serviceType, Item2: serviceKey })] = activatorsForSeviceDescriptors;
            _services.Match(serviceType, serviceKey, function(/**/ descriptor)
            {
                let activator = null;
                let $ref1 = { set value(v){ activator = v } };
                if (activatorsForSeviceDescriptors.TryGetValue(descriptor, $ref1))
                {
                    /*ServiceInstanceActivator*/ let instanceActivator = null;
                    if (descriptor.IsKeyedService  && descriptor.KeyedImplementationFactory  !== null || descriptor.IsKeyedService  && descriptor.ImplementationFactory  !== null)
                    {
                        instanceActivator = new ServiceFactoryInstanceActivator(descriptor);
                    }
                    else if (descriptor.IsKeyedService  && descriptor.KeyedImplementationInstance  !== null || descriptor.IsKeyedService  && descriptor.ImplementationInstance  !== null)
                    {
                        instanceActivator = new ServiceInstanceInstanceActivator(descriptor);
                    }
                    else if (descriptor.IsKeyedService  && descriptor.KeyedImplementationType  !== null || descriptor.IsKeyedService  && descriptor.ImplementationType  !== null)
                    {
                        instanceActivator = new ServiceConstructorActivator(descriptor, serviceType, serviceKey, serviceProvider);
                    }
                    else 
                    {
                        throw new InvalidOperationException("Unknown Error");
                    }
                    activatorsForSeviceDescriptors[descriptor] = instanceActivator;
                }
            });
        }
        return activatorsForSeviceDescriptors;
    }
    /*object*/ TryResolve(/*IServiceProvider*/ serviceProvider, /*Type*/ serviceType, /*object*/ serviceKey, /*bool*/ all, /*ServiceLifetime*/ currentScope)
    {
        //lock
        {
            /*var*/ let activatorsForType = GetActivators(serviceType, serviceKey, serviceProvider);
            if (activatorsForType.Any() && all)
            {
                return null;
            }
            if (all)
            {
                return activatorsForType.Select(function(/**/ a)
                {
                    return a.Value.Activate(serviceProvider);
                });
            }
            else 
            {
                /*var*/ let activator = activatorsForType.First();
                return activator.Value.Activate(serviceProvider);
            }
        }
    }
}

class BlazorJs_ServiceProvider_ServiceConstructorActivator extends BlazorJs_ServiceProvider_ServiceInstanceActivator
{
    /*Type*/ implementationType = null;
    /*ConstructorInfo*/ $constructor = null;
    /*object*/ serviceKey = null;
    constructor(/*ServiceDescriptor*/ descriptor, /*Type*/ serviceType, /*object*/ serviceKey, /*IServiceProvider*/ serviceProvider)
    {
        super(descriptor);
        implementationType = descriptor.IsKeyedService  ? descriptor.KeyedImplementationType  : descriptor.ImplementationType;
        if (implementationType.IsGenericTypeDefinition  && serviceType.IsGenericType)
        {
            /*var*/ let args = serviceType.GetGenericArguments();
            implementationType = implementationType.MakeGenericType(args);
        }
        /*var*/ let constructors = implementationType.GetConstructors();
        if (constructors.Length  === 0)
        {
            throw new InvalidOperationException(`No public constructor is defined on ${implementationType.Name}`);
        }
        else if (constructors.Length  > 1)
        {
            /*int*/ let maxW = 0;
            BlazorJs.forEach(constructors, function(c, $_i)
            {
                /*var*/ let w = 0;
                /*var*/ let parameters = c.GetParameters();
                if (parameters.All(function(/**/ p)
                {
                    return (BlazorJs.Cast(serviceProvider, IServiceCollection)).GetServiceDescriptors(p.ParameterType, null).Any();
                }))
                {
                    /*var*/ let parametersCount = parameters.Length;
                    w = parametersCount;
                }
                if (w > maxW)
                {
                    $constructor = c;
                    maxW = w;
                }
            });
            if ($constructor === null)
            throw new InvalidOperationException(`No constructor on ${serviceType.FullName} can be used to instatiate it from the container`);
        }
        else 
        {
            $constructor = constructors[0];
        }
        this.serviceKey  = serviceKey;
    }
    /*object*/ Activate(/*IServiceProvider*/ serviceProvider)
    {
        /*var*/ let types = $constructor.GetParameters();
        /*var*/ let parameters = types.Select(function(/**/ t)
        {
            if (serviceKey !== null)
            {
                /*var*/ let service = serviceProvider.GetKeyedService(t.ParameterType, serviceKey);
                if (service !== null)
                return service;
            }
            return serviceProvider.GetRequiredService(t.ParameterType);
        }).ToArray();
        return $constructor.Invoke(parameters);
    }
}

class BlazorJs_ServiceProvider_ServiceFactoryInstanceActivator extends BlazorJs_ServiceProvider_ServiceInstanceActivator
{
    constructor(/*ServiceDescriptor*/ descriptor)
    {
        super(descriptor);
    }
    /*object*/ Activate(/*IServiceProvider*/ serviceProvider)
    {
        if (Descriptor.IsKeyedService)
        return Descriptor.KeyedImplementationFactory(serviceProvider, Descriptor.ServiceKey);
        else 
        return Descriptor.ImplementationFactory(serviceProvider);
    }
}

class BlazorJs_ServiceProvider_ServiceInstanceActivator extends object
{
    /*ServiceDescriptor*/ _backingField_Descriptor = null;
    /*ServiceDescriptor*/ get Descriptor()
    {
        return _backingField_Descriptor;
    }
    constructor(/*ServiceDescriptor*/ descriptor)
    {
        super();
        Descriptor = descriptor;
    }
}

class BlazorJs_ServiceProvider_ServiceInstanceInstanceActivator extends BlazorJs_ServiceProvider_ServiceInstanceActivator
{
    constructor(/*ServiceDescriptor*/ descriptor)
    {
        super(descriptor);
    }
    /*object*/ Activate(/*IServiceProvider*/ serviceProvider)
    {
        if (Descriptor.IsKeyedService)
        return Descriptor.KeyedImplementationInstance;
        else 
        return Descriptor.ImplementationInstance;
    }
}

static class System_ArgumentExceptionExtension
{
    /*void*/ static ThrowIfNullOrEmpty(/*string*/ o)
    {
        if (string.IsNullOrEmpty(o))
        throw new NullReferenceException();
    }
    /*void*/ static ThrowIfNullOrWhiteSpace(/*string*/ o)
    {
        if (string.IsNullOrWhiteSpace(o))
        throw new NullReferenceException();
    }
}

static class System_ArgumentNullExceptionExtension
{
    /*void*/ static ThrowIfNull(/*object*/ o, { /*string*/ name = null})
    {
        if (o === null)
        throw new NullReferenceException();
    }
}

class System_DateOnly extends System_ValueType
{
    constructor()
    {
        super();
    }
}

class System_HashCode extends object
{
    constructor()
    {
        super();
    }
    /*int*/ code = 897534562;
    /*void*/ Add(/*object*/ c)
    {
        /*var*/ let cc = c.GetHashCode();
        code ^= cc;
    }
    /*int*/ ToHashCode()
    {
        return code;
    }
    /*int*/ static Combine(T1, T2, /*T1*/ t1, /*T2*/ t2)
    {
        /*HashCode*/ let hc = new HashCode();
        hc.Add(t1);
        hc.Add(t2);
        return hc.ToHashCode();
    }
    /*int*/ static Combine(T1, T2, T3, /*T1*/ t1, /*T2*/ t2, /*T3*/ t3)
    {
        /*HashCode*/ let hc = new HashCode();
        hc.Add(t1);
        hc.Add(t2);
        hc.Add(t3);
        return hc.ToHashCode();
    }
    /*int*/ static Combine(T1, T2, T3, T4, /*T1*/ t1, /*T2*/ t2, /*T3*/ t3, /*T4*/ t4)
    {
        /*HashCode*/ let hc = new HashCode();
        hc.Add(t1);
        hc.Add(t2);
        hc.Add(t3);
        hc.Add(t4);
        return hc.ToHashCode();
    }
    /*int*/ static Combine(T1, T2, T3, T4, T5, /*T1*/ t1, /*T2*/ t2, /*T3*/ t3, /*T4*/ t4, /*T5*/ t5)
    {
        /*HashCode*/ let hc = new HashCode();
        hc.Add(t1);
        hc.Add(t2);
        hc.Add(t3);
        hc.Add(t4);
        hc.Add(t5);
        return hc.ToHashCode();
    }
    /*int*/ static Combine(T1, T2, T3, T4, T5, T6, /*T1*/ t1, /*T2*/ t2, /*T3*/ t3, /*T4*/ t4, /*T5*/ t5, /*T6*/ t6)
    {
        /*HashCode*/ let hc = new HashCode();
        hc.Add(t1);
        hc.Add(t2);
        hc.Add(t3);
        hc.Add(t4);
        hc.Add(t5);
        hc.Add(t6);
        return hc.ToHashCode();
    }
    /*int*/ static Combine(T1, T2, T3, T4, T5, T6, T7, /*T1*/ t1, /*T2*/ t2, /*T3*/ t3, /*T4*/ t4, /*T5*/ t5, /*T6*/ t6, /*T7*/ t7)
    {
        /*HashCode*/ let hc = new HashCode();
        hc.Add(t1);
        hc.Add(t2);
        hc.Add(t3);
        hc.Add(t4);
        hc.Add(t5);
        hc.Add(t6);
        hc.Add(t7);
        return hc.ToHashCode();
    }
    /*int*/ static Combine(T1, T2, T3, T4, T5, T6, T7, T8, /*T1*/ t1, /*T2*/ t2, /*T3*/ t3, /*T4*/ t4, /*T5*/ t5, /*T6*/ t6, /*T7*/ t7, /*T8*/ t8)
    {
        /*HashCode*/ let hc = new HashCode();
        hc.Add(t1);
        hc.Add(t2);
        hc.Add(t3);
        hc.Add(t4);
        hc.Add(t5);
        hc.Add(t6);
        hc.Add(t7);
        hc.Add(t8);
        return hc.ToHashCode();
    }
}

const System_IAsyncEnumerable = (T, Base) => class extends Base
{
}
const System_IAsyncEnumerator = (T, Base) => class extends Base
{
    /*T*/ _backingField_Current = null;
    /*T*/ get Current()
    {
        return _backingField_Current;
    }
}
const System_IAsyncDisposable = (Base) => class extends Base
{
}

class System_Index extends H5_IH5Class(System_IEquatable(System_Index)(System_ValueType))
{
    constructor(/*int*/ value, /*bool*/ fromEnd)
    {
        super();
        Value = value;
        IsFromEnd = fromEnd;
    }
    /*Index*/ _backingField_End = null;
    /*Index*/ static get End()
    {
        return _backingField_End;
    }
    /*Index*/ _backingField_Start = null;
    /*Index*/ static get Start()
    {
        return _backingField_Start;
    }
    /*bool*/ _backingField_IsFromEnd = null;
    /*bool*/ get IsFromEnd()
    {
        return _backingField_IsFromEnd;
    }
    /*int*/ _backingField_Value = null;
    /*int*/ get Value()
    {
        return _backingField_Value;
    }
    /*Index*/ static FromEnd(/*int*/ value)
    {
        return new Index(value, true);
    }
    /*Index*/ static FromStart(/*int*/ value)
    {
        return new Index(value, false);
    }
    /*bool*/ Equals(/*Index*/ other)
    {
        return other.Value  === Value && other.IsFromEnd  === IsFromEnd;
    }
    /*bool*/ Equals(/*object*/ value)
    {
        if (value instanceof Index, other = value)
        return Equals(other);
        return false;
    }
    /*int*/ GetHashCode()
    {
        return HashCode.Combine(Value, IsFromEnd);
    }
    /*int*/ GetOffset(/*int*/ length)
    {
        if (IsFromEnd)
        {
            return length - 1 - Value;
        }
        return Value;
    }
    /*string*/ ToString()
    {
        return Value.ToString();
    }
    /*Index*/ static $op_Implicit_Index(/*int*/ value)
    {
        return new Index(value, value < 0);
    }
    /*int*/ static $op_Implicit_int(/*Index*/ value)
    {
        return value.Value;
    }
}

const System_IProgress = (/*in*/ T, Base) => class extends Base
{
}

const System_IServiceScope = (Base) => class extends Base
{
    /*IServiceProvider*/ _backingField_Service = null;
    /*IServiceProvider*/ get Service()
    {
        return _backingField_Service;
    }
}
static class System_ServiceProviderExtensions
{
    static System_ServiceProviderExtensions_ServiceScope = class extends System_IServiceScope(object)
    {
        /*IServiceProvider*/ _backingField_Service = null;
        /*IServiceProvider*/ get Service()
        {
            return _backingField_Service;
        }
        /*IServiceProvider*/ set Service(value)
        {
            _backingField_Service = value;
        }
        constructor(/*IServiceProvider*/ serviceProvider)
        {
            super();
            Service = serviceProvider;
        }
    }
    /*IServiceScope*/ static CreateScope(/*this IServiceProvider*/ serviceProvider)
    {
        return new ServiceScope(serviceProvider);
    }
}


class System_Range extends H5_IH5Class(System_IEquatable(System_Range)(System_ValueType))
{
    constructor(/*Index*/ start, /*Index*/ end)
    {
        super();
        Start = start;
        End = end;
    }
    /*Range*/ _backingField_All = null;
    /*Range*/ static get All()
    {
        return _backingField_All;
    }
    /*Index*/ _backingField_End = null;
    /*Index*/ get End()
    {
        return _backingField_End;
    }
    /*Index*/ _backingField_Start = null;
    /*Index*/ get Start()
    {
        return _backingField_Start;
    }
    /*Range*/ static EndAt(/*Index*/ end)
    {
        return new Range(0, end);
    }
    /*Range*/ static StartAt(/*Index*/ start)
    {
        return new Range(start, 1);
    }
    /*bool*/ Equals(/*object*/ value)
    {
        if (value instanceof Range, other = value)
        return Equals(other);
        return false;
    }
    /*bool*/ Equals(/*Range*/ other)
    {
        return Start.Equals(other.Start) && End.Equals(other.End);
    }
    /*int*/ GetHashCode()
    {
        return HashCode.Combine(Start, End);
    }
    /*(int Offset, int Length)*/ GetOffsetAndLength(/*int*/ length)
    {
        /*var*/ let startOffset = Start.GetOffset(length);
        return BlazorJs.TupleValue({ Item1: startOffset, Item2: length });
    }
    /*string*/ ToString()
    {
        return Start.ToString() + " to " + End.ToString();
    }
    /*int*/ get Length()
    {
        return End - Start + 1;
    }
}

const System_ReadOnlyMemory = (T) => class extends System_ValueType
{
    /*ReadOnlySpan<T>*/ static Empty = BlazorJs.getDefault();
    /*ReadOnlySpan<T>*/ _span = null;
    constructor(/*T[]*/ t, /*int*/ offset, /*int*/ length)
    {
        super();
        _span = new ReadOnlySpan(T)(t, offset, length);
    }
    constructor(/*ReadOnlySpan<T>*/ span)
    {
        super();
        this._span  = span;
    }
    /*ReadOnlySpan<T>*/ get Span()
    {
        return _span;
    }
    /*int*/ get Length()
    {
        return _span.Length;
    }
    /*ReadOnlyMemory<T>*/ Slice(/*int*/ start, { /*int*/ length = 1})
    {
        return new ReadOnlyMemory(T)(_span.Slice(start, length));
    }
}

const System_ReadOnlySpan = (T) => class extends H5_IH5Class(System_Collections_IEnumerable(System_Collections_Generic_IEnumerable(T)(System_ValueType)))
{
    /*T[]*/ _t = null;
    /*int*/ _offset = null;
    /*int*/ _length = null;
    /*ReadOnlySpan<T>*/ static Empty = BlazorJs.getDefault();
    constructor(/*T[]*/ t, /*int*/ offset, /*int*/ length)
    {
        super();
        _t = t;
        _offset = offset;
        if (length === 1)
        {
            if (t !== null)
            length = t.Length  - offset;
            else 
            length = 0;
        }
        _length = length;
    }
    /*int*/ get Offset()
    {
        return _offset;
    }
    /*bool*/ get IsEmpty()
    {
        return _length === 0;
    }
    /*int*/ get Length()
    {
        return _length;
    }
    /*T*/ getItem(/*int*/ index)
    {
        return _t[index + _offset];
    }
    /*void*/ ForEach(/*Func<T, int, bool>*/ iterator)
    {
        for(/*int*/ let i = 0; i < Length; i++)
        {
            if (iterator(this[i], i) === false)
            break;
        }
    }
    /*void*/ ReverseForEach(/*Func<T, int, bool>*/ iterator)
    {
        for(/*int*/ let i = Length - 1; i >= 0; i--)
        {
            if (iterator(this[i], i) === false)
            break;
        }
    }
    /*ReadOnlySpan<T>*/ getItem(/*Range*/ index)
    {
        return Slice(index.Start, index.Length);
    }
    /*ReadOnlySpan<T>*/ Slice(/*int*/ start, { /*int*/ length = 1})
    {
        if (length === 1)
        {
            length = _length - (start + _offset);
        }
        return new ReadOnlySpan(T)(_t, start + _offset, length);
    }
    /*void*/ CopyTo(/*Span<T>*/ destination)
    {
        ForEach(function(/**/ t, /**/ i)
        {
            destination[i] = t;
            return true;
        });
    }
    /*void*/ CopyTo(/*Stream*/ destination)
    {
        destination.Write(BlazorJs.Cast(BlazorJs.Cast(_t, object), byte), _offset, _length);
    }
    /*T[]*/ ToArray()
    {
        /*var*/ let newT = new Array(Length);
        ForEach(function(/**/ t, /**/ i)
        {
            newT[i] = t;
            return true;
        });
        return newT;
    }
    /*bool*/ Contains(/*T*/ c)
    {
        /*bool*/ let result = false;
        ForEach(function(/**/ t, /**/ i)
        {
            if (c.Equals(t))
            {
                result = true;
                return false;
            }
            return true;
        });
        return result;
    }
    /*bool*/ ContainsAny(/*params T[]*/ chars)
    {
        /*bool*/ let result = false;
        ForEach(function(/**/ t, /**/ i)
        {
            if (chars.Any(function(/**/ c)
            {
                return c.Equals(t);
            }))
            {
                result = true;
                return false;
            }
            return true;
        });
        return result;
    }
    /*bool*/ ContainsAnyExcept(/*params T[]*/ chars)
    {
        /*bool*/ let result = false;
        ForEach(function(/**/ t, /**/ i)
        {
            if (chars.Any(function(/**/ c)
            {
                return c.Equals(t);
            }))
            {
                result = true;
                return false;
            }
            return true;
        });
        return result;
    }
    /*int*/ IndexOf(/*T*/ c)
    {
        /*int*/ let index = 1;
        ForEach(function(/**/ t, /**/ i)
        {
            if (c.Equals(t))
            {
                index = i;
                return false;
            }
            return true;
        });
        return index;
    }
    /*int*/ LastIndexOf(/*T*/ c)
    {
        /*int*/ let index = 1;
        ReverseForEach(function(/**/ t, /**/ i)
        {
            if (c.Equals(t))
            {
                index = i;
                return false;
            }
            return true;
        });
        return index;
    }
    /*int*/ IndexOfAny(/*params T[]*/ chars)
    {
        /*int*/ let index = 1;
        ForEach(function(/**/ t, /**/ i)
        {
            if (chars.Any(function(/**/ c)
            {
                return c.Equals(t);
            }))
            {
                index = i;
                return false;
            }
            return true;
        });
        return index;
    }
    /*int*/ IndexOfAnyExcept(/*params T[]*/ chars)
    {
        /*int*/ let index = 1;
        ForEach(function(/**/ t, /**/ i)
        {
            if (chars.Any(function(/**/ c)
            {
                return c.Equals(t);
            }))
            {
                index = i;
                return false;
            }
            return true;
        });
        return index;
    }
    /*bool*/ StartsWith(/*T*/ needle)
    {
        return _length > 0 && this[0].Equals(needle);
    }
    /*bool*/ StartsWith(/*ReadOnlySpan<T>*/ other)
    {
        if (Length < other.Length)
        return false;
        /*bool*/ let starts = true;
        /*var*/ let me = this;
        other.ForEach(function(/**/ t, /**/ i)
        {
            /*bool*/ let eq = t.Equals(me[i]);
            if (eq)
            {
                return true;
            }
            starts = false;
            return false;
        });
        return starts;
    }
    /*int*/ Split(/*Span<Range>*/ ranges, /*T*/ delimiter)
    {
        /*int*/ let r_i = 0;
        /*int*/ let start = 0;
        ForEach(function(/**/ t, /**/ i)
        {
            if (delimiter.Equals(t))
            {
                ranges[r_i++] = new Range(start, i - 1);
                start = i + 1;
            }
            return true;
        });
        if (start > 0)
        {
            ranges[r_i++] = new Range(start, Length - 1);
        }
        return r_i;
    }
    /*ReadOnlySpan<T>*/ static $op_Implicit_ReadOnlySpan(/*T[]*/ ts)
    {
        return new ReadOnlySpan(T)(ts);
    }
    /*string*/ static $op_Implicit_string(/*ReadOnlySpan<T>*/ span)
    {
        return span.ToString();
    }
    /*string*/ ToString()
    {
        if (T === char)
        return (BlazorJs.Cast(BlazorJs.Cast(this, object), ReadOnlySpan(char))).AsString();
        return super.ToString();
    }
    /*IEnumerator<T>*/ GetEnumerator()
    {
        return new ReadOnlySpanEnumerator(this);
    }
    /*IEnumerator*/ GetEnumerator()
    {
        return new ReadOnlySpanEnumerator(this);
    }
    static System_ReadOnlySpan_ReadOnlySpanEnumerator = class extends System_Collections_IEnumerator(System_IDisposable(System_Collections_Generic_IEnumerator(T)(object)))
    {
        /*ReadOnlySpan<T>*/ span = null;
        /*int*/ index = 1;
        constructor(/*ReadOnlySpan<T>*/ span)
        {
            super();
            this.span  = span;
        }
        /*T*/ get Current()
        {
            return span[index];
        }
        /*object*/ get Current()
        {
            return span[index];
        }
        /*void*/ Dispose()
        {
            throw new NotImplementedException();
        }
        /*bool*/ MoveNext()
        {
            index++;
            return index < span.Length;
        }
        /*void*/ Reset()
        {
            index = 1;
        }
    }
}

class System_ServiceDescriptor extends object
{
    /*Type*/ _implementationType = null;
    /*object*/ _implementationInstance = null;
    /*object*/ _implementationFactory = null;
    /*ServiceLifetime*/ _backingField_Lifetime = null;
    /*ServiceLifetime*/ get Lifetime()
    {
        return _backingField_Lifetime;
    }
    /*object*/ _backingField_ServiceKey = null;
    /*object*/ get ServiceKey()
    {
        return _backingField_ServiceKey;
    }
    /*Type*/ _backingField_ServiceType = null;
    /*Type*/ get ServiceType()
    {
        return _backingField_ServiceType;
    }
    /*Type*/ get ImplementationType()
    {
        if (IsKeyedService)
        {
            ThrowKeyedDescriptor();
        }
        return _implementationType;
    }
    /*Type*/ get KeyedImplementationType()
    {
        if (IsKeyedService)
        {
            ThrowNonKeyedDescriptor();
        }
        return _implementationType;
    }
    /*object*/ get ImplementationInstance()
    {
        if (IsKeyedService)
        {
            ThrowKeyedDescriptor();
        }
        return _implementationInstance;
    }
    /*object*/ get KeyedImplementationInstance()
    {
        if (IsKeyedService)
        {
            ThrowNonKeyedDescriptor();
        }
        return _implementationInstance;
    }
    /*Func<IServiceProvider, object>*/ get ImplementationFactory()
    {
        if (IsKeyedService)
        {
            ThrowKeyedDescriptor();
        }
        return BlazorJs.Cast(_implementationFactory, Func(IServiceProvider, object));
    }
    /*Func<IServiceProvider, object, object>*/ get KeyedImplementationFactory()
    {
        if (IsKeyedService)
        {
            ThrowNonKeyedDescriptor();
        }
        return BlazorJs.Cast(_implementationFactory, Func(IServiceProvider, object, object));
    }
    /*bool*/ get IsKeyedService()
    {
        return ServiceKey !== null;
    }
    constructor(/*Type*/ serviceType, /*Type*/ implementationType, /*ServiceLifetime*/ lifetime)
    {
        super(serviceType, null, implementationType, lifetime);
    }
    constructor(/*Type*/ serviceType, /*object*/ serviceKey, /*Type*/ implementationType, /*ServiceLifetime*/ lifetime)
    {
        super(serviceType, serviceKey, lifetime);
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(implementationType, "implementationType");
        _implementationType = implementationType;
    }
    constructor(/*Type*/ serviceType, /*object*/ instance)
    {
        super(serviceType, null, instance);
    }
    constructor(/*Type*/ serviceType, /*object*/ serviceKey, /*object*/ instance)
    {
        super(serviceType, serviceKey, ServiceLifetime.Singleton);
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(instance, "instance");
        _implementationInstance = instance;
    }
    constructor(/*Type*/ serviceType, /*Func<IServiceProvider, object>*/ factory, /*ServiceLifetime*/ lifetime)
    {
        super(serviceType, BlazorJs.Cast(null, object), lifetime);
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(factory, "factory");
        _implementationFactory = factory;
    }
    constructor(/*Type*/ serviceType, /*object*/ serviceKey, /*Func<IServiceProvider, object, object>*/ factory, /*ServiceLifetime*/ lifetime)
    {
        super(serviceType, serviceKey, lifetime);
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(factory, "factory");
        if (serviceKey === null)
        {
            /*Func<IServiceProvider, object>*/ let implementationFactory = function(/**/ sp)
            {
                return factory(sp, null);
            };
            _implementationFactory = implementationFactory;
        }
        else 
        {
            _implementationFactory = factory;
        }
    }
    constructor(/*Type*/ serviceType, /*object*/ serviceKey, /*ServiceLifetime*/ lifetime)
    {
        super();
        Lifetime = lifetime;
        ServiceType = serviceType;
        ServiceKey = serviceKey;
    }
    /*string*/ ToString()
    {
        /*string*/ let text = `${"ServiceType"}: ${ServiceType} ${"Lifetime"}: ${Lifetime} `;
        if (IsKeyedService)
        {
            text += `${"ServiceKey"}: ${ServiceKey} `;
            if (KeyedImplementationType !== null)
            {
                return text + `${"KeyedImplementationType"}: ${KeyedImplementationType}`;
            }
            if (KeyedImplementationFactory !== null)
            {
                return text + `${"KeyedImplementationFactory"}: ${KeyedImplementationFactory}`;
            }
            return text + `${"KeyedImplementationInstance"}: ${KeyedImplementationInstance}`;
        }
        if (ImplementationType !== null)
        {
            return text + `${"ImplementationType"}: ${ImplementationType}`;
        }
        if (ImplementationFactory !== null)
        {
            return text + `${"ImplementationFactory"}: ${ImplementationFactory}`;
        }
        return text + `${"ImplementationInstance"}: ${ImplementationInstance}`;
    }
    /*Type*/ GetImplementationType()
    {
        if (ServiceKey === null)
        {
            if (ImplementationType !== null)
            {
                return ImplementationType;
            }
            if (ImplementationInstance !== null)
            {
                return ImplementationInstance.GetType();
            }
            if (ImplementationFactory !== null)
            {
                /*Type[]*/ let genericTypeArguments = ImplementationFactory.GetType().GetGenericArguments();
                return genericTypeArguments[1];
            }
        }
        else 
        {
            if (KeyedImplementationType !== null)
            {
                return KeyedImplementationType;
            }
            if (KeyedImplementationInstance !== null)
            {
                return KeyedImplementationInstance.GetType();
            }
            if (KeyedImplementationFactory !== null)
            {
                /*Type[]*/ let genericTypeArguments2 = KeyedImplementationFactory.GetType().GetGenericArguments();
                return genericTypeArguments2[2];
            }
        }
        return null;
    }
    /*ServiceDescriptor*/ static Transient(TService, TImplementation)
    {
        return DescribeKeyed(TService, TImplementation)(TService, TImplementation, null, ServiceLifetime.Transient);
    }
    /*ServiceDescriptor*/ static KeyedTransient(TService, TImplementation, /*object*/ serviceKey)
    {
        return DescribeKeyed(TService, TImplementation)(TService, TImplementation, serviceKey, ServiceLifetime.Transient);
    }
    /*ServiceDescriptor*/ static Transient(/*Type*/ service, /*Type*/ implementationType)
    {
        ThrowHelperExtension.ThrowIfNull(service, "service");
        ThrowHelperExtension.ThrowIfNull(implementationType, "implementationType");
        return Describe(service, implementationType, ServiceLifetime.Transient);
    }
    /*ServiceDescriptor*/ static KeyedTransient(/*Type*/ service, /*object*/ serviceKey, /*Type*/ implementationType)
    {
        ThrowHelperExtension.ThrowIfNull(service, "service");
        ThrowHelperExtension.ThrowIfNull(implementationType, "implementationType");
        return DescribeKeyed(service, serviceKey, implementationType, ServiceLifetime.Transient);
    }
    /*ServiceDescriptor*/ static Transient(TService, TImplementation, /*Func<IServiceProvider, TImplementation>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return Describe(TService, function(/**/ sp)
        {
            return implementationFactory(sp);
        }, ServiceLifetime.Transient);
    }
    /*ServiceDescriptor*/ static KeyedTransient(TService, TImplementation, /*object*/ serviceKey, /*Func<IServiceProvider, object, TImplementation>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return DescribeKeyed(TService, serviceKey, function(/**/ sp, /**/ key)
        {
            return implementationFactory(sp, key);
        }, ServiceLifetime.Transient);
    }
    /*ServiceDescriptor*/ static Transient(TService, /*Func<IServiceProvider, TService>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return Describe(TService, function(/**/ sp)
        {
            return implementationFactory(sp);
        }, ServiceLifetime.Transient);
    }
    /*ServiceDescriptor*/ static KeyedTransient(TService, /*object*/ serviceKey, /*Func<IServiceProvider, object, TService>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return DescribeKeyed(TService, serviceKey, function(/**/ sp, /**/ key)
        {
            return implementationFactory(sp, key);
        }, ServiceLifetime.Transient);
    }
    /*ServiceDescriptor*/ static Transient(/*Type*/ service, /*Func<IServiceProvider, object>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(service, "service");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return Describe(service, implementationFactory, ServiceLifetime.Transient);
    }
    /*ServiceDescriptor*/ static KeyedTransient(/*Type*/ service, /*object*/ serviceKey, /*Func<IServiceProvider, object, object>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(service, "service");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return DescribeKeyed(service, serviceKey, implementationFactory, ServiceLifetime.Transient);
    }
    /*ServiceDescriptor*/ static Scoped(TService, TImplementation)
    {
        return DescribeKeyed(TService, TImplementation)(TService, TImplementation, null, ServiceLifetime.Scoped);
    }
    /*ServiceDescriptor*/ static KeyedScoped(TService, TImplementation, /*object*/ serviceKey)
    {
        return DescribeKeyed(TService, TImplementation)(TService, TImplementation, serviceKey, ServiceLifetime.Scoped);
    }
    /*ServiceDescriptor*/ static Scoped(/*Type*/ service, /*Type*/ implementationType)
    {
        return Describe(service, implementationType, ServiceLifetime.Scoped);
    }
    /*ServiceDescriptor*/ static KeyedScoped(/*Type*/ service, /*object*/ serviceKey, /*Type*/ implementationType)
    {
        return DescribeKeyed(service, serviceKey, implementationType, ServiceLifetime.Scoped);
    }
    /*ServiceDescriptor*/ static Scoped(TService, TImplementation, /*Func<IServiceProvider, TImplementation>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return Describe(TService, function(/**/ sp)
        {
            return implementationFactory(sp);
        }, ServiceLifetime.Scoped);
    }
    /*ServiceDescriptor*/ static KeyedScoped(TService, TImplementation, /*object*/ serviceKey, /*Func<IServiceProvider, object, TImplementation>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return DescribeKeyed(TService, serviceKey, function(/**/ sp, /**/ key)
        {
            return implementationFactory(sp, key);
        }, ServiceLifetime.Scoped);
    }
    /*ServiceDescriptor*/ static Scoped(TService, /*Func<IServiceProvider, TService>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return Describe(TService, function(/**/ sp)
        {
            return implementationFactory(sp);
        }, ServiceLifetime.Scoped);
    }
    /*ServiceDescriptor*/ static KeyedScoped(TService, /*object*/ serviceKey, /*Func<IServiceProvider, object, TService>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return DescribeKeyed(TService, serviceKey, function(/**/ sp, /**/ key)
        {
            return implementationFactory(sp, key);
        }, ServiceLifetime.Scoped);
    }
    /*ServiceDescriptor*/ static Scoped(/*Type*/ service, /*Func<IServiceProvider, object>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(service, "service");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return Describe(service, implementationFactory, ServiceLifetime.Scoped);
    }
    /*ServiceDescriptor*/ static KeyedScoped(/*Type*/ service, /*object*/ serviceKey, /*Func<IServiceProvider, object, object>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(service, "service");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return DescribeKeyed(service, serviceKey, implementationFactory, ServiceLifetime.Scoped);
    }
    /*ServiceDescriptor*/ static Singleton(TService, TImplementation)
    {
        return DescribeKeyed(TService, TImplementation)(TService, TImplementation, null, ServiceLifetime.Singleton);
    }
    /*ServiceDescriptor*/ static KeyedSingleton(TService, TImplementation, /*object*/ serviceKey)
    {
        return DescribeKeyed(TService, TImplementation)(TService, TImplementation, serviceKey, ServiceLifetime.Singleton);
    }
    /*ServiceDescriptor*/ static Singleton(/*Type*/ service, /*Type*/ implementationType)
    {
        ThrowHelperExtension.ThrowIfNull(service, "service");
        ThrowHelperExtension.ThrowIfNull(implementationType, "implementationType");
        return Describe(service, implementationType, ServiceLifetime.Singleton);
    }
    /*ServiceDescriptor*/ static KeyedSingleton(/*Type*/ service, /*object*/ serviceKey, /*Type*/ implementationType)
    {
        ThrowHelperExtension.ThrowIfNull(service, "service");
        ThrowHelperExtension.ThrowIfNull(implementationType, "implementationType");
        return DescribeKeyed(service, serviceKey, implementationType, ServiceLifetime.Singleton);
    }
    /*ServiceDescriptor*/ static Singleton(TService, TImplementation, /*Func<IServiceProvider, TImplementation>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return Describe(TService, function(/**/ sp)
        {
            return implementationFactory(sp);
        }, ServiceLifetime.Singleton);
    }
    /*ServiceDescriptor*/ static KeyedSingleton(TService, TImplementation, /*object*/ serviceKey, /*Func<IServiceProvider, object, TImplementation>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return DescribeKeyed(TService, serviceKey, function(/**/ sp, /**/ key)
        {
            return implementationFactory(sp, key);
        }, ServiceLifetime.Singleton);
    }
    /*ServiceDescriptor*/ static Singleton(TService, /*Func<IServiceProvider, TService>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return Describe(TService, function(/**/ sp)
        {
            return implementationFactory(sp);
        }, ServiceLifetime.Singleton);
    }
    /*ServiceDescriptor*/ static KeyedSingleton(TService, /*object*/ serviceKey, /*Func<IServiceProvider, object, TService>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return DescribeKeyed(TService, serviceKey, function(/**/ sp, /**/ key)
        {
            return implementationFactory(sp, key);
        }, ServiceLifetime.Singleton);
    }
    /*ServiceDescriptor*/ static Singleton(/*Type*/ serviceType, /*Func<IServiceProvider, object>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return Describe(serviceType, implementationFactory, ServiceLifetime.Singleton);
    }
    /*ServiceDescriptor*/ static KeyedSingleton(/*Type*/ serviceType, /*object*/ serviceKey, /*Func<IServiceProvider, object, object>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return DescribeKeyed(serviceType, serviceKey, implementationFactory, ServiceLifetime.Singleton);
    }
    /*ServiceDescriptor*/ static Singleton(TService, /*TService*/ implementationInstance)
    {
        ThrowHelperExtension.ThrowIfNull(implementationInstance, "implementationInstance");
        return Singleton(TService, implementationInstance);
    }
    /*ServiceDescriptor*/ static KeyedSingleton(TService, /*object*/ serviceKey, /*TService*/ implementationInstance)
    {
        ThrowHelperExtension.ThrowIfNull(implementationInstance, "implementationInstance");
        return KeyedSingleton(TService, serviceKey, implementationInstance);
    }
    /*ServiceDescriptor*/ static Singleton(/*Type*/ serviceType, /*object*/ implementationInstance)
    {
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(implementationInstance, "implementationInstance");
        return new ServiceDescriptor(serviceType, implementationInstance);
    }
    /*ServiceDescriptor*/ static KeyedSingleton(/*Type*/ serviceType, /*object*/ serviceKey, /*object*/ implementationInstance)
    {
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(implementationInstance, "implementationInstance");
        return new ServiceDescriptor(serviceType, serviceKey, implementationInstance);
    }
    /*ServiceDescriptor*/ static DescribeKeyed(TService, TImplementation, /*object*/ serviceKey, /*ServiceLifetime*/ lifetime)
    {
        return DescribeKeyed(TService, serviceKey, TImplementation, lifetime);
    }
    /*ServiceDescriptor*/ static Describe(/*Type*/ serviceType, /*Type*/ implementationType, /*ServiceLifetime*/ lifetime)
    {
        return new ServiceDescriptor(serviceType, implementationType, lifetime);
    }
    /*ServiceDescriptor*/ static DescribeKeyed(/*Type*/ serviceType, /*object*/ serviceKey, /*Type*/ implementationType, /*ServiceLifetime*/ lifetime)
    {
        return new ServiceDescriptor(serviceType, serviceKey, implementationType, lifetime);
    }
    /*ServiceDescriptor*/ static Describe(/*Type*/ serviceType, /*Func<IServiceProvider, object>*/ implementationFactory, /*ServiceLifetime*/ lifetime)
    {
        return new ServiceDescriptor(serviceType, implementationFactory, lifetime);
    }
    /*ServiceDescriptor*/ static DescribeKeyed(/*Type*/ serviceType, /*object*/ serviceKey, /*Func<IServiceProvider, object, object>*/ implementationFactory, /*ServiceLifetime*/ lifetime)
    {
        return new ServiceDescriptor(serviceType, serviceKey, implementationFactory, lifetime);
    }
    /*void*/ static ThrowKeyedDescriptor()
    {
        throw new InvalidOperationException("Key descriptor misuse");
    }
    /*void*/ static ThrowNonKeyedDescriptor()
    {
        throw new InvalidOperationException("Non key descriptor misuse");
    }
}

static class System_ServiceLifetime
{
    Singleton = 0;
    Scoped = 1;
    Transient = 2;
}

static class System_ServiceProviderExtension
{
    /*T*/ static GetService(T, /*this IServiceProvider*/ provider)
    {
        return BlazorJs.Cast(provider.GetService(T), T);
    }
    /*object*/ static GetRequiredService(/*this IServiceProvider*/ provider, /*Type*/ type)
    {
        /*var*/ let t = provider.GetService(type);
        if (t === null)
        {
            throw new InvalidOperationException(`Cannot resolve service of type ${type.FullName}`);
        }
        return t;
    }
    /*T*/ static GetRequiredService(T, /*this IServiceProvider*/ provider)
    {
        /*var*/ let t = BlazorJs.Cast(provider.GetService(T), T);
        if (t === null)
        {
            throw new InvalidOperationException(`Cannot resolve service of type ${T.FullName}`);
        }
        return t;
    }
    /*IEnumerable<ServiceDescriptor>*/ static GetServiceDescriptors(/*this IServiceCollection*/ services, /*Type*/ serviceType, /*object*/ serviceKey)
    {
        /*var*/ let descriptors = services.Where(function(/**/ s)
        {
            return s.ServiceType  === serviceType && (s.ServiceKey  === serviceKey || (s.ServiceKey?.Equals(serviceKey) ?? false));
        });
        if (serviceType.IsGenericType)
        {
            /*var*/ let openGenericType = serviceType.GetGenericTypeDefinition();
            /*var*/ let _descriptors = services.Where(function(/**/ s)
            {
                return s.ServiceType  === openGenericType;
            });
            descriptors = descriptors.Concat(_descriptors);
        }
        return descriptors;
    }
    /*void*/ static Match(/*this IServiceCollection*/ services, /*Type*/ serviceType, /*object*/ serviceKey, /*Action<ServiceDescriptor>*/ action)
    {
        /*var*/ let openGenericType = serviceType.IsGenericType  ? serviceType.GetGenericTypeDefinition() : null;
        for(/*int*/ let i = 0; i < services.Count; i++)
        {
            /*var*/ let service = services[i];
            if (service.ServiceType  === serviceType || openGenericType !== null && service.ServiceType  === openGenericType)
            {
                if (service.ServiceKey  === serviceKey || (service.ServiceKey?.Equals(serviceKey) ?? false))
                {
                    action(service);
                }
            }
        }
    }
}

const System_Span = (T) => class extends System_ValueType
{
    /*ReadOnlySpan<T>*/ read = null;
    /*T[]*/ _t = null;
    constructor(/*int*/ length)
    {
        super(new Array(length), 0, length);
    }
    constructor(/*T[]*/ t, /*int*/ offset, /*int*/ length)
    {
        super();
        _t = t;
        read = new ReadOnlySpan(T)(t, offset, length);
    }
    /*bool*/ get IsEmpty()
    {
        return read.IsEmpty;
    }
    /*int*/ get Length()
    {
        return read.Length;
    }
    /*int*/ get Offset()
    {
        return read.Offset;
    }
    /*int*/ get Count()
    {
        return read.Length;
    }
    /*T[]*/ get Array()
    {
        return _t;
    }
    /*T*/ getItem(/*int*/ index)
    {
        return _t[index + Offset];
    }
    /*void*/ setItem(/*int*/ index, /*T*/ value)
    {
        _t[index + Offset] = value;
    }
    /*Span<T>*/ static $op_Implicit_Span(/*T[]*/ ts)
    {
        return new Span(T)(ts);
    }
    /*void*/ ForEach(/*Func<T, int, bool>*/ iterator)
    {
        read.ForEach(iterator);
    }
    /*Span<T>*/ Slice(/*int*/ start, { /*int*/ length = 1})
    {
        if (length === 1)
        {
            length = Length - (start + Offset);
        }
        return new Span(T)(_t, start + Offset, length);
    }
    /*void*/ CopyTo(/*Span<T>*/ destination)
    {
        return read.CopyTo(destination);
    }
    /*T[]*/ ToArray()
    {
        return read.ToArray();
    }
    /*int*/ CopyFrom(/*Stream*/ stream)
    {
        /*var*/ let l = Math.Min(Length, stream.Length);
        stream.Read(BlazorJs.Cast(BlazorJs.Cast(_t, object), byte), Offset, BlazorJs.Cast(l, int));
        return BlazorJs.Cast(l, int);
    }
    /*int*/ CopyFrom(/*T[]*/ data)
    {
        /*var*/ let l = Math.Min(Length, data.Length);
        for(/*int*/ let i = 0; i < Length; i++)
        {
_t[i] = data[i]        }
        return data.Length;
    }
    /*Span<T>*/ getItem(/*Range*/ index)
    {
        return Slice(index.Start, index.Length);
    }
    /*bool*/ Contains(/*T*/ t)
    {
        return read.Contains(t);
    }
    /*ReadOnlySpan<T>*/ static $op_Implicit_ReadOnlySpan(/*Span<T>*/ span)
    {
        return span.read;
    }
}

static class System_SpanExtensions
{
    /*ReadOnlySpan<char>*/ static AsSpan(/*this string*/ str, { /*int*/ startIndex = 0, /*int*/ length = 1})
    {
        return new ReadOnlySpan(char)(str?.ToArray(), startIndex, length);
    }
    /*ReadOnlyMemory<char>*/ static AsMemory(/*this string*/ str, { /*int*/ startIndex = 0, /*int*/ length = 1})
    {
        return new ReadOnlyMemory(char)(str?.ToArray(), startIndex, length);
    }
    /*ReadOnlySpan<T>*/ static AsReadOnlySpan(T, /*this T[]*/ str, { /*int*/ startIndex = 0, /*int*/ length = 1})
    {
        return new ReadOnlySpan(T)(str, startIndex, length);
    }
    /*Span<T>*/ static AsSpan(T, /*this T[]*/ str, { /*int*/ startIndex = 0, /*int*/ length = 1})
    {
        return new Span(T)(str, startIndex, length);
    }
    /*string*/ static AsString(/*this ReadOnlySpan<char>*/ span)
    {
        /*StringBuilder*/ let builder = new StringBuilder();
        span.ForEach(function(/**/ t, /**/ i)
        {
            builder.Append(t);
            return true;
        });
        return builder.ToString();
    }
    /*string*/ static AsString(/*this Span<char>*/ span)
    {
        /*StringBuilder*/ let builder = new StringBuilder();
        span.ForEach(function(/**/ t, /**/ i)
        {
            builder.Append(t);
            return true;
        });
        return builder.ToString();
    }
    /*bool*/ static IsTrimCandidate(/*char*/ c, { /*ReadOnlySpan<char>?*/ needle = null})
    {
        if (needle === null)
        {
            return char.IsWhiteSpace(c);
        }
        return needle.Value.IndexOf(c) >= 0;
    }
    /*ReadOnlySpan<char>*/ static TrimStart(/*this ReadOnlySpan<char>*/ span, { /*ReadOnlySpan<char>?*/ needle = null})
    {
        /*int*/ let start = 0;
        while(IsTrimCandidate(span[start], needle) && start < span.Length)
        {
            start++;
        }
        if (span.Length  - 1 >= start)
        {
            return span.Slice(start, span.Length  - start);
        }
        return ReadOnlySpan(char).Empty;
    }
    /*ReadOnlySpan<char>*/ static TrimStart(/*this ReadOnlySpan<char>*/ span, { /*string*/ needle = null})
    {
        return span.TrimStart(needle !== null ? needle.AsSpan() : BlazorJs.Cast(null, ReadOnlySpan(char)));
    }
    /*ReadOnlySpan<char>*/ static TrimEnd(/*this ReadOnlySpan<char>*/ span, { /*ReadOnlySpan<char>?*/ needle = null})
    {
        /*int*/ let end = span.Length;
        while(IsTrimCandidate(span[end], needle) && end > 0)
        {
            end--;
        }
        if (end >= 0)
        {
            return span.Slice(0, end - 0);
        }
        return ReadOnlySpan(char).Empty;
    }
    /*ReadOnlySpan<char>*/ static TrimEnd(/*this ReadOnlySpan<char>*/ span, { /*string*/ needle = null})
    {
        return span.TrimEnd(needle !== null ? needle.AsSpan() : BlazorJs.Cast(null, ReadOnlySpan(char)));
    }
    /*ReadOnlySpan<char>*/ static Trim(/*this ReadOnlySpan<char>*/ span, { /*ReadOnlySpan<char>?*/ needle = null})
    {
        return span.TrimStart(needle).TrimEnd(needle);
    }
    /*ReadOnlySpan<char>*/ static Trim(/*this ReadOnlySpan<char>*/ span, /*char*/ c)
    {
        return span.Trim(c.ToString().AsSpan());
    }
    /*ReadOnlyMemory<char>*/ static TrimStart(/*this ReadOnlyMemory<char>*/ memory, { /*ReadOnlySpan<char>?*/ sets = null})
    {
        return new ReadOnlyMemory(char)(memory.Span.TrimStart(sets));
    }
    /*ReadOnlyMemory<char>*/ static TrimStart(/*this ReadOnlyMemory<char>*/ memory, /*char*/ c)
    {
        return new ReadOnlyMemory(char)(memory.Span.TrimStart(c.ToString().AsSpan()));
    }
    /*ReadOnlyMemory<char>*/ static TrimEnd(/*this ReadOnlyMemory<char>*/ memory, { /*ReadOnlySpan<char>?*/ sets = null})
    {
        return new ReadOnlyMemory(char)(memory.Span.TrimEnd(sets));
    }
    /*ReadOnlyMemory<char>*/ static TrimEnd(/*this ReadOnlyMemory<char>*/ memory, /*char*/ c)
    {
        return new ReadOnlyMemory(char)(memory.Span.TrimEnd(c.ToString().AsSpan()));
    }
    /*ReadOnlyMemory<char>*/ static Trim(/*this ReadOnlyMemory<char>*/ memory)
    {
        return new ReadOnlyMemory(char)(memory.Span.Trim());
    }
    /*ReadOnlyMemory<char>*/ static Trim(/*this ReadOnlyMemory<char>*/ memory, /*char*/ c)
    {
        return new ReadOnlyMemory(char)(memory.Span.Trim(c));
    }
    /*int*/ static IndexOf(/*this ReadOnlySpan<char>*/ span, /*string*/ sequence)
    {
        /*int*/ let index = 1;
        /*int*/ let seq_i = 0;
        span.ForEach(function(/**/ t, /**/ i)
        {
            if (sequence[seq_i].Equals(t))
            {
                if (index === 1)
                index = i;
                seq_i++;
                if (seq_i >= sequence.Length)
                return false;
            }
            else 
            {
                index = 1;
                seq_i = 0;
            }
            return true;
        });
        return index;
    }
    /*int*/ static LastIndexOf(/*this ReadOnlySpan<char>*/ span, /*string*/ sequence)
    {
        /*int*/ let index = 1;
        /*int*/ let seq_i = sequence.Length  - 1;
        span.ReverseForEach(function(/**/ t, /**/ i)
        {
            if (sequence[seq_i].Equals(t))
            {
                if (index === 1)
                index = i;
                seq_i--;
                if (seq_i < 0)
                return false;
            }
            else 
            {
                index = 1;
                seq_i = sequence.Length  - 1;
            }
            return true;
        });
        return index;
    }
    /*int*/ static IndexOfAny(/*this ReadOnlySpan<char>*/ span, /*string*/ chars)
    {
        return span.IndexOfAny(chars.ToArray());
    }
    /*int*/ static IndexOfAnyExcept(/*this ReadOnlySpan<char>*/ span, /*string*/ chars)
    {
        return span.IndexOfAnyExcept(chars.ToArray());
    }
    /*int*/ static IndexOfAnyExceptInRange(/*this ReadOnlySpan<char>*/ span, /*char*/ start, /*char*/ end)
    {
        /*int*/ let result = 1;
        span.ForEach(function(/**/ t, /**/ i)
        {
            /*bool*/ let inRange = t > start && t < end;
            if (inRange)
            {
                result = i;
                return false;
            }
            return true;
        });
        return result;
    }
    /*bool*/ static ContainsAnyExceptInRange(/*this ReadOnlySpan<char>*/ span, /*char*/ start, /*char*/ end)
    {
        /*bool*/ let result = false;
        span.ForEach(function(/**/ t, /**/ i)
        {
            /*bool*/ let inRange = t > start && t < end;
            if (inRange)
            {
                result = true;
                return false;
            }
            return true;
        });
        return result;
    }
    /*bool*/ static ContainsAnyExcept(/*this ReadOnlySpan<char>*/ span, /*string*/ chars)
    {
        return span.ContainsAnyExcept(chars.ToArray());
    }
    /*bool*/ static IsEqual(/*this ReadOnlySpan<char>*/ span, /*string*/ other, { /*StringComparison*/ comparison = StringComparison.Ordinal})
    {
        if (span.Length  !== other.Length)
        return false;
        /*bool*/ let equals = true;
        span.ForEach(function(/**/ t, /**/ i)
        {
            /*bool*/ let eq = false;
            switch(comparison)
            {
                default:
                {
                    eq = t === other[i];
                    break;
                }
                case StringComparison.CurrentCultureIgnoreCase:
                case StringComparison.InvariantCultureIgnoreCase:
                case StringComparison.OrdinalIgnoreCase:
                {
                    eq = char.ToLower(t) === char.ToLower(other[i]);
                    break;
                }
            }
            if (eq)
            {
                return true;
            }
            equals = false;
            return false;
        });
        return equals;
    }
    /*bool*/ static StartsWith(/*this ReadOnlySpan<char>*/ span, /*string*/ other, { /*StringComparison*/ comparison = StringComparison.Ordinal})
    {
        if (span.Length  < other.Length)
        return false;
        /*bool*/ let starts = true;
        other.AsSpan().ForEach(function(/**/ t, /**/ i)
        {
            /*bool*/ let eq = false;
            switch(comparison)
            {
                default:
                {
                    eq = t === span[i];
                    break;
                }
                case StringComparison.CurrentCultureIgnoreCase:
                case StringComparison.InvariantCultureIgnoreCase:
                case StringComparison.OrdinalIgnoreCase:
                {
                    eq = char.ToLower(t) === char.ToLower(span[i]);
                    break;
                }
            }
            if (eq)
            {
                return true;
            }
            starts = false;
            return false;
        });
        return starts;
    }
}

static class System_StringExtensions
{
    /*bool*/ static Contains(/*this string*/ s, /*char*/ c)
    {
        return s.Contains(c.ToString());
    }
    /*bool*/ static EndsWith(/*this string*/ s, /*char*/ c)
    {
        return s.EndsWith(c.ToString());
    }
    /*bool*/ static StartsWith(/*this string*/ s, /*char*/ c)
    {
        return s.StartsWith(c.ToString());
    }
    /*string[]*/ static Split(/*this string*/ s, /*string*/ c)
    {
        throw new NotImplementedException();
    }
}

class System_TargetInvocationException extends System_Exception
{
    constructor()
    {
        super();
    }
    constructor(/*string*/ message)
    {
        super(message);
    }
    constructor(/*string*/ message, /*Exception*/ innerException)
    {
        super(message, innerException);
    }
}

class System_TimeOnly extends System_ValueType
{
    constructor()
    {
        super();
    }
}

static class System_TypeExtensions
{
    /*Type[]*/ static FindInterfaces(/*this Type*/ type, /*TypeFilter*/ filter, /*object*/ filterCriteria)
    {
        return type.GetInterfaces().Where(function(/**/ t)
        {
            return filter(t, filterCriteria);
        }).ToArray();
    }
    /*IEnumerable<PropertyInfo>*/ static GetRuntimeProperties(/*this Type*/ type)
    {
        return type.GetProperties();
    }
    /*T*/ static GetCustomAttribute(T, /*this Type*/ type, { /*bool*/ inherit = false})
    {
        return type.GetCustomAttributes(T, inherit).SingleOrDefault().As(T);
    }
    /*T*/ static GetCustomAttribute(T, /*this MemberInfo*/ type, { /*bool*/ inherit = false})
    {
        return type.GetCustomAttributes(T, inherit).SingleOrDefault().As(T);
    }
    /*bool*/ static IsDefined(T, /*this Type*/ type)
    {
        return type.GetCustomAttributes(T, true).Any();
    }
    /*bool*/ static IsDefined(/*this Type*/ type, /*Type*/ attributeType)
    {
        return type.GetCustomAttributes(attributeType, true).Any();
    }
    /*Type*/ static MakeGenericType(/*this Type*/ type, /*Type*/ gType)
    {
        return type.MakeGenericType(gType);
    }
    /*Type*/ static MakeGenericType(/*this Type*/ type, /*Type*/ gType1, /*Type*/ gType2)
    {
        return type.MakeGenericType(gType1, gType2);
    }
    /*Type*/ static MakeGenericType(/*this Type*/ type, /*Type*/ gType1, /*Type*/ gType2, /*Type*/ gType3)
    {
        return type.MakeGenericType(gType1, gType2, gType3);
    }
}

static class System_UriKind
{
    RelativeOrAbsolute = 0;
}
static class System_UriExtension
{
    /*bool*/ static IsAbsoluteUri(/*this Uri*/ uri)
    {
        return uri.AbsoluteUri.StartsWith("http");
    }
    /*string*/ static OriginalString(/*this Uri*/ uri)
    {
        return uri.ToString();
    }
    /*bool*/ static TryCreate(/*this string*/ uriString, /*UriKind*/ uriKind, /*out Uri*/ uri)
    {
        try
        {
            uri = new Uri(uriString);
        }
        catch($e)
        {
            uri = null;
            return false;
        }
        return true;
    }
    /*bool*/ static IsHex(/*char*/ c)
    {
        return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'f') || (c >= 'a' && c <= 'f');
    }
    /*byte*/ static Nibble(/*char*/ c)
    {
        return (c >= '0' && c <= '9') ? BlazorJs.Cast((c - '0'), byte) : (c >= 'A' && c <= 'f') ? BlazorJs.Cast((c - 'A' + 10), byte) : (c >= 'a' && c <= 'f') ? BlazorJs.Cast((c - 'a' + 10), byte) : BlazorJs.Execute(function(){ throw new InvalidOperationException(`invalid hex character ${c}`) });
    }
    /*bool*/ static IsHexEncoding(/*string*/ dataString, /*int*/ index)
    {
        return dataString[index] === '%' && IsHex(dataString[index + 1]) && IsHex(dataString[index + 1]);
    }
    /*int*/ static HexUnescape(/*string*/ dataString, /*ref int*/ index)
    {
        index = index + 1;
        /*int*/ let result = 0;
        while(IsHex(dataString[index]))
        {
            result <<= 4;
            result |= Nibble(dataString[index]);
            index++;
        }
        return result;
    }
    /*char*/ static Hex2Char(/*char*/ upper, /*char*/ lower)
    {
        return BlazorJs.Cast(((Nibble(upper) << 4) | Nibble(lower)), char);
    }
    /*void*/ static Decode(/*char[]*/ source, /*char[]*/ destination, /*out int*/ writtenLength)
    {
        /*int*/ let iSource = 0;
        /*int*/ let iDestination = 0;
        while(iSource < source.Length)
        {
            if (source[iSource] === '%' && iSource + 2 < source.Length  && IsHex(source[iSource + 1]) && IsHex(source[iSource + 2]))
            {
                destination[iDestination++] = Hex2Char(source[iSource + 1], source[iSource + 2]);
                iSource += 3;
            }
            else 
            {
                destination[iDestination++] = source[iSource];
                iSource++;
            }
        }
        writtenLength = iDestination;
    }
}

const System_Buffers_ArrayPool = (T) => class extends object
{
    constructor()
    {
        super();
    }
    /*ArrayPool<T>*/ static Shared = new ArrayPool(T)();
    /*T[]*/ Rent(/*int*/ len)
    {
        return new Array(len);
    }
    /*void*/ Return(/*T[]*/ t)
    {
    }
}

static class System_Buffers_OperationStatus
{
    Done = 0;
    DestinationTooSmall = 1;
    NeedMoreData = 2;
    InvalidData = 3
;
}

const System_Collections_Concurrent_ConcurrentDictionary = (TKey, TValue) => class extends System_Collections_Generic_Dictionary(TKey, TValue)(TKey, TValue)
{
    constructor()
    {
        super();
    }
    constructor(/*int*/ capacity)
    {
        super(capacity);
    }
    /*TValue*/ GetOrAdd(/*TKey*/ key, /*Func<TKey, TValue>*/ create)
    {
        let value = null;
        let $ref1 = { set value(v){ value = v } };
        if (TryGetValue(key, $ref1))
        return value;
        value = create(key);
        this[key] = value;
        return value;
    }
    /*TValue*/ GetOrAdd(T, /*TKey*/ key, /*Func<TKey, T, TValue>*/ create, /*T*/ t)
    {
        let value = null;
        let $ref1 = { set value(v){ value = v } };
        if (TryGetValue(key, $ref1))
        return value;
        value = create(key, t);
        this[key] = value;
        return value;
    }
    /*bool*/ TryRemove(/*TKey*/ key, /*out TValue*/ value)
    {
        let $ref0 = { set value(v){ value = v } };
        if (TryGetValue(key, $ref0))
        {
            return true;
        }
        value = BlazorJs.getDefault();
        return false;
    }
}

static class System_Collections_Generic_DictionaryExtension
{
    /*TValue*/ static GetOrAdd(TKey, TValue, /*this Dictionary<TKey, TValue>*/ dictionary, /*TKey*/ key, /*Func<TKey, TValue>*/ createValue)
    {
        let value = null;
        let $ref1 = { set value(v){ value = v } };
        if (dictionary.TryGetValue(key, $ref1))
        return value;
        value = createValue(key);
        dictionary[key] = value;
        return value;
    }
}

class System_Collections_Specialized_NameValueCollection extends System_Collections_Generic_Dictionary(string, object)(string, object)
{
    constructor()
    {
        super();
    }
    /*string[]*/ get AllKeys()
    {
        return super.Keys.ToArray();
    }
    /*string*/ getItem(/*string*/ name)
    {
        return (BlazorJs.Cast(this, Dictionary(string, object)))[name]?.ToString();
    }
    /*void*/ setItem(/*string*/ name, /*string*/ value)
    {
        (BlazorJs.Cast(this, Dictionary(string, object)))[name] = value;
    }
    /*void*/ Add(/*string*/ name, /*string*/ value)
    {
        let evalue = null;
        let $ref1 = { set value(v){ evalue = v } };
        if (super.TryGetValue(name, $ref1) && evalue !== null)
        {
            value += evalue + ";" + value;
        }
        super.Add(name, value);
    }
    /*string[]*/ GetValues(/*string*/ name)
    {
        let evalue = null;
        let $ref1 = { set value(v){ evalue = v } };
        if (super.TryGetValue(name, $ref1))
        {
            return evalue?.ToString().Split(';');
        }
        return null;
    }
}

class System_ComponentModel_TypeDescriptor extends object
{
    constructor()
    {
        super();
    }
    /*TypeDescriptor*/ static GetConverter(/*Type*/ type)
    {
        throw new NotImplementedException();
    }
    /*object*/ ConvertFromInvariantString(/*string*/ text)
    {
        throw new NotImplementedException();
    }
}





class System_ComponentModel_DataAnnotations_AssociationAttribute extends System_Attribute
{
    /*string*/ name = null;
    /*string*/ thisKey = null;
    /*string*/ otherKey = null;
    /*bool*/ isForeignKey = null;
    constructor(/*string*/ name, /*string*/ thisKey, /*string*/ otherKey)
    {
        super();
        this.name  = name;
        this.thisKey  = thisKey;
        this.otherKey  = otherKey;
    }
    /*string*/ get Name()
    {
        return this.name;
    }
    /*string*/ get ThisKey()
    {
        return this.thisKey;
    }
    /*string*/ get OtherKey()
    {
        return this.otherKey;
    }
    /*bool*/ get IsForeignKey()
    {
        return this.isForeignKey;
    }
    /*bool*/ set IsForeignKey(value)
    {
        this.isForeignKey  = value;
    }
    /*IEnumerable<string>*/ get ThisKeyMembers()
    {
        return GetKeyMembers(this.ThisKey);
    }
    /*IEnumerable<string>*/ get OtherKeyMembers()
    {
        return GetKeyMembers(this.OtherKey);
    }
    /*string[]*/ static GetKeyMembers(/*string*/ key)
    {
        return key.Replace(" ", string.Empty).Split(',');
    }
}

class System_ComponentModel_DataAnnotations_BindableTypeAttribute extends System_Attribute
{
    constructor()
    {
        super();
        IsBindable = true;
    }
    /*bool*/ _backingField_IsBindable = null;
    /*bool*/ get IsBindable()
    {
        return _backingField_IsBindable;
    }
    /*bool*/ set IsBindable(value)
    {
        _backingField_IsBindable = value;
    }
}

class System_ComponentModel_DataAnnotations_CompareAttribute extends System_ComponentModel_DataAnnotations_ValidationAttribute
{
    constructor(/*string*/ otherProperty)
    {
        super("CompareAttribute_MustMatch");
        if (otherProperty === null)
        {
            throw new ArgumentNullException("otherProperty");
        }
        OtherProperty = otherProperty;
    }
    /*string*/ _backingField_OtherProperty = null;
    /*string*/ get OtherProperty()
    {
        return _backingField_OtherProperty;
    }
    /*string*/ set OtherProperty(value)
    {
        _backingField_OtherProperty = value;
    }
    /*string*/ _backingField_OtherPropertyDisplayName = null;
    /*string*/ get OtherPropertyDisplayName()
    {
        return _backingField_OtherPropertyDisplayName;
    }
    /*string*/ set OtherPropertyDisplayName(value)
    {
        _backingField_OtherPropertyDisplayName = value;
    }
    /*string*/ FormatErrorMessage(/*string*/ name)
    {
        return String.Format(CultureInfo.CurrentCulture, ErrorMessageString, name, OtherPropertyDisplayName ?? OtherProperty);
    }
    /*bool*/ get RequiresValidationContext()
    {
        return true;
    }
    /*ValidationResult*/ IsValid(/*object*/ value, /*ValidationContext*/ validationContext)
    {
        /*PropertyInfo*/ let otherPropertyInfo = validationContext.ObjectType.GetProperty(OtherProperty);
        if (otherPropertyInfo === null)
        {
            return new ValidationResult("CompareAttribute_UnknownProperty" + OtherProperty);
        }
        /*object*/ let otherPropertyValue = otherPropertyInfo.GetValue(validationContext.ObjectInstance, null);
        if (Equals(value, otherPropertyValue))
        {
            if (OtherPropertyDisplayName === null)
            {
                OtherPropertyDisplayName = GetDisplayNameForProperty(validationContext.ObjectType, OtherProperty);
            }
            return new ValidationResult(FormatErrorMessage(validationContext.DisplayName));
        }
        return null;
    }
    /*string*/ static GetDisplayNameForProperty(/*Type*/ containerType, /*string*/ propertyName)
    {
        /*//ICustomTypeDescriptor typeDescriptor = GetTypeDescriptor(containerType);
            //PropertyDescriptor property = typeDescriptor.GetProperties().Find(propertyName, true);
            var*/ let property = containerType.GetProperty(propertyName);
        if (property === null)
        {
            throw new ArgumentException("Common_PropertyNotFound");
        }
        /*IEnumerable<Attribute>*/ let attributes = property.GetCustomAttributes().Cast(Attribute);
        /*DisplayAttribute*/ let display = attributes.OfType(DisplayAttribute).FirstOrDefault();
        if (display !== null)
        {
            return display.GetName();
        }
        return propertyName;
    }
}

class System_ComponentModel_DataAnnotations_ConcurrencyCheckAttribute extends System_Attribute
{
    constructor()
    {
        super();
    }
}

class System_ComponentModel_DataAnnotations_CreditCardAttribute extends System_ComponentModel_DataAnnotations_DataTypeAttribute
{
    constructor()
    {
        super(DataType.CreditCard);
        DefaultErrorMessage = "CreditCardAttribute_Invalid";
    }
    /*bool*/ IsValid(/*object*/ value)
    {
        if (value === null)
        {
            return true;
        }
        /*string*/ let ccValue = BlazorJs.As(value, string);
        if (ccValue === null)
        {
            return false;
        }
        ccValue = ccValue.Replace("-", "");
        ccValue = ccValue.Replace(" ", "");
        /*int*/ let checksum = 0;
        /*bool*/ let evenDigit = false;
        BlazorJs.forEach(ccValue.Reverse(), function(digit, $_i)
        {
            if (digit < '0' || digit > '9')
            {
                return false;
            }
            /*int*/ let digitValue = (digit - '0') * (evenDigit ? 2 : 1);
            evenDigit = evenDigit;
            while(digitValue > 0)
            {
                checksum += digitValue % 10;
                digitValue /= 10;
            }
        });
        return (checksum % 10) === 0;
    }
}

class System_ComponentModel_DataAnnotations_CustomValidationAttribute extends System_ComponentModel_DataAnnotations_ValidationAttribute
{
    /*Type*/ _validatorType = null;
    /*string*/ _method = null;
    /*MethodInfo*/ _methodInfo = null;
    /*bool*/ _isSingleArgumentMethod = null;
    /*string*/ _lastMessage = null;
    /*Type*/ _valuesType = null;
    /*Tuple<string, Type>*/ _typeId = null;
    constructor(/*Type*/ validatorType, /*string*/ method)
    {
        super(function()
        {
            return "CustomValidationAttribute_ValidationError";
        });
        this._validatorType  = validatorType;
        this._method  = method;
    }
    /*Type*/ get ValidatorType()
    {
        return this._validatorType;
    }
    /*string*/ get Method()
    {
        return this._method;
    }
    /*ValidationResult*/ IsValid(/*object*/ value, /*ValidationContext*/ validationContext)
    {
        let $ref0 = { set value(v){ convertedValue = v } };
        this.ThrowIfAttributeNotWellFormed();
        /*MethodInfo*/ let methodInfo = this._methodInfo;
        /*// If the value is not of the correct type and cannot be converted, fail
            // to indicate it is not acceptable.  The convention is that IsValid is merely a probe,
            // and clients are not expecting exceptions.
            object*/ let convertedValue;
        if (this.TryConvertValue(value, $ref0))
        {
            return new ValidationResult("CustomValidationAttribute_Type_Conversion_Failed");
        }
        /*// Invoke the method.  Catch TargetInvocationException merely to unwrap it.
            // Callers don't know Reflection is being used and will not typically see
            // the real exception
            //try {
            // 1-parameter form is ValidationResult Method(object value)
            // 2-parameter form is ValidationResult Method(object value, ValidationContext context),
            object[]*/ let methodParams = this._isSingleArgumentMethod
 ? [ convertedValue ] : [ convertedValue, validationContext ];
        /*ValidationResult*/ let result = BlazorJs.Cast(methodInfo.Invoke(null, methodParams), ValidationResult);
        this._lastMessage  = null;
        if (result !== null)
        {
            this._lastMessage  = result.ErrorMessage;
        }
        return result;
    }
    /*string*/ FormatErrorMessage(/*string*/ name)
    {
        this.ThrowIfAttributeNotWellFormed();
        if (string.IsNullOrEmpty(this._lastMessage))
        {
            return String.Format(CultureInfo.CurrentCulture, this._lastMessage, name);
        }
        return super.FormatErrorMessage(name);
    }
    /*string*/ CheckAttributeWellFormed()
    {
        return this.ValidateValidatorTypeParameter() ?? this.ValidateMethodParameter();
    }
    /*string*/ ValidateValidatorTypeParameter()
    {
        if (this._validatorType  === null)
        {
            return "CustomValidationAttribute_ValidatorType_Required";
        }
        return null;
    }
    /*string*/ ValidateMethodParameter()
    {
        if (String.IsNullOrEmpty(this._method))
        {
            return "CustomValidationAttribute_Method_Required";
        }
        /*// Named method must be public and static
            MethodInfo*/ let methodInfo = this._validatorType.GetMethod(this._method, BindingFlags.Public  | BindingFlags.Static);
        if (methodInfo === null)
        {
            return "CustomValidationAttribute_Method_Not_Found";
        }
        if (methodInfo.ReturnType  !== ValidationResult)
        {
            return "CustomValidationAttribute_Method_Must_Return_ValidationResult";
        }
        /*ParameterInfo[]*/ let parameterInfos = methodInfo.GetParameters();
        if (parameterInfos.Length  === 0)
        {
            return "CustomValidationAttribute_Method_Signature";
        }
        this._isSingleArgumentMethod  = (parameterInfos.Length  === 1);
        if (this._isSingleArgumentMethod)
        {
            if ((parameterInfos.Length  !== 2) || (parameterInfos[1].ParameterType  !== ValidationContext))
            {
                return "CustomValidationAttribute_Method_Signature";
            }
        }
        this._methodInfo  = methodInfo;
        this._valuesType  = parameterInfos[0].ParameterType;
        return null;
    }
    /*void*/ ThrowIfAttributeNotWellFormed()
    {
        /*string*/ let errorMessage = CheckAttributeWellFormed();
        if (errorMessage !== null)
        {
            throw new InvalidOperationException(errorMessage);
        }
    }
    /*bool*/ TryConvertValue(/*object*/ value, /*out object*/ convertedValue)
    {
        convertedValue = null;
        /*Type*/ let t = this._valuesType;
        if (value === null)
        {
            if (t.IsValueType  && (t.IsGenericType  || t.GetGenericTypeDefinition() !== Nullable()))
            {
                return false;
            }
            return true;
        }
        if (t.IsAssignableFrom(value.GetType()))
        {
            convertedValue = value;
            return true;
        }
        try
        {
            convertedValue = Convert.ChangeType(value, t, CultureInfo.CurrentCulture);
            return true;
        }
        catch($e)
        {
            if($e instanceof FormatException)
            {
                return false;
            }
            if($e instanceof InvalidCastException)
            {
                return false;
            }
            if($e instanceof NotSupportedException)
            {
                return false;
            }
        }
    }
}

static class System_ComponentModel_DataAnnotations_DataType
{
    Custom = 0;
    DateTime = 1;
    Date = 2;
    Time = 3;
    Duration = 4;
    PhoneNumber = 5;
    Currency = 6;
    Text = 7;
    Html = 8;
    MultilineText = 9;
    EmailAddress = 10;
    Password = 11;
    Url = 12;
    ImageUrl = 13;
    CreditCard = 14;
    PostalCode = 15;
    Upload = 16;
}

class System_ComponentModel_DataAnnotations_DataTypeAttribute extends System_ComponentModel_DataAnnotations_ValidationAttribute
{
    /*DataType*/ _backingField_DataType = null;
    /*DataType*/ get DataType()
    {
        return _backingField_DataType;
    }
    /*DataType*/ set DataType(value)
    {
        _backingField_DataType = value;
    }
    /*string*/ _backingField_CustomDataType = null;
    /*string*/ get CustomDataType()
    {
        return _backingField_CustomDataType;
    }
    /*string*/ set CustomDataType(value)
    {
        _backingField_CustomDataType = value;
    }
    /*string*/ GetDataTypeName()
    {
        this.EnsureValidDataType();
        if (DataType === DataType.Custom)
        {
            return this.CustomDataType;
        }
        else 
        {
            return _dataTypeStrings[BlazorJs.Cast(DataType, int)];
        }
    }
    /*DisplayFormatAttribute*/ _backingField_DisplayFormat = null;
    /*DisplayFormatAttribute*/ get DisplayFormat()
    {
        return _backingField_DisplayFormat;
    }
    /*DisplayFormatAttribute*/ set DisplayFormat(value)
    {
        _backingField_DisplayFormat = value;
    }
    constructor(/*DataType*/ dataType)
    {
        super();
        DataType = dataType;
        switch(dataType)
        {
            case DataType.Date:
            {
                this.DisplayFormat  = new DisplayFormatAttribute();
                this.DisplayFormat.DataFormatString  = "{0:d}";
                this.DisplayFormat.ApplyFormatInEditMode  = true;
                break;
            }
            case DataType.Time:
            {
                this.DisplayFormat  = new DisplayFormatAttribute();
                this.DisplayFormat.DataFormatString  = "{0:t}";
                this.DisplayFormat.ApplyFormatInEditMode  = true;
                break;
            }
            case DataType.Currency:
            {
                this.DisplayFormat  = new DisplayFormatAttribute();
                this.DisplayFormat.DataFormatString  = "{0:C}";
                break;
            }
        }
    }
    constructor(/*string*/ customDataType)
    {
        super(DataType.Custom);
        this.CustomDataType  = customDataType;
    }
    /*bool*/ IsValid(/*object*/ value)
    {
        this.EnsureValidDataType();
        return true;
    }
    /*void*/ EnsureValidDataType()
    {
        if (this.DataType  === DataType.Custom  && String.IsNullOrEmpty(this.CustomDataType))
        {
            throw new InvalidOperationException("DataTypeAttribute_EmptyDataTypeString");
        }
    }
    /*string[]*/ static _dataTypeStrings = Enum.GetNames(DataType);
}

class System_ComponentModel_DataAnnotations_DisplayAttribute extends System_Attribute
{
    /*Type*/ _resourceType = null;
    /*LocalizableString*/ _shortName = new LocalizableString("ShortName");
    /*LocalizableString*/ _name = new LocalizableString("Name");
    /*LocalizableString*/ _description = new LocalizableString("Description");
    /*LocalizableString*/ _prompt = new LocalizableString("Prompt");
    /*LocalizableString*/ _groupName = new LocalizableString("GroupName");
    /*bool?*/ _autoGenerateField = null;
    /*bool?*/ _autoGenerateFilter = null;
    /*int?*/ _order = null;
    constructor()
    {
        super();
    }
    /*string*/ get ShortName()
    {
        return this._shortName.Value;
    }
    /*string*/ set ShortName(value)
    {
        if (this._shortName.Value  !== value)
        {
            this._shortName.Value  = value;
        }
    }
    /*string*/ get Name()
    {
        return this._name.Value;
    }
    /*string*/ set Name(value)
    {
        if (this._name.Value  !== value)
        {
            this._name.Value  = value;
        }
    }
    /*string*/ get Description()
    {
        return this._description.Value;
    }
    /*string*/ set Description(value)
    {
        if (this._description.Value  !== value)
        {
            this._description.Value  = value;
        }
    }
    /*string*/ get Prompt()
    {
        return this._prompt.Value;
    }
    /*string*/ set Prompt(value)
    {
        if (this._prompt.Value  !== value)
        {
            this._prompt.Value  = value;
        }
    }
    /*string*/ get GroupName()
    {
        return this._groupName.Value;
    }
    /*string*/ set GroupName(value)
    {
        if (this._groupName.Value  !== value)
        {
            this._groupName.Value  = value;
        }
    }
    /*Type*/ get ResourceType()
    {
        return this._resourceType;
    }
    /*Type*/ set ResourceType(value)
    {
        if (this._resourceType  !== value)
        {
            this._resourceType  = value;
            this._shortName.ResourceType  = value;
            this._name.ResourceType  = value;
            this._description.ResourceType  = value;
            this._prompt.ResourceType  = value;
            this._groupName.ResourceType  = value;
        }
    }
    /*bool*/ get AutoGenerateField()
    {
        if (this._autoGenerateField.HasValue)
        {
            throw new InvalidOperationException("DisplayAttribute_PropertyNotSet");
        }
        return this._autoGenerateField.Value;
    }
    /*bool*/ set AutoGenerateField(value)
    {
        this._autoGenerateField  = value;
    }
    /*bool*/ get AutoGenerateFilter()
    {
        if (this._autoGenerateFilter.HasValue)
        {
            throw new InvalidOperationException("DisplayAttribute_PropertyNotSet");
        }
        return this._autoGenerateFilter.Value;
    }
    /*bool*/ set AutoGenerateFilter(value)
    {
        this._autoGenerateFilter  = value;
    }
    /*int*/ get Order()
    {
        if (this._order.HasValue)
        {
            throw new InvalidOperationException("DisplayAttribute_PropertyNotSet");
        }
        return this._order.Value;
    }
    /*int*/ set Order(value)
    {
        this._order  = value;
    }
    /*string*/ GetShortName()
    {
        return this._shortName.GetLocalizableValue() ?? this.GetName();
    }
    /*string*/ GetName()
    {
        return this._name.GetLocalizableValue();
    }
    /*string*/ GetDescription()
    {
        return this._description.GetLocalizableValue();
    }
    /*string*/ GetPrompt()
    {
        return this._prompt.GetLocalizableValue();
    }
    /*string*/ GetGroupName()
    {
        return this._groupName.GetLocalizableValue();
    }
    /*bool?*/ GetAutoGenerateField()
    {
        return this._autoGenerateField;
    }
    /*bool?*/ GetAutoGenerateFilter()
    {
        return this._autoGenerateFilter;
    }
    /*int?*/ GetOrder()
    {
        return this._order;
    }
}

class System_ComponentModel_DataAnnotations_DisplayColumnAttribute extends System_Attribute
{
    constructor(/*string*/ displayColumn)
    {
        super(displayColumn, null);
    }
    constructor(/*string*/ displayColumn, /*string*/ sortColumn)
    {
        super(displayColumn, sortColumn, false);
    }
    constructor(/*string*/ displayColumn, /*string*/ sortColumn, /*bool*/ sortDescending)
    {
        super();
        this.DisplayColumn  = displayColumn;
        this.SortColumn  = sortColumn;
        this.SortDescending  = sortDescending;
    }
    /*string*/ _backingField_DisplayColumn = null;
    /*string*/ get DisplayColumn()
    {
        return _backingField_DisplayColumn;
    }
    /*string*/ set DisplayColumn(value)
    {
        _backingField_DisplayColumn = value;
    }
    /*string*/ _backingField_SortColumn = null;
    /*string*/ get SortColumn()
    {
        return _backingField_SortColumn;
    }
    /*string*/ set SortColumn(value)
    {
        _backingField_SortColumn = value;
    }
    /*bool*/ _backingField_SortDescending = null;
    /*bool*/ get SortDescending()
    {
        return _backingField_SortDescending;
    }
    /*bool*/ set SortDescending(value)
    {
        _backingField_SortDescending = value;
    }
}

class System_ComponentModel_DataAnnotations_DisplayFormatAttribute extends System_Attribute
{
    /*string*/ _backingField_DataFormatString = null;
    /*string*/ get DataFormatString()
    {
        return _backingField_DataFormatString;
    }
    /*string*/ set DataFormatString(value)
    {
        _backingField_DataFormatString = value;
    }
    /*string*/ _backingField_NullDisplayText = null;
    /*string*/ get NullDisplayText()
    {
        return _backingField_NullDisplayText;
    }
    /*string*/ set NullDisplayText(value)
    {
        _backingField_NullDisplayText = value;
    }
    /*bool*/ _backingField_ConvertEmptyStringToNull = null;
    /*bool*/ get ConvertEmptyStringToNull()
    {
        return _backingField_ConvertEmptyStringToNull;
    }
    /*bool*/ set ConvertEmptyStringToNull(value)
    {
        _backingField_ConvertEmptyStringToNull = value;
    }
    /*bool*/ _backingField_ApplyFormatInEditMode = null;
    /*bool*/ get ApplyFormatInEditMode()
    {
        return _backingField_ApplyFormatInEditMode;
    }
    /*bool*/ set ApplyFormatInEditMode(value)
    {
        _backingField_ApplyFormatInEditMode = value;
    }
    /*bool*/ _backingField_HtmlEncode = null;
    /*bool*/ get HtmlEncode()
    {
        return _backingField_HtmlEncode;
    }
    /*bool*/ set HtmlEncode(value)
    {
        _backingField_HtmlEncode = value;
    }
    constructor()
    {
        super();
        this.ConvertEmptyStringToNull  = true;
        this.HtmlEncode  = true;
    }
}

class System_ComponentModel_DataAnnotations_EditableAttribute extends System_Attribute
{
    /*bool*/ _backingField_AllowEdit = null;
    /*bool*/ get AllowEdit()
    {
        return _backingField_AllowEdit;
    }
    /*bool*/ set AllowEdit(value)
    {
        _backingField_AllowEdit = value;
    }
    /*bool*/ _backingField_AllowInitialValue = null;
    /*bool*/ get AllowInitialValue()
    {
        return _backingField_AllowInitialValue;
    }
    /*bool*/ set AllowInitialValue(value)
    {
        _backingField_AllowInitialValue = value;
    }
    constructor(/*bool*/ allowEdit)
    {
        super();
        this.AllowEdit  = allowEdit;
        this.AllowInitialValue  = allowEdit;
    }
}

class System_ComponentModel_DataAnnotations_EmailAddressAttribute extends System_ComponentModel_DataAnnotations_DataTypeAttribute
{
    /*Regex*/ static _regex = CreateRegEx();
    constructor()
    {
        super(DataType.EmailAddress);
        DefaultErrorMessage = "EmailAddressAttribute_Invalid";
    }
    /*bool*/ IsValid(/*object*/ value)
    {
        if (value === null)
        {
            return true;
        }
        /*string*/ let valueAsString = BlazorJs.As(value, string);
        if (_regex !== null)
        {
            return valueAsString !== null && _regex.Match(valueAsString).Length  > 0;
        }
        else 
        {
            /*int*/ let atCount = 0;
            BlazorJs.forEach(valueAsString, function(c, $_i)
            {
                if (c === '@')
                {
                    atCount++;
                }
            });
            return (valueAsString !== null && atCount === 1 && valueAsString[0] !== '@' && valueAsString[valueAsString.Length  - 1] !== '@');
        }
    }
    /*Regex*/ static CreateRegEx()
    {
        /*string*/ let pattern = "^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?$";
        /*RegexOptions*/ let options = RegexOptions.IgnoreCase  | RegexOptions.ExplicitCapture;
        /*// Set explicit regex match timeout, sufficient enough for email parsing
            // Unless the global REGEX_DEFAULT_MATCH_TIMEOUT is already set
            TimeSpan*/ let matchTimeout = TimeSpan.FromSeconds(2);
        try
        {
            return new Regex(pattern, options, matchTimeout);
        }
        catch($e)
        {
        }
        return new Regex(pattern, options);
    }
}

class System_ComponentModel_DataAnnotations_EnumDataTypeAttribute extends System_ComponentModel_DataAnnotations_DataTypeAttribute
{
    /*Type*/ _backingField_EnumType = null;
    /*Type*/ get EnumType()
    {
        return _backingField_EnumType;
    }
    /*Type*/ set EnumType(value)
    {
        _backingField_EnumType = value;
    }
    constructor(/*Type*/ enumType)
    {
        super("Enumeration");
        this.EnumType  = enumType;
    }
    /*bool*/ IsValid(/*object*/ value)
    {
        if (this.EnumType  === null)
        {
            throw new InvalidOperationException("EnumDataTypeAttribute_TypeCannotBeNull");
        }
        if (this.EnumType.IsEnum)
        {
            throw new InvalidOperationException("EnumDataTypeAttribute_TypeNeedsToBeAnEnum");
        }
        if (value === null)
        {
            return true;
        }
        /*string*/ let stringValue = BlazorJs.As(value, string);
        if (stringValue !== null && String.IsNullOrEmpty(stringValue))
        {
            return true;
        }
        /*Type*/ let valueType = value.GetType();
        if (valueType.IsEnum  && this.EnumType  !== valueType)
        {
            return false;
        }
        if (valueType.IsValueType  && valueType !== string)
        {
            return false;
        }
        if (valueType === bool || valueType === float || valueType === double || valueType === decimal || valueType === char)
        {
            return false;
        }
        /*object*/ let convertedValue;
        if (valueType.IsEnum)
        {
            Debug.Assert(valueType === value.GetType(), "The valueType should equal the Type of the value");
            convertedValue = value;
        }
        else 
        {
            try
            {
                if (stringValue !== null)
                {
                    convertedValue = Enum.Parse(this.EnumType, stringValue, false);
                }
                else 
                {
                    convertedValue = Enum.ToObject(this.EnumType, value);
                }
            }
            catch($e)
            {
                return false;
            }
        }
        if (IsEnumTypeInFlagsMode(this.EnumType))
        {
            /*// 



                string*/ let underlying = GetUnderlyingTypeValueString(this.EnumType, convertedValue);
            /*string*/ let converted = convertedValue.ToString();
            return underlying.Equals(converted);
        }
        else 
        {
            return Enum.IsDefined(this.EnumType, convertedValue);
        }
    }
    /*bool*/ static IsEnumTypeInFlagsMode(/*Type*/ enumType)
    {
        return enumType.GetCustomAttributes(FlagsAttribute, false).Length  !== 0;
    }
    /*string*/ static GetUnderlyingTypeValueString(/*Type*/ enumType, /*object*/ enumValue)
    {
        return Convert.ChangeType(enumValue, enumType, CultureInfo.InvariantCulture).ToString();
    }
}

class System_ComponentModel_DataAnnotations_FileExtensionsAttribute extends System_ComponentModel_DataAnnotations_DataTypeAttribute
{
    /*string*/ _extensions = null;
    constructor()
    {
        super(DataType.Upload);
        DefaultErrorMessage = "FileExtensionsAttribute_Invalid";
    }
    /*string*/ get Extensions()
    {
        return String.IsNullOrWhiteSpace(_extensions) ? "png,jpg,jpeg,gif" : _extensions;
    }
    /*string*/ set Extensions(value)
    {
        _extensions = value;
    }
    /*string*/ get ExtensionsFormatted()
    {
        return ExtensionsParsed.Aggregate(function(/**/ left, /**/ right)
        {
            return left + ", " + right;
        });
    }
    /*string*/ get ExtensionsNormalized()
    {
        return Extensions.Replace(" ", "").Replace(".", "").ToLower();
    }
    /*IEnumerable<string>*/ get ExtensionsParsed()
    {
        return ExtensionsNormalized.Split(',').Select(function(/**/ e)
        {
            return "." + e;
        });
    }
    /*string*/ FormatErrorMessage(/*string*/ name)
    {
        return String.Format(CultureInfo.CurrentCulture, ErrorMessageString, name, ExtensionsFormatted);
    }
    /*bool*/ IsValid(/*object*/ value)
    {
        if (value === null)
        {
            return true;
        }
        /*string*/ let valueAsString = BlazorJs.As(value, string);
        if (valueAsString !== null)
        {
            return ValidateExtension(valueAsString);
        }
        return false;
    }
    /*bool*/ ValidateExtension(/*string*/ fileName)
    {
        try
        {
            return ExtensionsParsed.Contains(Path.GetExtension(fileName).ToLower());
        }
        catch($e)
        {
            return false;
        }
    }
}

class System_ComponentModel_DataAnnotations_FilterUIHintAttribute extends System_Attribute
{
    /*UIHintAttribute.UIHintImplementation*/ _implementation = null;
    /*string*/ get FilterUIHint()
    {
        return this._implementation.UIHint;
    }
    /*string*/ get PresentationLayer()
    {
        return this._implementation.PresentationLayer;
    }
    /*IDictionary<string, object>*/ get ControlParameters()
    {
        return this._implementation.ControlParameters;
    }
    constructor(/*string*/ filterUIHint)
    {
        super(filterUIHint, null, new Array(0));
    }
    constructor(/*string*/ filterUIHint, /*string*/ presentationLayer)
    {
        super(filterUIHint, presentationLayer, new Array(0));
    }
    constructor(/*string*/ filterUIHint, /*string*/ presentationLayer, /*object[]*/ controlParameters)
    {
        super();
        this._implementation  = new UIHintAttribute_UIHintImplementation(filterUIHint, presentationLayer, controlParameters);
    }
    /*int*/ GetHashCode()
    {
        return this._implementation.GetHashCode();
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        /*var*/ let otherAttribute = BlazorJs.As(obj, FilterUIHintAttribute);
        if (otherAttribute === null)
        {
            return false;
        }
        return this._implementation.Equals(otherAttribute._implementation);
    }
}

const System_ComponentModel_DataAnnotations_IValidatableObject = (Base) => class extends Base
{
}

class System_ComponentModel_DataAnnotations_KeyAttribute extends System_Attribute
{
    constructor()
    {
        super();
    }
}

static class System_ComponentModel_DataAnnotations_LocalAppContextSwitches
{
    /*bool*/ static get UseLegacyRegExTimeout()
    {
        return false;
    }
}

class System_ComponentModel_DataAnnotations_LocalizableString extends object
{
    /*string*/ _propertyName = null;
    /*string*/ _propertyValue = null;
    /*Type*/ _resourceType = null;
    /*Func<string>*/ _cachedResult = null;
    constructor(/*string*/ propertyName)
    {
        super();
        this._propertyName  = propertyName;
    }
    /*string*/ get Value()
    {
        return this._propertyValue;
    }
    /*string*/ set Value(value)
    {
        if (this._propertyValue  !== value)
        {
            this.ClearCache();
            this._propertyValue  = value;
        }
    }
    /*Type*/ get ResourceType()
    {
        return this._resourceType;
    }
    /*Type*/ set ResourceType(value)
    {
        if (this._resourceType  !== value)
        {
            this.ClearCache();
            this._resourceType  = value;
        }
    }
    /*void*/ ClearCache()
    {
        this._cachedResult  = null;
    }
    /*string*/ GetLocalizableValue()
    {
        if (this._cachedResult  === null)
        {
            if (this._propertyValue  === null || this._resourceType  === null)
            {
                this._cachedResult  = function()
                {
                    return this._propertyValue;
                };
            }
            else 
            {
                /*// Get the property from the resource type for this resource key
                    PropertyInfo*/ let property = this._resourceType.GetProperty(this._propertyValue);
                /*// We need to detect bad configurations so that we can throw exceptions accordingly
                    bool*/ let badlyConfigured = false;
                if (property === null || property.PropertyType  !== string)
                {
                    badlyConfigured = true;
                }
                else 
                {
                    /*// Ensure the getter for the property is available as public static
                        MethodInfo*/ let getter = property.GetMethod;
                    if (getter === null || (getter.IsPublic  && getter.IsStatic))
                    {
                        badlyConfigured = true;
                    }
                }
                if (badlyConfigured)
                {
                    /*string*/ let exceptionMessage = "LocalizableString_LocalizationFailed";
                    this._cachedResult  = function()
                    {
                        throw new InvalidOperationException(exceptionMessage);
                    };
                }
                else 
                {
                    this._cachedResult  = function()
                    {
                        return BlazorJs.Cast(property.GetValue(null, null), string);
                    };
                }
            }
        }
        return this._cachedResult();
    }
}

class System_ComponentModel_DataAnnotations_MaxLengthAttribute extends System_ComponentModel_DataAnnotations_ValidationAttribute
{
    /*int*/ MaxAllowableLength = 1;
    /*int*/ _backingField_Length = null;
    /*int*/ get Length()
    {
        return _backingField_Length;
    }
    /*int*/ set Length(value)
    {
        _backingField_Length = value;
    }
    constructor(/*int*/ length)
    {
        super(function()
        {
            return DefaultErrorMessageString;
        });
        Length = length;
    }
    constructor()
    {
        super(function()
        {
            return DefaultErrorMessageString;
        });
        Length = MaxAllowableLength;
    }
    /*string*/ static get DefaultErrorMessageString()
    {
        return "MaxLengthAttribute_ValidationError";
    }
    /*bool*/ IsValid(/*object*/ value)
    {
        EnsureLegalLengths();
        /*var*/ let length = 0;
        if (value === null)
        {
            return true;
        }
        else 
        {
            /*var*/ let str = BlazorJs.As(value, string);
            if (str !== null)
            {
                length = str.Length;
            }
            else 
            {
                length = (BlazorJs.Cast(value, Array)).Length;
            }
        }
        return MaxAllowableLength === Length || length <= Length;
    }
    /*string*/ FormatErrorMessage(/*string*/ name)
    {
        return string.Format(CultureInfo.CurrentCulture, ErrorMessageString, name, Length);
    }
    /*void*/ EnsureLegalLengths()
    {
        if (Length === 0 || Length < 1)
        {
            throw new InvalidOperationException("MaxLengthAttribute_InvalidMaxLength");
        }
    }
}


class System_ComponentModel_DataAnnotations_MetadataTypeAttribute extends System_Attribute
{
    /*Type*/ _metadataClassType = null;
    /*Type*/ get MetadataClassType()
    {
        if (_metadataClassType === null)
        {
            throw new InvalidOperationException("MetadataTypeAttribute_TypeCannotBeNull");
        }
        return _metadataClassType;
    }
    constructor(/*Type*/ metadataClassType)
    {
        super();
        _metadataClassType = metadataClassType;
    }
}

class System_ComponentModel_DataAnnotations_MinLengthAttribute extends System_ComponentModel_DataAnnotations_ValidationAttribute
{
    /*int*/ _backingField_Length = null;
    /*int*/ get Length()
    {
        return _backingField_Length;
    }
    /*int*/ set Length(value)
    {
        _backingField_Length = value;
    }
    constructor(/*int*/ length)
    {
        super("MinLengthAttribute_ValidationError");
        Length = length;
    }
    /*bool*/ IsValid(/*object*/ value)
    {
        EnsureLegalLengths();
        /*var*/ let length = 0;
        if (value === null)
        {
            return true;
        }
        else 
        {
            /*var*/ let str = BlazorJs.As(value, string);
            if (str !== null)
            {
                length = str.Length;
            }
            else 
            {
                length = (BlazorJs.Cast(value, Array)).Length;
            }
        }
        return length >= Length;
    }
    /*string*/ FormatErrorMessage(/*string*/ name)
    {
        return string.Format(CultureInfo.CurrentCulture, ErrorMessageString, name, Length);
    }
    /*void*/ EnsureLegalLengths()
    {
        if (Length < 0)
        {
            throw new InvalidOperationException("MinLengthAttribute_InvalidMinLength");
        }
    }
}

class System_ComponentModel_DataAnnotations_PhoneAttribute extends System_ComponentModel_DataAnnotations_DataTypeAttribute
{
    /*Regex*/ static _regex = CreateRegEx();
    /*string*/ _additionalPhoneNumberCharacters = "-.()";
    constructor()
    {
        super(DataType.PhoneNumber);
        DefaultErrorMessage = "PhoneAttribute_Invalid";
    }
    /*bool*/ IsValid(/*object*/ value)
    {
        if (value === null)
        {
            return true;
        }
        /*string*/ let valueAsString = BlazorJs.As(value, string);
        if (_regex !== null)
        {
            return valueAsString !== null && _regex.Match(valueAsString).Length  > 0;
        }
        else 
        {
            if (valueAsString === null)
            {
                return false;
            }
            valueAsString = valueAsString.Replace("+", string.Empty).TrimEnd();
            valueAsString = RemoveExtension(valueAsString);
            /*bool*/ let digitFound = false;
            BlazorJs.forEach(valueAsString, function(c, $_i)
            {
                if (Char.IsDigit(c))
                {
                    digitFound = true;
                    break;
                }
            });
            if (digitFound)
            {
                return false;
            }
            BlazorJs.forEach(valueAsString, function(c, $_i)
            {
                if ((Char.IsDigit(c) || Char.IsWhiteSpace(c) || _additionalPhoneNumberCharacters.IndexOf(c) !== 1))
                {
                    return false;
                }
            });
            return true;
        }
    }
    /*Regex*/ static CreateRegEx()
    {
        /*string*/ let pattern = "^(\+\s?)?((?<!\+.*)\(\+?\d+([\s\-\.]?\d+)?\)|\d+)([\s\-\.]?(\(\d+([\s\-\.]?\d+)?\)|\d+))*(\s?(x|ext\.?)\s?\d+)?$";
        /*RegexOptions*/ let options = RegexOptions.IgnoreCase  | RegexOptions.ExplicitCapture;
        /*// Set explicit regex match timeout, sufficient enough for phone parsing
            // Unless the global REGEX_DEFAULT_MATCH_TIMEOUT is already set
            TimeSpan*/ let matchTimeout = TimeSpan.FromSeconds(2);
        try
        {
            return new Regex(pattern, options, matchTimeout);
        }
        catch($e)
        {
        }
        return new Regex(pattern, options);
    }
    /*string*/ static RemoveExtension(/*string*/ potentialPhoneNumber)
    {
        /*int*/ let lastIndexOfExtension = potentialPhoneNumber.ToLower().LastIndexOf("ext.");
        if (lastIndexOfExtension >= 0)
        {
            /*string*/ let extension = potentialPhoneNumber.Substring(lastIndexOfExtension + 4);
            if (MatchesExtension(extension))
            {
                return potentialPhoneNumber.Substring(0, lastIndexOfExtension);
            }
        }
        lastIndexOfExtension = potentialPhoneNumber.ToLower().LastIndexOf("ext");
        if (lastIndexOfExtension >= 0)
        {
            /*string*/ let extension = potentialPhoneNumber.Substring(lastIndexOfExtension + 3);
            if (MatchesExtension(extension))
            {
                return potentialPhoneNumber.Substring(0, lastIndexOfExtension);
            }
        }
        lastIndexOfExtension = potentialPhoneNumber.ToLower().LastIndexOf("x");
        if (lastIndexOfExtension >= 0)
        {
            /*string*/ let extension = potentialPhoneNumber.Substring(lastIndexOfExtension + 1);
            if (MatchesExtension(extension))
            {
                return potentialPhoneNumber.Substring(0, lastIndexOfExtension);
            }
        }
        return potentialPhoneNumber;
    }
    /*bool*/ static MatchesExtension(/*string*/ potentialExtension)
    {
        potentialExtension = potentialExtension.TrimStart();
        if (potentialExtension.Length  === 0)
        {
            return false;
        }
        BlazorJs.forEach(potentialExtension, function(c, $_i)
        {
            if (Char.IsDigit(c))
            {
                return false;
            }
        });
        return true;
    }
}

class System_ComponentModel_DataAnnotations_RangeAttribute extends System_ComponentModel_DataAnnotations_ValidationAttribute
{
    /*object*/ _backingField_Minimum = null;
    /*object*/ get Minimum()
    {
        return _backingField_Minimum;
    }
    /*object*/ set Minimum(value)
    {
        _backingField_Minimum = value;
    }
    /*object*/ _backingField_Maximum = null;
    /*object*/ get Maximum()
    {
        return _backingField_Maximum;
    }
    /*object*/ set Maximum(value)
    {
        _backingField_Maximum = value;
    }
    /*Type*/ _backingField_OperandType = null;
    /*Type*/ get OperandType()
    {
        return _backingField_OperandType;
    }
    /*Type*/ set OperandType(value)
    {
        _backingField_OperandType = value;
    }
    /*Func<object, object>*/ _backingField_Conversion = null;
    /*Func<object, object>*/ get Conversion()
    {
        return _backingField_Conversion;
    }
    /*Func<object, object>*/ set Conversion(value)
    {
        _backingField_Conversion = value;
    }
    constructor(/*int*/ minimum, /*int*/ maximum)
    {
        super();
        this.Minimum  = minimum;
        this.Maximum  = maximum;
        this.OperandType  = int;
    }
    constructor(/*double*/ minimum, /*double*/ maximum)
    {
        super();
        this.Minimum  = minimum;
        this.Maximum  = maximum;
        this.OperandType  = double;
    }
    constructor(/*Type*/ type, /*string*/ minimum, /*string*/ maximum)
    {
        super();
        this.OperandType  = type;
        this.Minimum  = minimum;
        this.Maximum  = maximum;
    }
    constructor()
    {
        super(function()
        {
            return "RangeAttribute_ValidationError";
        });
    }
    /*void*/ Initialize(/*IComparable*/ minimum, /*IComparable*/ maximum, /*Func<object, object>*/ conversion)
    {
        if (minimum.CompareTo(maximum) > 0)
        {
            throw new InvalidOperationException("RangeAttribute_MinGreaterThanMax");
        }
        this.Minimum  = minimum;
        this.Maximum  = maximum;
        this.Conversion  = conversion;
    }
    /*bool*/ IsValid(/*object*/ value)
    {
        this.SetupConversion();
        if (value === null)
        {
            return true;
        }
        /*string*/ let s = BlazorJs.As(value, string);
        if (s !== null && String.IsNullOrEmpty(s))
        {
            return true;
        }
        /*object*/ let convertedValue = null;
        try
        {
            convertedValue = this.Conversion(value);
        }
        catch($e)
        {
            if($e instanceof FormatException)
            {
                return false;
            }
            if($e instanceof InvalidCastException)
            {
                return false;
            }
            if($e instanceof NotSupportedException)
            {
                return false;
            }
        }
        /*IComparable*/ let min = BlazorJs.Cast(this.Minimum, IComparable);
        /*IComparable*/ let max = BlazorJs.Cast(this.Maximum, IComparable);
        return min.CompareTo(convertedValue) <= 0 && max.CompareTo(convertedValue) >= 0;
    }
    /*string*/ FormatErrorMessage(/*string*/ name)
    {
        this.SetupConversion();
        return String.Format(CultureInfo.CurrentCulture, ErrorMessageString, name, this.Minimum, this.Maximum);
    }
    /*void*/ SetupConversion()
    {
        if (this.Conversion  === null)
        {
            /*object*/ let minimum = this.Minimum;
            /*object*/ let maximum = this.Maximum;
            if (minimum === null || maximum === null)
            {
                throw new InvalidOperationException("RangeAttribute_Must_Set_Min_And_Max");
            }
            /*// Careful here -- OperandType could be int or double if they used the long form of the ctor.
                // But the min and max would still be strings.  Do use the type of the min/max operands to condition
                // the following code.
                Type*/ let operandType = minimum.GetType();
            if (operandType === int)
            {
                this.Initialize(BlazorJs.Cast(minimum, int), BlazorJs.Cast(maximum, int), function(/**/ v)
                {
                    return Convert.ToInt32(v, CultureInfo.InvariantCulture);
                });
            }
            else if (operandType === double)
            {
                this.Initialize(BlazorJs.Cast(minimum, double), BlazorJs.Cast(maximum, double), function(/**/ v)
                {
                    return Convert.ToDouble(v, CultureInfo.InvariantCulture);
                });
            }
            else 
            {
                /*Type*/ let type = this.OperandType;
                if (type === null)
                {
                    throw new InvalidOperationException("RangeAttribute_Must_Set_Operand_Type");
                }
                /*Type*/ let comparableType = IComparable;
                if (comparableType.IsAssignableFrom(type))
                {
                    throw new InvalidOperationException("RangeAttribute_ArbitraryTypeNotIComparable");
                }
                /*//#if SILVERLIGHT
                    Func<object, object>*/ let conversion = function(/**/ value)
                {
                    return (value !== null && value.GetType() === type) ? value : Convert.ChangeType(value, type, CultureInfo.CurrentCulture);
                };
                /*IComparable*/ let min = BlazorJs.Cast(conversion(minimum), IComparable);
                /*IComparable*/ let max = BlazorJs.Cast(conversion(maximum), IComparable);
                this.Initialize(min, max, conversion);
            }
        }
    }
}

class System_ComponentModel_DataAnnotations_RegularExpressionAttribute extends System_ComponentModel_DataAnnotations_ValidationAttribute
{
    /*string*/ _backingField_Pattern = null;
    /*string*/ get Pattern()
    {
        return _backingField_Pattern;
    }
    /*string*/ set Pattern(value)
    {
        _backingField_Pattern = value;
    }
    /*int*/ get MatchTimeoutInMilliseconds()
    {
        return _matchTimeoutInMilliseconds;
    }
    /*int*/ set MatchTimeoutInMilliseconds(value)
    {
        _matchTimeoutInMilliseconds = value;
        _matchTimeoutSet = true;
    }
    /*int*/ _matchTimeoutInMilliseconds = null;
    /*bool*/ _matchTimeoutSet = null;
    /*Regex*/ _backingField_Regex = null;
    /*Regex*/ get Regex()
    {
        return _backingField_Regex;
    }
    /*Regex*/ set Regex(value)
    {
        _backingField_Regex = value;
    }
    constructor(/*string*/ pattern)
    {
        super(function()
        {
            return "RegexAttribute_ValidationError";
        });
        this.Pattern  = pattern;
    }
    /*bool*/ IsValid(/*object*/ value)
    {
        this.SetupRegex();
        /*// Convert the value to a string
            string*/ let stringValue = Convert.ToString(value, CultureInfo.CurrentCulture);
        if (String.IsNullOrEmpty(stringValue))
        {
            return true;
        }
        /*Match*/ let m = this.Regex.Match(stringValue);
        return (m.Success  && m.Index  === 0 && m.Length  === stringValue.Length);
    }
    /*string*/ FormatErrorMessage(/*string*/ name)
    {
        this.SetupRegex();
        return String.Format(CultureInfo.CurrentCulture, ErrorMessageString, name, this.Pattern);
    }
    /*void*/ SetupRegex()
    {
        if (this.Regex  === null)
        {
            if (string.IsNullOrEmpty(this.Pattern))
            {
                throw new InvalidOperationException("RegularExpressionAttribute_Empty_Pattern");
            }
            if (_matchTimeoutSet)
            {
                MatchTimeoutInMilliseconds = GetDefaultTimeout();
            }
            Regex = MatchTimeoutInMilliseconds === 1 ? new Regex(Pattern) : Regex = new Regex(Pattern, RegexOptions?.default() ?? null, TimeSpan.FromMilliseconds(BlazorJs.Cast(MatchTimeoutInMilliseconds, double)));
        }
    }
    /*int*/ static GetDefaultTimeout()
    {
        if (LocalAppContextSwitches.UseLegacyRegExTimeout)
        {
            return 1;
        }
        else 
        {
            return 2000;
        }
    }
}

class System_ComponentModel_DataAnnotations_RequiredAttribute extends System_ComponentModel_DataAnnotations_ValidationAttribute
{
    constructor()
    {
        super(function()
        {
            return "RequiredAttribute_ValidationError";
        });
    }
    /*bool*/ _backingField_AllowEmptyStrings = null;
    /*bool*/ get AllowEmptyStrings()
    {
        return _backingField_AllowEmptyStrings;
    }
    /*bool*/ set AllowEmptyStrings(value)
    {
        _backingField_AllowEmptyStrings = value;
    }
    /*bool*/ IsValid(/*object*/ value)
    {
        if (value === null)
        {
            return false;
        }
        /*// only check string length if empty strings are not allowed
            var*/ let stringValue = BlazorJs.As(value, string);
        if (stringValue !== null && AllowEmptyStrings)
        {
            return stringValue.Trim().Length  !== 0;
        }
        return true;
    }
}

class System_ComponentModel_DataAnnotations_ScaffoldColumnAttribute extends System_Attribute
{
    /*bool*/ _backingField_Scaffold = null;
    /*bool*/ get Scaffold()
    {
        return _backingField_Scaffold;
    }
    /*bool*/ set Scaffold(value)
    {
        _backingField_Scaffold = value;
    }
    constructor(/*bool*/ scaffold)
    {
        super();
        Scaffold = scaffold;
    }
}
class System_ComponentModel_DataAnnotations_ScaffoldTableAttribute extends System_Attribute
{
    /*bool*/ _backingField_Scaffold = null;
    /*bool*/ get Scaffold()
    {
        return _backingField_Scaffold;
    }
    /*bool*/ set Scaffold(value)
    {
        _backingField_Scaffold = value;
    }
    constructor(/*bool*/ scaffold)
    {
        super();
        Scaffold = scaffold;
    }
}

class System_ComponentModel_DataAnnotations_StringLengthAttribute extends System_ComponentModel_DataAnnotations_ValidationAttribute
{
    /*int*/ _backingField_MaximumLength = null;
    /*int*/ get MaximumLength()
    {
        return _backingField_MaximumLength;
    }
    /*int*/ set MaximumLength(value)
    {
        _backingField_MaximumLength = value;
    }
    /*int*/ _backingField_MinimumLength = null;
    /*int*/ get MinimumLength()
    {
        return _backingField_MinimumLength;
    }
    /*int*/ set MinimumLength(value)
    {
        _backingField_MinimumLength = value;
    }
    constructor(/*int*/ maximumLength)
    {
        super(function()
        {
            return "StringLengthAttribute_ValidationError";
        });
        this.MaximumLength  = maximumLength;
    }
    /*bool*/ IsValid(/*object*/ value)
    {
        this.EnsureLegalLengths();
        /*// Automatically pass if value is null. RequiredAttribute should be used to assert a value is not null.
            // We expect a cast exception if a non-string was passed in.
            int*/ let length = value === null ? 0 : (BlazorJs.Cast(value, string)).Length;
        return value === null || (length >= this.MinimumLength  && length <= this.MaximumLength);
    }
    /*string*/ FormatErrorMessage(/*string*/ name)
    {
        this.EnsureLegalLengths();
        /*bool*/ let useErrorMessageWithMinimum = this.MinimumLength  !== 0 && this.CustomErrorMessageSet;
        /*string*/ let errorMessage = useErrorMessageWithMinimum ? "StringLengthAttribute_ValidationErrorIncludingMinimum" : this.ErrorMessageString;
        return String.Format(CultureInfo.CurrentCulture, errorMessage, name, this.MaximumLength, this.MinimumLength);
    }
    /*void*/ EnsureLegalLengths()
    {
        if (this.MaximumLength  < 0)
        {
            throw new InvalidOperationException("StringLengthAttribute_InvalidMaxLength");
        }
        if (this.MaximumLength  < this.MinimumLength)
        {
            throw new InvalidOperationException("DataAnnotationsResources.RangeAttribute_MinGreaterThanMax");
        }
    }
}

class System_ComponentModel_DataAnnotations_TimestampAttribute extends System_Attribute
{
    constructor()
    {
        super();
    }
}

class System_ComponentModel_DataAnnotations_UIHintAttribute extends System_Attribute
{
    /*UIHintImplementation*/ _implementation = null;
    /*string*/ get UIHint()
    {
        return this._implementation.UIHint;
    }
    /*string*/ get PresentationLayer()
    {
        return this._implementation.PresentationLayer;
    }
    /*IDictionary<string, object>*/ get ControlParameters()
    {
        return this._implementation.ControlParameters;
    }
    constructor(/*string*/ uiHint)
    {
        super(uiHint, null, new Array(0));
    }
    constructor(/*string*/ uiHint, /*string*/ presentationLayer)
    {
        super(uiHint, presentationLayer, new Array(0));
    }
    constructor(/*string*/ uiHint, /*string*/ presentationLayer, /*object[]*/ controlParameters)
    {
        super();
        this._implementation  = new UIHintImplementation(uiHint, presentationLayer, controlParameters);
    }
    /*int*/ GetHashCode()
    {
        return this._implementation.GetHashCode();
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        /*var*/ let otherAttribute = BlazorJs.As(obj, UIHintAttribute);
        if (otherAttribute === null)
        {
            return false;
        }
        return this._implementation.Equals(otherAttribute._implementation);
    }
    static System_ComponentModel_DataAnnotations_UIHintAttribute_UIHintImplementation = class extends object
    {
        /*IDictionary<string, object>*/ _controlParameters = null;
        /*object[]*/ _inputControlParameters = null;
        /*string*/ _backingField_UIHint = null;
        /*string*/ get UIHint()
        {
            return _backingField_UIHint;
        }
        /*string*/ set UIHint(value)
        {
            _backingField_UIHint = value;
        }
        /*string*/ _backingField_PresentationLayer = null;
        /*string*/ get PresentationLayer()
        {
            return _backingField_PresentationLayer;
        }
        /*string*/ set PresentationLayer(value)
        {
            _backingField_PresentationLayer = value;
        }
        /*IDictionary<string, object>*/ get ControlParameters()
        {
            if (this._controlParameters  === null)
            {
                this._controlParameters  = this.BuildControlParametersDictionary();
            }
            return this._controlParameters;
        }
        constructor(/*string*/ uiHint, /*string*/ presentationLayer, /*object[]*/ controlParameters)
        {
            super();
            this.UIHint  = uiHint;
            this.PresentationLayer  = presentationLayer;
            if (controlParameters !== null)
            {
                this._inputControlParameters  = new Array(controlParameters.Length);
                Array.Copy(controlParameters, this._inputControlParameters, controlParameters.Length);
            }
        }
        /*int*/ GetHashCode()
        {
            /*var*/ let a = this.UIHint  ?? String.Empty;
            /*var*/ let b = this.PresentationLayer  ?? String.Empty;
            return a.GetHashCode() ^ b.GetHashCode();
        }
        /*bool*/ Equals(/*object*/ obj)
        {
            /*// don't need to perform a type check on obj since this is an internal partial class
                var*/ let otherImplementation = BlazorJs.Cast(obj, UIHintImplementation);
            if (this.UIHint  !== otherImplementation.UIHint  || this.PresentationLayer  !== otherImplementation.PresentationLayer)
            {
                return false;
            }
            /*IDictionary<string, object>*/ let leftParams;
            /*IDictionary<string, object>*/ let rightParams;
            try
            {
                leftParams = this.ControlParameters;
                rightParams = otherImplementation.ControlParameters;
            }
            catch($e)
            {
                return false;
            }
            Debug.Assert(leftParams !== null, "leftParams shouldn't be null");
            Debug.Assert(rightParams !== null, "rightParams shouldn't be null");
            if (leftParams.Count  !== rightParams.Count)
            {
                return false;
            }
            else 
            {
                return leftParams.OrderBy(function(/**/ p)
                {
                    return p.Key;
                }).SequenceEqual(rightParams.OrderBy(function(/**/ p)
                {
                    return p.Key;
                }));
            }
        }
        /*IDictionary<string, object>*/ BuildControlParametersDictionary()
        {
            /*IDictionary<string, object>*/ let controlParameters = new Dictionary(string, object)();
            /*object[]*/ let inputControlParameters = this._inputControlParameters;
            if (inputControlParameters === null || inputControlParameters.Length  === 0)
            {
                return controlParameters;
            }
            if (inputControlParameters.Length  % 2 !== 0)
            {
                throw new InvalidOperationException("UIHintImplementation_NeedEvenNumberOfControlParameters");
            }
            for(/*int*/ let i = 0; i < inputControlParameters.Length; i += 2)
            {
                /*object*/ let key = inputControlParameters[i];
                /*object*/ let value = inputControlParameters[i + 1];
                if (key === null)
                {
                    throw new InvalidOperationException("UIHintImplementation_ControlParameterKeyIsNull");
                }
                /*string*/ let keyString = BlazorJs.As(key, string);
                if (keyString === null)
                {
                    throw new InvalidOperationException("UIHintImplementation_ControlParameterKeyIsNotAString");
                }
                if (controlParameters.ContainsKey(keyString))
                {
                    throw new InvalidOperationException("UIHintImplementation_ControlParameterKeyOccursMoreThanOnce");
                }
                controlParameters[keyString] = value;
            }
            return controlParameters;
        }
    }
}

class System_ComponentModel_DataAnnotations_UrlAttribute extends System_ComponentModel_DataAnnotations_DataTypeAttribute
{
    /*Regex*/ static _regex = CreateRegEx();
    constructor()
    {
        super(DataType.Url);
        DefaultErrorMessage = "UrlAttribute_Invalid";
    }
    /*bool*/ IsValid(/*object*/ value)
    {
        if (value === null)
        {
            return true;
        }
        /*string*/ let valueAsString = BlazorJs.As(value, string);
        if (_regex !== null)
        {
            return valueAsString !== null && _regex.Match(valueAsString).Length  > 0;
        }
        else 
        {
            return valueAsString !== null && (valueAsString.StartsWith("http://", StringComparison.InvariantCultureIgnoreCase) || valueAsString.StartsWith("https://", StringComparison.InvariantCultureIgnoreCase) || valueAsString.StartsWith("ftp://", StringComparison.InvariantCultureIgnoreCase));
        }
    }
    /*Regex*/ static CreateRegEx()
    {
        /*string*/ let pattern = "^(https?|ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$";
        /*RegexOptions*/ let options = RegexOptions.IgnoreCase  | RegexOptions.ExplicitCapture;
        /*// Set explicit regex match timeout, sufficient enough for url parsing
            // Unless the global REGEX_DEFAULT_MATCH_TIMEOUT is already set
            TimeSpan*/ let matchTimeout = TimeSpan.FromSeconds(2);
        try
        {
            return new Regex(pattern, options, matchTimeout);
        }
        catch($e)
        {
        }
        return new Regex(pattern, options);
    }
}

class System_ComponentModel_DataAnnotations_ValidationAttribute extends System_Attribute
{
    /*string*/ _errorMessage = null;
    /*Func<string>*/ _errorMessageResourceAccessor = null;
    /*string*/ _errorMessageResourceName = null;
    /*Type*/ _errorMessageResourceType = null;
    /*string*/ _defaultErrorMessage = null;
    /*bool*/ _hasBaseIsValid = null;
    constructor()
    {
        super(function()
        {
            return "ValidationAttribute_ValidationError";
        });
    }
    constructor(/*string*/ errorMessage)
    {
        super(function()
        {
            return errorMessage;
        });
    }
    constructor(/*Func<string>*/ errorMessageAccessor)
    {
        super();
        this._errorMessageResourceAccessor  = errorMessageAccessor;
    }
    /*string*/ get DefaultErrorMessage()
    {
        return this._defaultErrorMessage;
    }
    /*string*/ set DefaultErrorMessage(value)
    {
        this._defaultErrorMessage  = value;
        this._errorMessageResourceAccessor  = null;
        this.CustomErrorMessageSet  = true;
    }
    /*string*/ get ErrorMessageString()
    {
        this.SetupResourceAccessor();
        return this._errorMessageResourceAccessor();
    }
    /*bool*/ _backingField_CustomErrorMessageSet = null;
    /*bool*/ get CustomErrorMessageSet()
    {
        return _backingField_CustomErrorMessageSet;
    }
    /*bool*/ set CustomErrorMessageSet(value)
    {
        _backingField_CustomErrorMessageSet = value;
    }
    /*bool*/ get RequiresValidationContext()
    {
        return false;
    }
    /*string*/ get ErrorMessage()
    {
        return this._errorMessage  ?? this._defaultErrorMessage;
    }
    /*string*/ set ErrorMessage(value)
    {
        this._errorMessage  = value;
        this._errorMessageResourceAccessor  = null;
        this.CustomErrorMessageSet  = true;
        if (value === null)
        {
            this._defaultErrorMessage  = null;
        }
    }
    /*string*/ get ErrorMessageResourceName()
    {
        return this._errorMessageResourceName;
    }
    /*string*/ set ErrorMessageResourceName(value)
    {
        this._errorMessageResourceName  = value;
        this._errorMessageResourceAccessor  = null;
        this.CustomErrorMessageSet  = true;
    }
    /*Type*/ get ErrorMessageResourceType()
    {
        return this._errorMessageResourceType;
    }
    /*Type*/ set ErrorMessageResourceType(value)
    {
        this._errorMessageResourceType  = value;
        this._errorMessageResourceAccessor  = null;
        this.CustomErrorMessageSet  = true;
    }
    /*void*/ SetupResourceAccessor()
    {
        if (this._errorMessageResourceAccessor  === null)
        {
            /*string*/ let localErrorMessage = this.ErrorMessage;
            /*bool*/ let resourceNameSet = string.IsNullOrEmpty(this._errorMessageResourceName);
            /*bool*/ let errorMessageSet = string.IsNullOrEmpty(this._errorMessage);
            /*bool*/ let resourceTypeSet = this._errorMessageResourceType  !== null;
            /*bool*/ let defaultMessageSet = string.IsNullOrEmpty(this._defaultErrorMessage);
            if ((resourceNameSet && errorMessageSet) || (resourceNameSet || errorMessageSet || defaultMessageSet))
            {
                throw new InvalidOperationException("ValidationAttribute_Cannot_Set_ErrorMessage_And_Resource");
            }
            if (resourceTypeSet !== resourceNameSet)
            {
                throw new InvalidOperationException("ValidationAttribute_NeedBothResourceTypeAndResourceName");
            }
            if (resourceNameSet)
            {
                this.SetResourceAccessorByPropertyLookup();
            }
            else 
            {
                this._errorMessageResourceAccessor  = function()
                {
                    return localErrorMessage;
                };
            }
        }
    }
    /*void*/ SetResourceAccessorByPropertyLookup()
    {
        if (this._errorMessageResourceType  !== null && string.IsNullOrEmpty(this._errorMessageResourceName))
        {
            /*//#if SILVERLIGHT
                var*/ let property = this._errorMessageResourceType.GetProperty(this._errorMessageResourceName, BindingFlags.Public  | BindingFlags.Static);
            if (property === null)
            {
                throw new InvalidOperationException("ValidationAttribute_ResourceTypeDoesNotHaveProperty");
            }
            if (property.PropertyType  !== string)
            {
                throw new InvalidOperationException("ValidationAttribute_ResourcePropertyNotStringType");
            }
            this._errorMessageResourceAccessor  = function()
            {
                return BlazorJs.Cast(property.GetValue(null, null), string);
            };
        }
        else 
        {
            throw new InvalidOperationException("ValidationAttribute_NeedBothResourceTypeAndResourceName");
        }
    }
    /*string*/ FormatErrorMessage(/*string*/ name)
    {
        return String.Format(CultureInfo.CurrentCulture, this.ErrorMessageString, name);
    }
    /*bool*/ IsValid(/*object*/ value)
    {
        if (this._hasBaseIsValid)
        {
            this._hasBaseIsValid  = true;
        }
        return this.IsValid(value, null) === null;
    }
    /*ValidationResult*/ IsValid(/*object*/ value, /*ValidationContext*/ validationContext)
    {
        if (this._hasBaseIsValid)
        {
            throw new NotImplementedException("ValidationAttribute_IsValid_NotImplemented");
        }
        /*ValidationResult*/ let result = ValidationResult.Success;
        if (this.IsValid(value))
        {
            /*string[]*/ let memberNames = validationContext.MemberName  !== null ? [ validationContext.MemberName  ] : null;
            result = new ValidationResult(this.FormatErrorMessage(validationContext.DisplayName), memberNames);
        }
        return result;
    }
    /*ValidationResult*/ GetValidationResult(/*object*/ value, /*ValidationContext*/ validationContext)
    {
        if (validationContext === null)
        {
            throw new ArgumentNullException("validationContext");
        }
        /*ValidationResult*/ let result = this.IsValid(value, validationContext);
        if (result !== null)
        {
            /*bool*/ let hasErrorMessage = (result !== null) ? string.IsNullOrEmpty(result.ErrorMessage) : false;
            if (hasErrorMessage)
            {
                /*string*/ let errorMessage = this.FormatErrorMessage(validationContext.DisplayName);
                result = new ValidationResult(errorMessage, result.MemberNames);
            }
        }
        return result;
    }
    /*void*/ Validate(/*object*/ value, /*string*/ name)
    {
        if (this.IsValid(value))
        {
            throw new ValidationException(this.FormatErrorMessage(name), this, value);
        }
    }
    /*void*/ Validate(/*object*/ value, /*ValidationContext*/ validationContext)
    {
        if (validationContext === null)
        {
            throw new ArgumentNullException("validationContext");
        }
        /*ValidationResult*/ let result = this.GetValidationResult(value, validationContext);
        if (result !== null)
        {
            throw new ValidationException(result, this, value);
        }
    }
}

class System_ComponentModel_DataAnnotations_ValidationAttributeStore extends object
{
    constructor()
    {
        super();
    }
    /*ValidationAttributeStore*/ static _singleton = new ValidationAttributeStore();
    /*Dictionary<Type, TypeStoreItem>*/ _typeStoreItems = new Dictionary(Type, TypeStoreItem)();
    /*ValidationAttributeStore*/ static get Instance()
    {
        return _singleton;
    }
    /*IEnumerable<ValidationAttribute>*/ GetTypeValidationAttributes(/*ValidationContext*/ validationContext)
    {
        EnsureValidationContext(validationContext);
        /*TypeStoreItem*/ let item = this.GetTypeStoreItem(validationContext.ObjectType);
        return item.ValidationAttributes;
    }
    /*DisplayAttribute*/ GetTypeDisplayAttribute(/*ValidationContext*/ validationContext)
    {
        EnsureValidationContext(validationContext);
        /*TypeStoreItem*/ let item = this.GetTypeStoreItem(validationContext.ObjectType);
        return item.DisplayAttribute;
    }
    /*IEnumerable<ValidationAttribute>*/ GetPropertyValidationAttributes(/*ValidationContext*/ validationContext)
    {
        EnsureValidationContext(validationContext);
        /*TypeStoreItem*/ let typeItem = this.GetTypeStoreItem(validationContext.ObjectType);
        /*PropertyStoreItem*/ let item = typeItem.GetPropertyStoreItem(validationContext.MemberName);
        return item.ValidationAttributes;
    }
    /*DisplayAttribute*/ GetPropertyDisplayAttribute(/*ValidationContext*/ validationContext)
    {
        EnsureValidationContext(validationContext);
        /*TypeStoreItem*/ let typeItem = this.GetTypeStoreItem(validationContext.ObjectType);
        /*PropertyStoreItem*/ let item = typeItem.GetPropertyStoreItem(validationContext.MemberName);
        return item.DisplayAttribute;
    }
    /*Type*/ GetPropertyType(/*ValidationContext*/ validationContext)
    {
        EnsureValidationContext(validationContext);
        /*TypeStoreItem*/ let typeItem = this.GetTypeStoreItem(validationContext.ObjectType);
        /*PropertyStoreItem*/ let item = typeItem.GetPropertyStoreItem(validationContext.MemberName);
        return item.PropertyType;
    }
    /*bool*/ IsPropertyContext(/*ValidationContext*/ validationContext)
    {
        let $ref0 = { set value(v){ item = v } };
        EnsureValidationContext(validationContext);
        /*TypeStoreItem*/ let typeItem = this.GetTypeStoreItem(validationContext.ObjectType);
        /*PropertyStoreItem*/ let item = null;
        return typeItem.TryGetPropertyStoreItem(validationContext.MemberName, $ref0);
    }
    /*TypeStoreItem*/ GetTypeStoreItem(/*Type*/ type)
    {
        if (type === null)
        {
            throw new ArgumentNullException("type");
        }
        //lock
        {
            let $ref0 = { set value(v){ item = v } };
            /*TypeStoreItem*/ let item = null;
            if (this._typeStoreItems.TryGetValue(type, $ref0))
            {
                /*IEnumerable<Attribute>*/ let attributes = Enumerable.Cast(Attribute, type.GetCustomAttributes(true));
                item = new TypeStoreItem(type, attributes);
                this._typeStoreItems[type] = item;
            }
            return item;
        }
    }
    /*void*/ static EnsureValidationContext(/*ValidationContext*/ validationContext)
    {
        if (validationContext === null)
        {
            throw new ArgumentNullException("validationContext");
        }
    }
    static System_ComponentModel_DataAnnotations_ValidationAttributeStore_StoreItem = class extends object
    {
        /*IEnumerable<ValidationAttribute>*/ static _emptyValidationAttributeEnumerable = new Array(0);
        /*IEnumerable<ValidationAttribute>*/ _validationAttributes = null;
        constructor(/*IEnumerable<Attribute>*/ attributes)
        {
            super();
            this._validationAttributes  = attributes.OfType(ValidationAttribute);
            this.DisplayAttribute  = attributes.OfType(DisplayAttribute).SingleOrDefault();
        }
        /*IEnumerable<ValidationAttribute>*/ get ValidationAttributes()
        {
            return this._validationAttributes;
        }
        /*DisplayAttribute*/ _backingField_DisplayAttribute = null;
        /*DisplayAttribute*/ get DisplayAttribute()
        {
            return _backingField_DisplayAttribute;
        }
        /*DisplayAttribute*/ set DisplayAttribute(value)
        {
            _backingField_DisplayAttribute = value;
        }
    }
    static System_ComponentModel_DataAnnotations_ValidationAttributeStore_TypeStoreItem = class extends System_ComponentModel_DataAnnotations_ValidationAttributeStore_StoreItem
    {
        /*object*/ _syncRoot = new object();
        /*Type*/ _type = null;
        /*Dictionary<string, PropertyStoreItem>*/ _propertyStoreItems = null;
        constructor(/*Type*/ type, /*IEnumerable<Attribute>*/ attributes)
        {
            super(attributes);
            this._type  = type;
        }
        /*PropertyStoreItem*/ GetPropertyStoreItem(/*string*/ propertyName)
        {
            let $ref0 = { set value(v){ item = v } };
            /*PropertyStoreItem*/ let item = null;
            if (this.TryGetPropertyStoreItem(propertyName, $ref0))
            {
                throw new ArgumentException("AttributeStore_Unknown_Property", nameof(propertyName));
            }
            return item;
        }
        /*bool*/ TryGetPropertyStoreItem(/*string*/ propertyName, /*out PropertyStoreItem*/ item)
        {
            let $ref0 = { set value(v){ item = v } };
            if (string.IsNullOrEmpty(propertyName))
            {
                throw new ArgumentNullException("propertyName");
            }
            if (this._propertyStoreItems  === null)
            {
                //lock
                {
                    if (this._propertyStoreItems  === null)
                    {
                        this._propertyStoreItems  = this.CreatePropertyStoreItems();
                    }
                }
            }
            if (this._propertyStoreItems.TryGetValue(propertyName, $ref0))
            {
                return false;
            }
            return true;
        }
        /*Dictionary<string, PropertyStoreItem>*/ CreatePropertyStoreItems()
        {
            /*Dictionary<string, PropertyStoreItem>*/ let propertyStoreItems = new Dictionary(string, PropertyStoreItem)();
            /*//#if SILVERLIGHT
                PropertyInfo[]*/ let properties = this._type.GetProperties();
            BlazorJs.forEach(properties, function(property, $_i)
            {
                /*PropertyStoreItem*/ let item = new PropertyStoreItem(property.PropertyType, Enumerable.Cast(Attribute, property.GetCustomAttributes(true)));
                propertyStoreItems[property.Name] = item;
            });
            return propertyStoreItems;
        }
    }
    static System_ComponentModel_DataAnnotations_ValidationAttributeStore_PropertyStoreItem = class extends System_ComponentModel_DataAnnotations_ValidationAttributeStore_StoreItem
    {
        /*Type*/ _propertyType = null;
        constructor(/*Type*/ propertyType, /*IEnumerable<Attribute>*/ attributes)
        {
            super(attributes);
            this._propertyType  = propertyType;
        }
        /*Type*/ get PropertyType()
        {
            return this._propertyType;
        }
    }
}

class System_ComponentModel_DataAnnotations_ValidationContext extends System_IServiceProvider(object)
{
    /*Func<Type, object>*/ _serviceProvider = null;
    /*object*/ _objectInstance = null;
    /*string*/ _memberName = null;
    /*string*/ _displayName = null;
    /*Dictionary<object, object>*/ _items = null;
    constructor(/*object*/ instance)
    {
        super(instance, null, null);
    }
    constructor(/*object*/ instance, /*IDictionary<object, object>*/ items)
    {
        super(instance, null, items);
    }
    constructor(/*object*/ instance, /*IServiceProvider*/ serviceProvider, /*IDictionary<object, object>*/ items)
    {
        super();
        if (instance === null)
        {
            throw new ArgumentNullException("instance");
        }
        if (serviceProvider !== null)
        {
            this.InitializeServiceProvider(function(/**/ serviceType)
            {
                return serviceProvider.GetService(serviceType);
            });
        }
        if (items !== null)
        {
            this._items  = new Dictionary(object, object)(items);
        }
        else 
        {
            this._items  = new Dictionary(object, object)();
        }
        this._objectInstance  = instance;
    }
    /*object*/ get ObjectInstance()
    {
        return this._objectInstance;
    }
    /*Type*/ get ObjectType()
    {
        return this.ObjectInstance.GetType();
    }
    /*string*/ get DisplayName()
    {
        if (string.IsNullOrEmpty(this._displayName))
        {
            this._displayName  = this.GetDisplayName();
            if (string.IsNullOrEmpty(this._displayName))
            {
                this._displayName  = this.MemberName;
                if (string.IsNullOrEmpty(this._displayName))
                {
                    this._displayName  = this.ObjectType.Name;
                }
            }
        }
        return this._displayName;
    }
    /*string*/ set DisplayName(value)
    {
        if (string.IsNullOrEmpty(value))
        {
            throw new ArgumentNullException("value");
        }
        this._displayName  = value;
    }
    /*string*/ get MemberName()
    {
        return this._memberName;
    }
    /*string*/ set MemberName(value)
    {
        this._memberName  = value;
    }
    /*IDictionary<object, object>*/ get Items()
    {
        return this._items;
    }
    /*string*/ GetDisplayName()
    {
        /*string*/ let displayName = null;
        /*ValidationAttributeStore*/ let store = ValidationAttributeStore.Instance;
        /*DisplayAttribute*/ let displayAttribute = null;
        if (string.IsNullOrEmpty(this._memberName))
        {
            displayAttribute = store.GetTypeDisplayAttribute(this);
        }
        else if (store.IsPropertyContext(this))
        {
            displayAttribute = store.GetPropertyDisplayAttribute(this);
        }
        if (displayAttribute !== null)
        {
            displayName = displayAttribute.GetName();
        }
        return displayName ?? this.MemberName;
    }
    /*void*/ InitializeServiceProvider(/*Func<Type, object>*/ serviceProvider)
    {
        this._serviceProvider  = serviceProvider;
    }
    /*object*/ GetService(/*Type*/ serviceType)
    {
        /*object*/ let service = null;
        if (this._serviceProvider  !== null)
        {
            service = this._serviceProvider(serviceType);
        }
        return service;
    }
    /*object*/ GetKeyedService(/*Type*/ type, /*object*/ key)
    {
        return GetService(type);
    }
}

class System_ComponentModel_DataAnnotations_ValidationException extends System_Exception
{
    /*ValidationResult*/ _validationResult = null;
    /*ValidationAttribute*/ _backingField_ValidationAttribute = null;
    /*ValidationAttribute*/ get ValidationAttribute()
    {
        return _backingField_ValidationAttribute;
    }
    /*ValidationAttribute*/ set ValidationAttribute(value)
    {
        _backingField_ValidationAttribute = value;
    }
    /*ValidationResult*/ get ValidationResult()
    {
        if (this._validationResult  === null)
        {
            this._validationResult  = new ValidationResult(this.Message);
        }
        return this._validationResult;
    }
    /*object*/ _backingField_Value = null;
    /*object*/ get Value()
    {
        return _backingField_Value;
    }
    /*object*/ set Value(value)
    {
        _backingField_Value = value;
    }
    constructor(/*ValidationResult*/ validationResult, /*ValidationAttribute*/ validatingAttribute, /*object*/ value)
    {
        super(validationResult.ErrorMessage, validatingAttribute, value);
        this._validationResult  = validationResult;
    }
    constructor(/*string*/ errorMessage, /*ValidationAttribute*/ validatingAttribute, /*object*/ value)
    {
        super(errorMessage);
        this.Value  = value;
        this.ValidationAttribute  = validatingAttribute;
    }
    constructor()
    {
        super();
    }
    constructor(/*string*/ message)
    {
        super(message);
    }
    constructor(/*string*/ message, /*Exception*/ innerException)
    {
        super(message, innerException);
    }
}

class System_ComponentModel_DataAnnotations_ValidationResult extends object
{
    /*IEnumerable<string>*/ _memberNames = null;
    /*string*/ _errorMessage = null;
    /*ValidationResult*/ static Success = null;
    constructor(/*string*/ errorMessage)
    {
        super(errorMessage, null);
    }
    constructor(/*string*/ errorMessage, /*IEnumerable<string>*/ memberNames)
    {
        super();
        this._errorMessage  = errorMessage;
        this._memberNames  = memberNames ?? new Array(0);
    }
    constructor(/*ValidationResult*/ validationResult)
    {
        super();
        if (validationResult === null)
        {
            throw new ArgumentNullException("validationResult");
        }
        this._errorMessage  = validationResult._errorMessage;
        this._memberNames  = validationResult._memberNames;
    }
    /*IEnumerable<string>*/ get MemberNames()
    {
        return this._memberNames;
    }
    /*string*/ get ErrorMessage()
    {
        return this._errorMessage;
    }
    /*string*/ set ErrorMessage(value)
    {
        this._errorMessage  = value;
    }
    /*string*/ ToString()
    {
        return this.ErrorMessage  ?? super.ToString();
    }
}

static class System_ComponentModel_DataAnnotations_Validator
{
    /*ValidationAttributeStore*/ static _store = ValidationAttributeStore.Instance;
    /*bool*/ static TryValidateProperty(/*object*/ value, /*ValidationContext*/ validationContext, /*ICollection<ValidationResult>*/ validationResults)
    {
        /*// Throw if value cannot be assigned to this property.  That is not a validation exception.
            Type*/ let propertyType = _store.GetPropertyType(validationContext);
        /*string*/ let propertyName = validationContext.MemberName;
        EnsureValidPropertyType(propertyName, propertyType, value);
        /*bool*/ let result = true;
        /*bool*/ let breakOnFirstError = (validationResults === null);
        /*IEnumerable<ValidationAttribute>*/ let attributes = _store.GetPropertyValidationAttributes(validationContext);
        BlazorJs.forEach(GetValidationErrors(value, validationContext, attributes, breakOnFirstError), function(err, $_i)
        {
            result = false;
            if (validationResults !== null)
            {
                validationResults.Add(err.ValidationResult);
            }
        });
        return result;
    }
    /*bool*/ static TryValidateObject(/*object*/ instance, /*ValidationContext*/ validationContext, /*ICollection<ValidationResult>*/ validationResults)
    {
        return TryValidateObject(instance, validationContext, validationResults, false);
    }
    /*bool*/ static TryValidateObject(/*object*/ instance, /*ValidationContext*/ validationContext, /*ICollection<ValidationResult>*/ validationResults, /*bool*/ validateAllProperties)
    {
        if (instance === null)
        {
            throw new ArgumentNullException("instance");
        }
        if (validationContext !== null && instance !== validationContext.ObjectInstance)
        {
            throw new ArgumentException("Validator_InstanceMustMatchValidationContextInstance", nameof(instance));
        }
        /*bool*/ let result = true;
        /*bool*/ let breakOnFirstError = (validationResults === null);
        BlazorJs.forEach(GetObjectValidationErrors(instance, validationContext, validateAllProperties, breakOnFirstError), function(err, $_i)
        {
            result = false;
            if (validationResults !== null)
            {
                validationResults.Add(err.ValidationResult);
            }
        });
        return result;
    }
    /*bool*/ static TryValidateValue(/*object*/ value, /*ValidationContext*/ validationContext, /*ICollection<ValidationResult>*/ validationResults, /*IEnumerable<ValidationAttribute>*/ validationAttributes)
    {
        /*bool*/ let result = true;
        /*bool*/ let breakOnFirstError = validationResults === null;
        BlazorJs.forEach(GetValidationErrors(value, validationContext, validationAttributes, breakOnFirstError), function(err, $_i)
        {
            result = false;
            if (validationResults !== null)
            {
                validationResults.Add(err.ValidationResult);
            }
        });
        return result;
    }
    /*void*/ static ValidateProperty(/*object*/ value, /*ValidationContext*/ validationContext)
    {
        /*// Throw if value cannot be assigned to this property.  That is not a validation exception.
            Type*/ let propertyType = _store.GetPropertyType(validationContext);
        EnsureValidPropertyType(validationContext.MemberName, propertyType, value);
        /*IEnumerable<ValidationAttribute>*/ let attributes = _store.GetPropertyValidationAttributes(validationContext);
        /*ValidationError*/ let err = GetValidationErrors(value, validationContext, attributes, false).FirstOrDefault();
        if (err !== null)
        {
            err.ThrowValidationException();
        }
    }
    /*void*/ static ValidateObject(/*object*/ instance, /*ValidationContext*/ validationContext)
    {
        ValidateObject(instance, validationContext, false);
    }
    /*void*/ static ValidateObject(/*object*/ instance, /*ValidationContext*/ validationContext, /*bool*/ validateAllProperties)
    {
        if (instance === null)
        {
            throw new ArgumentNullException("instance");
        }
        if (validationContext === null)
        {
            throw new ArgumentNullException("validationContext");
        }
        if (instance !== validationContext.ObjectInstance)
        {
            throw new ArgumentException("Validator_InstanceMustMatchValidationContextInstance", nameof(instance));
        }
        /*ValidationError*/ let err = GetObjectValidationErrors(instance, validationContext, validateAllProperties, false).FirstOrDefault();
        if (err !== null)
        {
            err.ThrowValidationException();
        }
    }
    /*void*/ static ValidateValue(/*object*/ value, /*ValidationContext*/ validationContext, /*IEnumerable<ValidationAttribute>*/ validationAttributes)
    {
        if (validationContext === null)
        {
            throw new ArgumentNullException("validationContext");
        }
        /*ValidationError*/ let err = GetValidationErrors(value, validationContext, validationAttributes, false).FirstOrDefault();
        if (err !== null)
        {
            err.ThrowValidationException();
        }
    }
    /*ValidationContext*/ static CreateValidationContext(/*object*/ instance, /*ValidationContext*/ validationContext)
    {
        if (validationContext === null)
        {
            throw new ArgumentNullException("validationContext");
        }
        /*// Create a new context using the existing ValidationContext that acts as an IServiceProvider and contains our existing items.
            ValidationContext*/ let context = new ValidationContext(instance, validationContext, validationContext.Items);
        return context;
    }
    /*bool*/ static CanBeAssigned(/*Type*/ destinationType, /*object*/ value)
    {
        if (destinationType === null)
        {
            throw new ArgumentNullException("destinationType");
        }
        if (value === null)
        {
            return destinationType.IsValueType  || (destinationType.IsGenericType  && destinationType.GetGenericTypeDefinition() === Nullable());
        }
        return destinationType.IsAssignableFrom(value.GetType());
    }
    /*void*/ static EnsureValidPropertyType(/*string*/ propertyName, /*Type*/ propertyType, /*object*/ value)
    {
        if (CanBeAssigned(propertyType, value))
        {
            throw new ArgumentException("Validator_Property_Value_Wrong_Type", nameof(value));
        }
    }
    /*IEnumerable<ValidationError>*/ static GetObjectValidationErrors(/*object*/ instance, /*ValidationContext*/ validationContext, /*bool*/ validateAllProperties, /*bool*/ breakOnFirstError)
    {
        if (instance === null)
        {
            throw new ArgumentNullException("instance");
        }
        if (validationContext === null)
        {
            throw new ArgumentNullException("validationContext");
        }
        /*// Step 1: Validate the object properties' validation attributes
            List<ValidationError>*/ let errors = new List(ValidationError)();
        errors.AddRange(GetObjectPropertyValidationErrors(instance, validationContext, validateAllProperties, breakOnFirstError));
        if (errors.Any())
        {
            return errors;
        }
        /*// Step 2: Validate the object's validation attributes
            IEnumerable<ValidationAttribute>*/ let attributes = _store.GetTypeValidationAttributes(validationContext);
        errors.AddRange(GetValidationErrors(instance, validationContext, attributes, breakOnFirstError));
        if (errors.Any())
        {
            return errors;
        }
        /*// Step 3: Test for IValidatableObject implementation
            IValidatableObject*/ let validatable = BlazorJs.As(instance, IValidatableObject);
        if (validatable !== null)
        {
            /*IEnumerable<ValidationResult>*/ let results = validatable.Validate(validationContext);
            BlazorJs.forEach(results.Where(function(/**/ r)
            {
                return r !== ValidationResult.Success;
            }), function(result, $_i)
            {
                errors.Add(new ValidationError(null, instance, result));
            });
        }
        return errors;
    }
    /*IEnumerable<ValidationError>*/ static GetObjectPropertyValidationErrors(/*object*/ instance, /*ValidationContext*/ validationContext, /*bool*/ validateAllProperties, /*bool*/ breakOnFirstError)
    {
        /*ICollection<KeyValuePair<ValidationContext, object>>*/ let properties = GetPropertyValues(instance, validationContext);
        /*List<ValidationError>*/ let errors = new List(ValidationError)();
        BlazorJs.forEach(properties, function(property, $_i)
        {
            /*// get list of all validation attributes for this property
                IEnumerable<ValidationAttribute>*/ let attributes = _store.GetPropertyValidationAttributes(property.Key);
            if (validateAllProperties)
            {
                errors.AddRange(GetValidationErrors(property.Value, property.Key, attributes, breakOnFirstError));
            }
            else 
            {
                /*// only validate the Required attributes
                    RequiredAttribute*/ let reqAttr = BlazorJs.As(attributes.FirstOrDefault(function(/**/ a)
                {
                    return a instanceof RequiredAttribute;
                }), RequiredAttribute);
                if (reqAttr !== null)
                {
                    /*// Note: we let the [Required] attribute do its own null testing,
                        // since the user may have subclassed it and have a deeper meaning to what 'required' means
                        ValidationResult*/ let validationResult = reqAttr.GetValidationResult(property.Value, property.Key);
                    if (validationResult !== ValidationResult.Success)
                    {
                        errors.Add(new ValidationError(reqAttr, property.Value, validationResult));
                    }
                }
            }
            if (breakOnFirstError && errors.Any())
            {
                break;
            }
        });
        return errors;
    }
    /*ICollection<KeyValuePair<ValidationContext, object>>*/ static GetPropertyValues(/*object*/ instance, /*ValidationContext*/ validationContext)
    {
        /*//#if SILVERLIGHT
            IEnumerable<PropertyInfo>*/ let properties = instance.GetType().GetProperties()property.GetIndexParameters().Any()property;
        /*List<KeyValuePair<ValidationContext, object>>*/ let items = new List(KeyValuePair(ValidationContext, object))(properties.Count());
        BlazorJs.forEach(properties, function(property, $_i)
        {
            /*ValidationContext*/ let context = CreateValidationContext(instance, validationContext);
            context.MemberName  = property.Name;
            if (_store.GetPropertyValidationAttributes(context).Any())
            {
                items.Add(new KeyValuePair(ValidationContext, object)(context, property.GetValue(instance, null)));
            }
        });
        return items;
    }
    /*IEnumerable<ValidationError>*/ static GetValidationErrors(/*object*/ value, /*ValidationContext*/ validationContext, /*IEnumerable<ValidationAttribute>*/ attributes, /*bool*/ breakOnFirstError)
    {
        if (validationContext === null)
        {
            throw new ArgumentNullException("validationContext");
        }
        /*List<ValidationError>*/ let errors = new List(ValidationError)();
        /*ValidationError*/ let validationError;
        /*// Get the required validator if there is one and test it first, aborting on failure
            RequiredAttribute*/ let required = BlazorJs.As(attributes.FirstOrDefault(function(/**/ a)
        {
            return a instanceof RequiredAttribute;
        }), RequiredAttribute);
        if (required !== null)
        {
            let $ref0 = { set value(v){ validationError = v } };
            if (TryValidate(value, validationContext, required, $ref0))
            {
                errors.Add(validationError);
                return errors;
            }
        }
        BlazorJs.forEach(attributes, function(attr, $_i)
        {
            if (attr !== required)
            {
                let $ref0 = { set value(v){ validationError = v } };
                if (TryValidate(value, validationContext, attr, $ref0))
                {
                    errors.Add(validationError);
                    if (breakOnFirstError)
                    {
                        break;
                    }
                }
            }
        });
        return errors;
    }
    /*bool*/ static TryValidate(/*object*/ value, /*ValidationContext*/ validationContext, /*ValidationAttribute*/ attribute, /*out ValidationError*/ validationError)
    {
        if (validationContext === null)
        {
            throw new ArgumentNullException("validationContext");
        }
        /*ValidationResult*/ let validationResult = attribute.GetValidationResult(value, validationContext);
        if (validationResult !== ValidationResult.Success)
        {
            validationError = new ValidationError(attribute, value, validationResult);
            return false;
        }
        validationError = null;
        return true;
    }
    static System_ComponentModel_DataAnnotations_Validator_ValidationError = class extends object
    {
        constructor(/*ValidationAttribute*/ validationAttribute, /*object*/ value, /*ValidationResult*/ validationResult)
        {
            super();
            this.ValidationAttribute  = validationAttribute;
            this.ValidationResult  = validationResult;
            this.Value  = value;
        }
        /*object*/ _backingField_Value = null;
        /*object*/ get Value()
        {
            return _backingField_Value;
        }
        /*object*/ set Value(value)
        {
            _backingField_Value = value;
        }
        /*ValidationAttribute*/ _backingField_ValidationAttribute = null;
        /*ValidationAttribute*/ get ValidationAttribute()
        {
            return _backingField_ValidationAttribute;
        }
        /*ValidationAttribute*/ set ValidationAttribute(value)
        {
            _backingField_ValidationAttribute = value;
        }
        /*ValidationResult*/ _backingField_ValidationResult = null;
        /*ValidationResult*/ get ValidationResult()
        {
            return _backingField_ValidationResult;
        }
        /*ValidationResult*/ set ValidationResult(value)
        {
            _backingField_ValidationResult = value;
        }
        /*void*/ ThrowValidationException()
        {
            throw new ValidationException(this.ValidationResult, this.ValidationAttribute, this.Value);
        }
    }
}

class System_Diagnostics_CodeAnalysis_DisallowNullAttribute extends System_Attribute
{
    constructor()
    {
        super();
    }
}

class System_Diagnostics_CodeAnalysis_MaybeNullWhenAttribute extends System_Attribute
{
    constructor(/*bool*/ returnValue)
    {
        super();
        ReturnValue = returnValue;
    }
    /*bool*/ _backingField_ReturnValue = null;
    /*bool*/ get ReturnValue()
    {
        return _backingField_ReturnValue;
    }
}

class System_Diagnostics_CodeAnalysis_NotNullIfNotNullAttribute extends System_Attribute
{
    constructor(/*string*/ parameterName)
    {
        super();
        ParameterName = parameterName;
    }
    /*string*/ _backingField_ParameterName = null;
    /*string*/ get ParameterName()
    {
        return _backingField_ParameterName;
    }
}

class System_Diagnostics_CodeAnalysis_NotNullWhenAttribute extends System_Attribute
{
    constructor(/*bool*/ returnValue)
    {
        super();
    }
    /*bool*/ _backingField_ReturnValue = null;
    /*bool*/ get ReturnValue()
    {
        return _backingField_ReturnValue;
    }
}

class System_Drawing_Color extends H5_IH5Class(System_IEquatable(System_Drawing_Color)(System_ValueType))
{
    constructor(/*byte*/ r, /*byte*/ g, /*byte*/ b, /*byte*/ a)
    {
        super();
        R = r;
        G = g;
        B = b;
        A = a;
    }
    /*byte*/ _backingField_R = null;
    /*byte*/ get R()
    {
        return _backingField_R;
    }
    /*byte*/ _backingField_G = null;
    /*byte*/ get G()
    {
        return _backingField_G;
    }
    /*byte*/ _backingField_B = null;
    /*byte*/ get B()
    {
        return _backingField_B;
    }
    /*byte*/ _backingField_A = null;
    /*byte*/ get A()
    {
        return _backingField_A;
    }
    /*Color*/ static FromArgb(/*int*/ alpha, /*int*/ red, /*int*/ green, /*int*/ blue)
    {
        return new Color(BlazorJs.Cast(red, byte), BlazorJs.Cast(green, byte), BlazorJs.Cast(blue, byte), BlazorJs.Cast(alpha, byte));
    }
    /*Color*/ static FromArgb(/*int*/ red, /*int*/ green, /*int*/ blue)
    {
        return new Color(BlazorJs.Cast(red, byte), BlazorJs.Cast(green, byte), BlazorJs.Cast(blue, byte), BlazorJs.Cast(255, byte));
    }
    /*bool*/ Equals(/*Color*/ other)
    {
        return A === other.A  && R === other.R  && G === other.G  && B === other.B;
    }
    /*float*/ GetBrightness()
    {
        throw new NotImplementedException();
    }
    /*float*/ GetHue()
    {
        throw new NotImplementedException();
    }
    /*float*/ GetSaturation()
    {
        throw new NotImplementedException();
    }
    /*int*/ ToArgb()
    {
        throw new NotImplementedException();
    }
}

class System_IO_AsyncStream extends System_IO_Stream
{
    constructor()
    {
        super();
    }
    /*IAsyncResult*/ BeginRead(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count, /*AsyncCallback*/ callback, /*object*/ state)
    {
        return TaskToAsyncResult.Begin(ReadAsync(buffer, offset, count, BlazorJs.getDefault()), callback, state);
    }
    /*int*/ EndRead(/*IAsyncResult*/ asyncResult)
    {
        return TaskToAsyncResult.End(int, asyncResult);
    }
    /*IAsyncResult*/ BeginWrite(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count, /*AsyncCallback*/ callback, /*object*/ state)
    {
        return TaskToAsyncResult.Begin(WriteAsync(buffer, offset, count, BlazorJs.getDefault()), callback, state);
    }
    /*void*/ EndWrite(/*IAsyncResult*/ asyncResult)
    {
        return TaskToAsyncResult.End(asyncResult);
    }
    /*Task<int>*/ ReadAsync(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count, /*CancellationToken*/ cancellationToken)
    {
        return ReadAsync(new Span(byte)(buffer, offset, count), cancellationToken);
    }
    /*Task*/ WriteAsync(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count, /*CancellationToken*/ cancellationToken)
    {
        return WriteAsync(new ReadOnlySpan(byte)(buffer, offset, count), cancellationToken);
    }
    /*Task*/ FlushAsync(/*CancellationToken*/ cancellationToken)
    {
        return NopAsync(cancellationToken);
    }
    /*void*/ Flush()
    {
    }
    /*void*/ Write(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count)
    {
        WriteAsync(buffer, offset, count, CancellationToken.None).FireAndForget();
    }
    /*int*/ Read(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count)
    {
        return ReadAsync(buffer, offset, count, CancellationToken.None).GetAwaiter().GetResult();
    }
    /*Task*/ static NopAsync(/*CancellationToken*/ cancellationToken)
    {
        return cancellationToken.IsCancellationRequested  ? BlazorJs.Execute(function(){ throw new TaskCanceledException() }) : Task.CompletedTask;
    }
}

static class System_IO_Path
{
    /*string*/ static GetExtension(/*string*/ name)
    {
        /*var*/ let dot = name.LastIndexOf('.');
        if (dot >= 0)
        return name.Substring(dot);
        return "";
    }
}

static class System_IO_StreamExtensions
{
    /*Task<int>*/ static WriteAsync(/*this Stream*/ stream, /*byte[]*/ data, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        stream.Write(data, 0, data.Length);
        return Task.FromResult(data.Length);
    }
    /*Task<int>*/ static WriteAsync(/*this Stream*/ stream, /*byte[]*/ data, /*int*/ offset, /*int*/ count, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        stream.Write(data, offset, count);
        return Task.FromResult(data.Length);
    }
    /*Task<int>*/ static WriteAsync(/*this Stream*/ stream, /*ReadOnlySpan<byte>*/ data, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        data.CopyTo(stream);
        return Task.FromResult(data.Length);
    }
    /*Task<int>*/ static ReadAsync(/*this Stream*/ stream, /*byte[]*/ buffer, /*int*/ offset, /*int*/ count, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        /*int*/ let len = stream.Read(buffer, offset, count);
        return Task.FromResult(len);
    }
    /*Task<int>*/ static ReadAsync(/*this Stream*/ stream, /*Span<byte>*/ buffer, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        /*var*/ let len = buffer.CopyFrom(stream);
        return Task.FromResult(len);
    }
    /*Task*/ static CopyToAsync(/*this Stream*/ stream, /*Stream*/ destination, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        throw new NotImplementedException();
    }
    /*Task*/ static CopyToAsync(/*this Stream*/ stream, /*Stream*/ destination, /*int*/ bufferSize, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        throw new NotImplementedException();
    }
}

static class System_IO_TextReaderExtension
{
    /*Task<string>*/ static ReadLineAsync(/*this TextReader*/ reader)
    {
        throw new NotImplementedException();
    }
}

static class System_Linq_Expressions_ExpressionExtensions
{
    /*Delegate*/ static Compile(/*this LambdaExpression*/ expression)
    {
        /*var*/ let exp = expression.Body;
        /*Func<object, object>*/ let _delegate = function(/**/ o)
        {
            return o;
        };
        while(exp !== null)
        {
            if (exp instanceof UnaryExpression, un = exp)
            {
                exp = un.Operand;
            }
            else if (exp instanceof MemberExpression, mem = exp)
            {
                /*var*/ let originalDelegate = _delegate;
                _delegate = function(/**/ d)
                {
                    /*var*/ let o = originalDelegate(d);
                    return (BlazorJs.Cast(mem.Member, PropertyInfo)).GetMethod.Invoke(o);
                };
                exp = mem.Expression;
            }
            else if (exp instanceof ParameterExpression, pem = exp)
            {
                if (pem.Name  !== "value")
                {
                    /*var*/ let originalDelegate = _delegate;
                    _delegate = function(/**/ d)
                    {
                        return originalDelegate(d)[pem.Name];
                    };
                }
                exp = null;
            }
            else 
            {
                throw new InvalidOperationException("Unimplemented expression type");
            }
        }
        return _delegate;
    }
    /*TDelegate*/ static Compile(TDelegate, /*this Expression<TDelegate>*/ expression)
    {
        return BlazorJs.Cast(BlazorJs.Cast(Compile(BlazorJs.Cast(expression, LambdaExpression)), object), TDelegate);
    }
    /*Expression*/ static Update(/*this Expression*/ expression, /*Expression*/ expression2)
    {
        throw new NotImplementedException();
    }
}

static class System_Net_Http_Ascii
{
    /*bool*/ static IsValid(/*string*/ str)
    {
        return str.All(function(/**/ c)
        {
            return c < 128;
        });
    }
    /*bool*/ static EqualsIgnoreCase(/*ReadOnlySpan<byte>*/ name, /*string*/ str)
    {
        if (name.Length  !== str.Length)
        return false;
        /*bool*/ let equals = true;
        name.ForEach(function(/**/ t, /**/ i)
        {
            /*bool*/ let eq = t === str[i];
            if (eq)
            {
                equals = false;
                return false;
            }
            return true;
        });
        return equals;
    }
}

static class System_Net_Http_CancellationHelper
{
    /*string*/ static s_cancellationMessage = new OperationCanceledException().Message;
    /*bool*/ static ShouldWrapInOperationCanceledException(/*Exception*/ exception, /*CancellationToken*/ cancellationToken)
    {
        return (exception instanceof OperationCanceledException) && cancellationToken.IsCancellationRequested;
    }
    /*Exception*/ static CreateOperationCanceledException(/*Exception*/ innerException, /*CancellationToken*/ cancellationToken)
    {
        return new TaskCanceledException(s_cancellationMessage, innerException);
    }
    /*void*/ static ThrowOperationCanceledException(/*Exception*/ innerException, /*CancellationToken*/ cancellationToken)
    {
        throw CreateOperationCanceledException(innerException, cancellationToken);
    }
    /*void*/ static ThrowIfCancellationRequested(/*CancellationToken*/ cancellationToken)
    {
        ThrowIfCancellationRequested(cancellationToken, { innerException : null });
    }
    /*void*/ static ThrowIfCancellationRequested(/*Exception*/ innerException, /*CancellationToken*/ cancellationToken)
    {
        if (cancellationToken.IsCancellationRequested)
        {
            ThrowOperationCanceledException(innerException, cancellationToken);
        }
    }
}

class System_Net_Http_EmptyContent extends System_Net_Http_HttpContent
{
    constructor()
    {
        super();
    }
    /*bool*/ TryComputeLength(/*out long*/ length)
    {
        length = 0;
        return true;
    }
    /*void*/ SerializeToStream(/*Stream*/ stream, /*CancellationToken*/ cancellationToken)
    {
    }
    /*Task*/ SerializeToStreamAsync(/*Stream*/ stream)
    {
        return Task.CompletedTask;
    }
    /*Task*/ SerializeToStreamAsync(/*Stream*/ stream, /*CancellationToken*/ cancellationToken)
    {
        return cancellationToken.IsCancellationRequested  ? BlazorJs.Execute(function(){ throw new TaskCanceledException() }) : SerializeToStreamAsync(stream);
    }
    /*Stream*/ CreateContentReadStream(/*CancellationToken*/ cancellationToken)
    {
        return EmptyReadStream.Instance;
    }
    /*Task<Stream>*/ CreateContentReadStreamAsync()
    {
        return Task.FromResult(Stream, EmptyReadStream.Instance);
    }
    /*Task<Stream>*/ CreateContentReadStreamAsync(/*CancellationToken*/ cancellationToken)
    {
        return cancellationToken.IsCancellationRequested  ? BlazorJs.Execute(function(){ throw new TaskCanceledException() }) : CreateContentReadStreamAsync();
    }
    /*Stream*/ TryCreateContentReadStream()
    {
        return EmptyReadStream.Instance;
    }
    /*bool*/ get AllowDuplex()
    {
        return false;
    }
}

class System_Net_Http_EmptyReadStream extends System_Net_Http_HttpBaseStream
{
    /*EmptyReadStream*/ _backingField_Instance = null;
    /*EmptyReadStream*/ static get Instance()
    {
        return _backingField_Instance;
    }
    constructor()
    {
        super();
    }
    /*bool*/ get CanRead()
    {
        return true;
    }
    /*bool*/ get CanWrite()
    {
        return false;
    }
    /*void*/ Dispose(/*bool*/ disposing)
    {
    }
    /*void*/ Close()
    {
    }
    /*Task<int>*/ ReadAsync(/*Span<byte>*/ buffer, /*CancellationToken*/ cancellationToken)
    {
        return cancellationToken.IsCancellationRequested  ? BlazorJs.Execute(function(){ throw new TaskCanceledException() }) : Task.FromResult(0);
    }
    /*Task<int>*/ WriteAsync(/*ReadOnlySpan<byte>*/ buffer, /*CancellationToken*/ cancellationToken)
    {
        throw new NotSupportedException("net_http_content_readonly_stream");
    }
    /*int*/ Read(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count)
    {
        return 0;
    }
}

static class System_Net_Http_HexConverter
{
    /*char*/ static ToCharUpper(/*int*/ c)
    {
        return BlazorJs.Cast((c <= 9 ? '0' + c : 'A' + (c - 10)), char);
    }
}

class System_Net_Http_HttpBaseStream extends System_IO_AsyncStream
{
    constructor()
    {
        super();
    }
    /*bool*/ get CanSeek()
    {
        return false;
    }
    /*long*/ Seek(/*long*/ offset, /*SeekOrigin*/ origin)
    {
        throw new NotSupportedException();
    }
    /*void*/ SetLength(/*long*/ value)
    {
        throw new NotSupportedException();
    }
    /*long*/ get Length()
    {
        throw new NotSupportedException();
    }
    /*long*/ get Position()
    {
        throw new NotSupportedException();
    }
    /*long*/ set Position(value)
    {
        throw new NotSupportedException();
    }
    /*int*/ ReadByte()
    {
        /*byte[]*/ let b = [ 0 ];
        return Read(b, 0, 1) === 1 ? b[0] : 1;
    }
    /*void*/ Write(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count)
    {
        WriteAsync(buffer, offset, count, CancellationToken.None).GetAwaiter().GetResult();
    }
    /*void*/ WriteByte(/*byte*/ value)
    {
        return Write([ value ], 0, 1);
    }
}

class System_Net_Http_HttpClient extends System_Net_Http_HttpMessageInvoker
{
    /*TimeSpan*/ static s_defaultTimeout = TimeSpan.FromSeconds(100);
    /*TimeSpan*/ static s_maxTimeout = TimeSpan.FromMilliseconds(int.MaxValue);
    /*TimeSpan*/ static s_infiniteTimeout = TimeSpan.MaxValue;
    /*HttpCompletionOption*/ DefaultCompletionOption = HttpCompletionOption.ResponseContentRead;
    /*bool*/ _operationStarted = null;
    /*bool*/ _disposed = null;
    /*CancellationTokenSource*/ _pendingRequestsCts = null;
    /*HttpRequestHeaders*/ _defaultRequestHeaders = null;
    /*Version*/ _defaultRequestVersion = HttpRequestMessage.DefaultRequestVersion;
    /*HttpVersionPolicy*/ _defaultVersionPolicy = HttpRequestMessage.DefaultVersionPolicy;
    /*Uri*/ _baseAddress = null;
    /*TimeSpan*/ _timeout = null;
    /*int*/ _maxResponseContentBufferSize = null;
    /*HttpRequestHeaders*/ get DefaultRequestHeaders()
    {
        return _defaultRequestHeaders = _defaultRequestHeaders ?? new HttpRequestHeaders();
    }
    /*Version*/ get DefaultRequestVersion()
    {
        return _defaultRequestVersion;
    }
    /*Version*/ set DefaultRequestVersion(value)
    {
        CheckDisposedOrStarted();
        _defaultRequestVersion = value;
    }
    /*HttpVersionPolicy*/ get DefaultVersionPolicy()
    {
        return _defaultVersionPolicy;
    }
    /*HttpVersionPolicy*/ set DefaultVersionPolicy(value)
    {
        CheckDisposedOrStarted();
        _defaultVersionPolicy = value;
    }
    /*Uri*/ get BaseAddress()
    {
        return _baseAddress;
    }
    /*Uri*/ set BaseAddress(value)
    {
        CheckDisposedOrStarted();
        _baseAddress = value;
    }
    /*TimeSpan*/ get Timeout()
    {
        return _timeout;
    }
    /*TimeSpan*/ set Timeout(value)
    {
        if (value !== s_infiniteTimeout)
        {
            if (value === TimeSpan.Zero  || value > s_maxTimeout)
            throw new ArgumentOutOfRangeException();
        }
        CheckDisposedOrStarted();
        _timeout = value;
    }
    /*long*/ get MaxResponseContentBufferSize()
    {
        return _maxResponseContentBufferSize;
    }
    /*long*/ set MaxResponseContentBufferSize(value)
    {
        if (value <= 0)
        throw new ArgumentOutOfRangeException();
        if (value > HttpContent.MaxBufferSize)
        {
            throw new ArgumentOutOfRangeException();
        }
        CheckDisposedOrStarted();
        Debug.Assert(HttpContent.MaxBufferSize  <= int.MaxValue);
        _maxResponseContentBufferSize = BlazorJs.Cast(value, int);
    }
    constructor()
    {
        super(new BrowserHttpHandler());
    }
    constructor(/*HttpMessageHandler*/ handler)
    {
        super(handler, true);
    }
    constructor(/*HttpMessageHandler*/ handler, /*bool*/ disposeHandler)
    {
        super(handler, disposeHandler);
        _timeout = s_defaultTimeout;
        _maxResponseContentBufferSize = HttpContent.MaxBufferSize;
        _pendingRequestsCts = new CancellationTokenSource();
    }
    /*Task<string>*/ GetStringAsync(/*string*/ requestUri)
    {
        return GetStringAsync(CreateUri(requestUri));
    }
    /*Task<string>*/ GetStringAsync(/*Uri*/ requestUri)
    {
        return GetStringAsync(requestUri, CancellationToken.None);
    }
    /*Task<string>*/ GetStringAsync(/*string*/ requestUri, /*CancellationToken*/ cancellationToken)
    {
        return GetStringAsync(CreateUri(requestUri), cancellationToken);
    }
    /*Task<string>*/ GetStringAsync(/*Uri*/ requestUri, /*CancellationToken*/ cancellationToken)
    {
        /*HttpRequestMessage*/ let request = CreateRequestMessage(HttpMethod.Get, requestUri);
        CheckRequestBeforeSend(request);
        return GetStringAsyncCore(request, cancellationToken);
    }
    /*Task<string>*/ async GetStringAsyncCore(/*HttpRequestMessage*/ request, /*CancellationToken*/ cancellationToken)
    {
        BlazorJs.TupleValue({ Item1: CancellationTokenSourcects, Item2: booldisposeCts, Item3: CancellationTokenSourcependingRequestsCts }) = PrepareCancellationTokenSource(cancellationToken);
        /*HttpResponseMessage*/ let response = null;
        /*HttpContent.LimitArrayPoolWriteStream*/ let buffer = null;
        /*Stream*/ let responseStream = null;
        try
        {
            response = await super.SendAsync(request, cts.Token);
            ThrowForNullResponse(response);
            response.EnsureSuccessStatusCode();
            /*// Get the response content.
                HttpContent*/ let c = response.Content;
            buffer = new HttpContent_LimitArrayPoolWriteStream(_maxResponseContentBufferSize, c.Headers.ContentLength.GetValueOrDefault(), { getFinalSizeFromPool : true });
            responseStream = c.TryReadAsStream();
            if (responseStream === null)
            {
                responseStream = await c.ReadAsStreamAsync(cts.Token);
            }
            try
            {
                responseStream.CopyTo(buffer);
            }
            catch(e)
            {
                throw HttpContent.WrapStreamCopyException(e);
            }
            return HttpContent.ReadBufferAsString(buffer, c.Headers);
        }
        catch(e)
        {
            HandleFailure(e, response, cts, cancellationToken, pendingRequestsCts);
            throw e;
        }
        finally
        {
            {
                FinishSend(response, cts, disposeCts);
                buffer?.Dispose();
                responseStream?.Dispose();
            }
        }
    }
    /*Task<byte[]>*/ GetByteArrayAsync(/*string*/ requestUri)
    {
        return GetByteArrayAsync(CreateUri(requestUri));
    }
    /*Task<byte[]>*/ GetByteArrayAsync(/*Uri*/ requestUri)
    {
        return GetByteArrayAsync(requestUri, CancellationToken.None);
    }
    /*Task<byte[]>*/ GetByteArrayAsync(/*string*/ requestUri, /*CancellationToken*/ cancellationToken)
    {
        return GetByteArrayAsync(CreateUri(requestUri), cancellationToken);
    }
    /*Task<byte[]>*/ GetByteArrayAsync(/*Uri*/ requestUri, /*CancellationToken*/ cancellationToken)
    {
        /*HttpRequestMessage*/ let request = CreateRequestMessage(HttpMethod.Get, requestUri);
        CheckRequestBeforeSend(request);
        return GetByteArrayAsyncCore(request, cancellationToken);
    }
    /*Task<byte[]>*/ async GetByteArrayAsyncCore(/*HttpRequestMessage*/ request, /*CancellationToken*/ cancellationToken)
    {
        BlazorJs.TupleValue({ Item1: CancellationTokenSourcects, Item2: booldisposeCts, Item3: CancellationTokenSourcependingRequestsCts }) = PrepareCancellationTokenSource(cancellationToken);
        /*HttpResponseMessage*/ let response = null;
        /*HttpContent.LimitArrayPoolWriteStream*/ let buffer = null;
        /*Stream*/ let responseStream = null;
        try
        {
            response = await super.SendAsync(request, cts.Token);
            ThrowForNullResponse(response);
            response.EnsureSuccessStatusCode();
            /*// Get the response content.
                HttpContent*/ let c = response.Content;
            buffer = new HttpContent_LimitArrayPoolWriteStream(_maxResponseContentBufferSize, c.Headers.ContentLength.GetValueOrDefault(), { getFinalSizeFromPool : false });
            responseStream = c.TryReadAsStream() ?? await c.ReadAsStreamAsync(cts.Token);
            try
            {
                responseStream.CopyTo(buffer);
            }
            catch(e)
            {
                throw HttpContent.WrapStreamCopyException(e);
            }
            return buffer.ToArray();
        }
        catch(e)
        {
            HandleFailure(e, response, cts, cancellationToken, pendingRequestsCts);
            throw e;
        }
        finally
        {
            {
                buffer?.Dispose();
                responseStream?.Dispose();
                FinishSend(response, cts, disposeCts);
            }
        }
    }
    /*Task<Stream>*/ GetStreamAsync(/*string*/ requestUri)
    {
        return GetStreamAsync(CreateUri(requestUri));
    }
    /*Task<Stream>*/ GetStreamAsync(/*string*/ requestUri, /*CancellationToken*/ cancellationToken)
    {
        return GetStreamAsync(CreateUri(requestUri), cancellationToken);
    }
    /*Task<Stream>*/ GetStreamAsync(/*Uri*/ requestUri)
    {
        return GetStreamAsync(requestUri, CancellationToken.None);
    }
    /*Task<Stream>*/ GetStreamAsync(/*Uri*/ requestUri, /*CancellationToken*/ cancellationToken)
    {
        /*HttpRequestMessage*/ let request = CreateRequestMessage(HttpMethod.Get, requestUri);
        CheckRequestBeforeSend(request);
        return GetStreamAsyncCore(request, cancellationToken);
    }
    /*Task<Stream>*/ async GetStreamAsyncCore(/*HttpRequestMessage*/ request, /*CancellationToken*/ cancellationToken)
    {
        BlazorJs.TupleValue({ Item1: CancellationTokenSourcects, Item2: booldisposeCts, Item3: CancellationTokenSourcependingRequestsCts }) = PrepareCancellationTokenSource(cancellationToken);
        /*HttpResponseMessage*/ let response = null;
        try
        {
            response = await super.SendAsync(request, cts.Token);
            ThrowForNullResponse(response);
            response.EnsureSuccessStatusCode();
            /*HttpContent*/ let c = response.Content;
            return c.TryReadAsStream() ?? await c.ReadAsStreamAsync(cancellationToken);
        }
        catch(e)
        {
            HandleFailure(e, response, cts, cancellationToken, pendingRequestsCts);
            throw e;
        }
        finally
        {
            {
                FinishSend(response, cts, disposeCts);
            }
        }
    }
    /*Task<HttpResponseMessage>*/ GetAsync(/*string*/ requestUri)
    {
        return GetAsync(CreateUri(requestUri));
    }
    /*Task<HttpResponseMessage>*/ GetAsync(/*Uri*/ requestUri)
    {
        return GetAsync(requestUri, DefaultCompletionOption);
    }
    /*Task<HttpResponseMessage>*/ GetAsync(/*string*/ requestUri, /*HttpCompletionOption*/ completionOption)
    {
        return GetAsync(CreateUri(requestUri), completionOption);
    }
    /*Task<HttpResponseMessage>*/ GetAsync(/*Uri*/ requestUri, /*HttpCompletionOption*/ completionOption)
    {
        return GetAsync(requestUri, completionOption, CancellationToken.None);
    }
    /*Task<HttpResponseMessage>*/ GetAsync(/*string*/ requestUri, /*CancellationToken*/ cancellationToken)
    {
        return GetAsync(CreateUri(requestUri), cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ GetAsync(/*Uri*/ requestUri, /*CancellationToken*/ cancellationToken)
    {
        return GetAsync(requestUri, DefaultCompletionOption, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ GetAsync(/*string*/ requestUri, /*HttpCompletionOption*/ completionOption, /*CancellationToken*/ cancellationToken)
    {
        return GetAsync(CreateUri(requestUri), completionOption, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ GetAsync(/*Uri*/ requestUri, /*HttpCompletionOption*/ completionOption, /*CancellationToken*/ cancellationToken)
    {
        return SendAsync(CreateRequestMessage(HttpMethod.Get, requestUri), completionOption, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ PostAsync(/*string*/ requestUri, /*HttpContent*/ content)
    {
        return PostAsync(CreateUri(requestUri), content);
    }
    /*Task<HttpResponseMessage>*/ PostAsync(/*Uri*/ requestUri, /*HttpContent*/ content)
    {
        return PostAsync(requestUri, content, CancellationToken.None);
    }
    /*Task<HttpResponseMessage>*/ PostAsync(/*string*/ requestUri, /*HttpContent*/ content, /*CancellationToken*/ cancellationToken)
    {
        return PostAsync(CreateUri(requestUri), content, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ PostAsync(/*Uri*/ requestUri, /*HttpContent*/ content, /*CancellationToken*/ cancellationToken)
    {
        /*HttpRequestMessage*/ let request = CreateRequestMessage(HttpMethod.Post, requestUri);
        request.Content  = content;
        return SendAsync(request, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ PutAsync(/*string*/ requestUri, /*HttpContent*/ content)
    {
        return PutAsync(CreateUri(requestUri), content);
    }
    /*Task<HttpResponseMessage>*/ PutAsync(/*Uri*/ requestUri, /*HttpContent*/ content)
    {
        return PutAsync(requestUri, content, CancellationToken.None);
    }
    /*Task<HttpResponseMessage>*/ PutAsync(/*string*/ requestUri, /*HttpContent*/ content, /*CancellationToken*/ cancellationToken)
    {
        return PutAsync(CreateUri(requestUri), content, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ PutAsync(/*Uri*/ requestUri, /*HttpContent*/ content, /*CancellationToken*/ cancellationToken)
    {
        /*HttpRequestMessage*/ let request = CreateRequestMessage(HttpMethod.Put, requestUri);
        request.Content  = content;
        return SendAsync(request, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ PatchAsync(/*string*/ requestUri, /*HttpContent*/ content)
    {
        return PatchAsync(CreateUri(requestUri), content);
    }
    /*Task<HttpResponseMessage>*/ PatchAsync(/*Uri*/ requestUri, /*HttpContent*/ content)
    {
        return PatchAsync(requestUri, content, CancellationToken.None);
    }
    /*Task<HttpResponseMessage>*/ PatchAsync(/*string*/ requestUri, /*HttpContent*/ content, /*CancellationToken*/ cancellationToken)
    {
        return PatchAsync(CreateUri(requestUri), content, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ PatchAsync(/*Uri*/ requestUri, /*HttpContent*/ content, /*CancellationToken*/ cancellationToken)
    {
        /*HttpRequestMessage*/ let request = CreateRequestMessage(HttpMethod.Patch, requestUri);
        request.Content  = content;
        return SendAsync(request, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ DeleteAsync(/*string*/ requestUri)
    {
        return DeleteAsync(CreateUri(requestUri));
    }
    /*Task<HttpResponseMessage>*/ DeleteAsync(/*Uri*/ requestUri)
    {
        return DeleteAsync(requestUri, CancellationToken.None);
    }
    /*Task<HttpResponseMessage>*/ DeleteAsync(/*string*/ requestUri, /*CancellationToken*/ cancellationToken)
    {
        return DeleteAsync(CreateUri(requestUri), cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ DeleteAsync(/*Uri*/ requestUri, /*CancellationToken*/ cancellationToken)
    {
        return SendAsync(CreateRequestMessage(HttpMethod.Delete, requestUri), cancellationToken);
    }
    /*HttpResponseMessage*/ Send(/*HttpRequestMessage*/ request)
    {
        return Send(request, DefaultCompletionOption, { cancellationToken : BlazorJs.getDefault() });
    }
    /*HttpResponseMessage*/ Send(/*HttpRequestMessage*/ request, /*HttpCompletionOption*/ completionOption)
    {
        return Send(request, completionOption, { cancellationToken : BlazorJs.getDefault() });
    }
    /*HttpResponseMessage*/ Send(/*HttpRequestMessage*/ request, /*CancellationToken*/ cancellationToken)
    {
        return Send(request, DefaultCompletionOption, cancellationToken);
    }
    /*HttpResponseMessage*/ Send(/*HttpRequestMessage*/ request, /*HttpCompletionOption*/ completionOption, /*CancellationToken*/ cancellationToken)
    {
        CheckRequestBeforeSend(request);
        BlazorJs.TupleValue({ Item1: CancellationTokenSourcects, Item2: booldisposeCts, Item3: CancellationTokenSourcependingRequestsCts }) = PrepareCancellationTokenSource(cancellationToken);
        /*HttpResponseMessage*/ let response = null;
        try
        {
            response = super.Send(request, cts.Token);
            ThrowForNullResponse(response);
            if (ShouldBufferResponse(completionOption, request))
            {
                response.Content.LoadIntoBuffer(_maxResponseContentBufferSize, cts.Token);
            }
            return response;
        }
        catch(e)
        {
            HandleFailure(e, response, cts, cancellationToken, pendingRequestsCts);
            throw e;
        }
        finally
        {
            {
                FinishSend(response, cts, disposeCts);
            }
        }
    }
    /*Task<HttpResponseMessage>*/ SendAsync(/*HttpRequestMessage*/ request)
    {
        return SendAsync(request, DefaultCompletionOption, CancellationToken.None);
    }
    /*Task<HttpResponseMessage>*/ SendAsync(/*HttpRequestMessage*/ request, /*CancellationToken*/ cancellationToken)
    {
        return SendAsync(request, DefaultCompletionOption, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ SendAsync(/*HttpRequestMessage*/ request, /*HttpCompletionOption*/ completionOption)
    {
        return SendAsync(request, completionOption, CancellationToken.None);
    }
    /*Task<HttpResponseMessage>*/ SendAsync(/*HttpRequestMessage*/ request, /*HttpCompletionOption*/ completionOption, /*CancellationToken*/ cancellationToken)
    {
        CheckRequestBeforeSend(request);
        BlazorJs.TupleValue({ Item1: CancellationTokenSourcects, Item2: booldisposeCts, Item3: CancellationTokenSourcependingRequestsCts }) = PrepareCancellationTokenSource(cancellationToken);
        return Core(request, completionOption, cts, disposeCts, pendingRequestsCts, cancellationToken);
        /*Task<HttpResponseMessage>*/ async function Core(/*HttpRequestMessage*/ innerRequest, /*HttpCompletionOption*/ innerCompletionOption, /*CancellationTokenSource*/ innerCts, /*bool*/ innerDisposeCts, /*CancellationTokenSource*/ innerPendingRequestsCts, /*CancellationToken*/ originalCancellationToken)
        {
            /*HttpResponseMessage*/ let response = null;
            try
            {
                response = await super.SendAsync(innerRequest, innerCts.Token);
                ThrowForNullResponse(response);
                if (ShouldBufferResponse(innerCompletionOption, innerRequest))
                {
                    await response.Content.LoadIntoBufferAsync(_maxResponseContentBufferSize, innerCts.Token);
                }
                return response;
            }
            catch(e)
            {
                HandleFailure(e, response, innerCts, originalCancellationToken, innerPendingRequestsCts);
                throw e;
            }
            finally
            {
                {
                    FinishSend(response, innerCts, innerDisposeCts);
                }
            }
        }
    }
    /*void*/ CheckRequestBeforeSend(/*HttpRequestMessage*/ request)
    {
        if (request === null)
        throw new ArgumentNullException();
        if (_disposed)
        throw new ObjectDisposedException("request");
        CheckRequestMessage(request);
        SetOperationStarted();
        PrepareRequestMessage(request);
    }
    /*void*/ static ThrowForNullResponse(/*HttpResponseMessage*/ response)
    {
        if (response)
        {
            throw new InvalidOperationException();
        }
    }
    /*bool*/ static ShouldBufferResponse(/*HttpCompletionOption*/ completionOption, /*HttpRequestMessage*/ request)
    {
        return completionOption === HttpCompletionOption.ResponseContentRead  && string.Equals(request.Method.Method, "HEAD", StringComparison.OrdinalIgnoreCase);
    }
    /*void*/ HandleFailure(/*Exception*/ e, /*HttpResponseMessage*/ response, /*CancellationTokenSource*/ cts, /*CancellationToken*/ cancellationToken, /*CancellationTokenSource*/ pendingRequestsCts)
    {
        response?.Dispose();
        /*Exception*/ let toThrow = null;
        if (e instanceof OperationCanceledException, oce = e)
        {
            if (cancellationToken.IsCancellationRequested)
            {
                if (oce.CancellationToken.Equals(cancellationToken))
                {
                    e = toThrow = new TaskCanceledException(oce.Message, oce);
                }
            }
            else if (cts.IsCancellationRequested  && pendingRequestsCts.IsCancellationRequested)
            {
                if (cancellationToken.IsCancellationRequested)
                {
                    Debug.Assert(_timeout.TotalSeconds  > 0);
                    e = toThrow = new TaskCanceledException("", new TimeoutException(e.Message, e));
                }
            }
        }
        else if (e instanceof HttpRequestException && cts.IsCancellationRequested)
        {
            e = toThrow = CancellationHelper.CreateOperationCanceledException(e, cts.Token);
        }
        if (toThrow !== null)
        {
            throw toThrow;
        }
    }
    /*void*/ static FinishSend(/*HttpResponseMessage*/ response, /*CancellationTokenSource*/ cts, /*bool*/ disposeCts)
    {
        if (disposeCts)
        {
            cts.Dispose();
        }
    }
    /*void*/ Dispose(/*bool*/ disposing)
    {
        if (disposing && _disposed)
        {
            _disposed = true;
            _pendingRequestsCts.Cancel();
            _pendingRequestsCts.Dispose();
        }
        super.Dispose(disposing);
    }
    /*void*/ SetOperationStarted()
    {
        if (_operationStarted)
        {
            _operationStarted = true;
        }
    }
    /*void*/ CheckDisposedOrStarted()
    {
        if (_disposed)
        throw new ObjectDisposedException("");
        if (_operationStarted)
        {
            throw new InvalidOperationException("net_http_operation_started");
        }
    }
    /*void*/ static CheckRequestMessage(/*HttpRequestMessage*/ request)
    {
        if (request.MarkAsSent())
        {
            throw new InvalidOperationException("net_http_client_request_already_sent");
        }
    }
    /*void*/ PrepareRequestMessage(/*HttpRequestMessage*/ request)
    {
        /*Uri*/ let requestUri = null;
        if ((request.RequestUri  === null) && (_baseAddress === null))
        {
            throw new InvalidOperationException("net_http_client_invalid_requesturi");
        }
        if (request.RequestUri  === null)
        {
            requestUri = _baseAddress;
        }
        else 
        {
            if (request.RequestUri.IsAbsoluteUri())
            {
                if (_baseAddress === null)
                {
                    throw new InvalidOperationException("net_http_client_invalid_requesturi");
                }
                else 
                {
                    requestUri = new Uri(_baseAddress?.ToString() + request.RequestUri.ToString());
                }
            }
        }
        if (requestUri !== null)
        {
            request.RequestUri  = requestUri;
        }
        if (_defaultRequestHeaders !== null)
        {
            request.Headers.AddHeaders(_defaultRequestHeaders);
        }
    }
    /*(CancellationTokenSource TokenSource, bool DisposeTokenSource, CancellationTokenSource PendingRequestsCts)*/ PrepareCancellationTokenSource(/*CancellationToken*/ cancellationToken)
    {
        /*// We need a CancellationTokenSource to use with the request.  We always have the global
            // _pendingRequestsCts to use, plus we may have a token provided by the caller, and we may
            // have a timeout.  If we have a timeout or a caller-provided token, we need to create a new
            // CTS (we can't, for example, timeout the pending requests CTS, as that could cancel other
            // unrelated operations).  Otherwise, we can use the pending requests CTS directly.

            // Snapshot the current pending requests cancellation source. It can change concurrently due to cancellation being requested
            // and it being replaced, and we need a stable view of it: if cancellation occurs and the caller's token hasn't been canceled,
            // it's either due to this source or due to the timeout, and checking whether this source is the culprit is reliable whereas
            // it's more approximate checking elapsed time.
            CancellationTokenSource*/ let pendingRequestsCts = _pendingRequestsCts;
        /*bool*/ let hasTimeout = _timeout !== s_infiniteTimeout;
        if (hasTimeout || cancellationToken.CanBeCanceled)
        {
            /*CancellationTokenSource*/ let cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken, pendingRequestsCts.Token);
            if (hasTimeout)
            {
                cts.CancelAfter(_timeout);
            }
            return BlazorJs.TupleValue({ Item1: cts, DisposeTokenSource : true, Item3: pendingRequestsCts });
        }
        return BlazorJs.TupleValue({ Item1: pendingRequestsCts, DisposeTokenSource : false, Item3: pendingRequestsCts });
    }
    /*Uri*/ static CreateUri(/*string*/ uri)
    {
        return string.IsNullOrEmpty(uri) ? null : new Uri(uri);
    }
    /*HttpRequestMessage*/ CreateRequestMessage(/*HttpMethod*/ method, /*Uri*/ uri)
    {
        return BlazorJs.PopulateProperty(new HttpRequestMessage(method, uri), function(/*HttpRequestMessage*/ $obj)
        {
            $obj.Version = _defaultRequestVersion;
            $obj.VersionPolicy = _defaultVersionPolicy;
        });
    }
}

static class System_Net_Http_HttpCompletionOption
{
    ResponseContentRead = 0;
    ResponseHeadersRead = 1;
}

class System_Net_Http_HttpContent extends System_IDisposable(object)
{
    /*HttpContentHeaders*/ _headers = null;
    /*LimitArrayPoolWriteStream*/ _bufferedContent = null;
    /*object*/ _contentReadStream = null;
    /*bool*/ _disposed = null;
    /*bool*/ _canCalculateLength = null;
    /*int*/ MaxBufferSize = int.MaxValue;
    /*Encoding*/ static DefaultStringEncoding = Encoding.UTF8;
    /*int*/ UTF8CodePage = 65001;
    /*int*/ UTF32CodePage = 12000;
    /*int*/ UnicodeCodePage = 1200;
    /*int*/ BigEndianUnicodeCodePage = 1201;
    /*ReadOnlySpan<byte>*/ static get UTF8Preamble()
    {
        return [ 0xEF, 0xBB, 0xBF ];
    }
    /*ReadOnlySpan<byte>*/ static get UTF32Preamble()
    {
        return [ 0xFF, 0xFE, 0x00, 0x00 ];
    }
    /*ReadOnlySpan<byte>*/ static get UnicodePreamble()
    {
        return [ 0xFF, 0xFE ];
    }
    /*ReadOnlySpan<byte>*/ static get BigEndianUnicodePreamble()
    {
        return [ 0xFE, 0xFF ];
    }
    /*HttpContentHeaders*/ get Headers()
    {
        return _headers = _headers ?? new HttpContentHeaders(this);
    }
    /*bool*/ get IsBuffered()
    {
        return (_bufferedContent);
    }
    constructor()
    {
        super();
        _canCalculateLength = true;
    }
    /*MemoryStream*/ CreateMemoryStreamFromBufferedContent()
    {
        Debug.Assert(IsBuffered);
        return new MemoryStream(_bufferedContent.GetSingleBuffer(), 0, BlazorJs.Cast(_bufferedContent.Length, int), { writable : false });
    }
    /*Task<string>*/ ReadAsStringAsync()
    {
        return ReadAsStringAsync(CancellationToken.None);
    }
    /*Task<string>*/ ReadAsStringAsync(/*CancellationToken*/ cancellationToken)
    {
        CheckDisposed();
        return WaitAndReturnAsync(LoadIntoBufferAsync(cancellationToken), this, function(/**/ s)
        {
            return s.ReadBufferedContentAsString();
        });
    }
    /*string*/ ReadBufferedContentAsString()
    {
        Debug.Assert(IsBuffered);
        return ReadBufferAsString(_bufferedContent, Headers);
    }
    /*string*/ static ReadBufferAsString(/*LimitArrayPoolWriteStream*/ stream, /*HttpContentHeaders*/ headers)
    {
        if (stream.Length  === 0)
        {
            return string.Empty;
        }
        /*// We don't validate the Content-Encoding header: If the content was encoded, it's the caller's
            // responsibility to make sure to only call ReadAsString() on already decoded content. E.g. if the
            // Content-Encoding is 'gzip' the user should set HttpClientHandler.AutomaticDecompression to get a
            // decoded response stream.

            ReadOnlySpan<byte>*/ let firstBuffer = stream.GetFirstBuffer();
        Debug.Assert(firstBuffer.Length  >= 4 || firstBuffer.Length  === stream.Length);
        /*Encoding*/ let encoding = null;
        /*int*/ let bomLength = 1;
        /*string*/ let charset = headers.ContentType?.CharSet;
        if (charset !== null)
        {
            try
            {
                if (charset.Length  > 2 && charset.StartsWith("\"") && charset.EndsWith("\""))
                {
                    encoding = Encoding.GetEncoding(charset.Substring(1, charset.Length  - 2));
                }
                else 
                {
                    encoding = Encoding.GetEncoding(charset);
                }
                bomLength = GetPreambleLength(firstBuffer, encoding);
            }
            catch(e)
            {
                throw new InvalidOperationException("net_http_content_invalid_charset", e);
            }
        }
        if (encoding === null)
        {
            let $ref0 = { set value(v){ encoding = v } };
            let $ref1 = { set value(v){ bomLength = v } };
            if (TryDetectEncoding(firstBuffer, $ref0, $ref1))
            {
                encoding = DefaultStringEncoding;
                bomLength = 0;
            }
        }
        if (firstBuffer.Length  === stream.Length)
        {
            return encoding.GetString(firstBuffer.Slice(bomLength).ToArray());
        }
        else 
        {
            /*byte[]*/ let buffer = new Array(BlazorJs.Cast(stream.Length, int));
            stream.CopyToCore(buffer);
            /*string*/ let result = encoding.GetString(buffer, bomLength, buffer.Length  - bomLength);
            return result;
        }
    }
    /*Task<byte[]>*/ ReadAsByteArrayAsync()
    {
        return ReadAsByteArrayAsync(CancellationToken.None);
    }
    /*Task<byte[]>*/ ReadAsByteArrayAsync(/*CancellationToken*/ cancellationToken)
    {
        CheckDisposed();
        return WaitAndReturnAsync(LoadIntoBufferAsync(cancellationToken), this, function(/**/ s)
        {
            return s.ReadBufferedContentAsByteArray();
        });
    }
    /*byte[]*/ ReadBufferedContentAsByteArray()
    {
        Debug.Assert(_bufferedContent !== null);
        return _bufferedContent.CreateCopy();
    }
    /*Stream*/ ReadAsStream()
    {
        return ReadAsStream(CancellationToken.None);
    }
    /*Stream*/ ReadAsStream(/*CancellationToken*/ cancellationToken)
    {
        CheckDisposed();
        if (_contentReadStream === null)
        {
            /*Stream*/ let s = IsBuffered ? CreateMemoryStreamFromBufferedContent() : CreateContentReadStream(cancellationToken);
            _contentReadStream = s;
            return s;
        }
        else if (_contentReadStream instanceof Stream, stream = _contentReadStream)
        {
            return stream;
        }
        else 
        {
            throw new HttpRequestException("net_http_content_read_as_stream_has_task");
        }
    }
    /*Task<Stream>*/ ReadAsStreamAsync()
    {
        return ReadAsStreamAsync(CancellationToken.None);
    }
    /*Task<Stream>*/ ReadAsStreamAsync(/*CancellationToken*/ cancellationToken)
    {
        CheckDisposed();
        if (_contentReadStream === null)
        {
            /*Task<Stream>*/ let t = IsBuffered ? Task.FromResult(Stream, CreateMemoryStreamFromBufferedContent()) : CreateContentReadStreamAsync(cancellationToken);
            _contentReadStream = t;
            return t;
        }
        else if (_contentReadStream instanceof Task(Stream), t = _contentReadStream)
        {
            return t;
        }
        else 
        {
            Debug.Assert(_contentReadStream instanceof Stream, `Expected a Stream, got $${_contentReadStream}`);
            /*Task<Stream>*/ let ts = Task.FromResult(BlazorJs.Cast(_contentReadStream, Stream));
            _contentReadStream = ts;
            return ts;
        }
    }
    /*Stream*/ TryReadAsStream()
    {
        CheckDisposed();
        if (_contentReadStream === null)
        {
            /*Stream*/ let s = IsBuffered ? CreateMemoryStreamFromBufferedContent() : TryCreateContentReadStream();
            _contentReadStream = s;
            return s;
        }
        else if (_contentReadStream instanceof Stream, s = _contentReadStream)
        {
            return s;
        }
        else 
        {
            Debug.Assert(_contentReadStream instanceof Task(Stream), `Expected a Task<Stream>, got $${_contentReadStream}`);
            /*Task<Stream>*/ let t = BlazorJs.Cast(_contentReadStream, Task(Stream));
            return t.Status  === TaskStatus.RanToCompletion  ? t.Result  : null;
        }
    }
    /*void*/ SerializeToStream(/*Stream*/ stream, /*CancellationToken*/ cancellationToken)
    {
        throw new NotSupportedException("net_http_missing_sync_implementation");
    }
    /*Task*/ SerializeToStreamAsync(/*Stream*/ stream, /*CancellationToken*/ cancellationToken)
    {
        return SerializeToStreamAsync(stream);
    }
    /*bool*/ get AllowDuplex()
    {
        return true;
    }
    /*void*/ CopyTo(/*Stream*/ stream, /*CancellationToken*/ cancellationToken)
    {
        CheckDisposed();
        if (stream === null)
        throw new ArgumentNullException(nameof(stream));
        try
        {
            if (IsBuffered)
            {
                stream.Write(_bufferedContent.GetSingleBuffer(), 0, BlazorJs.Cast(_bufferedContent.Length, int));
            }
            else 
            {
                SerializeToStream(stream, cancellationToken);
            }
        }
        catch(e)
        {
            throw GetStreamCopyException(e);
        }
    }
    /*Task*/ CopyToAsync(/*Stream*/ stream)
    {
        return CopyToAsync(stream, CancellationToken.None);
    }
    /*Task*/ static async WaitAsync(/*Task*/ copyTask)
    {
        try
        {
            await copyTask;
        }
        catch(e)
        {
            throw WrapStreamCopyException(e);
        }
    }
    /*Task*/ CopyToAsync(/*Stream*/ stream, /*CancellationToken*/ cancellationToken)
    {
        CheckDisposed();
        if (stream === null)
        throw new ArgumentNullException(nameof(stream));
        try
        {
            return WaitAsync(InternalCopyToAsync(stream, cancellationToken));
        }
        catch(e)
        {
            throw GetStreamCopyException(e);
        }
    }
    /*Task*/ InternalCopyToAsync(/*Stream*/ stream, /*CancellationToken*/ cancellationToken)
    {
        if (IsBuffered)
        {
            return stream.WriteAsync(_bufferedContent.GetSingleBuffer(), cancellationToken);
        }
        /*Task*/ let task = SerializeToStreamAsync(stream, cancellationToken);
        CheckTaskNotNull(task);
        return task;
    }
    /*void*/ LoadIntoBuffer(/*long*/ maxBufferSize, /*CancellationToken*/ cancellationToken)
    {
        let tempBuffer = null;
        let $ref1 = { set value(v){ tempBuffer = v } };
        let error = null;
        let $ref3 = { set value(v){ error = v } };
        CheckDisposed();
        if (CreateTemporaryBuffer(maxBufferSize, $ref1, $ref3))
        {
            return ;
        }
        if (tempBuffer === null)
        {
            throw error;
        }
        /*// Register for cancellation and tear down the underlying stream in case of cancellation/timeout.
            // We're only comfortable disposing of the HttpContent instance like this because LoadIntoBuffer is internal and
            // we're only using it on content instances we get back from a handler's Send call that haven't been given out to the user yet.
            // If we were to ever make LoadIntoBuffer public, we'd need to rethink this.
            CancellationTokenRegistration*/ let cancellationRegistration = cancellationToken.Register(function(/**/ s)
        {
            return (BlazorJs.Cast(s, HttpContent)).Dispose();
        }, this);
        try
        {
            SerializeToStream(tempBuffer, cancellationToken);
        }
        catch(e)
        {
            tempBuffer.Dispose();
            if (CancellationHelper.ShouldWrapInOperationCanceledException(e, cancellationToken))
            {
                throw CancellationHelper.CreateOperationCanceledException(e, cancellationToken);
            }
            if (StreamCopyExceptionNeedsWrapping(e))
            {
                throw GetStreamCopyException(e);
            }
            throw e;
        }
        finally
        {
            {
                cancellationRegistration.Dispose();
            }
        }
        tempBuffer.ReallocateIfPooled();
        _bufferedContent = tempBuffer;
    }
    /*Task*/ LoadIntoBufferAsync()
    {
        return LoadIntoBufferAsync(MaxBufferSize);
    }
    /*Task*/ LoadIntoBufferAsync(/*long*/ maxBufferSize)
    {
        return LoadIntoBufferAsync(maxBufferSize, CancellationToken.None);
    }
    /*Task*/ LoadIntoBufferAsync(/*CancellationToken*/ cancellationToken)
    {
        return LoadIntoBufferAsync(MaxBufferSize, cancellationToken);
    }
    /*Task*/ LoadIntoBufferAsync(/*long*/ maxBufferSize, /*CancellationToken*/ cancellationToken)
    {
        let tempBuffer = null;
        let $ref1 = { set value(v){ tempBuffer = v } };
        let error = null;
        let $ref3 = { set value(v){ error = v } };
        CheckDisposed();
        if (CreateTemporaryBuffer(maxBufferSize, $ref1, $ref3))
        {
            return Task.CompletedTask;
        }
        if (tempBuffer === null)
        {
            throw error;
        }
        try
        {
            /*Task*/ let task = SerializeToStreamAsync(tempBuffer, cancellationToken);
            CheckTaskNotNull(task);
            return LoadIntoBufferAsyncCore(task, tempBuffer);
        }
        catch(e)
        {
            tempBuffer.Dispose();
            if (StreamCopyExceptionNeedsWrapping(e))
            {
                throw GetStreamCopyException(e);
            }
            throw e;
        }
    }
    /*Task*/ async LoadIntoBufferAsyncCore(/*Task*/ serializeToStreamTask, /*LimitArrayPoolWriteStream*/ tempBuffer)
    {
        try
        {
            await serializeToStreamTask;
        }
        catch(e)
        {
            tempBuffer.Dispose();
            /*Exception*/ let we = GetStreamCopyException(e);
            if (we !== e)
            throw we;
            throw e;
        }
        tempBuffer.ReallocateIfPooled();
        _bufferedContent = tempBuffer;
    }
    /*Stream*/ CreateContentReadStream(/*CancellationToken*/ cancellationToken)
    {
        LoadIntoBuffer(MaxBufferSize, cancellationToken);
        return CreateMemoryStreamFromBufferedContent();
    }
    /*Task<Stream>*/ CreateContentReadStreamAsync()
    {
        return WaitAndReturnAsync(LoadIntoBufferAsync(), this, function(/**/ s)
        {
            return BlazorJs.Cast(s.CreateMemoryStreamFromBufferedContent(), Stream);
        });
    }
    /*Task<Stream>*/ CreateContentReadStreamAsync(/*CancellationToken*/ cancellationToken)
    {
        return CreateContentReadStreamAsync();
    }
    /*Stream*/ TryCreateContentReadStream()
    {
        return null;
    }
    /*long?*/ GetComputedOrBufferLength()
    {
        CheckDisposed();
        if (IsBuffered)
        {
            return _bufferedContent.Length;
        }
        if (_canCalculateLength)
        {
            let $ref0 = { set value(v){ length = v } };
            /*long*/ let length;
            if (TryComputeLength($ref0))
            {
                return length;
            }
            _canCalculateLength = false;
        }
        return null;
    }
    /*bool*/ CreateTemporaryBuffer(/*long*/ maxBufferSize, /*out LimitArrayPoolWriteStream*/ tempBuffer, /*out Exception*/ error)
    {
        if (maxBufferSize > HttpContent.MaxBufferSize)
        {
            throw new ArgumentOutOfRangeException(nameof(maxBufferSize), maxBufferSize, "net_http_content_buffersize_limit");
        }
        if (IsBuffered)
        {
            tempBuffer = BlazorJs.getDefault();
            error = BlazorJs.getDefault();
            return false;
        }
        /*// If we have a Content-Length allocate the right amount of buffer up-front. Also check whether the
            // content length exceeds the max. buffer size.
            long*/ let contentLength = Headers.ContentLength.GetValueOrDefault();
        Debug.Assert(contentLength >= 0);
        if (contentLength > maxBufferSize)
        {
            tempBuffer = null;
            error = CreateOverCapacityException(maxBufferSize);
        }
        else 
        {
            tempBuffer = new LimitArrayPoolWriteStream(BlazorJs.Cast(maxBufferSize, int), contentLength, { getFinalSizeFromPool : false });
            error = null;
        }
        return true;
    }
    /*void*/ Dispose(/*bool*/ disposing)
    {
        if (disposing && _disposed)
        {
            _disposed = true;
            if (_contentReadStream !== null)
            {
                /*Stream*/ let s = BlazorJs.As(_contentReadStream, Stream) ?? (_contentReadStream instanceof Task(Stream), t = _contentReadStream && t.Status  === TaskStatus.RanToCompletion  ? t.Result  : null);
                s?.Dispose();
                _contentReadStream = null;
            }
            if (IsBuffered)
            {
                _bufferedContent.Dispose();
            }
        }
    }
    /*void*/ Dispose()
    {
        Dispose(true);
    }
    /*void*/ CheckDisposed()
    {
        if (_disposed)
        throw new ObjectDisposedException("");
    }
    /*void*/ CheckTaskNotNull(/*Task*/ task)
    {
        if (task === null)
        {
            /*var*/ let e = new InvalidOperationException("net_http_content_no_task_returned");
            throw e;
        }
    }
    /*bool*/ static StreamCopyExceptionNeedsWrapping(/*Exception*/ e)
    {
        return e instanceof IOException || e instanceof ObjectDisposedException;
    }
    /*Exception*/ static GetStreamCopyException(/*Exception*/ originalException)
    {
        return StreamCopyExceptionNeedsWrapping(originalException) ? WrapStreamCopyException(originalException) : originalException;
    }
    /*Exception*/ static WrapStreamCopyException(/*Exception*/ e)
    {
        Debug.Assert(StreamCopyExceptionNeedsWrapping(e));
        /*HttpRequestError*/ let error = e instanceof HttpIOException, ioEx = e ? ioEx.HttpRequestError  : HttpRequestError.Unknown;
        return new HttpRequestException(error, "net_http_content_stream_copy_error", e);
    }
    /*int*/ static GetPreambleLength(/*ReadOnlySpan<byte>*/ data, /*Encoding*/ encoding)
    {
        Debug.Assert(encoding !== null);
        switch(encoding.CodePage)
        {
            case UTF8CodePage:
            {
                return data.StartsWith(UTF8Preamble) ? UTF8Preamble.Length  : 0;
            }
            case UTF32CodePage:
            {
                return data.StartsWith(UTF32Preamble) ? UTF32Preamble.Length  : 0;
            }
            case UnicodeCodePage:
            {
                return data.StartsWith(UnicodePreamble) ? UnicodePreamble.Length  : 0;
            }
            case BigEndianUnicodeCodePage:
            {
                return data.StartsWith(BigEndianUnicodePreamble) ? BigEndianUnicodePreamble.Length  : 0;
            }
            default:
            {
                return 0;
            }
        }
    }
    /*bool*/ static TryDetectEncoding(/*ReadOnlySpan<byte>*/ data, /*out Encoding*/ encoding, /*out int*/ preambleLength)
    {
        if (data.StartsWith(UTF8Preamble))
        {
            encoding = Encoding.UTF8;
            preambleLength = UTF8Preamble.Length;
            return true;
        }
        if (data.StartsWith(UTF32Preamble))
        {
            encoding = Encoding.UTF32;
            preambleLength = UTF32Preamble.Length;
            return true;
        }
        if (data.StartsWith(UnicodePreamble))
        {
            encoding = Encoding.Unicode;
            preambleLength = UnicodePreamble.Length;
            return true;
        }
        if (data.StartsWith(BigEndianUnicodePreamble))
        {
            encoding = Encoding.BigEndianUnicode;
            preambleLength = BigEndianUnicodePreamble.Length;
            return true;
        }
        encoding = null;
        preambleLength = 0;
        return false;
    }
    /*Task<TResult>*/ static async WaitAndReturnAsync(TState, TResult, /*Task*/ waitTask, /*TState*/ state, /*Func<TState, TResult>*/ returnFunc)
    {
        await waitTask;
        return returnFunc(state);
    }
    /*HttpRequestException*/ static CreateOverCapacityException(/*long*/ maxBufferSize)
    {
        return new HttpRequestException(HttpRequestError.ConfigurationLimitExceeded, "net_http_content_buffersize_exceeded");
    }
    static System_Net_Http_HttpContent_LimitArrayPoolWriteStream = class extends System_IO_AsyncStream
    {
        /*int*/ MinInitialBufferSize = 16 * 1024;
        /*int*/ MaxInitialBufferSize = 16 * 1024 * 1024;
        /*int*/ ResizeFactor = 2;
        /*int*/ LastResizeFactor = 4;
        /*int*/ _maxBufferSize = null;
        /*int*/ _expectedFinalSize = null;
        /*bool*/ _shouldPoolFinalSize = null;
        /*bool*/ _lastBufferIsPooled = null;
        /*byte[]*/ _lastBuffer = null;
        /*byte[][]*/ _pooledBuffers = null;
        /*int*/ _lastBufferOffset = null;
        /*int*/ _totalLength = null;
        constructor(/*int*/ maxBufferSize, /*long*/ expectedFinalSize, /*bool*/ getFinalSizeFromPool)
        {
            super();
            Debug.Assert(maxBufferSize >= 0);
            Debug.Assert(expectedFinalSize >= 0);
            if (expectedFinalSize > maxBufferSize)
            {
                throw CreateOverCapacityException(maxBufferSize);
            }
            _maxBufferSize = maxBufferSize;
            _expectedFinalSize = BlazorJs.Cast(expectedFinalSize, int);
            _shouldPoolFinalSize = getFinalSizeFromPool || expectedFinalSize === 0;
            _lastBufferIsPooled = false;
            _lastBuffer = new Array(0);
        }
        /*void*/ Dispose(/*bool*/ disposing)
        {
            ReturnAllPooledBuffers();
            super.Dispose(disposing);
        }
        /*byte[]*/ ToArray()
        {
            Debug.Assert(_shouldPoolFinalSize || _expectedFinalSize === 0);
            if (_lastBufferIsPooled && _totalLength === _lastBuffer.Length)
            {
                Debug.Assert(_pooledBuffers);
                return _lastBuffer;
            }
            if (_totalLength === 0)
            {
                return new Array(0);
            }
            /*byte[]*/ let buffer = new Array(_totalLength);
            CopyToCore(buffer);
            return buffer;
        }
        /*byte[]*/ GetSingleBuffer()
        {
            Debug.Assert(_lastBufferIsPooled);
            Debug.Assert(_pooledBuffers);
            return _lastBuffer;
        }
        /*ReadOnlySpan<byte>*/ GetFirstBuffer()
        {
            return _pooledBuffers instanceof byte, buffers = _pooledBuffers ? buffers[0] : _lastBuffer.AsReadOnlySpan(0, _totalLength);
        }
        /*byte[]*/ CreateCopy()
        {
            Debug.Assert(_lastBufferIsPooled);
            Debug.Assert(_pooledBuffers);
            Debug.Assert(_lastBufferOffset === _totalLength);
            Debug.Assert(_lastBufferOffset <= _lastBuffer.Length);
            return _lastBuffer.AsSpan(0, _totalLength).ToArray();
        }
        /*void*/ ReallocateIfPooled()
        {
            Debug.Assert(_lastBufferIsPooled || _pooledBuffers);
            if (_lastBufferIsPooled)
            {
                /*byte[]*/ let newBuffer = new Array(_totalLength);
                CopyToCore(newBuffer);
                ReturnAllPooledBuffers();
                _lastBuffer = newBuffer;
                _lastBufferOffset = newBuffer.Length;
            }
        }
        /*Task<int>*/ ReadAsync(/*Span<byte>*/ buffer, /*CancellationToken*/ cancellationToken)
        {
            throw new NotImplementedException();
        }
        /*Task<int>*/ WriteAsync(/*ReadOnlySpan<byte>*/ buffer, /*CancellationToken*/ cancellationToken)
        {
            if (_maxBufferSize - _totalLength < buffer.Length)
            {
                throw CreateOverCapacityException(_maxBufferSize);
            }
            /*byte[]*/ let lastBuffer = _lastBuffer;
            /*int*/ let offset = _lastBufferOffset;
            if (lastBuffer.Length  - offset >= buffer.Length)
            {
                buffer.CopyTo(lastBuffer.AsSpan(offset));
                _lastBufferOffset = offset + buffer.Length;
                _totalLength += buffer.Length;
            }
            else 
            {
                GrowAndWrite(buffer);
            }
            return Task.FromResult(buffer.Length);
        }
        /*void*/ GrowAndWrite(/*ReadOnlySpan<byte>*/ buffer)
        {
            Debug.Assert(_totalLength + buffer.Length  <= _maxBufferSize);
            /*int*/ let lastBufferCapacity = _lastBuffer.Length;
            /*// Start by doubling the current array size.
                int*/ let newBufferCapacity = BlazorJs.Cast(Math.Min(BlazorJs.Cast(lastBufferCapacity, uint) * ResizeFactor, 100 * 1024 * 1024), int);
            newBufferCapacity = Math.Max(newBufferCapacity, _totalLength + buffer.Length);
            if (lastBufferCapacity === 0)
            {
                /*int*/ let minCapacity = _expectedFinalSize === 0 ? MinInitialBufferSize : Math.Min(_expectedFinalSize, MaxInitialBufferSize / LastResizeFactor);
                newBufferCapacity = Math.Max(newBufferCapacity, minCapacity);
            }
            /*// Avoid having the last buffer expand beyond the size limit too much.
                // It may still go beyond the limit somewhat due to the ArrayPool's buffer sizes being powers of 2.
                int*/ let currentTotalCapacity = _totalLength - _lastBufferOffset + lastBufferCapacity;
            /*int*/ let remainingUntilMaxCapacity = _maxBufferSize - currentTotalCapacity;
            newBufferCapacity = Math.Min(newBufferCapacity, remainingUntilMaxCapacity);
            /*int*/ let newTotalCapacity = currentTotalCapacity + newBufferCapacity;
            Debug.Assert(newBufferCapacity > 0);
            /*byte[]*/ let newBuffer;
            if (_shouldPoolFinalSize && newTotalCapacity >= _expectedFinalSize / LastResizeFactor)
            {
                newBuffer = new Array(_totalLength + buffer.Length  <= _expectedFinalSize ? _expectedFinalSize : newTotalCapacity);
                CopyToCore(newBuffer);
                ReturnAllPooledBuffers();
                buffer.CopyTo(newBuffer.AsSpan(_totalLength));
                _totalLength += buffer.Length;
                _lastBufferOffset = _totalLength;
                _lastBufferIsPooled = false;
            }
            else if (lastBufferCapacity === 0)
            {
                Debug.Assert(_pooledBuffers);
                Debug.Assert(_lastBufferOffset === 0);
                Debug.Assert(_totalLength === 0);
                newBuffer = ArrayPool(byte).Shared.Rent(newBufferCapacity);
                Debug.Assert(_shouldPoolFinalSize || newBuffer.Length  !== _expectedFinalSize);
                buffer.CopyTo(newBuffer);
                _totalLength = _lastBufferOffset = buffer.Length;
                _lastBufferIsPooled = true;
            }
            else 
            {
                Debug.Assert(_lastBufferIsPooled);
                _totalLength += buffer.Length;
                /*// When buffers are stored in '_pooledBuffers', they are assumed to be full.
                    // Copy as many bytes as we can fit into the current buffer now.
                    Span<byte>*/ let remainingInCurrentBuffer = _lastBuffer.AsSpan(_lastBufferOffset);
                Debug.Assert(remainingInCurrentBuffer.Length  < buffer.Length);
                buffer.Slice(0, remainingInCurrentBuffer.Length).CopyTo(remainingInCurrentBuffer);
                buffer = buffer.Slice(remainingInCurrentBuffer.Length);
                newBuffer = ArrayPool(byte).Shared.Rent(newBufferCapacity);
                buffer.CopyTo(newBuffer);
                _lastBufferOffset = buffer.Length;
                /*// Find the first empty slot in '_pooledBuffers', resizing the array if needed.
                    int*/ let bufferCount = 0;
                if (_pooledBuffers)
                {
                    _pooledBuffers = [  ];
                }
                else 
                {
                    /*byte[][]*/ let buffers = _pooledBuffers;
                    while(bufferCount < buffers.Length  && (buffers[bufferCount]))
                    {
                        bufferCount++;
                    }
                    if (bufferCount === buffers.Length)
                    {
                        let $ref0 = { set value(v){ _pooledBuffers = v } };
                        Debug.Assert(bufferCount <= 16);
                        Array.Resize($ref0, bufferCount + 4);
                    }
                }
                _pooledBuffers[bufferCount] = _lastBuffer;
            }
            _lastBuffer = newBuffer;
        }
        /*void*/ CopyToCore(/*Span<byte>*/ destination)
        {
            Debug.Assert(destination.Length  >= _totalLength);
            if (_pooledBuffers instanceof byte, buffers = _pooledBuffers)
            {
                Debug.Assert(buffers.Length  > 0 && (buffers[0]));
                BlazorJs.forEach(buffers, function(buffer, $_i)
                {
                    if (buffer)
                    {
                        break;
                    }
                    Debug.Assert(destination.Length  >= buffer.Length);
                    buffer.AsSpan().CopyTo(destination);
                    destination = destination.Slice(buffer.Length);
                });
            }
            Debug.Assert(_lastBufferOffset <= _lastBuffer.Length);
            Debug.Assert(_lastBufferOffset <= destination.Length);
            _lastBuffer.AsSpan(0, _lastBufferOffset).CopyTo(destination);
        }
        /*void*/ ReturnAllPooledBuffers()
        {
            if (_pooledBuffers instanceof byte, buffers = _pooledBuffers)
            {
                _pooledBuffers = null;
                BlazorJs.forEach(buffers, function(buffer, $_i)
                {
                    if (buffer)
                    {
                        break;
                    }
                    ArrayPool(byte).Shared.Return(buffer);
                });
            }
            Debug.Assert((_lastBuffer));
            /*byte[]*/ let lastBuffer = _lastBuffer;
            _lastBuffer = null;
            if (_lastBufferIsPooled)
            {
                _lastBufferIsPooled = false;
                ArrayPool(byte).Shared.Return(lastBuffer);
            }
        }
        /*void*/ Flush()
        {
        }
        /*Task*/ FlushAsync(/*CancellationToken*/ cancellationToken)
        {
            return Task.CompletedTask;
        }
        /*long*/ get Length()
        {
            return _totalLength;
        }
        /*bool*/ get CanWrite()
        {
            return true;
        }
        /*bool*/ get CanRead()
        {
            return false;
        }
        /*bool*/ get CanSeek()
        {
            return false;
        }
        /*long*/ get Position()
        {
            throw new NotSupportedException();
        }
        /*long*/ set Position(value)
        {
            throw new NotSupportedException();
        }
        /*int*/ Read(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count)
        {
            throw new NotSupportedException();
        }
        /*long*/ Seek(/*long*/ offset, /*SeekOrigin*/ origin)
        {
            throw new NotSupportedException();
        }
        /*void*/ SetLength(/*long*/ value)
        {
            throw new NotSupportedException();
        }
    }
}

static class System_Net_Http_HttpHandlerDefaults
{
    /*int*/ DefaultInitialHttp2StreamWindowSize = 65535;
}

class System_Net_Http_HttpIOException extends System_IO_IOException
{
    constructor(/*HttpRequestError*/ httpRequestError, /*string*/ message, /*Exception*/ innerException)
    {
        super(message, innerException);
        HttpRequestError = httpRequestError;
    }
    /*HttpRequestError*/ _backingField_HttpRequestError = null;
    /*HttpRequestError*/ get HttpRequestError()
    {
        return _backingField_HttpRequestError;
    }
    /*string*/ get Message()
    {
        return `${super.Message} (${HttpRequestError})`;
    }
}

class System_Net_Http_HttpMessageHandler extends System_IDisposable(object)
{
    constructor()
    {
        super();
    }
    /*HttpResponseMessage*/ Send(/*HttpRequestMessage*/ request, /*CancellationToken*/ cancellationToken)
    {
        throw new NotSupportedException();
    }
    /*void*/ Dispose(/*bool*/ disposing)
    {
    }
    /*void*/ Dispose()
    {
        Dispose(true);
    }
}

class System_Net_Http_HttpMessageInvoker extends System_IDisposable(object)
{
    /*bool*/ _disposed = null;
    /*bool*/ _disposeHandler = null;
    /*HttpMessageHandler*/ _handler = null;
    constructor(/*HttpMessageHandler*/ handler)
    {
        super(handler, true);
    }
    constructor(/*HttpMessageHandler*/ handler, /*bool*/ disposeHandler)
    {
        super();
        _handler = handler;
        _disposeHandler = disposeHandler;
    }
    /*HttpResponseMessage*/ Send(/*HttpRequestMessage*/ request, /*CancellationToken*/ cancellationToken)
    {
        return _handler.Send(request, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ SendAsync(/*HttpRequestMessage*/ request, /*CancellationToken*/ cancellationToken)
    {
        return _handler.SendAsync(request, cancellationToken);
    }
    /*void*/ Dispose()
    {
        Dispose(true);
    }
    /*void*/ Dispose(/*bool*/ disposing)
    {
        if (disposing && _disposed)
        {
            _disposed = true;
            if (_disposeHandler)
            {
                _handler.Dispose();
            }
        }
    }
}

class System_Net_Http_HttpMethod extends H5_IH5Class(System_IEquatable(System_Net_Http_HttpMethod)(object))
{
    /*string*/ _method = null;
    /*int*/ _hashcode = null;
    /*HttpMethod*/ _backingField_Get = null;
    /*HttpMethod*/ static get Get()
    {
        return _backingField_Get;
    }
    /*HttpMethod*/ _backingField_Put = null;
    /*HttpMethod*/ static get Put()
    {
        return _backingField_Put;
    }
    /*HttpMethod*/ _backingField_Post = null;
    /*HttpMethod*/ static get Post()
    {
        return _backingField_Post;
    }
    /*HttpMethod*/ _backingField_Delete = null;
    /*HttpMethod*/ static get Delete()
    {
        return _backingField_Delete;
    }
    /*HttpMethod*/ _backingField_Head = null;
    /*HttpMethod*/ static get Head()
    {
        return _backingField_Head;
    }
    /*HttpMethod*/ _backingField_Options = null;
    /*HttpMethod*/ static get Options()
    {
        return _backingField_Options;
    }
    /*HttpMethod*/ _backingField_Trace = null;
    /*HttpMethod*/ static get Trace()
    {
        return _backingField_Trace;
    }
    /*HttpMethod*/ _backingField_Patch = null;
    /*HttpMethod*/ static get Patch()
    {
        return _backingField_Patch;
    }
    /*HttpMethod*/ _backingField_Connect = null;
    /*HttpMethod*/ static get Connect()
    {
        return _backingField_Connect;
    }
    /*string*/ get Method()
    {
        return _method;
    }
    constructor(/*string*/ method)
    {
        super();
        if (string.IsNullOrEmpty(method))
        throw new ArgumentException();
        if (HttpRuleParser.IsToken(method.AsSpan()))
        {
            throw new FormatException("net_http_httpmethod_format_error");
        }
        _method = method;
    }
    /*bool*/ Equals(/*HttpMethod*/ other)
    {
        return (other) && string.Equals(_method, other._method, StringComparison.OrdinalIgnoreCase);
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        return obj instanceof HttpMethod, method = obj && Equals(method);
    }
    /*int*/ GetHashCode()
    {
        if (_hashcode === 0)
        {
            _hashcode = StringComparer.OrdinalIgnoreCase.GetHashCode(_method);
        }
        return _hashcode;
    }
    /*string*/ ToString()
    {
        return _method;
    }
    /*bool*/ static $op_IsEqual(/*HttpMethod*/ left, /*HttpMethod*/ right)
    {
        return ReferenceEquals(left, null) || ReferenceEquals(right, null) ? ReferenceEquals(left, right) : left.Equals(right);
    }
    /*bool*/ static $op_IsNotEqual(/*HttpMethod*/ left, /*HttpMethod*/ right)
    {
        return (left === right);
    }
    /*HttpMethod*/ static Parse(/*ReadOnlySpan<char>*/ method)
    {
        return GetKnownMethod(method) ?? new HttpMethod(method.ToString());
    }
    /*HttpMethod*/ static GetKnownMethod(/*ReadOnlySpan<char>*/ method)
    {
        if (method.Length  >= 3)
        {
            /*HttpMethod*/ let match = null;
            switch(method[0] | 0x20)
            {
                case 'c':
                {
                    match = Connect;
                    break;
                }
                case 'd':
                {
                    match = Delete;
                    break;
                }
                case 'g':
                {
                    match = Get;
                    break;
                }
                case 'h':
                {
                    match = Head;
                    break;
                }
                case 'o':
                {
                    match = Options;
                    break;
                }
                case 'p':
                {
                    switch(method.Length)
                    {
                        case 3:
                        {
                            match = Put;
                            break;
                        }
                        case 4:
                        {
                            match = Post;
                            break;
                        }
                        default:
                        {
                            match = Patch;
                            break;
                        }
                    }
                    match = Head;
                    break;
                }
                case 't':
                {
                    match = Trace;
                    break;
                }
            }
            if ((match) && method.IsEqual(match._method, StringComparison.OrdinalIgnoreCase))
            {
                return match;
            }
        }
        return null;
    }
}

static class System_Net_Http_HttpParseResult
{
    Parsed = 0;
    NotParsed = 1;
    InvalidFormat = 2;
}

static class System_Net_Http_HttpRequestError
{
    Unknown = 0;
    NameResolutionError = 1;
    ConnectionError = 2;
    SecureConnectionError = 3;
    HttpProtocolError = 4;
    ExtendedConnectNotSupported = 5;
    VersionNegotiationError = 6;
    UserAuthenticationError = 7;
    ProxyTunnelError = 8;
    InvalidResponse = 9;
    ResponseEnded = 10;
    ConfigurationLimitExceeded = 11;
}

class System_Net_Http_HttpRequestException extends System_Exception
{
    /*RequestRetryType*/ _backingField_AllowRetry = null;
    /*RequestRetryType*/ get AllowRetry()
    {
        return _backingField_AllowRetry;
    }
    constructor()
    {
        super();
    }
    constructor(/*string*/ message)
    {
        super(message);
    }
    constructor(/*string*/ message, /*Exception*/ inner)
    {
        super(message, inner);
        if (inner !== null)
        {
            HResult = inner.HResult;
        }
    }
    constructor(/*string*/ message, /*Exception*/ inner, /*HttpStatusCode?*/ statusCode)
    {
        super(message, inner);
        StatusCode = statusCode;
    }
    constructor(/*HttpRequestError*/ httpRequestError, /*string*/ message, /*Exception*/ inner, /*HttpStatusCode?*/ statusCode)
    {
        super(message, inner, statusCode);
        HttpRequestError = httpRequestError;
    }
    /*HttpRequestError*/ _backingField_HttpRequestError = null;
    /*HttpRequestError*/ get HttpRequestError()
    {
        return _backingField_HttpRequestError;
    }
    /*HttpStatusCode?*/ _backingField_StatusCode = null;
    /*HttpStatusCode?*/ get StatusCode()
    {
        return _backingField_StatusCode;
    }
    constructor(/*HttpRequestError*/ httpRequestError, /*string*/ message, /*Exception*/ inner, /*RequestRetryType*/ allowRetry)
    {
        super(httpRequestError, message, inner);
        AllowRetry = allowRetry;
    }
}

class System_Net_Http_HttpRequestMessage extends System_IDisposable(object)
{
    /*Version*/ static get DefaultRequestVersion()
    {
        return HttpVersion.Version11;
    }
    /*HttpVersionPolicy*/ static get DefaultVersionPolicy()
    {
        return HttpVersionPolicy.RequestVersionOrLower;
    }
    /*int*/ MessageNotYetSent = 0;
    /*int*/ MessageAlreadySent = 1;
    /*int*/ MessageIsRedirect = 2;
    /*int*/ MessageDisposed = 4;
    /*int*/ _sendStatus = MessageNotYetSent;
    /*HttpMethod*/ _method = null;
    /*Uri*/ _requestUri = null;
    /*HttpRequestHeaders*/ _headers = null;
    /*Version*/ _version = null;
    /*HttpVersionPolicy*/ _versionPolicy = null;
    /*HttpContent*/ _content = null;
    /*HttpRequestOptions*/ _options = null;
    /*Version*/ get Version()
    {
        return _version;
    }
    /*Version*/ set Version(value)
    {
        if (value === null)
        throw new ArgumentNullException();
        CheckDisposed();
        _version = value;
    }
    /*HttpVersionPolicy*/ get VersionPolicy()
    {
        return _versionPolicy;
    }
    /*HttpVersionPolicy*/ set VersionPolicy(value)
    {
        CheckDisposed();
        _versionPolicy = value;
    }
    /*HttpContent*/ get Content()
    {
        return _content;
    }
    /*HttpContent*/ set Content(value)
    {
        CheckDisposed();
        _content = value;
    }
    /*HttpMethod*/ get Method()
    {
        return _method;
    }
    /*HttpMethod*/ set Method(value)
    {
        if (value === null)
        throw new ArgumentNullException();
        CheckDisposed();
        _method = value;
    }
    /*Uri*/ get RequestUri()
    {
        return _requestUri;
    }
    /*Uri*/ set RequestUri(value)
    {
        CheckDisposed();
        _requestUri = value;
    }
    /*HttpRequestHeaders*/ get Headers()
    {
        return _headers = _headers ?? new HttpRequestHeaders();
    }
    /*bool*/ get HasHeaders()
    {
        return _headers !== null;
    }
    /*IDictionary<string, object>*/ get Properties()
    {
        return Options;
    }
    /*HttpRequestOptions*/ get Options()
    {
        return _options = _options ?? new HttpRequestOptions();
    }
    constructor()
    {
        super(HttpMethod.Get, BlazorJs.Cast(null, Uri));
    }
    constructor(/*HttpMethod*/ method, /*Uri*/ requestUri)
    {
        super();
        if (method === null)
        throw new ArgumentNullException();
        _method = method;
        _requestUri = requestUri;
        _version = DefaultRequestVersion;
        _versionPolicy = DefaultVersionPolicy;
    }
    constructor(/*HttpMethod*/ method, /*string*/ requestUri)
    {
        super(method, string.IsNullOrEmpty(requestUri) ? null : new Uri(requestUri));
    }
    /*string*/ ToString()
    {
        /*StringBuilder*/ let sb = new StringBuilder();
        sb.Append("Method: ");
        sb.Append(_method);
        sb.Append(", RequestUri: '");
        if (_requestUri)
        {
            sb.Append("<null>");
        }
        else 
        {
            sb.Append(`${_requestUri}`);
        }
        sb.Append("', Version: ");
        sb.Append(_version);
        sb.Append(", Content: ");
        sb.Append(_content === null ? "<null>" : _content.GetType().ToString());
        sb.AppendLine(", Headers:");
        HeaderUtilities.DumpHeaders(sb, _headers, _content?.Headers);
        return sb.ToString();
    }
    /*bool*/ MarkAsSent()
    {
        let $ref0 = { set value(v){ _sendStatus = v } };
        return InterlockedExtension.CompareExchange($ref0, MessageAlreadySent, MessageNotYetSent) === MessageNotYetSent;
    }
    /*bool*/ WasSentByHttpClient()
    {
        return (_sendStatus & MessageAlreadySent) !== 0;
    }
    /*void*/ MarkAsRedirected()
    {
        return _sendStatus |= MessageIsRedirect;
    }
    /*bool*/ WasRedirected()
    {
        return (_sendStatus & MessageIsRedirect) !== 0;
    }
    /*bool*/ get Disposed()
    {
        return (_sendStatus & MessageDisposed) !== 0;
    }
    /*bool*/ set Disposed(value)
    {
        Debug.Assert(value);
        _sendStatus |= MessageDisposed;
    }
    /*bool*/ get IsExtendedConnectRequest()
    {
        return Method === HttpMethod.Connect  && _headers?.Protocol !== null;
    }
    /*void*/ Dispose(/*bool*/ disposing)
    {
        if (disposing && Disposed)
        {
            Disposed = true;
            _content?.Dispose();
        }
    }
    /*void*/ Dispose()
    {
        Dispose(true);
    }
    /*void*/ CheckDisposed()
    {
        if (Disposed)
        throw new ObjectDisposedException("");
    }
}

class System_Net_Http_HttpRequestOptions extends System_Collections_Generic_IReadOnlyCollection(System_Collections_Generic_KeyValuePair(string, object))(System_Collections_Generic_IReadOnlyDictionary(string, object)(H5_IH5Class(System_Collections_IEnumerable(System_Collections_Generic_IEnumerable(System_Collections_Generic_KeyValuePair(string, object))(System_Collections_Generic_ICollection(System_Collections_Generic_KeyValuePair(string, object))(System_Collections_Generic_IDictionary(string, object)(object)))))))
{
    /*Dictionary<string, object>*/ _backingField_Options = null;
    /*Dictionary<string, object>*/ get Options()
    {
        return _backingField_Options;
    }
    /*bool*/ TryGetValue(/*string*/ key, /*out object*/ value)
    {
        let $ref0 = { set value(v){ value = v } };
        return Options.TryGetValue(key, $ref0);
    }
    /*object*/ getItem(/*string*/ key)
    {
        return Options[key];
    }
    /*IEnumerable<string>*/ get Keys()
    {
        return Options.Keys;
    }
    /*IEnumerable<object>*/ get Values()
    {
        return Options.Values;
    }
    /*object*/ getItem(/*string*/ key)
    {
        return Options[key];
    }
    /*void*/ setItem(/*string*/ key, /*object*/ value)
    {
        Options[key] = value;
    }
    /*ICollection<string>*/ get Keys()
    {
        return Options.Keys;
    }
    /*ICollection<object>*/ get Values()
    {
        return Options.Values;
    }
    /*int*/ get Count()
    {
        return Options.Count;
    }
    /*bool*/ get IsReadOnly()
    {
        return (BlazorJs.Cast(Options, IDictionary(string, object))).IsReadOnly;
    }
    /*void*/ Add(/*string*/ key, /*object*/ value)
    {
        return Options.Add(key, value);
    }
    /*void*/ Add(/*KeyValuePair<string, object>*/ item)
    {
        return (BlazorJs.Cast(Options, IDictionary(string, object))).Add(item);
    }
    /*void*/ Clear()
    {
        return Options.Clear();
    }
    /*bool*/ Contains(/*KeyValuePair<string, object>*/ item)
    {
        return (BlazorJs.Cast(Options, IDictionary(string, object))).Contains(item);
    }
    /*bool*/ ContainsKey(/*string*/ key)
    {
        return Options.ContainsKey(key);
    }
    /*void*/ CopyTo(/*KeyValuePair<string, object>[]*/ array, /*int*/ arrayIndex)
    {
        return (BlazorJs.Cast(Options, IDictionary(string, object))).CopyTo(array, arrayIndex);
    }
    /*IEnumerator<KeyValuePair<string, object>>*/ GetEnumerator()
    {
        return Options.GetEnumerator();
    }
    /*System.Collections.IEnumerator*/ GetEnumerator()
    {
        return (BlazorJs.Cast(Options, System_Collections_IEnumerable)).GetEnumerator();
    }
    /*bool*/ Remove(/*string*/ key)
    {
        return Options.Remove(key);
    }
    /*bool*/ Remove(/*KeyValuePair<string, object>*/ item)
    {
        return (BlazorJs.Cast(Options, IDictionary(string, object))).Remove(item);
    }
    /*bool*/ ContainsKey(/*string*/ key)
    {
        return Options.ContainsKey(key);
    }
    /*bool*/ TryGetValue(/*string*/ key, /*out object*/ value)
    {
        let $ref0 = { set value(v){ value = v } };
        return Options.TryGetValue(key, $ref0);
    }
    /*int*/ get Count()
    {
        return Options.Count;
    }
    constructor()
    {
        super();
    }
    /*bool*/ TryGetValue(TValue, /*HttpRequestOptionsKey<TValue>*/ key, /*out TValue*/ value)
    {
        let _value = null;
        let $ref1 = { set value(v){ _value = v } };
        if (Options.TryGetValue(key.Key, $ref1) && _value instanceof TValue, tvalue = _value)
        {
            value = tvalue;
            return true;
        }
        value = TValue?.default() ?? null;
        return false;
    }
    /*void*/ Set(TValue, /*HttpRequestOptionsKey<TValue>*/ key, /*TValue*/ value)
    {
        Options[key.Key] = value;
    }
    /*string*/ DebuggerToString()
    {
        return `Count = ${Options.Count}`;
    }
    static System_Net_Http_HttpRequestOptions_HttpRequestOptionsDebugView = class extends object
    {
        /*HttpRequestOptions*/ options = null;
        constructor(/*HttpRequestOptions*/ options)
        {
            super();
            this.options  = options;
        }
        /*KeyValuePair<string, object>[]*/ get Items()
        {
            /*var*/ let dictionary = BlazorJs.Cast(options, IDictionary(string, object));
            /*var*/ let items = new Array(dictionary.Count);
            dictionary.CopyTo(items, 0);
            return items;
        }
    }
}

const System_Net_Http_HttpRequestOptionsKey = (TValue) => class extends System_ValueType
{
    /*string*/ _backingField_Key = null;
    /*string*/ get Key()
    {
        return _backingField_Key;
    }
    constructor(/*string*/ key)
    {
        super();
        Key = key;
    }
}

class System_Net_Http_HttpResponseMessage extends System_IDisposable(object)
{
    /*HttpStatusCode*/ DefaultStatusCode = HttpStatusCode.OK;
    /*Version*/ static get DefaultResponseVersion()
    {
        return HttpVersion.Version11;
    }
    /*HttpStatusCode*/ _statusCode = null;
    /*HttpResponseHeaders*/ _headers = null;
    /*HttpResponseHeaders*/ _trailingHeaders = null;
    /*string*/ _reasonPhrase = null;
    /*HttpRequestMessage*/ _requestMessage = null;
    /*Version*/ _version = null;
    /*HttpContent*/ _content = null;
    /*bool*/ _disposed = null;
    /*Version*/ get Version()
    {
        return _version;
    }
    /*Version*/ set Version(value)
    {
        if (value === null)
        throw new ArgumentNullException();
        CheckDisposed();
        _version = value;
    }
    /*void*/ SetVersionWithoutValidation(/*Version*/ value)
    {
        return _version = value;
    }
    /*HttpContent*/ get Content()
    {
        return _content = _content ?? new EmptyContent();
    }
    /*HttpContent*/ set Content(value)
    {
        CheckDisposed();
        _content = value;
    }
    /*HttpStatusCode*/ get StatusCode()
    {
        return _statusCode;
    }
    /*HttpStatusCode*/ set StatusCode(value)
    {
        if (value < 0 || value > BlazorJs.Cast(999, HttpStatusCode))
        throw new ArgumentOutOfRangeException();
        CheckDisposed();
        _statusCode = value;
    }
    /*void*/ SetStatusCodeWithoutValidation(/*HttpStatusCode*/ value)
    {
        return _statusCode = value;
    }
    /*string*/ get ReasonPhrase()
    {
        if (_reasonPhrase !== null)
        {
            return _reasonPhrase;
        }
        return StatusCode.ToString();
    }
    /*string*/ set ReasonPhrase(value)
    {
        if ((value !== null) && HttpRuleParser.ContainsNewLine(value))
        {
            throw new FormatException("net_http_reasonphrase_format_error");
        }
        CheckDisposed();
        _reasonPhrase = value;
    }
    /*void*/ SetReasonPhraseWithoutValidation(/*string*/ value)
    {
        return _reasonPhrase = value;
    }
    /*HttpResponseHeaders*/ get Headers()
    {
        return _headers = _headers ?? new HttpResponseHeaders();
    }
    /*HttpResponseHeaders*/ get TrailingHeaders()
    {
        return _trailingHeaders = _trailingHeaders ?? new HttpResponseHeaders({ containsTrailingHeaders : true });
    }
    /*void*/ StoreReceivedTrailingHeaders(/*HttpResponseHeaders*/ headers)
    {
        Debug.Assert(headers.ContainsTrailingHeaders);
        if (_trailingHeaders)
        {
            _trailingHeaders = headers;
        }
        else 
        {
            _trailingHeaders.AddHeaders(headers);
        }
    }
    /*HttpRequestMessage*/ get RequestMessage()
    {
        return _requestMessage;
    }
    /*HttpRequestMessage*/ set RequestMessage(value)
    {
        CheckDisposed();
        _requestMessage = value;
    }
    /*bool*/ get IsSuccessStatusCode()
    {
        return (BlazorJs.Cast(_statusCode, int) >= 200) && (BlazorJs.Cast(_statusCode, int) <= 299);
    }
    constructor()
    {
        super(DefaultStatusCode);
    }
    constructor(/*HttpStatusCode*/ statusCode)
    {
        super();
        if (statusCode < 0 || statusCode > BlazorJs.Cast(999, HttpStatusCode))
        throw new ArgumentOutOfRangeException();
        _statusCode = statusCode;
        _version = DefaultResponseVersion;
    }
    /*HttpResponseMessage*/ EnsureSuccessStatusCode()
    {
        if (IsSuccessStatusCode)
        {
            throw new HttpRequestException(string.IsNullOrWhiteSpace(ReasonPhrase) ? "net_http_message_not_success_statuscode" : "net_http_message_not_success_statuscode_reason", null, _statusCode);
        }
        return this;
    }
    /*string*/ ToString()
    {
        /*StringBuilder*/ let sb = new StringBuilder();
        sb.Append("StatusCode: ");
        sb.Append(BlazorJs.Cast(_statusCode, int));
        sb.Append(", ReasonPhrase: '");
        sb.Append(ReasonPhrase ?? "<null>");
        sb.Append("', Version: ");
        sb.Append(_version);
        sb.Append(", Content: ");
        sb.Append(_content === null ? "<null>" : _content.GetType().ToString());
        sb.AppendLine(", Headers:");
        HeaderUtilities.DumpHeaders(sb, _headers, _content?.Headers);
        if (_trailingHeaders !== null)
        {
            sb.AppendLine(", Trailing Headers:");
            HeaderUtilities.DumpHeaders(sb, _trailingHeaders);
        }
        return sb.ToString();
    }
    /*void*/ Dispose(/*bool*/ disposing)
    {
        if (disposing && _disposed)
        {
            _disposed = true;
            _content?.Dispose();
        }
    }
    /*void*/ Dispose()
    {
        Dispose(true);
    }
    /*void*/ CheckDisposed()
    {
        if (_disposed)
        throw new ObjectDisposedException("");
    }
}

static class System_Net_Http_HttpRuleParser
{
    /*string*/ static s_tokenChars = "!#$%&'*+-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ^_`abcdefghijklmnopqrstuvwxyz|~";
    /*string*/ static s_tokenBytes = "!#$%&'*+-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ^_`abcdefghijklmnopqrstuvwxyz|~";
    /*string*/ static s_hostDelimiterChars = "/ \t\r,";
    /*int*/ MaxNestedCount = 5;
    /*char*/ CR = BlazorJs.Cast(13, char);
    /*char*/ LF = BlazorJs.Cast(10, char);
    /*int*/ MaxInt64Digits = 19;
    /*int*/ MaxInt32Digits = 10;
    /*Encoding*/ static get DefaultHttpEncoding()
    {
        return Encoding.Default;
    }
    /*int*/ static GetTokenLength(/*string*/ input, /*int*/ startIndex)
    {
        /*ReadOnlySpan<char>*/ let slice = input.AsSpan(startIndex);
        /*int*/ let index = slice.IndexOfAnyExcept(s_tokenChars);
        return index < 0 ? slice.Length  : index;
    }
    /*bool*/ static IsToken(/*ReadOnlySpan<char>*/ input)
    {
        return input.ContainsAnyExcept(s_tokenChars);
    }
    /*bool*/ static IsToken(/*ReadOnlySpan<byte>*/ input)
    {
        return input.ContainsAnyExcept(Encoding.ASCII.GetBytes(s_tokenBytes));
    }
    /*string*/ static GetTokenString(/*ReadOnlySpan<byte>*/ input)
    {
        Debug.Assert(IsToken(input));
        return Encoding.ASCII.GetString(input.ToArray());
    }
    /*int*/ static GetWhitespaceLength(/*string*/ input, /*int*/ startIndex)
    {
        Debug.Assert(input !== null);
        if (startIndex >= input.Length)
        {
            return 0;
        }
        /*int*/ let current = startIndex;
        /*char*/ let c;
        while(current < input.Length)
        {
            c = input[current];
            if ((c === ' ') || (c === '\t'))
            {
                current++;
            }
            return current - startIndex;
        }
        return input.Length  - startIndex;
    }
    /*bool*/ static ContainsNewLine(/*string*/ value, { /*int*/ startIndex = 0})
    {
        return value.AsSpan(startIndex).ContainsAny('\r', '\n');
    }
    /*int*/ static GetNumberLength(/*string*/ input, /*int*/ startIndex, /*bool*/ allowDecimal)
    {
        Debug.Assert(input !== null);
        Debug.Assert((startIndex >= 0) && (startIndex < input.Length));
        /*int*/ let current = startIndex;
        /*char*/ let c;
        /*// If decimal values are not allowed, we pretend to have read the '.' character already. I.e. if a dot is
            // found in the string, parsing will be aborted.
            bool*/ let haveDot = allowDecimal;
        if (input[current] === '.')
        {
            return 0;
        }
        while(current < input.Length)
        {
            c = input[current];
            if (char.IsDigit(c))
            {
                current++;
            }
            else if (haveDot && (c === '.'))
            {
                haveDot = true;
                current++;
            }
            else 
            {
                break;
            }
        }
        return current - startIndex;
    }
    /*int*/ static GetHostLength(/*string*/ input, /*int*/ startIndex, /*bool*/ allowToken)
    {
        Debug.Assert(input !== null);
        Debug.Assert(startIndex >= 0);
        if (startIndex >= input.Length)
        {
            return 0;
        }
        /*ReadOnlySpan<char>*/ let slice = input.AsSpan(startIndex);
        /*// A 'host' is either a token (if 'allowToken' == true) or a valid host name as defined by the URI RFC.
            // So we first iterate through the string and search for path delimiters and whitespace. When found, stop
            // and try to use the substring as token or URI host name. If it works, we have a host name, otherwise not.
            int*/ let index = slice.IndexOfAny(s_hostDelimiterChars);
        if (index >= 0)
        {
            if (index === 0)
            {
                return 0;
            }
            if (slice[index] === '/')
            {
                return 0;
            }
            slice = slice.Slice(0, index);
        }
        if ((allowToken && IsToken(slice)) || IsValidHostName(slice))
        {
            return slice.Length;
        }
        return 0;
    }
    /*HttpParseResult*/ static GetCommentLength(/*string*/ input, /*int*/ startIndex, /*out int*/ length)
    {
        let $ref0 = { set value(v){ length = v } };
        return GetExpressionLength(input, startIndex, '(', ')', true, 1, $ref0);
    }
    /*HttpParseResult*/ static GetQuotedStringLength(/*string*/ input, /*int*/ startIndex, /*out int*/ length)
    {
        let $ref0 = { set value(v){ length = v } };
        return GetExpressionLength(input, startIndex, '"', '"', false, 1, $ref0);
    }
    /*HttpParseResult*/ static GetQuotedPairLength(/*string*/ input, /*int*/ startIndex, /*out int*/ length)
    {
        Debug.Assert(input !== null);
        Debug.Assert((startIndex >= 0) && (startIndex < input.Length));
        length = 0;
        if (input[startIndex] !== '\\')
        {
            return HttpParseResult.NotParsed;
        }
        if ((startIndex + 2 > input.Length) || (input[startIndex + 1] > 127))
        {
            return HttpParseResult.InvalidFormat;
        }
        length = 2;
        return HttpParseResult.Parsed;
    }
    /*HttpParseResult*/ static GetExpressionLength(/*string*/ input, /*int*/ startIndex, /*char*/ openChar, /*char*/ closeChar, /*bool*/ supportsNesting, /*int*/ nestedCount, /*out int*/ length)
    {
        Debug.Assert(input !== null);
        Debug.Assert((startIndex >= 0) && (startIndex < input.Length));
        length = 0;
        if (input[startIndex] !== openChar)
        {
            return HttpParseResult.NotParsed;
        }
        /*int*/ let current = startIndex + 1;
        while(current < input.Length)
        {
            let $ref0 = { set value(v){ quotedPairLength = v } };
            /*// Only check whether we have a quoted char, if we have at least 3 characters left to read (i.e.
                // quoted char + closing char). Otherwise the closing char may be considered part of the quoted char.
                int*/ let quotedPairLength;
            if ((current + 2 < input.Length) && (GetQuotedPairLength(input, current, $ref0) === HttpParseResult.Parsed))
            {
                current += quotedPairLength;
            }
            /*char*/ let c = input[current];
            if (c === '\r' || c === '\n')
            {
                return HttpParseResult.InvalidFormat;
            }
            if (supportsNesting && (c === openChar))
            {
                let $ref0 = { set value(v){ nestedLength = v } };
                if (nestedCount > MaxNestedCount)
                {
                    return HttpParseResult.InvalidFormat;
                }
                /*int*/ let nestedLength;
                /*HttpParseResult*/ let nestedResult = GetExpressionLength(input, current, openChar, closeChar, supportsNesting, nestedCount + 1, $ref0);
                switch(nestedResult)
                {
                    case HttpParseResult.Parsed:
                    {
                        current += nestedLength;
                        break;
                    }
                    case HttpParseResult.NotParsed:
                    {
                        Debug.Fail("'NotParsed' is unexpected: We started nested expression " + "parsing, because we found the open-char. So either it's a valid nested " + "expression or it has invalid format.");
                        break;
                    }
                    case HttpParseResult.InvalidFormat:
                    {
                        return HttpParseResult.InvalidFormat;
                    }
                    default:
                    {
                        Debug.Fail("Unknown enum result: " + nestedResult);
                        break;
                    }
                }
            }
            if (input[current] === closeChar)
            {
                length = current - startIndex + 1;
                return HttpParseResult.Parsed;
            }
            current++;
        }
        return HttpParseResult.InvalidFormat;
    }
    /*bool*/ static IsValidHostName(/*ReadOnlySpan<char>*/ host)
    {
        return true;
    }
}

static class System_Net_Http_HttpStatusCode
{
    OK = 200
;
}

class System_Net_Http_HttpVersion extends object
{
    constructor()
    {
        super();
    }
    /*Version*/ static Version11 = new Version();
}

static class System_Net_Http_HttpVersionPolicy
{
    RequestVersionOrLower = 0;
    RequestVersionOrHigher = 1;
    RequestVersionExact = 2;
}

static class System_Net_Http_RequestRetryType
{
    NoRetry = 0;
    RetryOnConnectionFailure = 1;
    RetryOnLowerHttpVersion = 2;
    RetryOnNextProxy = 3;
    RetryOnStreamLimitReached = 4;
}

class System_Net_Http_StreamContent extends System_Net_Http_HttpContent
{
    /*Stream*/ _content = null;
    /*int*/ _bufferSize = null;
    /*bool*/ _contentConsumed = null;
    /*long*/ _start = null;
    constructor(/*Stream*/ content)
    {
        super();
        if (content === null)
        throw new ArgumentNullException(nameof(content));
        InitializeContent(content, 0);
    }
    constructor(/*Stream*/ content, /*int*/ bufferSize)
    {
        super();
        if (content === null)
        throw new ArgumentNullException(nameof(content));
        if (bufferSize <= 0)
        throw new ArgumentOutOfRangeException(nameof(bufferSize));
        InitializeContent(content, bufferSize);
    }
    /*void*/ InitializeContent(/*Stream*/ content, /*int*/ bufferSize)
    {
        _content = content;
        _bufferSize = bufferSize;
        if (content.CanSeek)
        {
            _start = content.Position;
        }
    }
    /*void*/ SerializeToStream(/*Stream*/ stream, /*CancellationToken*/ cancellationToken)
    {
        Debug.Assert(stream !== null);
        PrepareContent();
        StreamToStreamCopy.Copy(_content, stream, _bufferSize, _content.CanSeek);
    }
    /*Task*/ SerializeToStreamAsync(/*Stream*/ stream)
    {
        return SerializeToStreamAsyncCore(stream, BlazorJs.getDefault());
    }
    /*Task*/ SerializeToStreamAsync(/*Stream*/ stream, /*CancellationToken*/ cancellationToken)
    {
        return GetType() === StreamContent ? SerializeToStreamAsyncCore(stream, cancellationToken) : super.SerializeToStreamAsync(stream, cancellationToken);
    }
    /*Task*/ SerializeToStreamAsyncCore(/*Stream*/ stream, /*CancellationToken*/ cancellationToken)
    {
        Debug.Assert(stream !== null);
        PrepareContent();
        return StreamToStreamCopy.CopyAsync(_content, stream, _bufferSize, _content.CanSeek, cancellationToken);
    }
    /*bool*/ TryComputeLength(/*out long*/ length)
    {
        if (_content.CanSeek)
        {
            length = _content.Length  - _start;
            return true;
        }
        else 
        {
            length = 0;
            return false;
        }
    }
    /*void*/ Dispose(/*bool*/ disposing)
    {
        if (disposing)
        {
            _content.Dispose();
        }
        super.Dispose(disposing);
    }
    /*Stream*/ CreateContentReadStream(/*CancellationToken*/ cancellationToken)
    {
        SeekToStartIfSeekable();
        return new ReadOnlyStream(_content);
    }
    /*Task<Stream>*/ CreateContentReadStreamAsync()
    {
        SeekToStartIfSeekable();
        return Task.FromResult(Stream, new ReadOnlyStream(_content));
    }
    /*Stream*/ TryCreateContentReadStream()
    {
        return GetType() === StreamContent ? new ReadOnlyStream(_content) : null;
    }
    /*bool*/ get AllowDuplex()
    {
        return false;
    }
    /*void*/ PrepareContent()
    {
        if (_contentConsumed)
        {
            if (_content.CanSeek)
            {
                _content.Position  = _start;
            }
            else 
            {
                throw new InvalidOperationException("net_http_content_stream_already_read");
            }
        }
        _contentConsumed = true;
    }
    /*void*/ SeekToStartIfSeekable()
    {
        if (_content.CanSeek)
        {
            _content.Position  = _start;
        }
    }
    static System_Net_Http_StreamContent_ReadOnlyStream = class extends System_IO_Stream
    {
        /*Stream*/ innerStream = null;
        constructor(/*Stream*/ innerStream)
        {
            super();
        }
        /*bool*/ get CanWrite()
        {
            return false;
        }
        /*void*/ Flush()
        {
        }
        /*void*/ SetLength(/*long*/ value)
        {
            throw new NotSupportedException("net_http_content_readonly_stream");
        }
        /*IAsyncResult*/ BeginWrite(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count, /*AsyncCallback*/ callback, /*object*/ state)
        {
            throw new NotSupportedException("net_http_content_readonly_stream");
        }
        /*void*/ EndWrite(/*IAsyncResult*/ asyncResult)
        {
            throw new NotSupportedException("net_http_content_readonly_stream");
        }
        /*void*/ Write(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count)
        {
            throw new NotSupportedException("net_http_content_readonly_stream");
        }
        /*void*/ WriteByte(/*byte*/ value)
        {
            throw new NotSupportedException("net_http_content_readonly_stream");
        }
        /*long*/ Seek(/*long*/ offset, /*SeekOrigin*/ origin)
        {
            throw new NotImplementedException();
        }
        /*int*/ Read(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count)
        {
            throw new NotImplementedException();
        }
        /*int*/ get WriteTimeout()
        {
            throw new InvalidOperationException("net_http_content_readonly_stream");
        }
        /*int*/ set WriteTimeout(value)
        {
            throw new InvalidOperationException("net_http_content_readonly_stream");
        }
        /*bool*/ get CanRead()
        {
            return innerStream.CanRead;
        }
        /*bool*/ get CanSeek()
        {
            return innerStream.CanSeek;
        }
        /*long*/ get Length()
        {
            return innerStream.Length;
        }
        /*long*/ get Position()
        {
            return innerStream.Position;
        }
        /*long*/ set Position(value)
        {
            innerStream.Position  = value;
        }
    }
}

static class System_Net_Http_StreamToStreamCopy
{
    /*void*/ static Copy(/*Stream*/ source, /*Stream*/ destination, /*int*/ bufferSize, /*bool*/ disposeSource)
    {
        Debug.Assert(source !== null);
        Debug.Assert(destination !== null);
        Debug.Assert(bufferSize >= 0);
        if (bufferSize === 0)
        {
            source.CopyTo(destination);
        }
        else 
        {
            source.CopyTo(destination, bufferSize);
        }
        if (disposeSource)
        {
            DisposeSource(source);
        }
    }
    /*Task*/ static CopyAsync(/*Stream*/ source, /*Stream*/ destination, /*int*/ bufferSize, /*bool*/ disposeSource, { /*CancellationToken*/ cancellationToken = CancellationToken?.default() ?? null})
    {
        Debug.Assert(source !== null);
        Debug.Assert(destination !== null);
        Debug.Assert(bufferSize >= 0);
        try
        {
            /*Task*/ let copyTask = bufferSize === 0 ? source.CopyToAsync(destination, cancellationToken) : source.CopyToAsync(destination, bufferSize, cancellationToken);
            if (disposeSource)
            {
                return copyTask;
            }
            switch(copyTask.Status)
            {
                case TaskStatus.RanToCompletion:
                {
                    DisposeSource(source);
                    return Task.CompletedTask;
                }
                case TaskStatus.Faulted:
                case TaskStatus.Canceled:
                {
                    return copyTask;
                }
                default:
                {
                    return DisposeSourceAsync(copyTask, source);
                    /*Task*/ async function DisposeSourceAsync(/*Task*/ mcopyTask, /*Stream*/ msource)
                    {
                        await mcopyTask;
                        DisposeSource(msource);
                    }
                }
            }
        }
        catch(e)
        {
            throw e;
        }
    }
    /*void*/ static DisposeSource(/*Stream*/ source)
    {
        try
        {
            source.Dispose();
        }
        catch(e)
        {
        }
    }
}

static class System_Net_Http_Json_HttpClientJsonExtensions
{
    /*Task<object>*/ static FromJsonAsyncCore(/*Func<HttpClient, Uri, CancellationToken, Task<HttpResponseMessage>>*/ getMethod, /*HttpClient*/ client, /*Uri*/ requestUri, /*Type*/ type, /*JsonSerializerOptions*/ options, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        return FromJsonAsyncCoreImpl(object, BlazorJs.TupleType(Type, JsonSerializerOptions))(object, (Type, JsonSerializerOptions), getMethod, client, requestUri, function(/**/ stream, /**/ innerOptions, /**/ cancellation)
        {
            return JsonSerializer.DeserializeAsync(stream, innerOptions.Item1, innerOptions.Item2  ?? JsonSerializerOptions.Web, cancellation);
        }, BlazorJs.TupleValue({ Item1: type, Item2: options }), cancellationToken);
    }
    /*Task<TValue>*/ static FromJsonAsyncCore(TValue, /*Func<HttpClient, Uri, CancellationToken, Task<HttpResponseMessage>>*/ getMethod, /*HttpClient*/ client, /*Uri*/ requestUri, /*JsonSerializerOptions*/ options, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        return FromJsonAsyncCoreImpl(TValue, JsonSerializerOptions)(TValue, JsonSerializerOptions, getMethod, client, requestUri, function(/**/ stream, /**/ innerOptions, /**/ cancellation)
        {
            return JsonSerializer.DeserializeAsync(TValue, stream, innerOptions ?? JsonSerializerOptions.Web, cancellation);
        }, options, cancellationToken);
    }
    /*Task<object>*/ static FromJsonAsyncCore(/*Func<HttpClient, Uri, CancellationToken, Task<HttpResponseMessage>>*/ getMethod, /*HttpClient*/ client, /*Uri*/ requestUri, /*Type*/ type, /*JsonSerializerContext*/ context, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        return FromJsonAsyncCoreImpl(object, BlazorJs.TupleType(Type, JsonSerializerContext))(object, (Type, JsonSerializerContext), getMethod, client, requestUri, function(/**/ stream, /**/ options, /**/ cancellation)
        {
            return JsonSerializer.DeserializeAsync(stream, options.Item1, options.Item2, cancellation);
        }, BlazorJs.TupleValue({ Item1: type, Item2: context }), cancellationToken);
    }
    /*Task<TValue>*/ static FromJsonAsyncCore(TValue, /*Func<HttpClient, Uri, CancellationToken, Task<HttpResponseMessage>>*/ getMethod, /*HttpClient*/ client, /*Uri*/ requestUri, /*JsonTypeInfo<TValue>*/ jsonTypeInfo, /*CancellationToken*/ cancellationToken)
    {
        return FromJsonAsyncCoreImpl(TValue, JsonTypeInfo(TValue))(TValue, JsonTypeInfo(TValue), getMethod, client, requestUri, function(/**/ stream, /**/ options, /**/ cancellation)
        {
            return JsonSerializer.DeserializeAsync(stream, options, cancellation);
        }, jsonTypeInfo, cancellationToken);
    }
    /*Task<TValue>*/ static FromJsonAsyncCoreImpl(TValue, TJsonOptions, /*Func<HttpClient, Uri, CancellationToken, Task<HttpResponseMessage>>*/ getMethod, /*HttpClient*/ client, /*Uri*/ requestUri, /*Func<Stream, TJsonOptions, CancellationToken, Task<TValue>>*/ deserializeMethod, /*TJsonOptions*/ jsonOptions, /*CancellationToken*/ cancellationToken)
    {
        if (client)
        {
            throw new ArgumentNullException(nameof(client));
        }
        /*TimeSpan*/ let timeout = client.Timeout;
        /*// Create the CTS before the initial SendAsync so that the SendAsync counts against the timeout.
            CancellationTokenSource*/ let linkedCTS = null;
        if (timeout !== TimeSpan.MaxValue)
        {
            linkedCTS = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            linkedCTS.CancelAfter(timeout);
        }
        /*// We call SendAsync outside of the async Core method to propagate exception even without awaiting the returned task.
            Task<HttpResponseMessage>*/ let responseTask;
        try
        {
            responseTask = getMethod(client, requestUri, cancellationToken);
        }
        catch($e)
        {
            linkedCTS?.Dispose();
            throw $e;
        }
        /*bool*/ let usingResponseHeadersRead = ReferenceEquals(getMethod, s_deleteAsync);
        return Core(client, responseTask, usingResponseHeadersRead, linkedCTS, deserializeMethod, jsonOptions, cancellationToken);
        /*Task<TValue>*/ async function Core(/*HttpClient*/ innerClient, /*Task<HttpResponseMessage>*/ innerResponseTask, /*bool*/ innerUsingResponseHeadersRead, /*CancellationTokenSource*/ innerLinkedCTS, /*Func<Stream, TJsonOptions, CancellationToken, Task<TValue>>*/ innerDeserializeMethod, /*TJsonOptions*/ innerJsonOptions, /*CancellationToken*/ innerCancellationToken)
        {
            /*HttpResponseMessage*/ let response = null;
            /*Stream*/ let readStream = null;
            try
            {
                response = await innerResponseTask;
                response.EnsureSuccessStatusCode();
                try
                {
                    readStream = await GetHttpResponseStreamAsync(innerClient, response, innerUsingResponseHeadersRead, innerCancellationToken);
                    return await innerDeserializeMethod(readStream, innerJsonOptions, innerLinkedCTS?.Token ?? innerCancellationToken);
                }
                catch(oce)
                {
                    /*// Matches how HttpClient throws a timeout exception.
                        string*/ let message = "net_http_request_timedout";
                    throw new TaskCanceledException(message, new TimeoutException(oce.Message, oce));
                }
            }
            finally
            {
                {
                    response?.Dispose();
                    readStream?.Dispose();
                    innerLinkedCTS?.Dispose();
                }
            }
        }
    }
    /*Uri*/ static CreateUri(/*string*/ uri)
    {
        return string.IsNullOrEmpty(uri) ? null : new Uri(uri);
    }
    /*Task<Stream>*/ static GetHttpResponseStreamAsync(/*HttpClient*/ client, /*HttpResponseMessage*/ response, /*bool*/ usingResponseHeadersRead, /*CancellationToken*/ cancellationToken)
    {
        Debug.Assert(client.MaxResponseContentBufferSize  > 0 & client.MaxResponseContentBufferSize  <= int.MaxValue);
        /*int*/ let contentLengthLimit = BlazorJs.Cast(client.MaxResponseContentBufferSize, int);
        if (response.Content.Headers.ContentLength  instanceof long && contentLength > contentLengthLimit)
        {
            LengthLimitReadStream.ThrowExceededBufferLimit(contentLengthLimit);
        }
        /*Task<Stream>*/ let task = HttpContentJsonExtensions.GetContentStreamAsync(response.Content, cancellationToken);
        return usingResponseHeadersRead ? GetLengthLimitReadStreamAsync(client, task) : task;
    }
    /*Task<Stream>*/ static async GetLengthLimitReadStreamAsync(/*HttpClient*/ client, /*Task<Stream>*/ task)
    {
        /*Stream*/ let contentStream = await task;
        return new LengthLimitReadStream(contentStream, BlazorJs.Cast(client.MaxResponseContentBufferSize, int));
    }
    /*Func<HttpClient, Uri, CancellationToken, Task<HttpResponseMessage>>*/ static s_deleteAsync = function(/**/ client, /**/ uri, /**/ cancellation)
    {
        return client.DeleteAsync(uri, cancellation);
    };
    /*Task<object>*/ static DeleteFromJsonAsync(/*this HttpClient*/ client, /*string*/ requestUri, /*Type*/ type, /*JsonSerializerOptions*/ options, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        return DeleteFromJsonAsync(client, CreateUri(requestUri), type, options, cancellationToken);
    }
    /*Task<object>*/ static DeleteFromJsonAsync(/*this HttpClient*/ client, /*Uri*/ requestUri, /*Type*/ type, /*JsonSerializerOptions*/ options, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        return FromJsonAsyncCore(s_deleteAsync, client, requestUri, type, options, cancellationToken);
    }
    /*Task<TValue>*/ static DeleteFromJsonAsync(TValue, /*this HttpClient*/ client, /*string*/ requestUri, /*JsonSerializerOptions*/ options, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        return DeleteFromJsonAsync(TValue)(TValue, client, CreateUri(requestUri), options, cancellationToken);
    }
    /*Task<TValue>*/ static DeleteFromJsonAsync(TValue, /*this HttpClient*/ client, /*Uri*/ requestUri, /*JsonSerializerOptions*/ options, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        return FromJsonAsyncCore(TValue)(TValue, s_deleteAsync, client, requestUri, options, cancellationToken);
    }
    /*Task<object>*/ static DeleteFromJsonAsync(/*this HttpClient*/ client, /*string*/ requestUri, /*Type*/ type, /*JsonSerializerContext*/ context, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        return DeleteFromJsonAsync(client, CreateUri(requestUri), type, context, cancellationToken);
    }
    /*Task<object>*/ static DeleteFromJsonAsync(/*this HttpClient*/ client, /*Uri*/ requestUri, /*Type*/ type, /*JsonSerializerContext*/ context, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        return FromJsonAsyncCore(s_deleteAsync, client, requestUri, type, context, cancellationToken);
    }
    /*Task<TValue>*/ static DeleteFromJsonAsync(TValue, /*this HttpClient*/ client, /*string*/ requestUri, /*JsonTypeInfo<TValue>*/ jsonTypeInfo, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        return DeleteFromJsonAsync(client, CreateUri(requestUri), jsonTypeInfo, cancellationToken);
    }
    /*Task<TValue>*/ static DeleteFromJsonAsync(TValue, /*this HttpClient*/ client, /*Uri*/ requestUri, /*JsonTypeInfo<TValue>*/ jsonTypeInfo, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        return FromJsonAsyncCore(s_deleteAsync, client, requestUri, jsonTypeInfo, cancellationToken);
    }
    /*Task<object>*/ static DeleteFromJsonAsync(/*this HttpClient*/ client, /*string*/ requestUri, /*Type*/ type, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        return DeleteFromJsonAsync(client, requestUri, type, cancellationToken, { options : null });
    }
    /*Task<object>*/ static DeleteFromJsonAsync(/*this HttpClient*/ client, /*Uri*/ requestUri, /*Type*/ type, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        return DeleteFromJsonAsync(client, requestUri, type, cancellationToken, { options : null });
    }
    /*Task<TValue>*/ static DeleteFromJsonAsync(TValue, /*this HttpClient*/ client, /*string*/ requestUri, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        return DeleteFromJsonAsync(TValue)(TValue, client, requestUri, cancellationToken, { options : null });
    }
    /*Task<TValue>*/ static DeleteFromJsonAsync(TValue, /*this HttpClient*/ client, /*Uri*/ requestUri, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        return DeleteFromJsonAsync(TValue)(TValue, client, requestUri, cancellationToken, { options : null });
    }
    /*Func<HttpClient, Uri, CancellationToken, Task<HttpResponseMessage>>*/ static s_getAsync = function(/**/ client, /**/ uri, /**/ cancellation)
    {
        return client.GetAsync(uri, HttpCompletionOption.ResponseHeadersRead, cancellation);
    };
    /*Task<object>*/ static GetFromJsonAsync(/*this HttpClient*/ client, /*string*/ requestUri, /*Type*/ type, /*JsonSerializerOptions*/ options, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        return GetFromJsonAsync(client, CreateUri(requestUri), type, options, cancellationToken);
    }
    /*Task<object>*/ static GetFromJsonAsync(/*this HttpClient*/ client, /*Uri*/ requestUri, /*Type*/ type, /*JsonSerializerOptions*/ options, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        return FromJsonAsyncCore(function(/**/ innerClient, /**/ uri, /**/ cancellation)
        {
            return innerClient.GetAsync(uri, HttpCompletionOption.ResponseHeadersRead, cancellation);
        }, client, requestUri, type, options, cancellationToken);
    }
    /*Task<TValue>*/ static GetFromJsonAsync(TValue, /*this HttpClient*/ client, /*string*/ requestUri, /*JsonSerializerOptions*/ options, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        return GetFromJsonAsync(TValue)(TValue, client, CreateUri(requestUri), options, cancellationToken);
    }
    /*Task<TValue>*/ static GetFromJsonAsync(TValue, /*this HttpClient*/ client, /*Uri*/ requestUri, /*JsonSerializerOptions*/ options, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        return FromJsonAsyncCore(TValue)(TValue, s_getAsync, client, requestUri, options, cancellationToken);
    }
    /*Task<object>*/ static GetFromJsonAsync(/*this HttpClient*/ client, /*string*/ requestUri, /*Type*/ type, /*JsonSerializerContext*/ context, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        return GetFromJsonAsync(client, CreateUri(requestUri), type, context, cancellationToken);
    }
    /*Task<object>*/ static GetFromJsonAsync(/*this HttpClient*/ client, /*Uri*/ requestUri, /*Type*/ type, /*JsonSerializerContext*/ context, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        return FromJsonAsyncCore(s_getAsync, client, requestUri, type, context, cancellationToken);
    }
    /*Task<TValue>*/ static GetFromJsonAsync(TValue, /*this HttpClient*/ client, /*string*/ requestUri, /*JsonTypeInfo<TValue>*/ jsonTypeInfo, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        return GetFromJsonAsync(client, CreateUri(requestUri), jsonTypeInfo, cancellationToken);
    }
    /*Task<TValue>*/ static GetFromJsonAsync(TValue, /*this HttpClient*/ client, /*Uri*/ requestUri, /*JsonTypeInfo<TValue>*/ jsonTypeInfo, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        return FromJsonAsyncCore(s_getAsync, client, requestUri, jsonTypeInfo, cancellationToken);
    }
    /*Task<object>*/ static GetFromJsonAsync(/*this HttpClient*/ client, /*string*/ requestUri, /*Type*/ type, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        return GetFromJsonAsync(client, requestUri, type, cancellationToken, { options : null });
    }
    /*Task<object>*/ static GetFromJsonAsync(/*this HttpClient*/ client, /*Uri*/ requestUri, /*Type*/ type, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        return GetFromJsonAsync(client, requestUri, type, cancellationToken, { options : null });
    }
    /*Task<TValue>*/ static GetFromJsonAsync(TValue, /*this HttpClient*/ client, /*string*/ requestUri, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        return GetFromJsonAsync(TValue)(TValue, client, requestUri, cancellationToken, { options : null });
    }
    /*Task<TValue>*/ static GetFromJsonAsync(TValue, /*this HttpClient*/ client, /*Uri*/ requestUri, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        return GetFromJsonAsync(TValue)(TValue, client, requestUri, cancellationToken, { options : null });
    }
    /*HttpMethod*/ static get HttpPatch()
    {
        return s_httpPatch = s_httpPatch ?? new HttpMethod("PATCH");
    }
    /*HttpMethod*/ static s_httpPatch = null;
    /*Task<HttpResponseMessage>*/ static PatchAsync(/*this HttpClient*/ client, /*string*/ requestUri, /*HttpContent*/ content, /*CancellationToken*/ cancellationToken)
    {
        return client.PatchAsync(CreateUri(requestUri), content, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ static PatchAsync(/*this HttpClient*/ client, /*Uri*/ requestUri, /*HttpContent*/ content, /*CancellationToken*/ cancellationToken)
    {
        /*// HttpClient.PatchAsync is not available in .NET standard and NET462
            HttpRequestMessage*/ let request = BlazorJs.PopulateProperty(new HttpRequestMessage(HttpPatch, requestUri), function(/*HttpRequestMessage*/ $obj)
        {
            $obj.Content = content;
        });
        return client.SendAsync(request, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ static PatchAsJsonAsync(TValue, /*this HttpClient*/ client, /*string*/ requestUri, /*TValue*/ value, { /*JsonSerializerOptions*/ options = null, /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        if (client)
        {
            throw new ArgumentNullException(nameof(client));
        }
        /*JsonContent*/ let content = JsonContent.Create(value, options, { mediaType : null });
        return client.PatchAsync(requestUri, content, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ static PatchAsJsonAsync(TValue, /*this HttpClient*/ client, /*Uri*/ requestUri, /*TValue*/ value, { /*JsonSerializerOptions*/ options = null, /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        if (client)
        {
            throw new ArgumentNullException(nameof(client));
        }
        /*JsonContent*/ let content = JsonContent.Create(value, options, { mediaType : null });
        return client.PatchAsync(requestUri, content, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ static PatchAsJsonAsync(TValue, /*this HttpClient*/ client, /*string*/ requestUri, /*TValue*/ value, /*CancellationToken*/ cancellationToken)
    {
        return client.PatchAsJsonAsync(requestUri, value, cancellationToken, { options : null });
    }
    /*Task<HttpResponseMessage>*/ static PatchAsJsonAsync(TValue, /*this HttpClient*/ client, /*Uri*/ requestUri, /*TValue*/ value, /*CancellationToken*/ cancellationToken)
    {
        return client.PatchAsJsonAsync(requestUri, value, cancellationToken, { options : null });
    }
    /*Task<HttpResponseMessage>*/ static PatchAsJsonAsync(TValue, /*this HttpClient*/ client, /*string*/ requestUri, /*TValue*/ value, /*JsonTypeInfo<TValue>*/ jsonTypeInfo, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        if (client)
        {
            throw new ArgumentNullException(nameof(client));
        }
        /*JsonContent*/ let content = JsonContent.Create(value, jsonTypeInfo);
        return client.PatchAsync(requestUri, content, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ static PatchAsJsonAsync(TValue, /*this HttpClient*/ client, /*Uri*/ requestUri, /*TValue*/ value, /*JsonTypeInfo<TValue>*/ jsonTypeInfo, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        if (client)
        {
            throw new ArgumentNullException(nameof(client));
        }
        /*JsonContent*/ let content = JsonContent.Create(value, jsonTypeInfo);
        return client.PatchAsync(requestUri, content, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ static PostAsJsonAsync(TValue, /*this HttpClient*/ client, /*string*/ requestUri, /*TValue*/ value, { /*JsonSerializerOptions*/ options = null, /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        if (client)
        {
            throw new ArgumentNullException(nameof(client));
        }
        /*JsonContent*/ let content = JsonContent.Create(value, options, { mediaType : null });
        return client.PostAsync(requestUri, content, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ static PostAsJsonAsync(TValue, /*this HttpClient*/ client, /*Uri*/ requestUri, /*TValue*/ value, { /*JsonSerializerOptions*/ options = null, /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        if (client)
        {
            throw new ArgumentNullException(nameof(client));
        }
        /*JsonContent*/ let content = JsonContent.Create(value, options, { mediaType : null });
        return client.PostAsync(requestUri, content, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ static PostAsJsonAsync(TValue, /*this HttpClient*/ client, /*string*/ requestUri, /*TValue*/ value, /*CancellationToken*/ cancellationToken)
    {
        return client.PostAsJsonAsync(requestUri, value, cancellationToken, { options : null });
    }
    /*Task<HttpResponseMessage>*/ static PostAsJsonAsync(TValue, /*this HttpClient*/ client, /*Uri*/ requestUri, /*TValue*/ value, /*CancellationToken*/ cancellationToken)
    {
        return client.PostAsJsonAsync(requestUri, value, cancellationToken, { options : null });
    }
    /*Task<HttpResponseMessage>*/ static PostAsJsonAsync(TValue, /*this HttpClient*/ client, /*string*/ requestUri, /*TValue*/ value, /*JsonTypeInfo<TValue>*/ jsonTypeInfo, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        if (client)
        {
            throw new ArgumentNullException(nameof(client));
        }
        /*JsonContent*/ let content = JsonContent.Create(value, jsonTypeInfo);
        return client.PostAsync(requestUri, content, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ static PostAsJsonAsync(TValue, /*this HttpClient*/ client, /*Uri*/ requestUri, /*TValue*/ value, /*JsonTypeInfo<TValue>*/ jsonTypeInfo, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        if (client)
        {
            throw new ArgumentNullException(nameof(client));
        }
        /*JsonContent*/ let content = JsonContent.Create(value, jsonTypeInfo);
        return client.PostAsync(requestUri, content, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ static PutAsJsonAsync(TValue, /*this HttpClient*/ client, /*string*/ requestUri, /*TValue*/ value, { /*JsonSerializerOptions*/ options = null, /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        if (client)
        {
            throw new ArgumentNullException(nameof(client));
        }
        /*JsonContent*/ let content = JsonContent.Create(value, options, { mediaType : null });
        return client.PutAsync(requestUri, content, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ static PutAsJsonAsync(TValue, /*this HttpClient*/ client, /*Uri*/ requestUri, /*TValue*/ value, { /*JsonSerializerOptions*/ options = null, /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        if (client)
        {
            throw new ArgumentNullException(nameof(client));
        }
        /*JsonContent*/ let content = JsonContent.Create(value, options, { mediaType : null });
        return client.PutAsync(requestUri, content, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ static PutAsJsonAsync(TValue, /*this HttpClient*/ client, /*string*/ requestUri, /*TValue*/ value, /*CancellationToken*/ cancellationToken)
    {
        return client.PutAsJsonAsync(requestUri, value, cancellationToken, { options : null });
    }
    /*Task<HttpResponseMessage>*/ static PutAsJsonAsync(TValue, /*this HttpClient*/ client, /*Uri*/ requestUri, /*TValue*/ value, /*CancellationToken*/ cancellationToken)
    {
        return client.PutAsJsonAsync(requestUri, value, cancellationToken, { options : null });
    }
    /*Task<HttpResponseMessage>*/ static PutAsJsonAsync(TValue, /*this HttpClient*/ client, /*string*/ requestUri, /*TValue*/ value, /*JsonTypeInfo<TValue>*/ jsonTypeInfo, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        if (client)
        {
            throw new ArgumentNullException(nameof(client));
        }
        /*JsonContent*/ let content = JsonContent.Create(value, jsonTypeInfo);
        return client.PutAsync(requestUri, content, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ static PutAsJsonAsync(TValue, /*this HttpClient*/ client, /*Uri*/ requestUri, /*TValue*/ value, /*JsonTypeInfo<TValue>*/ jsonTypeInfo, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        if (client)
        {
            throw new ArgumentNullException(nameof(client));
        }
        /*JsonContent*/ let content = JsonContent.Create(value, jsonTypeInfo);
        return client.PutAsync(requestUri, content, cancellationToken);
    }
}









static class System_Net_Http_Json_HttpContentJsonExtensions
{
    /*string*/ SerializationUnreferencedCodeMessage = "JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.";
    /*string*/ SerializationDynamicCodeMessage = "JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext.";
    /*Task<object>*/ static ReadFromJsonAsync(/*this HttpContent*/ content, /*Type*/ type, /*JsonSerializerOptions*/ options, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        if (content)
        {
            throw new ArgumentNullException(nameof(content));
        }
        return ReadFromJsonAsyncCore(content, type, options, cancellationToken);
    }
    /*Task<object>*/ static ReadFromJsonAsync(/*this HttpContent*/ content, /*Type*/ type, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        return ReadFromJsonAsync(content, type, { options : null, cancellationToken : cancellationToken });
    }
    /*Task<T>*/ static ReadFromJsonAsync(T, /*this HttpContent*/ content, /*JsonSerializerOptions*/ options, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        if (content)
        {
            throw new ArgumentNullException(nameof(content));
        }
        return ReadFromJsonAsyncCore(T)(T, content, options, cancellationToken);
    }
    /*Task<T>*/ static ReadFromJsonAsync(T, /*this HttpContent*/ content, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        return ReadFromJsonAsync(T)(T, content, { options : null, cancellationToken : cancellationToken });
    }
    /*Task<object>*/ static async ReadFromJsonAsyncCore(/*HttpContent*/ content, /*Type*/ type, /*JsonSerializerOptions*/ options, /*CancellationToken*/ cancellationToken)
    {
        const contentStream = null
        try
        {
            /*Stream*/ let contentStream = await GetContentStreamAsync(content, cancellationToken);
            return await JsonSerializer.DeserializeAsync(contentStream, type, options ?? JsonSerializerOptions.Web, cancellationToken);
        }
        finally
        {
            contentStream?.Dispose();
        }
    }
    /*Task<T>*/ static async ReadFromJsonAsyncCore(T, /*HttpContent*/ content, /*JsonSerializerOptions*/ options, /*CancellationToken*/ cancellationToken)
    {
        const contentStream = null
        try
        {
            /*Stream*/ let contentStream = await GetContentStreamAsync(content, cancellationToken);
            return await JsonSerializer.DeserializeAsync(T, contentStream, options ?? JsonSerializerOptions.Web, cancellationToken);
        }
        finally
        {
            contentStream?.Dispose();
        }
    }
    /*Task<object>*/ static ReadFromJsonAsync(/*this HttpContent*/ content, /*Type*/ type, /*JsonSerializerContext*/ context, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        if (content)
        {
            throw new ArgumentNullException(nameof(content));
        }
        return ReadFromJsonAsyncCore(content, type, context, cancellationToken);
    }
    /*Task<T>*/ static ReadFromJsonAsync(T, /*this HttpContent*/ content, /*JsonTypeInfo<T>*/ jsonTypeInfo, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        if (content)
        {
            throw new ArgumentNullException(nameof(content));
        }
        return ReadFromJsonAsyncCore(content, jsonTypeInfo, cancellationToken);
    }
    /*Task<object>*/ static async ReadFromJsonAsyncCore(/*HttpContent*/ content, /*Type*/ type, /*JsonSerializerContext*/ context, /*CancellationToken*/ cancellationToken)
    {
        const contentStream = null
        try
        {
            /*Stream*/ let contentStream = await GetContentStreamAsync(content, cancellationToken);
            return await JsonSerializer.DeserializeAsync(contentStream, type, context, cancellationToken);
        }
        finally
        {
            contentStream?.Dispose();
        }
    }
    /*Task<T>*/ static async ReadFromJsonAsyncCore(T, /*HttpContent*/ content, /*JsonTypeInfo<T>*/ jsonTypeInfo, /*CancellationToken*/ cancellationToken)
    {
        const contentStream = null
        try
        {
            /*Stream*/ let contentStream = await GetContentStreamAsync(content, cancellationToken);
            return await JsonSerializer.DeserializeAsync(contentStream, jsonTypeInfo, cancellationToken);
        }
        finally
        {
            contentStream?.Dispose();
        }
    }
    /*Task<Stream>*/ static GetContentStreamAsync(/*HttpContent*/ content, /*CancellationToken*/ cancellationToken)
    {
        /*Task<Stream>*/ let task = ReadHttpContentStreamAsync(content, cancellationToken);
        return JsonHelpers.GetEncoding(content) instanceof Encoding && sourceEncoding !== Encoding.UTF8  ? GetTranscodingStreamAsync(task, sourceEncoding) : task;
    }
    /*Task<Stream>*/ static async GetTranscodingStreamAsync(/*Task<Stream>*/ task, /*Encoding*/ sourceEncoding)
    {
        /*Stream*/ let contentStream = await task;
        return GetTranscodingStream(contentStream, sourceEncoding);
    }
    /*Task<Stream>*/ static ReadHttpContentStreamAsync(/*HttpContent*/ content, /*CancellationToken*/ cancellationToken)
    {
        if (cancellationToken.IsCancellationRequested)
        {
            throw new TaskCanceledException();
        }
        return content.ReadAsStreamAsync();
    }
    /*TranscodingReadStream*/ static GetTranscodingStream(/*Stream*/ contentStream, /*Encoding*/ sourceEncoding)
    {
        return new TranscodingReadStream(contentStream, sourceEncoding);
    }
}



class System_Net_Http_Json_JsonContent extends System_Net_Http_HttpContent
{
    /*JsonTypeInfo*/ _typeInfo = null;
    /*Type*/ get ObjectType()
    {
        return _typeInfo.Type;
    }
    /*object*/ _backingField_Value = null;
    /*object*/ get Value()
    {
        return _backingField_Value;
    }
    constructor(/*object*/ inputValue, /*JsonTypeInfo*/ jsonTypeInfo, /*MediaTypeHeaderValue*/ mediaType)
    {
        super();
        Debug.Assert((jsonTypeInfo));
        Debug.Assert(inputValue || jsonTypeInfo.Type.IsAssignableFrom(inputValue.GetType()));
        Value = inputValue;
        _typeInfo = jsonTypeInfo;
        if ((mediaType))
        {
            Headers.ContentType  = mediaType;
        }
        else 
        {
            Headers.TryAddWithoutValidation("Content-Type", JsonHelpers.DefaultMediaType);
        }
    }
    /*JsonContent*/ static Create(T, /*T*/ inputValue, { /*MediaTypeHeaderValue*/ mediaType = null, /*JsonSerializerOptions*/ options = null})
    {
        return Create(inputValue, JsonHelpers.GetJsonTypeInfo(T, options), mediaType);
    }
    /*JsonContent*/ static Create(/*object*/ inputValue, /*Type*/ inputType, { /*MediaTypeHeaderValue*/ mediaType = null, /*JsonSerializerOptions*/ options = null})
    {
        if (inputType === null)
        throw new ArgumentNullException(nameof(inputType));
        EnsureTypeCompatibility(inputValue, inputType);
        return new JsonContent(inputValue, JsonHelpers.GetJsonTypeInfo(inputType, options), mediaType);
    }
    /*JsonContent*/ static Create(T, /*T*/ inputValue, /*JsonTypeInfo<T>*/ jsonTypeInfo, { /*MediaTypeHeaderValue*/ mediaType = null})
    {
        if (jsonTypeInfo === null)
        throw new ArgumentNullException(nameof(jsonTypeInfo));
        return new JsonContent(inputValue, jsonTypeInfo, mediaType);
    }
    /*JsonContent*/ static Create(/*object*/ inputValue, /*JsonTypeInfo*/ jsonTypeInfo, { /*MediaTypeHeaderValue*/ mediaType = null})
    {
        if (jsonTypeInfo === null)
        throw new ArgumentNullException(nameof(jsonTypeInfo));
        EnsureTypeCompatibility(inputValue, jsonTypeInfo.Type);
        return new JsonContent(inputValue, jsonTypeInfo, mediaType);
    }
    /*Task*/ SerializeToStreamAsync(/*Stream*/ stream)
    {
        return SerializeToStreamAsyncCore(stream, CancellationToken.None);
    }
    /*bool*/ TryComputeLength(/*out long*/ length)
    {
        length = 0;
        return false;
    }
    /*Task*/ SerializeToStreamAsyncCore(/*Stream*/ targetStream, /*CancellationToken*/ cancellationToken)
    {
        /*Encoding*/ let targetEncoding = JsonHelpers.GetEncoding(this);
        return targetEncoding !== null && targetEncoding !== Encoding.UTF8  ? SerializeToStreamAsyncTranscoding(targetStream, targetEncoding, cancellationToken, { async : true }) : JsonSerializer.SerializeAsync(targetStream, Value, _typeInfo, cancellationToken);
    }
    /*Task*/ async SerializeToStreamAsyncTranscoding(/*Stream*/ targetStream, /*bool*/ async, /*Encoding*/ targetEncoding, /*CancellationToken*/ cancellationToken)
    {
        Debug.Assert(async, "HttpContent synchronous serialization is only supported since .NET 5.0");
        const transcodingStream = null
        try
        {
            /*TranscodingWriteStream*/ let transcodingStream = new TranscodingWriteStream(targetStream, targetEncoding);
            await JsonSerializer.SerializeAsync(transcodingStream, Value, _typeInfo, cancellationToken);
            await transcodingStream.FinalWriteAsync(cancellationToken);
        }
        finally
        {
            transcodingStream?.Dispose();
        }
    }
    /*void*/ static EnsureTypeCompatibility(/*object*/ inputValue, /*Type*/ inputType)
    {
        if ((inputValue) && inputType.IsAssignableFrom(inputValue.GetType()))
        {
            throw new ArgumentException("SerializeWrongType");
        }
    }
}


static class System_Net_Http_Json_JsonHelpers
{
    /*JsonTypeInfo*/ static GetJsonTypeInfo(/*Type*/ type, /*JsonSerializerOptions*/ options)
    {
        Debug.Assert((type));
        return new JsonTypeInfo(type);
    }
    /*string*/ DefaultMediaType = "application/json; charset=utf-8";
    /*Encoding*/ static GetEncoding(/*HttpContent*/ content)
    {
        /*Encoding*/ let encoding = null;
        if (content.Headers.ContentType?.CharSet instanceof string)
        {
            try
            {
                if (charset.Length  > 2 && charset[0] === '\"' && charset[charset.Length  - 1] === '\"')
                {
                    encoding = Encoding.GetEncoding(charset.Substring(1, charset.Length  - 2));
                }
                else 
                {
                    encoding = Encoding.GetEncoding(charset);
                }
            }
            catch(e)
            {
                throw new InvalidOperationException("CharSetInvalid", e);
            }
            Debug.Assert(encoding !== null);
        }
        return encoding;
    }
}

class System_Net_Http_Json_LengthLimitReadStream extends System_IO_AsyncStream
{
    /*Stream*/ _innerStream = null;
    /*int*/ _lengthLimit = null;
    /*int*/ _remainingLength = null;
    constructor(/*Stream*/ innerStream, /*int*/ lengthLimit)
    {
        super();
        _innerStream = innerStream;
        _lengthLimit = _remainingLength = lengthLimit;
    }
    /*void*/ CheckLengthLimit(/*int*/ read)
    {
        _remainingLength -= read;
        if (_remainingLength < 0)
        {
            ThrowExceededBufferLimit(_lengthLimit);
        }
    }
    /*void*/ static ThrowExceededBufferLimit(/*int*/ limit)
    {
        throw new HttpRequestException("net_http_content_buffersize_exceeded");
    }
    /*bool*/ get CanRead()
    {
        return _innerStream.CanRead;
    }
    /*bool*/ get CanSeek()
    {
        return _innerStream.CanSeek;
    }
    /*bool*/ get CanWrite()
    {
        return false;
    }
    /*Task<int>*/ async ReadAsync(/*Span<byte>*/ buffer, /*CancellationToken*/ cancellationToken)
    {
        /*int*/ let read = await _innerStream.ReadAsync(buffer, cancellationToken);
        CheckLengthLimit(read);
        return read;
    }
    /*int*/ Read(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count)
    {
        /*int*/ let read = _innerStream.Read(buffer, offset, count);
        CheckLengthLimit(read);
        return read;
    }
    /*void*/ Flush()
    {
        return _innerStream.Flush();
    }
    /*Task*/ FlushAsync(/*CancellationToken*/ cancellationToken)
    {
        _innerStream.Flush();
        return Task.CompletedTask;
    }
    /*long*/ Seek(/*long*/ offset, /*SeekOrigin*/ origin)
    {
        return _innerStream.Seek(offset, origin);
    }
    /*void*/ SetLength(/*long*/ value)
    {
        return _innerStream.SetLength(value);
    }
    /*long*/ get Length()
    {
        return _innerStream.Length;
    }
    /*long*/ get Position()
    {
        return _innerStream.Position;
    }
    /*long*/ set Position(value)
    {
        _innerStream.Position  = value;
    }
    /*void*/ Write(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count)
    {
        throw new NotSupportedException();
    }
    /*Task<int>*/ WriteAsync(/*ReadOnlySpan<byte>*/ buffer, /*CancellationToken*/ cancellationToken)
    {
        throw new NotImplementedException();
    }
}

class System_Net_Http_Json_TranscodingReadStream extends System_IO_AsyncStream
{
    /*int*/ static OverflowBufferSize = Encoding.UTF8.GetMaxByteCount(1);
    /*int*/ MaxByteBufferSize = 4096;
    /*Stream*/ _stream = null;
    /*Decoder*/ _decoder = null;
    /*Encoder*/ _encoder = null;
    /*Span<byte>*/ _byteBuffer = null;
    /*Span<char>*/ _charBuffer = null;
    /*Span<byte>*/ _overflowBuffer = null;
    /*bool*/ _disposed = null;
    constructor(/*Stream*/ input, /*Encoding*/ sourceEncoding)
    {
        super();
        _stream = input;
        _byteBuffer = new Span(byte)(ArrayPool(byte).Shared.Rent(MaxByteBufferSize), 0, { length : 0 });
        /*// Attempt to allocate a char buffer than can tolerate the worst-case scenario for this
            // encoding. This would allow the byte -> char conversion to complete in a single call.
            // The conversion process is tolerant of char buffer that is not large enough to convert all the bytes at once.
            int*/ let maxCharBufferSize = sourceEncoding.GetMaxCharCount(MaxByteBufferSize);
        _charBuffer = new Span(char)(ArrayPool(char).Shared.Rent(maxCharBufferSize), 0, { length : 0 });
        _overflowBuffer = new Span(byte)(ArrayPool(byte).Shared.Rent(OverflowBufferSize), 0, { length : 0 });
        _decoder = sourceEncoding.GetDecoder();
        _encoder = Encoding.UTF8.GetEncoder();
    }
    /*bool*/ get CanRead()
    {
        return true;
    }
    /*bool*/ get CanSeek()
    {
        return false;
    }
    /*bool*/ get CanWrite()
    {
        return false;
    }
    /*long*/ get Length()
    {
        throw new NotSupportedException();
    }
    /*long*/ get Position()
    {
        throw new NotSupportedException();
    }
    /*long*/ set Position(value)
    {
        throw new NotSupportedException();
    }
    /*int*/ get ByteBufferCount()
    {
        return _byteBuffer.Count;
    }
    /*int*/ get CharBufferCount()
    {
        return _charBuffer.Count;
    }
    /*int*/ get OverflowCount()
    {
        return _overflowBuffer.Count;
    }
    /*int*/ Read(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count)
    {
        throw new NotSupportedException();
    }
    /*Task<int>*/ ReadAsync(/*Span<byte>*/ buffer, /*CancellationToken*/ cancellationToken)
    {
        return ReadAsyncCore(buffer, cancellationToken);
    }
    /*Task<int>*/ async ReadAsyncCore(/*Span<byte>*/ readBuffer, /*CancellationToken*/ cancellationToken)
    {
        let overFlowChars = null;
        let $ref1 = { set value(v){ overFlowChars = v } };
        let overflowBytes = null;
        let $ref3 = { set value(v){ overflowBytes = v } };
        let $ref4 = { set value(v){ _ = v } };
        if (readBuffer.Length  === 0)
        {
            return 0;
        }
        if (_overflowBuffer.Count  > 0)
        {
            /*int*/ let bytesToCopy = Math.Min(readBuffer.Length, _overflowBuffer.Count);
            _overflowBuffer.Slice(0, bytesToCopy).CopyTo(readBuffer);
            _overflowBuffer = _overflowBuffer.Slice(bytesToCopy);
            return bytesToCopy;
        }
        /*bool*/ let shouldFlushEncoder = false;
        if (_charBuffer.Count  === 0)
        {
            /*int*/ let bytesRead = await ReadInputChars(cancellationToken);
            shouldFlushEncoder = bytesRead === 0 && _byteBuffer.Count  === 0;
        }
        /*bool*/ let completed = false;
        /*int*/ let charsRead = BlazorJs.getDefault();
        /*int*/ let bytesWritten = BlazorJs.getDefault();
        if (readBuffer.Count  > OverflowBufferSize || _charBuffer.Count  === 0)
        {
            let $ref0 = { set value(v){ charsRead = v } };
            let $ref1 = { set value(v){ bytesWritten = v } };
            let $ref2 = { set value(v){ completed = v } };
            _encoder.Convert(_charBuffer.Array, _charBuffer.Offset, _charBuffer.Count, readBuffer.Array, readBuffer.Offset, readBuffer.Count, shouldFlushEncoder, $ref0, $ref1, $ref2);
        }
        _charBuffer = _charBuffer.Slice(charsRead);
        if (completed || bytesWritten > 0)
        {
            return bytesWritten;
        }
        _encoder.Convert(_charBuffer.Array, _charBuffer.Offset, _charBuffer.Count, _overflowBuffer.Array, 0, _overflowBuffer.Array.Length, shouldFlushEncoder, $ref1, $ref3, $ref4);
        Debug.Assert(overflowBytes > 0 && overFlowChars > 0, "We expect writes to the overflow buffer to always succeed since it is large enough to accommodate at least one char.");
        _charBuffer = _charBuffer.Slice(overFlowChars);
        Debug.Assert(readBuffer.Count  < overflowBytes);
        _overflowBuffer.Array.AsSpan(0, readBuffer.Count).CopyTo(readBuffer);
        Debug.Assert(_overflowBuffer.Array  !== null);
        _overflowBuffer = new Span(byte)(_overflowBuffer.Array, readBuffer.Count, overflowBytes - readBuffer.Count);
        Debug.Assert(_overflowBuffer.Count  > 0);
        return readBuffer.Count;
    }
    /*Task<int>*/ async ReadInputChars(/*CancellationToken*/ cancellationToken)
    {
        let bytesUsed = null;
        let $ref1 = { set value(v){ bytesUsed = v } };
        let charsUsed = null;
        let $ref3 = { set value(v){ charsUsed = v } };
        let $ref4 = { set value(v){ _ = v } };
        Debug.Assert(_byteBuffer.Array  !== null);
        Array.Copy(_byteBuffer.Array, _byteBuffer.Offset, _byteBuffer.Array, 0, _byteBuffer.Count);
        /*//Buffer.BlockCopy(_byteBuffer.Array, _byteBuffer.Offset, _byteBuffer.Array, 0, _byteBuffer.Count);

            int*/ let offset = _byteBuffer.Count;
        /*int*/ let count = _byteBuffer.Array.Length  - _byteBuffer.Count;
        /*int*/ let bytesRead = await _stream.ReadAsync(_byteBuffer.Array, offset, count, cancellationToken);
        _byteBuffer = new Span(byte)(_byteBuffer.Array, 0, offset + bytesRead);
        Debug.Assert(_byteBuffer.Array  !== null);
        Debug.Assert(_charBuffer.Array  !== null);
        Debug.Assert(_charBuffer.Count  === 0, "We should only expect to read more input chars once all buffered content is read");
        _decoder.Convert(_byteBuffer.Array, _byteBuffer.Offset, _byteBuffer.Count, _charBuffer.Array, 0, _charBuffer.Array.Length, bytesRead === 0, $ref1, $ref3, $ref4);
        Debug.Assert(bytesRead !== 0 || _byteBuffer.Count  - bytesUsed === 0);
        _byteBuffer = _byteBuffer.Slice(bytesUsed);
        _charBuffer = new Span(char)(_charBuffer.Array, 0, charsUsed);
        return bytesRead;
    }
    /*void*/ Flush()
    {
        throw new NotSupportedException();
    }
    /*long*/ Seek(/*long*/ offset, /*SeekOrigin*/ origin)
    {
        throw new NotSupportedException();
    }
    /*void*/ SetLength(/*long*/ value)
    {
        throw new NotSupportedException();
    }
    /*void*/ Write(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count)
    {
        throw new NotSupportedException();
    }
    /*void*/ Dispose(/*bool*/ disposing)
    {
        if (_disposed)
        {
            _disposed = true;
            /*char[]*/ let charBuffer = _charBuffer.Array;
            Debug.Assert(charBuffer !== null);
            _charBuffer = BlazorJs.getDefault();
            ArrayPool(char).Shared.Return(charBuffer);
            /*byte[]*/ let byteBuffer = _byteBuffer.Array;
            Debug.Assert(byteBuffer !== null);
            _byteBuffer = BlazorJs.getDefault();
            ArrayPool(byte).Shared.Return(byteBuffer);
            /*byte[]*/ let overflowBuffer = _overflowBuffer.Array;
            Debug.Assert(overflowBuffer !== null);
            _overflowBuffer = BlazorJs.getDefault();
            ArrayPool(byte).Shared.Return(overflowBuffer);
            _stream.Dispose();
        }
    }
    /*Task<int>*/ WriteAsync(/*ReadOnlySpan<byte>*/ buffer, /*CancellationToken*/ cancellationToken)
    {
        throw new NotImplementedException();
    }
}

class System_Net_Http_Json_TranscodingWriteStream extends System_IO_AsyncStream
{
    /*int*/ MaxCharBufferSize = 4096;
    /*int*/ MaxByteBufferSize = 4 * MaxCharBufferSize;
    /*int*/ _maxByteBufferSize = null;
    /*Stream*/ _stream = null;
    /*Decoder*/ _decoder = null;
    /*Encoder*/ _encoder = null;
    /*char[]*/ _charBuffer = null;
    /*int*/ _charsDecoded = null;
    /*bool*/ _disposed = null;
    constructor(/*Stream*/ stream, /*Encoding*/ targetEncoding)
    {
        super();
        _stream = stream;
        _charBuffer = ArrayPool(char).Shared.Rent(MaxCharBufferSize);
        _maxByteBufferSize = Math.Min(MaxByteBufferSize, targetEncoding.GetMaxByteCount(MaxCharBufferSize));
        _decoder = Encoding.UTF8.GetDecoder();
        _encoder = targetEncoding.GetEncoder();
    }
    /*bool*/ get CanRead()
    {
        return false;
    }
    /*bool*/ get CanSeek()
    {
        return false;
    }
    /*bool*/ get CanWrite()
    {
        return true;
    }
    /*long*/ get Length()
    {
        throw new NotSupportedException();
    }
    /*long*/ _backingField_Position = null;
    /*long*/ get Position()
    {
        return _backingField_Position;
    }
    /*long*/ set Position(value)
    {
        _backingField_Position = value;
    }
    /*void*/ Flush()
    {
        throw new NotSupportedException();
    }
    /*Task*/ FlushAsync(/*CancellationToken*/ cancellationToken)
    {
        _stream.Flush();
        return Task.CompletedTask;
    }
    /*int*/ Read(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count)
    {
        throw new NotSupportedException();
    }
    /*long*/ Seek(/*long*/ offset, /*SeekOrigin*/ origin)
    {
        throw new NotSupportedException();
    }
    /*void*/ SetLength(/*long*/ value)
    {
        throw new NotSupportedException();
    }
    /*void*/ Write(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count)
    {
        throw new NotSupportedException();
    }
    /*Task<int>*/ WriteAsync(/*ReadOnlySpan<byte>*/ buffer, /*CancellationToken*/ cancellationToken)
    {
        return WriteAsyncCore(buffer, cancellationToken);
    }
    /*Task<int>*/ async WriteAsyncCore(/*ReadOnlySpan<byte>*/ bufferSegment, /*CancellationToken*/ cancellationToken)
    {
        /*bool*/ let decoderCompleted = false;
        /*int*/ let len = 0;
        while(decoderCompleted)
        {
            let bytesDecoded = null;
            let $ref1 = { set value(v){ bytesDecoded = v } };
            let charsDecoded = null;
            let $ref3 = { set value(v){ charsDecoded = v } };
            let $ref4 = { set value(v){ decoderCompleted = v } };
            _decoder.Convert(bufferSegment.ToArray(), 0, bufferSegment.Length, _charBuffer, _charsDecoded, _charBuffer.Length  - _charsDecoded, false, $ref1, $ref3, $ref4);
            len += bytesDecoded;
            _charsDecoded += charsDecoded;
            bufferSegment = bufferSegment.Slice(bytesDecoded);
            await WriteBufferAsync(cancellationToken);
        }
        return len;
    }
    /*Task*/ async WriteBufferAsync(/*CancellationToken*/ cancellationToken)
    {
        /*bool*/ let encoderCompleted = false;
        /*int*/ let charsWritten = 0;
        /*byte[]*/ let byteBuffer = ArrayPool(byte).Shared.Rent(_maxByteBufferSize);
        while(encoderCompleted && charsWritten < _charsDecoded)
        {
            let charsEncoded = null;
            let $ref1 = { set value(v){ charsEncoded = v } };
            let bytesUsed = null;
            let $ref3 = { set value(v){ bytesUsed = v } };
            let $ref4 = { set value(v){ encoderCompleted = v } };
            _encoder.Convert(_charBuffer, charsWritten, _charsDecoded - charsWritten, byteBuffer, 0, byteBuffer.Length, false, $ref1, $ref3, $ref4);
            await _stream.WriteAsync(byteBuffer, 0, bytesUsed, cancellationToken);
            charsWritten += charsEncoded;
        }
        ArrayPool(byte).Shared.Return(byteBuffer);
        _charsDecoded = 0;
    }
    /*void*/ Dispose(/*bool*/ disposing)
    {
        if (_disposed)
        {
            _disposed = true;
            /*char[]*/ let toReturn = _charBuffer;
            _charBuffer = null;
            ArrayPool(char).Shared.Return(toReturn);
        }
    }
    /*Task*/ async FinalWriteAsync(/*CancellationToken*/ cancellationToken)
    {
        /*// Flush the encoder.
            byte[]*/ let byteBuffer = ArrayPool(byte).Shared.Rent(_maxByteBufferSize);
        /*bool*/ let encoderCompleted = false;
        while(encoderCompleted)
        {
            let $ref0 = { set value(v){ _ = v } };
            let bytesUsed = null;
            let $ref2 = { set value(v){ bytesUsed = v } };
            let $ref3 = { set value(v){ encoderCompleted = v } };
            _encoder.Convert(Array.Empty(char), 0, 0, byteBuffer, 0, byteBuffer.Length, true, $ref0, $ref2, $ref3);
            await _stream.WriteAsync(byteBuffer, 0, bytesUsed, cancellationToken);
        }
        ArrayPool(byte).Shared.Return(byteBuffer);
    }
    /*Task<int>*/ ReadAsync(/*Span<byte>*/ buffer, /*CancellationToken*/ cancellationToken)
    {
        throw new NotImplementedException();
    }
}

const System_Numerics_IParsable = (T, Base) => class extends Base
{
}

static class System_Reflection_AssemblyExtension
{
    static System_Reflection_AssemblyExtension_AssemblyName = class extends object
    {
        constructor()
        {
            super();
        }
        /*string*/ _backingField_Name = null;
        /*string*/ get Name()
        {
            return _backingField_Name;
        }
        /*string*/ set Name(value)
        {
            _backingField_Name = value;
        }
    }
    /*AssemblyName*/ static GetName(/*this Assembly*/ assembly)
    {
        return BlazorJs.PopulateProperty(new AssemblyName(), function(/*AssemblyName*/ $obj)
        {
            $obj.Name = assembly.FullName ;
        });
    }
    /*Stream*/ static GetManifestResourceStream(/*this Assembly*/ assembly, /*string*/ name)
    {
        return Stream.Null;
    }
}

static class System_Reflection_AttributeExtension
{
    /*IEnumerable<T>*/ static GetCustomAttributes(T, /*this Type*/ t, /*bool*/ inherit)
    {
        return Enumerable.Cast(T, t.GetCustomAttributes(T, inherit));
    }
    /*IEnumerable<T>*/ static GetCustomAttributes(T, /*this MethodInfo*/ t, /*bool*/ inherit)
    {
        return Enumerable.Cast(T, t.GetCustomAttributes(T, inherit));
    }
}

const System_Runtime_CompilerServices_ConditionalWeakTable = (TKey, TValue) => class extends System_Collections_Generic_Dictionary(TKey, TValue)(TKey, TValue)
{
    constructor()
    {
        super();
    }
}

class System_Runtime_CompilerServices_IsExternalInit extends object
{
    constructor()
    {
        super();
    }
}

class System_Runtime_CompilerServices_RequiredMemberAttribute extends System_Attribute
{
    constructor()
    {
        super();
    }
}

static class Microsoft_AspNetCore_Components_CompilerServices_RuntimeHelpers
{
    /*T*/ static TypeCheck(T, /*T*/ t)
    {
        return t;
    }
}

class System_Security_Claims_Claim extends object
{
    static System_Security_Claims_Claim_SerializationMask = class
    {
        None = 0;
        NameClaimType = 1;
        RoleClaimType = 2;
        StringType = 4;
        Issuer = 8;
        OriginalIssuerEqualsIssuer = 16;
        OriginalIssuer = 32;
        HasProperties = 64;
        UserData = 128;
    }
    /*byte[]*/ _userSerializationData = null;
    /*string*/ _issuer = null;
    /*string*/ _originalIssuer = null;
    /*Dictionary<string, string>*/ _properties = null;
    /*ClaimsIdentity*/ _subject = null;
    /*string*/ _type = null;
    /*string*/ _value = null;
    /*string*/ _valueType = null;
    constructor(/*BinaryReader*/ reader)
    {
        super(reader, null);
    }
    constructor(/*BinaryReader*/ reader, /*ClaimsIdentity*/ subject)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(reader);
        _subject = subject;
        /*SerializationMask*/ let mask = BlazorJs.Cast(reader.ReadInt32(), SerializationMask);
        /*int*/ let numPropertiesRead = 1;
        /*int*/ let numPropertiesToRead = reader.ReadInt32();
        _value = reader.ReadString();
        if ((mask & SerializationMask.NameClaimType) === SerializationMask.NameClaimType)
        {
            _type = ClaimsIdentity.DefaultNameClaimType;
        }
        else if ((mask & SerializationMask.RoleClaimType) === SerializationMask.RoleClaimType)
        {
            _type = ClaimsIdentity.DefaultRoleClaimType;
        }
        else 
        {
            _type = reader.ReadString();
            numPropertiesRead++;
        }
        if ((mask & SerializationMask.StringType) === SerializationMask.StringType)
        {
            _valueType = reader.ReadString();
            numPropertiesRead++;
        }
        else 
        {
            _valueType = ClaimValueTypes.String;
        }
        if ((mask & SerializationMask.Issuer) === SerializationMask.Issuer)
        {
            _issuer = reader.ReadString();
            numPropertiesRead++;
        }
        else 
        {
            _issuer = ClaimsIdentity.DefaultIssuer;
        }
        if ((mask & SerializationMask.OriginalIssuerEqualsIssuer) === SerializationMask.OriginalIssuerEqualsIssuer)
        {
            _originalIssuer = _issuer;
        }
        else if ((mask & SerializationMask.OriginalIssuer) === SerializationMask.OriginalIssuer)
        {
            _originalIssuer = reader.ReadString();
            numPropertiesRead++;
        }
        else 
        {
            _originalIssuer = ClaimsIdentity.DefaultIssuer;
        }
        if ((mask & SerializationMask.HasProperties) === SerializationMask.HasProperties)
        {
            /*int*/ let numProperties = reader.ReadInt32();
            numPropertiesRead++;
            for(/*int*/ let i = 0; i < numProperties; i++)
            {
                Properties.Add(reader.ReadString(), reader.ReadString());
            }
        }
        if ((mask & SerializationMask.UserData) === SerializationMask.UserData)
        {
            /*int*/ let cb = reader.ReadInt32();
            _userSerializationData = reader.ReadBytes(cb);
            numPropertiesRead++;
        }
        for(/*int*/ let i = numPropertiesRead; i < numPropertiesToRead; i++)
        {
            reader.ReadString();
        }
    }
    constructor(/*string*/ type, /*string*/ value)
    {
        super(type, value, ClaimValueTypes.String, ClaimsIdentity.DefaultIssuer, ClaimsIdentity.DefaultIssuer, BlazorJs.Cast(null, ClaimsIdentity));
    }
    constructor(/*string*/ type, /*string*/ value, /*string*/ valueType)
    {
        super(type, value, valueType, ClaimsIdentity.DefaultIssuer, ClaimsIdentity.DefaultIssuer, BlazorJs.Cast(null, ClaimsIdentity));
    }
    constructor(/*string*/ type, /*string*/ value, /*string*/ valueType, /*string*/ issuer)
    {
        super(type, value, valueType, issuer, issuer, BlazorJs.Cast(null, ClaimsIdentity));
    }
    constructor(/*string*/ type, /*string*/ value, /*string*/ valueType, /*string*/ issuer, /*string*/ originalIssuer)
    {
        super(type, value, valueType, issuer, originalIssuer, BlazorJs.Cast(null, ClaimsIdentity));
    }
    constructor(/*string*/ type, /*string*/ value, /*string*/ valueType, /*string*/ issuer, /*string*/ originalIssuer, /*ClaimsIdentity*/ subject)
    {
        super(type, value, valueType, issuer, originalIssuer, subject, null, null);
    }
    constructor(/*string*/ type, /*string*/ value, /*string*/ valueType, /*string*/ issuer, /*string*/ originalIssuer, /*ClaimsIdentity*/ subject, /*string*/ propertyKey, /*string*/ propertyValue)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(type);
        ArgumentNullExceptionExtension.ThrowIfNull(value);
        _type = type;
        _value = value;
        _valueType = string.IsNullOrEmpty(valueType) ? ClaimValueTypes.String  : valueType;
        _issuer = string.IsNullOrEmpty(issuer) ? ClaimsIdentity.DefaultIssuer  : issuer;
        _originalIssuer = string.IsNullOrEmpty(originalIssuer) ? _issuer : originalIssuer;
        _subject = subject;
        if (propertyKey !== null)
        {
            _properties = new Dictionary(string, string)();
            _properties[propertyKey] = propertyValue;
        }
    }
    constructor(/*Claim*/ other)
    {
        super(other, (other === null ? BlazorJs.Cast(null, ClaimsIdentity) : other._subject));
    }
    constructor(/*Claim*/ other, /*ClaimsIdentity*/ subject)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(other);
        _issuer = other._issuer;
        _originalIssuer = other._originalIssuer;
        _subject = subject;
        _type = other._type;
        _value = other._value;
        _valueType = other._valueType;
        if (other._properties  !== null)
        {
            _properties = new Dictionary(string, string)(other._properties);
        }
        if (other._userSerializationData  !== null)
        {
            _userSerializationData = BlazorJs.As(other._userSerializationData.Clone(), byte);
        }
    }
    /*byte[]*/ get CustomSerializationData()
    {
        return _userSerializationData;
    }
    /*string*/ get Issuer()
    {
        return _issuer;
    }
    /*string*/ get OriginalIssuer()
    {
        return _originalIssuer;
    }
    /*IDictionary<string, string>*/ get Properties()
    {
        return _properties = _properties ?? new Dictionary(string, string)();
    }
    /*ClaimsIdentity*/ get Subject()
    {
        return _subject;
    }
    /*string*/ get Type()
    {
        return _type;
    }
    /*string*/ get Value()
    {
        return _value;
    }
    /*string*/ get ValueType()
    {
        return _valueType;
    }
    /*Claim*/ Clone()
    {
        return Clone(BlazorJs.Cast(null, ClaimsIdentity));
    }
    /*Claim*/ Clone(/*ClaimsIdentity*/ identity)
    {
        return new Claim(this, identity);
    }
    /*void*/ WriteTo(/*BinaryWriter*/ writer)
    {
        WriteTo(writer, null);
    }
    /*void*/ WriteTo(/*BinaryWriter*/ writer, /*byte[]*/ userData)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(writer);
        /*int*/ let numberOfPropertiesWritten = 1;
        /*SerializationMask*/ let mask = SerializationMask.None;
        if (string.Equals(_type, ClaimsIdentity.DefaultNameClaimType))
        {
            mask |= SerializationMask.NameClaimType;
        }
        else if (string.Equals(_type, ClaimsIdentity.DefaultRoleClaimType))
        {
            mask |= SerializationMask.RoleClaimType;
        }
        else 
        {
            numberOfPropertiesWritten++;
        }
        if (string.Equals(_valueType, ClaimValueTypes.String, StringComparison.Ordinal))
        {
            numberOfPropertiesWritten++;
            mask |= SerializationMask.StringType;
        }
        if (string.Equals(_issuer, ClaimsIdentity.DefaultIssuer, StringComparison.Ordinal))
        {
            numberOfPropertiesWritten++;
            mask |= SerializationMask.Issuer;
        }
        if (string.Equals(_originalIssuer, _issuer, StringComparison.Ordinal))
        {
            mask |= SerializationMask.OriginalIssuerEqualsIssuer;
        }
        else if (string.Equals(_originalIssuer, ClaimsIdentity.DefaultIssuer))
        {
            numberOfPropertiesWritten++;
            mask |= SerializationMask.OriginalIssuer;
        }
        if (_properties !== null && _properties.Count  > 0)
        {
            numberOfPropertiesWritten++;
            mask |= SerializationMask.HasProperties;
        }
        if (userData !== null && userData.Length  > 0)
        {
            numberOfPropertiesWritten++;
            mask |= SerializationMask.UserData;
        }
        writer.Write(BlazorJs.Cast(mask, int));
        writer.Write(numberOfPropertiesWritten);
        writer.Write(_value);
        if (((mask & SerializationMask.NameClaimType) !== SerializationMask.NameClaimType) && ((mask & SerializationMask.RoleClaimType) !== SerializationMask.RoleClaimType))
        {
            writer.Write(_type);
        }
        if ((mask & SerializationMask.StringType) === SerializationMask.StringType)
        {
            writer.Write(_valueType);
        }
        if ((mask & SerializationMask.Issuer) === SerializationMask.Issuer)
        {
            writer.Write(_issuer);
        }
        if ((mask & SerializationMask.OriginalIssuer) === SerializationMask.OriginalIssuer)
        {
            writer.Write(_originalIssuer);
        }
        if ((mask & SerializationMask.HasProperties) === SerializationMask.HasProperties)
        {
            writer.Write(_properties.Count);
            BlazorJs.forEach(_properties, function(kvp, $_i)
            {
                writer.Write(kvp.Key);
                writer.Write(kvp.Value);
            });
        }
        if ((mask & SerializationMask.UserData) === SerializationMask.UserData)
        {
            writer.Write(userData.Length);
            writer.Write(userData);
        }
        writer.Flush();
    }
    /*string*/ ToString()
    {
        return _type + ": " + _value;
    }
}

class System_Security_Claims_ClaimsIdentity extends System_Security_Principal_IIdentity(object)
{
    static System_Security_Claims_ClaimsIdentity_SerializationMask = class
    {
        None = 0;
        AuthenticationType = 1;
        BootstrapConext = 2;
        NameClaimType = 4;
        RoleClaimType = 8;
        HasClaims = 16;
        HasLabel = 32;
        Actor = 64;
        UserData = 128;
    }
    /*byte[]*/ _userSerializationData = null;
    /*ClaimsIdentity*/ _actor = null;
    /*string*/ _authenticationType = null;
    /*object*/ _bootstrapContext = null;
    /*List<List<Claim>>*/ _externalClaims = null;
    /*string*/ _label = null;
    /*List<Claim>*/ _instanceClaims = new List(Claim)();
    /*string*/ _nameClaimType = DefaultNameClaimType;
    /*string*/ _roleClaimType = DefaultRoleClaimType;
    /*string*/ DefaultIssuer = "LOCAL AUTHORITY";
    /*string*/ DefaultNameClaimType = ClaimTypes.Name;
    /*string*/ DefaultRoleClaimType = ClaimTypes.Role;
    constructor()
    {
        super(BlazorJs.Cast(null, IIdentity), BlazorJs.Cast(null, IEnumerable(Claim)), BlazorJs.Cast(null, string), BlazorJs.Cast(null, string), BlazorJs.Cast(null, string));
    }
    constructor(/*IIdentity*/ identity)
    {
        super(identity, BlazorJs.Cast(null, IEnumerable(Claim)), BlazorJs.Cast(null, string), BlazorJs.Cast(null, string), BlazorJs.Cast(null, string));
    }
    constructor(/*IEnumerable<Claim>*/ claims)
    {
        super(BlazorJs.Cast(null, IIdentity), claims, BlazorJs.Cast(null, string), BlazorJs.Cast(null, string), BlazorJs.Cast(null, string));
    }
    constructor(/*string*/ authenticationType)
    {
        super(BlazorJs.Cast(null, IIdentity), BlazorJs.Cast(null, IEnumerable(Claim)), authenticationType, BlazorJs.Cast(null, string), BlazorJs.Cast(null, string));
    }
    constructor(/*IEnumerable<Claim>*/ claims, /*string*/ authenticationType)
    {
        super(BlazorJs.Cast(null, IIdentity), claims, authenticationType, BlazorJs.Cast(null, string), BlazorJs.Cast(null, string));
    }
    constructor(/*IIdentity*/ identity, /*IEnumerable<Claim>*/ claims)
    {
        super(identity, claims, BlazorJs.Cast(null, string), BlazorJs.Cast(null, string), BlazorJs.Cast(null, string));
    }
    constructor(/*string*/ authenticationType, /*string*/ nameType, /*string*/ roleType)
    {
        super(BlazorJs.Cast(null, IIdentity), BlazorJs.Cast(null, IEnumerable(Claim)), authenticationType, nameType, roleType);
    }
    constructor(/*IEnumerable<Claim>*/ claims, /*string*/ authenticationType, /*string*/ nameType, /*string*/ roleType)
    {
        super(BlazorJs.Cast(null, IIdentity), claims, authenticationType, nameType, roleType);
    }
    constructor(/*IIdentity*/ identity, /*IEnumerable<Claim>*/ claims, /*string*/ authenticationType, /*string*/ nameType, /*string*/ roleType)
    {
        super();
        /*ClaimsIdentity*/ let claimsIdentity = BlazorJs.As(identity, ClaimsIdentity);
        _authenticationType = (identity !== null && string.IsNullOrEmpty(authenticationType)) ? identity.AuthenticationType  : authenticationType;
        _nameClaimType = string.IsNullOrEmpty(nameType) ? nameType : (claimsIdentity !== null ? claimsIdentity._nameClaimType  : DefaultNameClaimType);
        _roleClaimType = string.IsNullOrEmpty(roleType) ? roleType : (claimsIdentity !== null ? claimsIdentity._roleClaimType  : DefaultRoleClaimType);
        if (claimsIdentity !== null)
        {
            _label = claimsIdentity._label;
            _bootstrapContext = claimsIdentity._bootstrapContext;
            if (claimsIdentity.Actor  !== null)
            {
                if (IsCircular(claimsIdentity.Actor))
                {
                    _actor = claimsIdentity.Actor;
                }
                else 
                {
                    throw new InvalidOperationException("ActorGraphCircular");
                }
            }
            SafeAddClaims(claimsIdentity._instanceClaims);
        }
        else 
        {
            if (identity !== null && string.IsNullOrEmpty(identity.Name))
            {
                SafeAddClaim(new Claim(_nameClaimType, identity.Name, ClaimValueTypes.String, DefaultIssuer, DefaultIssuer, this));
            }
        }
        if (claims !== null)
        {
            SafeAddClaims(claims);
        }
    }
    constructor(/*BinaryReader*/ reader)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(reader);
        Initialize(reader);
    }
    constructor(/*ClaimsIdentity*/ other)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(other);
        if (other._actor  !== null)
        {
            _actor = other._actor.Clone();
        }
        _authenticationType = other._authenticationType;
        _bootstrapContext = other._bootstrapContext;
        _label = other._label;
        _nameClaimType = other._nameClaimType;
        _roleClaimType = other._roleClaimType;
        if (other._userSerializationData  !== null)
        {
            _userSerializationData = BlazorJs.As(other._userSerializationData.Clone(), byte);
        }
        SafeAddClaims(other._instanceClaims);
    }
    /*string*/ get AuthenticationType()
    {
        return _authenticationType;
    }
    /*bool*/ get IsAuthenticated()
    {
        return string.IsNullOrEmpty(_authenticationType);
    }
    /*ClaimsIdentity*/ get Actor()
    {
        return _actor;
    }
    /*ClaimsIdentity*/ set Actor(value)
    {
        if (value !== null)
        {
            if (IsCircular(value))
            {
                throw new InvalidOperationException("ActorGraphCircular");
            }
        }
        _actor = value;
    }
    /*object*/ get BootstrapContext()
    {
        return _bootstrapContext;
    }
    /*object*/ set BootstrapContext(value)
    {
        _bootstrapContext = value;
    }
    /*IEnumerable<Claim>*/ get Claims()
    {
        if (_externalClaims === null)
        {
            return _instanceClaims;
        }
        return CombinedClaimsIterator();
    }
    /*IEnumerable<Claim>*/ CombinedClaimsIterator()
    {
        for(/*int*/ let i = 0; i < _instanceClaims.Count; i++)
        {
_instanceClaims[i]        }
        for(/*int*/ let j = 0; j < _externalClaims.Count; j++)
        {
            if (_externalClaims[j] !== null)
            {
                BlazorJs.forEach(_externalClaims[j], function(claim, $_i)
                {
claim                });
            }
        }
    }
    /*byte[]*/ get CustomSerializationData()
    {
        return _userSerializationData;
    }
    /*List<List<Claim>>*/ get ExternalClaims()
    {
        return _externalClaims = _externalClaims ?? new List(List(Claim))();
    }
    /*string*/ get Label()
    {
        return _label;
    }
    /*string*/ set Label(value)
    {
        _label = value;
    }
    /*string*/ get Name()
    {
        /*Claim*/ let claim = FindFirst(_nameClaimType);
        if (claim !== null)
        {
            return claim.Value;
        }
        return null;
    }
    /*string*/ get NameClaimType()
    {
        return _nameClaimType;
    }
    /*string*/ get RoleClaimType()
    {
        return _roleClaimType;
    }
    /*ClaimsIdentity*/ Clone()
    {
        return new ClaimsIdentity(this);
    }
    /*void*/ AddClaim(/*Claim*/ claim)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(claim);
        if (object.ReferenceEquals(claim.Subject, this))
        {
            _instanceClaims.Add(claim);
        }
        else 
        {
            _instanceClaims.Add(claim.Clone(this));
        }
    }
    /*void*/ AddClaims(/*IEnumerable<Claim>*/ claims)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(claims);
        BlazorJs.forEach(claims, function(claim, $_i)
        {
            if (claim === null)
            {
            }
            if (object.ReferenceEquals(claim.Subject, this))
            {
                _instanceClaims.Add(claim);
            }
            else 
            {
                _instanceClaims.Add(claim.Clone(this));
            }
        });
    }
    /*bool*/ TryRemoveClaim(/*Claim*/ claim)
    {
        if (claim === null)
        {
            return false;
        }
        /*bool*/ let removed = false;
        for(/*int*/ let i = 0; i < _instanceClaims.Count; i++)
        {
            if (object.ReferenceEquals(_instanceClaims[i], claim))
            {
                _instanceClaims.RemoveAt(i);
                removed = true;
                break;
            }
        }
        return removed;
    }
    /*void*/ RemoveClaim(/*Claim*/ claim)
    {
        if (TryRemoveClaim(claim))
        {
            throw new InvalidOperationException("ClaimCannotBeRemoved");
        }
    }
    /*void*/ SafeAddClaims(/*IEnumerable<Claim>*/ claims)
    {
        BlazorJs.forEach(claims, function(claim, $_i)
        {
            if (claim === null)
            if (object.ReferenceEquals(claim.Subject, this))
            {
                _instanceClaims.Add(claim);
            }
            else 
            {
                _instanceClaims.Add(claim.Clone(this));
            }
        });
    }
    /*void*/ SafeAddClaim(/*Claim*/ claim)
    {
        if (claim === null)
        return ;
        if (object.ReferenceEquals(claim.Subject, this))
        {
            _instanceClaims.Add(claim);
        }
        else 
        {
            _instanceClaims.Add(claim.Clone(this));
        }
    }
    /*IEnumerable<Claim>*/ FindAll(/*Predicate<Claim>*/ match)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(match);
        return Core(match);
        /*IEnumerable<Claim>*/ function Core(/*Predicate<Claim>*/ match2)
        {
            BlazorJs.forEach(Claims, function(claim, $_i)
            {
                if (match2(claim))
                {
claim                }
            });
        }
    }
    /*IEnumerable<Claim>*/ FindAll(/*string*/ type)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(type);
        return Core(type);
        /*IEnumerable<Claim>*/ function Core(/*string*/ type2)
        {
            BlazorJs.forEach(Claims, function(claim, $_i)
            {
                if (claim !== null)
                {
                    if (string.Equals(claim.Type, type2, StringComparison.OrdinalIgnoreCase))
                    {
claim                    }
                }
            });
        }
    }
    /*Claim*/ FindFirst(/*Predicate<Claim>*/ match)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(match);
        BlazorJs.forEach(Claims, function(claim, $_i)
        {
            if (match(claim))
            {
                return claim;
            }
        });
        return null;
    }
    /*Claim*/ FindFirst(/*string*/ type)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(type);
        BlazorJs.forEach(Claims, function(claim, $_i)
        {
            if (claim !== null)
            {
                if (string.Equals(claim.Type, type, StringComparison.OrdinalIgnoreCase))
                {
                    return claim;
                }
            }
        });
        return null;
    }
    /*bool*/ HasClaim(/*Predicate<Claim>*/ match)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(match);
        BlazorJs.forEach(Claims, function(claim, $_i)
        {
            if (match(claim))
            {
                return true;
            }
        });
        return false;
    }
    /*bool*/ HasClaim(/*string*/ type, /*string*/ value)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(type);
        ArgumentNullExceptionExtension.ThrowIfNull(value);
        BlazorJs.forEach(Claims, function(claim, $_i)
        {
            if (claim !== null && string.Equals(claim.Type, type, StringComparison.OrdinalIgnoreCase) && string.Equals(claim.Value, value, StringComparison.Ordinal))
            {
                return true;
            }
        });
        return false;
    }
    /*void*/ Initialize(/*BinaryReader*/ reader)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(reader);
        /*SerializationMask*/ let mask = BlazorJs.Cast(reader.ReadInt32(), SerializationMask);
        /*int*/ let numPropertiesRead = 0;
        /*int*/ let numPropertiesToRead = reader.ReadInt32();
        if ((mask & SerializationMask.AuthenticationType) === SerializationMask.AuthenticationType)
        {
            _authenticationType = reader.ReadString();
            numPropertiesRead++;
        }
        if ((mask & SerializationMask.BootstrapConext) === SerializationMask.BootstrapConext)
        {
            _bootstrapContext = reader.ReadString();
            numPropertiesRead++;
        }
        if ((mask & SerializationMask.NameClaimType) === SerializationMask.NameClaimType)
        {
            _nameClaimType = reader.ReadString();
            numPropertiesRead++;
        }
        else 
        {
            _nameClaimType = ClaimsIdentity.DefaultNameClaimType;
        }
        if ((mask & SerializationMask.RoleClaimType) === SerializationMask.RoleClaimType)
        {
            _roleClaimType = reader.ReadString();
            numPropertiesRead++;
        }
        else 
        {
            _roleClaimType = ClaimsIdentity.DefaultRoleClaimType;
        }
        if ((mask & SerializationMask.HasLabel) === SerializationMask.HasLabel)
        {
            _label = reader.ReadString();
            numPropertiesRead++;
        }
        if ((mask & SerializationMask.HasClaims) === SerializationMask.HasClaims)
        {
            /*int*/ let numberOfClaims = reader.ReadInt32();
            for(/*int*/ let index = 0; index < numberOfClaims; index++)
            {
                _instanceClaims.Add(CreateClaim(reader));
            }
            numPropertiesRead++;
        }
        if ((mask & SerializationMask.Actor) === SerializationMask.Actor)
        {
            _actor = new ClaimsIdentity(reader);
            numPropertiesRead++;
        }
        if ((mask & SerializationMask.UserData) === SerializationMask.UserData)
        {
            /*int*/ let cb = reader.ReadInt32();
            _userSerializationData = reader.ReadBytes(cb);
            numPropertiesRead++;
        }
        for(/*int*/ let i = numPropertiesRead; i < numPropertiesToRead; i++)
        {
            reader.ReadString();
        }
    }
    /*Claim*/ CreateClaim(/*BinaryReader*/ reader)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(reader);
        return new Claim(reader, this);
    }
    /*void*/ WriteTo(/*BinaryWriter*/ writer)
    {
        WriteTo(writer, null);
    }
    /*void*/ WriteTo(/*BinaryWriter*/ writer, /*byte[]*/ userData)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(writer);
        /*int*/ let numberOfPropertiesWritten = 0;
        /*var*/ let mask = SerializationMask.None;
        if (_authenticationType !== null)
        {
            mask |= SerializationMask.AuthenticationType;
            numberOfPropertiesWritten++;
        }
        if (_bootstrapContext !== null)
        {
            if (_bootstrapContext instanceof string)
            {
                mask |= SerializationMask.BootstrapConext;
                numberOfPropertiesWritten++;
            }
        }
        if (string.Equals(_nameClaimType, ClaimsIdentity.DefaultNameClaimType, StringComparison.Ordinal))
        {
            mask |= SerializationMask.NameClaimType;
            numberOfPropertiesWritten++;
        }
        if (string.Equals(_roleClaimType, ClaimsIdentity.DefaultRoleClaimType, StringComparison.Ordinal))
        {
            mask |= SerializationMask.RoleClaimType;
            numberOfPropertiesWritten++;
        }
        if (string.IsNullOrWhiteSpace(_label))
        {
            mask |= SerializationMask.HasLabel;
            numberOfPropertiesWritten++;
        }
        if (_instanceClaims.Count  > 0)
        {
            mask |= SerializationMask.HasClaims;
            numberOfPropertiesWritten++;
        }
        if (_actor !== null)
        {
            mask |= SerializationMask.Actor;
            numberOfPropertiesWritten++;
        }
        if (userData !== null && userData.Length  > 0)
        {
            numberOfPropertiesWritten++;
            mask |= SerializationMask.UserData;
        }
        writer.Write(BlazorJs.Cast(mask, int));
        writer.Write(numberOfPropertiesWritten);
        if ((mask & SerializationMask.AuthenticationType) === SerializationMask.AuthenticationType)
        {
            writer.Write(_authenticationType);
        }
        if ((mask & SerializationMask.BootstrapConext) === SerializationMask.BootstrapConext)
        {
            writer.Write(BlazorJs.Cast(_bootstrapContext, string));
        }
        if ((mask & SerializationMask.NameClaimType) === SerializationMask.NameClaimType)
        {
            writer.Write(_nameClaimType);
        }
        if ((mask & SerializationMask.RoleClaimType) === SerializationMask.RoleClaimType)
        {
            writer.Write(_roleClaimType);
        }
        if ((mask & SerializationMask.HasLabel) === SerializationMask.HasLabel)
        {
            writer.Write(_label);
        }
        if ((mask & SerializationMask.HasClaims) === SerializationMask.HasClaims)
        {
            writer.Write(_instanceClaims.Count);
            BlazorJs.forEach(_instanceClaims, function(claim, $_i)
            {
                claim.WriteTo(writer);
            });
        }
        if ((mask & SerializationMask.Actor) === SerializationMask.Actor)
        {
            _actor.WriteTo(writer);
        }
        if ((mask & SerializationMask.UserData) === SerializationMask.UserData)
        {
            writer.Write(userData.Length);
            writer.Write(userData);
        }
        writer.Flush();
    }
    /*bool*/ IsCircular(/*ClaimsIdentity*/ subject)
    {
        if (ReferenceEquals(this, subject))
        {
            return true;
        }
        /*ClaimsIdentity*/ let currSubject = subject;
        while(currSubject.Actor  !== null)
        {
            if (ReferenceEquals(this, currSubject.Actor))
            {
                return true;
            }
            currSubject = currSubject.Actor;
        }
        return false;
    }
    /*string*/ DebuggerToString()
    {
        /*// DebuggerDisplayAttribute is inherited. Use virtual members instead of private fields to gather data.
            int*/ let claimsCount = 0;
        BlazorJs.forEach(Claims, function(item, $_i)
        {
            claimsCount++;
        });
        /*string*/ let debugText = `IsAuthenticated = ${(IsAuthenticated ? "true" : "false")}`;
        if (Name !== null)
        {
            debugText += `, Name = ${Name}`;
        }
        if (claimsCount > 0)
        {
            debugText += `, Claims = ${claimsCount}`;
        }
        return debugText;
    }
}

class System_Security_Claims_ClaimsPrincipal extends System_Security_Principal_IPrincipal(object)
{
    static System_Security_Claims_ClaimsPrincipal_SerializationMask = class
    {
        None = 0;
        HasIdentities = 1;
        UserData = 2
;
    }
    /*List<ClaimsIdentity>*/ _identities = new List(ClaimsIdentity)();
    /*byte[]*/ _userSerializationData = null;
    /*Func<IEnumerable<ClaimsIdentity>, ClaimsIdentity>*/ static s_identitySelector = SelectPrimaryIdentity;
    /*Func<ClaimsPrincipal>*/ static s_principalSelector = ClaimsPrincipalSelector;
    /*ClaimsPrincipal*/ static SelectClaimsPrincipal()
    {
        return new ClaimsPrincipal();
    }
    /*ClaimsIdentity*/ static SelectPrimaryIdentity(/*IEnumerable<ClaimsIdentity>*/ identities)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(identities);
        BlazorJs.forEach(identities, function(identity, $_i)
        {
            if (identity !== null)
            {
                return identity;
            }
        });
        return null;
    }
    /*Func<IEnumerable<ClaimsIdentity>, ClaimsIdentity>*/ static get PrimaryIdentitySelector()
    {
        return s_identitySelector;
    }
    /*Func<IEnumerable<ClaimsIdentity>, ClaimsIdentity>*/ static set PrimaryIdentitySelector(value)
    {
        s_identitySelector = value;
    }
    /*Func<ClaimsPrincipal>*/ static get ClaimsPrincipalSelector()
    {
        return s_principalSelector;
    }
    /*Func<ClaimsPrincipal>*/ static set ClaimsPrincipalSelector(value)
    {
        s_principalSelector = value;
    }
    constructor()
    {
        super();
    }
    constructor(/*IEnumerable<ClaimsIdentity>*/ identities)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(identities);
        _identities.AddRange(identities);
    }
    constructor(/*IIdentity*/ identity)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(identity);
        if (identity instanceof ClaimsIdentity, ci = identity)
        {
            _identities.Add(ci);
        }
        else 
        {
            _identities.Add(new ClaimsIdentity(identity));
        }
    }
    constructor(/*IPrincipal*/ principal)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(principal);
        /*//
            // If IPrincipal is a ClaimsPrincipal add all of the identities
            // If IPrincipal is not a ClaimsPrincipal, create a new identity from IPrincipal.Identity
            //
            ClaimsPrincipal*/ let cp = BlazorJs.As(principal, ClaimsPrincipal);
        if (null === cp)
        {
            _identities.Add(new ClaimsIdentity(principal.Identity));
        }
        else 
        {
            if (null !== cp.Identities)
            {
                _identities.AddRange(cp.Identities);
            }
        }
    }
    constructor(/*BinaryReader*/ reader)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(reader);
        /*SerializationMask*/ let mask = BlazorJs.Cast(reader.ReadInt32(), SerializationMask);
        /*int*/ let numPropertiesToRead = reader.ReadInt32();
        /*int*/ let numPropertiesRead = 0;
        if ((mask & SerializationMask.HasIdentities) === SerializationMask.HasIdentities)
        {
            numPropertiesRead++;
            /*int*/ let numberOfIdentities = reader.ReadInt32();
            for(/*int*/ let index = 0; index < numberOfIdentities; index)
            {
                _identities.Add(CreateClaimsIdentity(reader));
            }
        }
        if ((mask & SerializationMask.UserData) === SerializationMask.UserData)
        {
            /*int*/ let cb = reader.ReadInt32();
            _userSerializationData = reader.ReadBytes(cb);
            numPropertiesRead++;
        }
        for(/*int*/ let i = numPropertiesRead; i < numPropertiesToRead; i++)
        {
            reader.ReadString();
        }
    }
    /*void*/ AddIdentity(/*ClaimsIdentity*/ identity)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(identity);
        _identities.Add(identity);
    }
    /*void*/ AddIdentities(/*IEnumerable<ClaimsIdentity>*/ identities)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(identities);
        _identities.AddRange(identities);
    }
    /*IEnumerable<Claim>*/ get Claims()
    {
        BlazorJs.forEach(Identities, function(identity, $_i)
        {
            BlazorJs.forEach(identity.Claims, function(claim, $_i)
            {
claim            });
        });
    }
    /*byte[]*/ get CustomSerializationData()
    {
        return _userSerializationData;
    }
    /*ClaimsPrincipal*/ Clone()
    {
        return new ClaimsPrincipal(this);
    }
    /*ClaimsIdentity*/ CreateClaimsIdentity(/*BinaryReader*/ reader)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(reader);
        return new ClaimsIdentity(reader);
    }
    /*ClaimsPrincipal*/ static get Current()
    {
        return (s_principalSelector) ? s_principalSelector() : SelectClaimsPrincipal();
    }
    /*IEnumerable<Claim>*/ FindAll(/*Predicate<Claim>*/ match)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(match);
        return Core(match);
        /*IEnumerable<Claim>*/ function Core(/*Predicate<Claim>*/ match2)
        {
            BlazorJs.forEach(Identities, function(identity, $_i)
            {
                if (identity !== null)
                {
                    BlazorJs.forEach(identity.FindAll(match2), function(claim, $_i)
                    {
claim                    });
                }
            });
        }
    }
    /*IEnumerable<Claim>*/ FindAll(/*string*/ type)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(type);
        return Core(type);
        /*IEnumerable<Claim>*/ function Core(/*string*/ type2)
        {
            BlazorJs.forEach(Identities, function(identity, $_i)
            {
                if (identity !== null)
                {
                    BlazorJs.forEach(identity.FindAll(type2), function(claim, $_i)
                    {
claim                    });
                }
            });
        }
    }
    /*Claim*/ FindFirst(/*Predicate<Claim>*/ match)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(match);
        /*Claim*/ let claim = null;
        BlazorJs.forEach(Identities, function(identity, $_i)
        {
            if (identity !== null)
            {
                claim = identity.FindFirst(match);
                if (claim !== null)
                {
                    return claim;
                }
            }
        });
        return claim;
    }
    /*Claim*/ FindFirst(/*string*/ type)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(type);
        /*Claim*/ let claim = null;
        for(/*int*/ let i = 0; i < _identities.Count; i++)
        {
            if (_identities[i] !== null)
            {
                claim = _identities[i].FindFirst(type);
                if (claim !== null)
                {
                    return claim;
                }
            }
        }
        return claim;
    }
    /*bool*/ HasClaim(/*Predicate<Claim>*/ match)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(match);
        for(/*int*/ let i = 0; i < _identities.Count; i++)
        {
            if (_identities[i] !== null)
            {
                if (_identities[i].HasClaim(match))
                {
                    return true;
                }
            }
        }
        return false;
    }
    /*bool*/ HasClaim(/*string*/ type, /*string*/ value)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(type);
        ArgumentNullExceptionExtension.ThrowIfNull(value);
        for(/*int*/ let i = 0; i < _identities.Count; i++)
        {
            if (_identities[i] !== null)
            {
                if (_identities[i].HasClaim(type, value))
                {
                    return true;
                }
            }
        }
        return false;
    }
    /*IEnumerable<ClaimsIdentity>*/ get Identities()
    {
        return _identities;
    }
    /*System.Security.Principal.IIdentity*/ get Identity()
    {
        if (s_identitySelector !== null)
        {
            return s_identitySelector(_identities);
        }
        else 
        {
            return SelectPrimaryIdentity(_identities);
        }
    }
    /*bool*/ IsInRole(/*string*/ role)
    {
        for(/*int*/ let i = 0; i < _identities.Count; i++)
        {
            if (_identities[i] !== null)
            {
                if (_identities[i].HasClaim(_identities[i].RoleClaimType, role))
                {
                    return true;
                }
            }
        }
        return false;
    }
    /*void*/ WriteTo(/*BinaryWriter*/ writer)
    {
        WriteTo(writer, null);
    }
    /*void*/ WriteTo(/*BinaryWriter*/ writer, /*byte[]*/ userData)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(writer);
        /*int*/ let numberOfPropertiesWritten = 0;
        /*var*/ let mask = SerializationMask.None;
        if (_identities.Count  > 0)
        {
            mask |= SerializationMask.HasIdentities;
            numberOfPropertiesWritten++;
        }
        if (userData !== null && userData.Length  > 0)
        {
            numberOfPropertiesWritten++;
            mask |= SerializationMask.UserData;
        }
        writer.Write(BlazorJs.Cast(mask, int));
        writer.Write(numberOfPropertiesWritten);
        if ((mask & SerializationMask.HasIdentities) === SerializationMask.HasIdentities)
        {
            writer.Write(_identities.Count);
            BlazorJs.forEach(_identities, function(identity, $_i)
            {
                identity.WriteTo(writer);
            });
        }
        if ((mask & SerializationMask.UserData) === SerializationMask.UserData)
        {
            writer.Write(userData.Length);
            writer.Write(userData);
        }
        writer.Flush();
    }
}

static class System_Security_Claims_ClaimTypes
{
    /*string*/ ClaimTypeNamespace = "http://schemas.microsoft.com/ws/2008/06/identity/claims";
    /*string*/ AuthenticationInstant = ClaimTypeNamespace + "/authenticationinstant";
    /*string*/ AuthenticationMethod = ClaimTypeNamespace + "/authenticationmethod";
    /*string*/ CookiePath = ClaimTypeNamespace + "/cookiepath";
    /*string*/ DenyOnlyPrimarySid = ClaimTypeNamespace + "/denyonlyprimarysid";
    /*string*/ DenyOnlyPrimaryGroupSid = ClaimTypeNamespace + "/denyonlyprimarygroupsid";
    /*string*/ DenyOnlyWindowsDeviceGroup = ClaimTypeNamespace + "/denyonlywindowsdevicegroup";
    /*string*/ Dsa = ClaimTypeNamespace + "/dsa";
    /*string*/ Expiration = ClaimTypeNamespace + "/expiration";
    /*string*/ Expired = ClaimTypeNamespace + "/expired";
    /*string*/ GroupSid = ClaimTypeNamespace + "/groupsid";
    /*string*/ IsPersistent = ClaimTypeNamespace + "/ispersistent";
    /*string*/ PrimaryGroupSid = ClaimTypeNamespace + "/primarygroupsid";
    /*string*/ PrimarySid = ClaimTypeNamespace + "/primarysid";
    /*string*/ Role = ClaimTypeNamespace + "/role";
    /*string*/ SerialNumber = ClaimTypeNamespace + "/serialnumber";
    /*string*/ UserData = ClaimTypeNamespace + "/userdata";
    /*string*/ Version = ClaimTypeNamespace + "/version";
    /*string*/ WindowsAccountName = ClaimTypeNamespace + "/windowsaccountname";
    /*string*/ WindowsDeviceClaim = ClaimTypeNamespace + "/windowsdeviceclaim";
    /*string*/ WindowsDeviceGroup = ClaimTypeNamespace + "/windowsdevicegroup";
    /*string*/ WindowsUserClaim = ClaimTypeNamespace + "/windowsuserclaim";
    /*string*/ WindowsFqbnVersion = ClaimTypeNamespace + "/windowsfqbnversion";
    /*string*/ WindowsSubAuthority = ClaimTypeNamespace + "/windowssubauthority";
    /*string*/ ClaimType2005Namespace = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims";
    /*string*/ Anonymous = ClaimType2005Namespace + "/anonymous";
    /*string*/ Authentication = ClaimType2005Namespace + "/authentication";
    /*string*/ AuthorizationDecision = ClaimType2005Namespace + "/authorizationdecision";
    /*string*/ Country = ClaimType2005Namespace + "/country";
    /*string*/ DateOfBirth = ClaimType2005Namespace + "/dateofbirth";
    /*string*/ Dns = ClaimType2005Namespace + "/dns";
    /*string*/ DenyOnlySid = ClaimType2005Namespace + "/denyonlysid";
    /*string*/ Email = ClaimType2005Namespace + "/emailaddress";
    /*string*/ Gender = ClaimType2005Namespace + "/gender";
    /*string*/ GivenName = ClaimType2005Namespace + "/givenname";
    /*string*/ Hash = ClaimType2005Namespace + "/hash";
    /*string*/ HomePhone = ClaimType2005Namespace + "/homephone";
    /*string*/ Locality = ClaimType2005Namespace + "/locality";
    /*string*/ MobilePhone = ClaimType2005Namespace + "/mobilephone";
    /*string*/ Name = ClaimType2005Namespace + "/name";
    /*string*/ NameIdentifier = ClaimType2005Namespace + "/nameidentifier";
    /*string*/ OtherPhone = ClaimType2005Namespace + "/otherphone";
    /*string*/ PostalCode = ClaimType2005Namespace + "/postalcode";
    /*string*/ Rsa = ClaimType2005Namespace + "/rsa";
    /*string*/ Sid = ClaimType2005Namespace + "/sid";
    /*string*/ Spn = ClaimType2005Namespace + "/spn";
    /*string*/ StateOrProvince = ClaimType2005Namespace + "/stateorprovince";
    /*string*/ StreetAddress = ClaimType2005Namespace + "/streetaddress";
    /*string*/ Surname = ClaimType2005Namespace + "/surname";
    /*string*/ System = ClaimType2005Namespace + "/system";
    /*string*/ Thumbprint = ClaimType2005Namespace + "/thumbprint";
    /*string*/ Upn = ClaimType2005Namespace + "/upn";
    /*string*/ Uri = ClaimType2005Namespace + "/uri";
    /*string*/ Webpage = ClaimType2005Namespace + "/webpage";
    /*string*/ X500DistinguishedName = ClaimType2005Namespace + "/x500distinguishedname";
    /*string*/ ClaimType2009Namespace = "http://schemas.xmlsoap.org/ws/2009/09/identity/claims";
    /*string*/ Actor = ClaimType2009Namespace + "/actor";
}

static class System_Security_Claims_ClaimValueTypes
{
    /*string*/ XmlSchemaNamespace = "http://www.w3.org/2001/XMLSchema";
    /*string*/ Base64Binary = XmlSchemaNamespace + "#base64Binary";
    /*string*/ Base64Octet = XmlSchemaNamespace + "#base64Octet";
    /*string*/ Boolean = XmlSchemaNamespace + "#boolean";
    /*string*/ Date = XmlSchemaNamespace + "#date";
    /*string*/ DateTime = XmlSchemaNamespace + "#dateTime";
    /*string*/ Double = XmlSchemaNamespace + "#double";
    /*string*/ Fqbn = XmlSchemaNamespace + "#fqbn";
    /*string*/ HexBinary = XmlSchemaNamespace + "#hexBinary";
    /*string*/ Integer = XmlSchemaNamespace + "#integer";
    /*string*/ Integer32 = XmlSchemaNamespace + "#integer32";
    /*string*/ Integer64 = XmlSchemaNamespace + "#integer64";
    /*string*/ Sid = XmlSchemaNamespace + "#sid";
    /*string*/ String = XmlSchemaNamespace + "#string";
    /*string*/ Time = XmlSchemaNamespace + "#time";
    /*string*/ UInteger32 = XmlSchemaNamespace + "#uinteger32";
    /*string*/ UInteger64 = XmlSchemaNamespace + "#uinteger64";
    /*string*/ SoapSchemaNamespace = "http://schemas.xmlsoap.org/";
    /*string*/ DnsName = SoapSchemaNamespace + "claims/dns";
    /*string*/ Email = SoapSchemaNamespace + "ws/2005/05/identity/claims/emailaddress";
    /*string*/ Rsa = SoapSchemaNamespace + "ws/2005/05/identity/claims/rsa";
    /*string*/ UpnName = SoapSchemaNamespace + "claims/UPN";
    /*string*/ XmlSignatureConstantsNamespace = "http://www.w3.org/2000/09/xmldsig#";
    /*string*/ DsaKeyValue = XmlSignatureConstantsNamespace + "DSAKeyValue";
    /*string*/ KeyInfo = XmlSignatureConstantsNamespace + "KeyInfo";
    /*string*/ RsaKeyValue = XmlSignatureConstantsNamespace + "RSAKeyValue";
    /*string*/ XQueryOperatorsNameSpace = "http://www.w3.org/TR/2002/WD-xquery-operators-20020816";
    /*string*/ DaytimeDuration = XQueryOperatorsNameSpace + "#dayTimeDuration";
    /*string*/ YearMonthDuration = XQueryOperatorsNameSpace + "#yearMonthDuration";
    /*string*/ Xacml10Namespace = "urn:oasis:names:tc:xacml:1.0";
    /*string*/ Rfc822Name = Xacml10Namespace + ":data-type:rfc822Name";
    /*string*/ X500Name = Xacml10Namespace + ":data-type:x500Name";
}

class System_Security_Principal_GenericIdentity extends System_Security_Claims_ClaimsIdentity
{
    /*string*/ m_name = null;
    /*string*/ m_type = null;
    constructor(/*string*/ name)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(name);
        m_name = name;
        m_type = "";
        AddNameClaim();
    }
    constructor(/*string*/ name, /*string*/ type)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(name);
        ArgumentNullExceptionExtension.ThrowIfNull(type);
        m_name = name;
        m_type = type;
        AddNameClaim();
    }
    constructor(/*GenericIdentity*/ identity)
    {
        super(identity);
        m_name = identity.m_name;
        m_type = identity.m_type;
    }
    /*ClaimsIdentity*/ Clone()
    {
        return new GenericIdentity(this);
    }
    /*IEnumerable<Claim>*/ get Claims()
    {
        return super.Claims;
    }
    /*string*/ get Name()
    {
        return m_name;
    }
    /*string*/ get AuthenticationType()
    {
        return m_type;
    }
    /*bool*/ get IsAuthenticated()
    {
        return m_name.Equals("");
    }
    /*void*/ AddNameClaim()
    {
        if (m_name !== null)
        {
            super.AddClaim(new Claim(super.NameClaimType, m_name, ClaimValueTypes.String, ClaimsIdentity.DefaultIssuer, ClaimsIdentity.DefaultIssuer, this));
        }
    }
}

class System_Security_Principal_GenericPrincipal extends System_Security_Claims_ClaimsPrincipal
{
    /*IIdentity*/ m_identity = null;
    /*string[]*/ m_roles = null;
    constructor(/*IIdentity*/ identity, /*string[]*/ roles)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(identity);
        m_identity = identity;
        if (roles !== null)
        {
            m_roles = BlazorJs.Cast(roles.Clone(), string);
        }
        else 
        {
            m_roles = null;
        }
        AddIdentityWithRoles(m_identity, m_roles);
    }
    /*void*/ AddIdentityWithRoles(/*IIdentity*/ identity, /*string[]*/ roles)
    {
        if (identity instanceof ClaimsIdentity, claimsIdentity = identity)
        {
            claimsIdentity = claimsIdentity.Clone();
        }
        else 
        {
            claimsIdentity = new ClaimsIdentity(identity);
        }
        if (roles !== null && roles.Length  > 0)
        {
            /*List<Claim>*/ let roleClaims = new List(Claim)(roles.Length);
            BlazorJs.forEach(roles, function(role, $_i)
            {
                if (string.IsNullOrWhiteSpace(role))
                {
                    roleClaims.Add(new Claim(claimsIdentity.RoleClaimType, role, ClaimValueTypes.String, ClaimsIdentity.DefaultIssuer, ClaimsIdentity.DefaultIssuer, claimsIdentity));
                }
            });
            claimsIdentity.ExternalClaims.Add(roleClaims);
        }
        super.AddIdentity(claimsIdentity);
    }
    /*IIdentity*/ get Identity()
    {
        return m_identity;
    }
    /*bool*/ IsInRole(/*string*/ role)
    {
        if (role === null || m_roles === null)
        return false;
        for(/*int*/ let i = 0; i < m_roles.Length; i)
        {
            if (string.Equals(m_roles[i], role, StringComparison.OrdinalIgnoreCase))
            return true;
        }
        return super.IsInRole(role);
    }
    /*GenericPrincipal*/ static GetDefaultInstance()
    {
        return new GenericPrincipal(new GenericIdentity(string.Empty), [ string.Empty  ]);
    }
}

const System_Security_Principal_IIdentity = (Base) => class extends Base
{
    /*//
        // Summary:
        //     Gets the type of authentication used.
        //
        // Returns:
        //     The type of authentication used to identify the user.
        string*/ _backingField_AuthenticationType = null;
    /*//
        // Summary:
        //     Gets the type of authentication used.
        //
        // Returns:
        //     The type of authentication used to identify the user.
        string*/ get AuthenticationType()
    {
        return _backingField_AuthenticationType;
    }
    /*//
        // Summary:
        //     Gets a value that indicates whether the user has been authenticated.
        //
        // Returns:
        //     true if the user was authenticated; otherwise, false.
        bool*/ _backingField_IsAuthenticated = null;
    /*//
        // Summary:
        //     Gets a value that indicates whether the user has been authenticated.
        //
        // Returns:
        //     true if the user was authenticated; otherwise, false.
        bool*/ get IsAuthenticated()
    {
        return _backingField_IsAuthenticated;
    }
    /*//
        // Summary:
        //     Gets the name of the current user.
        //
        // Returns:
        //     The name of the user on whose behalf the code is running.
        string*/ _backingField_Name = null;
    /*//
        // Summary:
        //     Gets the name of the current user.
        //
        // Returns:
        //     The name of the user on whose behalf the code is running.
        string*/ get Name()
    {
        return _backingField_Name;
    }
}

const System_Security_Principal_IPrincipal = (Base) => class extends Base
{
    /*// Retrieve the identity object
        IIdentity*/ _backingField_Identity = null;
    /*// Retrieve the identity object
        IIdentity*/ get Identity()
    {
        return _backingField_Identity;
    }
}

static class System_Security_Principal_PrincipalPolicy
{
    UnauthenticatedPrincipal = 0;
    NoPrincipal = 1;
    WindowsPrincipal = 2;
}

static class System_Security_Principal_TokenImpersonationLevel
{
    None = 0;
    Anonymous = 1;
    Identification = 2;
    Impersonation = 3;
    Delegation = 4
;
}

class System_Text_Decoder extends object
{
    /*Encoding*/ encoding = null;
    constructor(/*Encoding*/ encoding)
    {
        super();
        this.encoding  = encoding;
    }
    /*void*/ Convert(/*byte[]*/ inBytes, /*int*/ byteIndex, /*int*/ byteCount, /*char[]*/ outChars, /*int*/ charIndex, /*int*/ charCount, /*bool*/ flush, /*out int*/ bytesUsed, /*out int*/ charsUsed, /*out bool*/ completed)
    {
        throw new NotImplementedException();
    }
}
class System_Text_Encoder extends object
{
    /*Encoding*/ encoding = null;
    constructor(/*Encoding*/ encoding)
    {
        super();
        this.encoding  = encoding;
    }
    /*void*/ Convert(/*char[]*/ inChars, /*int*/ charIndex, /*int*/ charCount, /*byte[]*/ outBytes, /*int*/ byteIndex, /*int*/ byteCount, /*bool*/ flush, /*out int*/ charsUsed, /*out int*/ bytesUsed, /*out bool*/ completed)
    {
        throw new NotImplementedException();
    }
}
static class System_Text_EncodingExtensions
{
    /*Encoder*/ static GetEncoder(/*this Encoding*/ encoding)
    {
        return new Encoder(encoding);
    }
    /*Decoder*/ static GetDecoder(/*this Encoding*/ encoding)
    {
        return new Decoder(encoding);
    }
}

class System_Text_Json_Serialization_JsonAttribute extends System_Attribute
{
    constructor()
    {
        super();
    }
}

static class System_Text_Json_JsonCommentHandling
{
    Skip = 0;
}

class System_Text_Json_Serialization_JsonConstructorAttribute extends System_Text_Json_Serialization_JsonAttribute
{
    constructor()
    {
        super();
    }
}

class System_Text_Json_Serialization_JsonConverterAttribute extends System_Text_Json_Serialization_JsonAttribute
{
    constructor(/*Type*/ type)
    {
        super();
    }
}

class System_Text_Json_JsonDocument extends object
{
    constructor(/*object*/ obj)
    {
        super();
        Object = obj;
    }
    /*object*/ _backingField_Object = null;
    /*object*/ get Object()
    {
        return _backingField_Object;
    }
    /*JsonElement*/ get RootElement()
    {
        return new JsonElement(Object);
    }
    /*JsonDocument*/ static Parse(/*string*/ json, /*JsonDocumentOptions*/ options)
    {
        /*var*/ let _object = JsonSerializer.Deserialize(object, json);
        return new JsonDocument(_object);
    }
}

class System_Text_Json_JsonDocumentOptions extends object
{
    constructor()
    {
        super();
    }
    /*JsonCommentHandling*/ _backingField_CommentHandling = null;
    /*JsonCommentHandling*/ get CommentHandling()
    {
        return _backingField_CommentHandling;
    }
    /*JsonCommentHandling*/ set CommentHandling(value)
    {
        _backingField_CommentHandling = value;
    }
    /*bool*/ _backingField_AllowTrailingCommas = null;
    /*bool*/ get AllowTrailingCommas()
    {
        return _backingField_AllowTrailingCommas;
    }
    /*bool*/ set AllowTrailingCommas(value)
    {
        _backingField_AllowTrailingCommas = value;
    }
}

class System_Text_Json_JsonElement extends System_ValueType
{
    /*object*/ _backingField_Object = null;
    /*object*/ get Object()
    {
        return _backingField_Object;
    }
    constructor(/*object*/ obj)
    {
        super();
        Object = obj;
    }
    /*bool*/ TryGetProperty(/*string*/ path, /*out JsonElement*/ element)
    {
        /*var*/ let o = Object[path];
        if (o !== null)
        {
            element = new JsonElement(o);
            return true;
        }
        element = BlazorJs.getDefault();
        return false;
    }
}

class System_Text_Json_Serialization_JsonIgnoreAttribute extends System_Text_Json_Serialization_JsonAttribute
{
    constructor()
    {
        super();
    }
    /*JsonIgnoreCondition*/ _backingField_Condition = null;
    /*JsonIgnoreCondition*/ get Condition()
    {
        return _backingField_Condition;
    }
    /*JsonIgnoreCondition*/ set Condition(value)
    {
        _backingField_Condition = value;
    }
}

static class System_Text_Json_Serialization_JsonIgnoreCondition
{
    Never = 0;
    Always = 1;
    WhenWritingDefault = 2;
    WhenWritingNull = 3
;
}

class System_Text_Json_Serialization_JsonPropertyNameAttribute extends System_Text_Json_Serialization_JsonAttribute
{
    constructor(/*string*/ name)
    {
        super();
        Name = name;
    }
    /*string*/ _backingField_Name = null;
    /*string*/ get Name()
    {
        return _backingField_Name;
    }
}

static class System_Text_Json_JsonSerializer
{
    /*void*/ static DeepCopy(/*object*/ source, /*object*/ destination)
    {
        if (source !== null && destination !== null)
        {
            /*var*/ let props = object.GetOwnPropertyNames(source);
            /*var*/ let properties = destination.GetType().GetProperties();
            for(/*int*/ let i = 0; i < props.Length; i++)
            {
                /*var*/ let value = source[props[i]];
                if (value !== null)
                {
                    /*var*/ let property = properties.SingleOrDefault(function(/**/ p)
                    {
                        return p.Name.Equals(props[i], StringComparison.InvariantCultureIgnoreCase);
                    });
                    if (property !== null)
                    {
                        /*var*/ let type = H5.Script.TypeOf(value);
                        if (type === "number" || type === "string")
                        {
                            if (type === "string")
                            value = ValueConverter.Convert(value, property.PropertyType);
                            property.SetValue(destination, value);
                        }
                        else if (type === "object")
                        {
                            if (H5.Script.IsArray(value))
                            {
                                /*Type*/ let elementType = property.PropertyType.GetElementType() ?? property.PropertyType.GetGenericArguments()[0];
                                /*Array*/ let valueArray = value.As(Array);
                                /*Array*/ let newArray = Array.CreateInstance(elementType, valueArray.Length);
                                for(/*int*/ let ii = 0; ii < valueArray.Length; ii++)
                                {
                                    /*var*/ let obj = Activator.CreateInstance(elementType);
                                    DeepCopy(valueArray[ii], obj);
                                    newArray[ii] = obj;
                                }
                                property.SetValue(destination, newArray);
                            }
                            else 
                            {
                                /*var*/ let newObject = Activator.CreateInstance(property.PropertyType);
                                DeepCopy(value, newObject);
                                property.SetValue(destination, newObject);
                            }
                        }
                    }
                }
            }
        }
    }
    /*object*/ static Convert(/*object*/ obj, /*Type*/ type)
    {
        /*var*/ let newObject = Activator.CreateInstance(type);
        DeepCopy(obj, newObject);
        return newObject;
    }
    /*object*/ static Convert(/*string*/ json, /*Type*/ type)
    {
        /*var*/ let obj = DeserializeImpl(json);
        /*var*/ let jtype = H5.Script.TypeOf(obj);
        if (obj === null || obj.GetType() === type || jtype === "number" || jtype === "string")
        return json;
        return Convert(obj, type);
    }
    /*T*/ static Convert(T, /*string*/ json, { /*Type*/ type = null})
    {
        return BlazorJs.Cast(Convert(json, type ?? T), T);
    }
    /*T*/ static Convert(T, /*object*/ obj, { /*Type*/ type = null})
    {
        return BlazorJs.Cast(Convert(obj, type ?? T), T);
    }
    /*Task<string>*/ static async AsStringAsync(/*Stream*/ utf8Json, /*CancellationToken*/ cancellationToken)
    {
        /*Span<byte>*/ let span = new Span(byte)(BlazorJs.Cast(utf8Json.Length, int));
        await utf8Json.ReadAsync(span, cancellationToken);
        return Encoding.UTF8.GetString(span.Array);
    }
    /*string*/ static AsString(/*Stream*/ utf8Json)
    {
        /*Span<byte>*/ let span = new Span(byte)(BlazorJs.Cast(utf8Json.Length, int));
        utf8Json.ReadAsync(span, CancellationToken.None).GetAwaiter().GetResult();
        return Encoding.UTF8.GetString(span.Array);
    }
    /*string*/ static AsString(/*ReadOnlySpan<byte>*/ span)
    {
        return Encoding.UTF8.GetString(span.ToArray());
    }
    /*string*/ static AsString(/*ReadOnlySpan<char>*/ span)
    {
        return span.AsString();
    }
    /*string*/ static SerializeToString(/*object*/ o, /*Type*/ type)
    {
        /*var*/ let str = SerializeImpl(o);
        return str;
    }
    /*void*/ static SerializeToStream(/*object*/ o, /*Stream*/ utf8Json, /*Type*/ type)
    {
        /*var*/ let str = SerializeImpl(o);
        /*var*/ let bytes = Encoding.UTF8.GetBytes(str);
        utf8Json.Write(bytes, 0, bytes.Length);
    }
    /*Task*/ static async SerializeToStreamAsync(/*object*/ o, /*Stream*/ utf8Json, /*Type*/ type, /*CancellationToken*/ cancellationToken)
    {
        /*var*/ let str = SerializeImpl(o);
        /*var*/ let bytes = Encoding.UTF8.GetBytes(str);
        await utf8Json.WriteAsync(bytes, cancellationToken);
    }
    /*byte[]*/ static SerializeToBytes(/*object*/ o, /*Type*/ type)
    {
        /*var*/ let str = SerializeImpl(o);
        return Encoding.UTF8.GetBytes(str);
    }
    /*TValue*/ static Deserialize(TValue, /*Stream*/ utf8Json, { /*JsonSerializerOptions*/ options = null})
    {
        return Convert(TValue)(TValue, AsString(utf8Json));
    }
    /*TValue*/ static Deserialize(TValue, /*Stream*/ utf8Json, /*JsonTypeInfo<TValue>*/ jsonTypeInfo)
    {
        return Convert(TValue)(TValue, AsString(utf8Json));
    }
    /*TValue*/ static Deserialize(TValue, /*ReadOnlySpan<byte>*/ utf8Json, { /*JsonSerializerOptions*/ options = null})
    {
        return Convert(TValue)(TValue, AsString(utf8Json));
    }
    /*TValue*/ static Deserialize(TValue, /*ReadOnlySpan<byte>*/ utf8Json, /*JsonTypeInfo<TValue>*/ jsonTypeInfo)
    {
        return Convert(TValue)(TValue, AsString(utf8Json));
    }
    /*TValue*/ static Deserialize(TValue, /*ReadOnlySpan<char>*/ json, { /*JsonSerializerOptions*/ options = null})
    {
        return Convert(TValue)(TValue, AsString(json));
    }
    /*TValue*/ static Deserialize(TValue, /*ReadOnlySpan<char>*/ json, /*JsonTypeInfo<TValue>*/ jsonTypeInfo)
    {
        return Convert(TValue)(TValue, AsString(json));
    }
    /*TValue*/ static Deserialize(TValue, /*string*/ json, { /*JsonSerializerOptions*/ options = null})
    {
        return Convert(TValue)(TValue, json);
    }
    /*TValue*/ static Deserialize(TValue, /*string*/ json, /*JsonTypeInfo<TValue>*/ jsonTypeInfo)
    {
        return Convert(TValue)(TValue, json);
    }
    /*object*/ static Deserialize(/*Stream*/ utf8Json, /*Type*/ returnType, { /*JsonSerializerOptions*/ options = null})
    {
        return Convert(AsString(utf8Json), returnType);
    }
    /*object*/ static Deserialize(/*Stream*/ utf8Json, /*Type*/ returnType, /*JsonSerializerContext*/ context)
    {
        return Convert(AsString(utf8Json), returnType);
    }
    /*object*/ static Deserialize(/*ReadOnlySpan<byte>*/ utf8Json, /*JsonTypeInfo*/ jsonTypeInfo)
    {
        return Convert(AsString(utf8Json), jsonTypeInfo.Type);
    }
    /*object*/ static Deserialize(/*ReadOnlySpan<byte>*/ utf8Json, /*Type*/ returnType, { /*JsonSerializerOptions*/ options = null})
    {
        return Convert(AsString(utf8Json), returnType);
    }
    /*object*/ static Deserialize(/*ReadOnlySpan<byte>*/ utf8Json, /*Type*/ returnType, /*JsonSerializerContext*/ context)
    {
        return Convert(AsString(utf8Json), returnType);
    }
    /*object*/ static Deserialize(/*ReadOnlySpan<char>*/ json, /*JsonTypeInfo*/ jsonTypeInfo)
    {
        return Convert(AsString(json), jsonTypeInfo.Type);
    }
    /*object*/ static Deserialize(/*ReadOnlySpan<char>*/ json, /*Type*/ returnType, { /*JsonSerializerOptions*/ options = null})
    {
        return Convert(AsString(json), returnType);
    }
    /*object*/ static Deserialize(/*ReadOnlySpan<char>*/ json, /*Type*/ returnType, /*JsonSerializerContext*/ context)
    {
        return Convert(AsString(json), returnType);
    }
    /*object*/ static Deserialize(/*string*/ json, /*JsonTypeInfo*/ jsonTypeInfo)
    {
        return Convert(json, jsonTypeInfo.Type);
    }
    /*object*/ static Deserialize(/*string*/ json, /*Type*/ returnType, { /*JsonSerializerOptions*/ options = null})
    {
        return Convert(json, returnType);
    }
    /*object*/ static Deserialize(/*string*/ json, /*Type*/ returnType, /*JsonSerializerContext*/ context)
    {
        return Convert(json, returnType);
    }
    /*object*/ static Deserialize(/*Stream*/ utf8Json, /*JsonTypeInfo*/ jsonTypeInfo)
    {
        return Convert(AsString(utf8Json), jsonTypeInfo.Type);
    }
    /*Task<TValue>*/ static async DeserializeAsync(TValue, /*Stream*/ utf8Json, { /*JsonSerializerOptions*/ options = null, /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        return Convert(TValue)(TValue, await AsStringAsync(utf8Json, cancellationToken));
    }
    /*Task<object>*/ static async DeserializeAsync(/*Stream*/ utf8Json, /*Type*/ returnType, /*JsonSerializerContext*/ context, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        return Convert(await AsStringAsync(utf8Json, cancellationToken), returnType);
    }
    /*Task<object>*/ static async DeserializeAsync(/*Stream*/ utf8Json, /*JsonTypeInfo*/ jsonTypeInfo, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        return Convert(await AsStringAsync(utf8Json, cancellationToken), jsonTypeInfo.Type);
    }
    /*Task<TValue>*/ static async DeserializeAsync(TValue, /*Stream*/ utf8Json, /*JsonTypeInfo<TValue>*/ jsonTypeInfo, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        return Convert(TValue)(TValue, await AsStringAsync(utf8Json, cancellationToken), jsonTypeInfo.Type);
    }
    /*Task<object>*/ static async DeserializeAsync(/*Stream*/ utf8Json, /*Type*/ returnType, { /*JsonSerializerOptions*/ options = null, /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        return Convert(await AsStringAsync(utf8Json, cancellationToken), returnType);
    }
    /*TValue*/ static Deserialize(TValue, /*this JsonDocument*/ document, { /*JsonSerializerOptions*/ options = null})
    {
        return Convert(TValue)(TValue, document.Object);
    }
    /*TValue*/ static Deserialize(TValue, /*this JsonDocument*/ document, /*JsonTypeInfo<TValue>*/ jsonTypeInfo)
    {
        return Convert(TValue)(TValue, document.Object);
    }
    /*TValue*/ static Deserialize(TValue, /*this JsonElement*/ element, { /*JsonSerializerOptions*/ options = null})
    {
        return Convert(TValue)(TValue, element.Object);
    }
    /*TValue*/ static Deserialize(TValue, /*this JsonElement*/ element, /*JsonTypeInfo<TValue>*/ jsonTypeInfo)
    {
        return Convert(TValue)(TValue, element.Object);
    }
    /*object*/ static Deserialize(/*this JsonDocument*/ document, /*Type*/ returnType, { /*JsonSerializerOptions*/ options = null})
    {
        return Convert(document.Object, returnType);
    }
    /*object*/ static Deserialize(/*this JsonDocument*/ document, /*JsonTypeInfo*/ jsonTypeInfo)
    {
        return Convert(document.Object, jsonTypeInfo.Type);
    }
    /*object*/ static Deserialize(/*this JsonElement*/ element, /*Type*/ returnType, { /*JsonSerializerOptions*/ options = null})
    {
        return Convert(element.Object, returnType);
    }
    /*object*/ static Deserialize(/*this JsonElement*/ element, /*Type*/ returnType, /*JsonSerializerContext*/ context)
    {
        return Convert(element.Object, returnType);
    }
    /*object*/ static Deserialize(/*this JsonElement*/ element, /*JsonTypeInfo*/ jsonTypeInfo)
    {
        return Convert(element.Object, jsonTypeInfo.Type);
    }
    /*object*/ static Deserialize(/*this JsonDocument*/ document, /*Type*/ returnType, /*JsonSerializerContext*/ context)
    {
        return Convert(document.Object, returnType);
    }
    /*string*/ static Serialize(TValue, /*TValue*/ value, { /*JsonSerializerOptions*/ options = null})
    {
        return SerializeToString(value, TValue);
    }
    /*void*/ static Serialize(TValue, /*Stream*/ utf8Json, /*TValue*/ value, /*JsonTypeInfo<TValue>*/ jsonTypeInfo)
    {
        SerializeToStream(value, utf8Json, jsonTypeInfo.Type);
    }
    /*void*/ static Serialize(TValue, /*Stream*/ utf8Json, /*TValue*/ value, { /*JsonSerializerOptions*/ options = null})
    {
        SerializeToStream(value, utf8Json, TValue);
    }
    /*string*/ static Serialize(/*object*/ value, /*Type*/ inputType, /*JsonSerializerContext*/ context)
    {
        return SerializeToString(value, inputType);
    }
    /*string*/ static Serialize(/*object*/ value, /*Type*/ inputType, { /*JsonSerializerOptions*/ options = null})
    {
        return SerializeToString(value, inputType);
    }
    /*string*/ static Serialize(TValue, /*TValue*/ value, /*JsonTypeInfo<TValue>*/ jsonTypeInfo)
    {
        return SerializeToString(value, jsonTypeInfo.Type);
    }
    /*void*/ static Serialize(/*Stream*/ utf8Json, /*object*/ value, /*JsonTypeInfo*/ jsonTypeInfo)
    {
        SerializeToStream(value, utf8Json, jsonTypeInfo.Type);
    }
    /*void*/ static Serialize(/*Stream*/ utf8Json, /*object*/ value, /*Type*/ inputType, { /*JsonSerializerOptions*/ options = null})
    {
        SerializeToStream(value, utf8Json, inputType);
    }
    /*void*/ static Serialize(/*Stream*/ utf8Json, /*object*/ value, /*Type*/ inputType, /*JsonSerializerContext*/ context)
    {
        SerializeToStream(value, utf8Json, inputType);
    }
    /*string*/ static Serialize(/*object*/ value, /*JsonTypeInfo*/ jsonTypeInfo)
    {
        return SerializeToString(value, jsonTypeInfo.Type);
    }
    /*Task*/ static SerializeAsync(/*Stream*/ utf8Json, /*object*/ value, /*JsonTypeInfo*/ jsonTypeInfo, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        return SerializeToStreamAsync(value, utf8Json, jsonTypeInfo.Type, cancellationToken);
    }
    /*Task*/ static SerializeAsync(/*Stream*/ utf8Json, /*object*/ value, /*Type*/ inputType, { /*JsonSerializerOptions*/ options = null, /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        return SerializeToStreamAsync(value, utf8Json, inputType, cancellationToken);
    }
    /*Task*/ static SerializeAsync(/*Stream*/ utf8Json, /*object*/ value, /*Type*/ inputType, /*JsonSerializerContext*/ context, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        return SerializeToStreamAsync(value, utf8Json, inputType, cancellationToken);
    }
    /*Task*/ static SerializeAsync(TValue, /*Stream*/ utf8Json, /*TValue*/ value, { /*JsonSerializerOptions*/ options = null, /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        return SerializeToStreamAsync(value, utf8Json, TValue, cancellationToken);
    }
    /*Task*/ static SerializeAsync(TValue, /*Stream*/ utf8Json, /*TValue*/ value, /*JsonTypeInfo<TValue>*/ jsonTypeInfo, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        return SerializeToStreamAsync(value, utf8Json, jsonTypeInfo.Type, cancellationToken);
    }
    /*byte[]*/ static SerializeToUtf8Bytes(TValue, /*TValue*/ value, { /*JsonSerializerOptions*/ options = null})
    {
        return SerializeToBytes(value, TValue);
    }
    /*byte[]*/ static SerializeToUtf8Bytes(TValue, /*TValue*/ value, /*JsonTypeInfo<TValue>*/ jsonTypeInfo)
    {
        return SerializeToBytes(value, jsonTypeInfo.Type);
    }
    /*byte[]*/ static SerializeToUtf8Bytes(/*object*/ value, /*JsonTypeInfo*/ jsonTypeInfo)
    {
        return SerializeToBytes(value, jsonTypeInfo.Type);
    }
    /*byte[]*/ static SerializeToUtf8Bytes(/*object*/ value, /*Type*/ inputType, { /*JsonSerializerOptions*/ options = null})
    {
        return SerializeToBytes(value, inputType);
    }
    /*byte[]*/ static SerializeToUtf8Bytes(/*object*/ value, /*Type*/ inputType, /*JsonSerializerContext*/ context)
    {
        return SerializeToBytes(value, inputType);
    }
}

class System_Text_Json_Serialization_JsonSerializerContext extends object
{
    constructor()
    {
        super();
    }
}

class System_Text_Json_JsonSerializerOptions extends object
{
    constructor()
    {
        super();
    }
    /*JsonSerializerOptions*/ static Web = new JsonSerializerOptions();
    /*JsonCommentHandling*/ _backingField_ReadCommentHandling = null;
    /*JsonCommentHandling*/ get ReadCommentHandling()
    {
        return _backingField_ReadCommentHandling;
    }
    /*JsonCommentHandling*/ set ReadCommentHandling(value)
    {
        _backingField_ReadCommentHandling = value;
    }
}

class System_Text_Json_Serialization_Metadata_JsonTypeInfo extends object
{
    constructor(/*Type*/ type)
    {
        super();
        Type = type;
    }
    /*Type*/ _backingField_Type = null;
    /*Type*/ get Type()
    {
        return _backingField_Type;
    }
    constructor()
    {
        super(T);
    }
}

static class System_Text_Json_JsonValueKind
{
    Null = 0;
    Undefined = 1;
}

static class System_Text_Unicode_Utf8
{
    /*OperationStatus*/ static ToUtf16(/*ReadOnlySpan<byte>*/ source, /*Span<char>*/ destination, /*out int*/ bytesRead, /*out int*/ charsWritten, { /*bool*/ replaceInvalidSequences = true, /*bool*/ isFinalBlock = true})
    {
        throw new NotImplementedException();
    }
}

static class System_Threading_InterlockedExtension
{
    /*int*/ static CompareExchange(/*ref int*/ location1, /*int*/ value, /*int*/ comparand)
    {
        /*var*/ let old = location1;
        if (location1 === comparand)
        {
            location1 = value;
        }
        return old;
    }
    /*T*/ static CompareExchange(T, /*ref T*/ location1, /*T*/ value, /*T*/ comparand)
    {
        /*var*/ let old = location1;
        if (location1.Equals(comparand))
        {
            location1 = value;
        }
        return old;
    }
}

class System_Threading_SemaphoreSlim extends System_IDisposable(object)
{
    /*int*/ taken = null;
    /*int*/ maxCount = null;
    constructor(/*int*/ initialCount)
    {
        super();
        maxCount = initialCount;
        taken = 0;
    }
    constructor(/*int*/ initialCount, /*int*/ maxCount)
    {
        super();
        taken = 0;
        this.maxCount  = maxCount;
    }
    /*int*/ get CurrentCount()
    {
        return maxCount - taken;
    }
    /*void*/ Dispose()
    {
    }
    /*int*/ Release()
    {
        return Release(1);
    }
    /*//
        // Summary:
        //     Releases the System.Threading.SemaphoreSlim object a specified number of times.
        //
        //
        // Parameters:
        //   releaseCount:
        //     The number of times to exit the semaphore.
        //
        // Returns:
        //     The previous count of the System.Threading.SemaphoreSlim.
        //
        // Exceptions:
        //   T:System.ObjectDisposedException:
        //     The current instance has already been disposed.
        //
        //   T:System.ArgumentOutOfRangeException:
        //     releaseCount is less than 1.
        //
        //   T:System.Threading.SemaphoreFullException:
        //     The System.Threading.SemaphoreSlim has already reached its maximum size.
        List<TaskCompletionSource<bool>>*/ blockedWaits = new List(TaskCompletionSource(bool))();
    /*int*/ Release(/*int*/ releaseCount)
    {
        /*//if (releaseCount> tak)
            int*/ let currentCount = CurrentCount;
        while(releaseCount-- > 0)
        {
            if (blockedWaits.Count  > 0)
            {
                /*var*/ let task = blockedWaits.Last();
                blockedWaits.Remove(task);
                task.SetResult(true);
            }
        }
        return currentCount;
    }
    /*void*/ Wait()
    {
        throw new NotImplementedException();
    }
    /*bool*/ Wait(/*int*/ millisecondsTimeout)
    {
        throw new NotImplementedException();
    }
    /*bool*/ Wait(/*int*/ millisecondsTimeout, /*CancellationToken*/ cancellationToken)
    {
        throw new NotImplementedException();
    }
    /*bool*/ Wait(/*TimeSpan*/ timeout)
    {
        throw new NotImplementedException();
    }
    /*bool*/ Wait(/*TimeSpan*/ timeout, /*CancellationToken*/ cancellationToken)
    {
        throw new NotImplementedException();
    }
    /*void*/ Wait(/*CancellationToken*/ cancellationToken)
    {
        throw new NotImplementedException();
    }
    /*Task*/ WaitAsync()
    {
        return WaitAsync(int.MaxValue, CancellationToken.None);
    }
    /*Task<bool>*/ WaitAsync(/*int*/ millisecondsTimeout)
    {
        return WaitAsync(millisecondsTimeout, CancellationToken.None);
    }
    /*Task<bool>*/ WaitAsync(/*int*/ millisecondsTimeout, /*CancellationToken*/ cancellationToken)
    {
        if (CurrentCount > 0)
        {
            taken++;
            return Task.FromResult(false);
        }
        /*TaskCompletionSource<bool>*/ let tcs = new TaskCompletionSource(bool)();
        blockedWaits.Add(tcs);
        cancellationToken.Register(function()
        {
            blockedWaits.Remove(tcs);
            tcs.TrySetCanceled();
        });
        if (millisecondsTimeout >= 0 && millisecondsTimeout !== int.MaxValue)
        {
            /*CancellationTokenSource*/ let cts = new CancellationTokenSource();
            cts.Token.Register(function()
            {
                blockedWaits.Remove(tcs);
                tcs.TrySetCanceled();
            });
            cts.CancelAfter(millisecondsTimeout);
        }
        return tcs.Task;
    }
    /*Task*/ WaitAsync(/*CancellationToken*/ cancellationToken)
    {
        return WaitAsync(int.MaxValue, cancellationToken);
    }
    /*Task<bool>*/ WaitAsync(/*TimeSpan*/ timeout)
    {
        return WaitAsync(BlazorJs.Cast(timeout.TotalMilliseconds, int), CancellationToken.None);
    }
    /*Task<bool>*/ WaitAsync(/*TimeSpan*/ timeout, /*CancellationToken*/ cancellationToken)
    {
        return WaitAsync(timeout.Milliseconds, cancellationToken);
    }
}

class System_Threading_Tasks_TaskCompletionSource extends System_Threading_Tasks_TaskCompletionSource(object)(object)
{
    constructor()
    {
        super();
    }
    /*void*/ TrySetResult()
    {
        return TrySetResult(BlazorJs.getDefault());
    }
    /*void*/ SetResult()
    {
        return SetResult(BlazorJs.getDefault());
    }
}

static class System_Threading_Tasks_TaskExtensions
{
    /*void*/ static TrySetCanceled(T, /*this TaskCompletionSource<T>*/ tcs, /*CancellationToken*/ token)
    {
        tcs.TrySetCanceled();
    }
}

static class System_Threading_Tasks_TaskToAsyncResult
{
    /*IAsyncResult*/ static Begin(/*Task*/ task, /*AsyncCallback*/ callback, /*object*/ state)
    {
        if (task)
        {
            throw new ArgumentNullException(nameof(task));
        }
        return new TaskAsyncResult(task, state, callback);
    }
    /*void*/ static End(/*IAsyncResult*/ asyncResult)
    {
        return Unwrap(asyncResult).GetAwaiter().GetResult();
    }
    /*TResult*/ static End(TResult, /*IAsyncResult*/ asyncResult)
    {
        return Unwrap(TResult)(TResult, asyncResult).GetAwaiter().GetResult();
    }
    /*Task*/ static Unwrap(/*IAsyncResult*/ asyncResult)
    {
        if (asyncResult)
        {
            throw new ArgumentNullException(nameof(asyncResult));
        }
        if (((BlazorJs.As(asyncResult, TaskAsyncResult))?._task instanceof Task))
        {
            throw new ArgumentException(null, nameof(asyncResult));
        }
        return task;
    }
    /*Task<TResult>*/ static Unwrap(TResult, /*IAsyncResult*/ asyncResult)
    {
        if (asyncResult)
        {
            throw new ArgumentNullException(nameof(asyncResult));
        }
        if (((BlazorJs.As(asyncResult, TaskAsyncResult))?._task instanceof Task(TResult)))
        {
            throw new ArgumentException(null, nameof(asyncResult));
        }
        return task;
    }
    static System_Threading_Tasks_TaskToAsyncResult_TaskAsyncResult = class extends System_IAsyncResult(object)
    {
        /*Task*/ _task = null;
        /*AsyncCallback*/ _callback = null;
        constructor(/*Task*/ task, /*object*/ state, /*AsyncCallback*/ callback)
        {
            super();
            _task = task;
            AsyncState = state;
            if (task.IsCompleted)
            {
                CompletedSynchronously = true;
                callback?.Invoke(this);
            }
            else if ((callback))
            {
                _callback = callback;
                _task.GetAwaiter().OnCompleted(function()
                {
                    return _callback.Invoke(this);
                });
            }
        }
        /*object*/ _backingField_AsyncState = null;
        /*object*/ get AsyncState()
        {
            return _backingField_AsyncState;
        }
        /*bool*/ _backingField_CompletedSynchronously = null;
        /*bool*/ get CompletedSynchronously()
        {
            return _backingField_CompletedSynchronously;
        }
        /*bool*/ get IsCompleted()
        {
            return _task.IsCompleted;
        }
    }
}

class System_Threading_Tasks_ValueTask extends System_Threading_Tasks_Task
{
    /*Task*/ task = null;
    constructor(/*Task*/ task)
    {
        super(null);
        this.task  = task;
    }
    /*Task*/ AsTask()
    {
        return task ?? this;
    }
    constructor(/*Action*/ action)
    {
        super(action);
    }
    constructor(/*Action<object>*/ action, /*object*/ state)
    {
        super(action, state);
    }
    /*ValueTask*/ static get CompletedTask()
    {
        return new ValueTask(Task.CompletedTask);
    }
    /*ValueTask<T>*/ static FromResult(T, /*T*/ t)
    {
        return new ValueTask(T)(Task.FromResult(T, t));
    }
}
const System_Threading_Tasks_ValueTask = (TResult) => class extends System_Threading_Tasks_Task(TResult)(TResult)
{
    /*Task<TResult>*/ task = null;
    constructor(/*Task<TResult>*/ task)
    {
        super(null);
        this.task  = task;
    }
    constructor(/*Func<TResult>*/ $function)
    {
        super($function);
    }
    constructor(/*Func<object, TResult>*/ $function, /*object*/ state)
    {
        super($function, state);
    }
    /*TResult*/ get Result()
    {
        return task !== null ? task.Result  : super.Result;
    }
    /*Task<TResult>*/ AsTask()
    {
        return task ?? this;
    }
    /*Task*/ ContinueWith(/*Action<Task<TResult>>*/ continuationAction)
    {
        return task?.ContinueWith(continuationAction) ?? super.ContinueWith(continuationAction);
    }
    /*Task<TNewResult>*/ ContinueWith(TNewResult, /*Func<Task<TResult>, TNewResult>*/ continuationFunction)
    {
        return task?.ContinueWith(continuationFunction) ?? super.ContinueWith(continuationFunction);
    }
    /*TaskAwaiter<TResult>*/ GetAwaiter()
    {
        return task?.GetAwaiter() ?? super.GetAwaiter();
    }
    /*void*/ SetResult(/*TResult*/ result)
    {
        if (task !== null)
        task.SetResult(result);
        else 
        super.SetResult(result);
    }
}

static class System_Web_HttpUtility
{
    /*NameValueCollection*/ static ParseQueryString(/*string*/ query)
    {
        /*Span<Range>*/ let ranges = new Span(Range)(50);
        /*var*/ let span = query.AsSpan().Trim('?');
        /*int*/ let len = span.Split(ranges, '&');
        /*NameValueCollection*/ let collection = new NameValueCollection();
        for(/*int*/ let i = 0; i < len; i++)
        {
            /*var*/ let kv = span[ranges[i]];
            /*Span<Range>*/ let innerRanges = new Span(Range)(2);
            /*var*/ let ilen = kv.Split(innerRanges, '=');
            /*string*/ let value = null;
            /*string*/ let key = kv[innerRanges[0]];
            if (ilen > 1)
            {
                value = kv[innerRanges[0]];
            }
            collection.Add(key, value);
        }
        return collection;
    }
}


class BlazorJs_Core_Components_LiteRouting_LiteRouter extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
    }
    /*NavigationManager*/ _backingField_Navigation = null;
    /*NavigationManager*/ get Navigation()
    {
        return _backingField_Navigation;
    }
    /*NavigationManager*/ set Navigation(value)
    {
        _backingField_Navigation = value;
    }
    /*Type*/ _backingField_DefaultLayout = null;
    /*Type*/ get DefaultLayout()
    {
        return _backingField_DefaultLayout;
    }
    /*Type*/ set DefaultLayout(value)
    {
        _backingField_DefaultLayout = value;
    }
    /*RenderFragment*/ _backingField_NotFound = null;
    /*RenderFragment*/ get NotFound()
    {
        return _backingField_NotFound;
    }
    /*RenderFragment*/ set NotFound(value)
    {
        _backingField_NotFound = value;
    }
    /*int*/ routeIndexSequenceNumber = null;
    /*RouteRegistration*/ route = null;
    /*object*/ routeParameter = null;
    /*void*/ RefreshRoute({ /*string*/ location = null})
    {
        let $ref0 = { set value(v){ routeIndexSequenceNumber = v } };
        let $ref1 = { set value(v){ routeParameter = v } };
        routeParameter = null;
        route = RouteTableFactory.Match(location ?? (document.location.pathname  + document.location.search), $ref0, $ref1);
    }
    /*RenderFragment*/ RenderLayout(/*Type*/ layoutType, /*RenderFragment*/ body)
    {
        return function(/**/ frame, /**/ key)
        {
            frame.Component(layoutType, function(/**/ component)
            {
                (BlazorJs.Cast(component, ILayoutComponent)).Body  = body;
            }, { sequenceNumber : Utility.LiteRouter_Layout_SequenceNumber });
        };
    }
    /*RenderFragment*/ Found()
    {
        /*RenderFragment*/ let pageContent = function(/**/ frame, /**/ key)
        {
            frame.Component(route.PageType, function(/**/ component)
            {
                if (route.ParameterSetter  !== null && routeParameter !== null)
                {
                    BlazorJs.forEach(Object.GetOwnPropertyNames(routeParameter), function(name, $_i)
                    {
                        route.ParameterSetter(component, name, BlazorJs.Cast(routeParameter[name], string));
                    });
                }
            }, { sequenceNumber : Utility.LiteRouter_Page_SequenceNumber  + routeIndexSequenceNumber });
        };
        /*var*/ let layout = route.Layout  ?? DefaultLayout;
        if (layout !== null)
        {
            return RenderLayout(layout, pageContent);
        }
        return pageContent;
    }
    /*void*/ OnInitialized()
    {
        RefreshRoute();
        Navigation.LocationChanged  += Navigation_OnLocationChanged;
        super.OnInitialized();
    }
    /*void*/ Dispose()
    {
        Navigation.LocationChanged  -= Navigation_OnLocationChanged;
        super.Dispose();
    }
    /*void*/ Navigation_OnLocationChanged(/*object*/ sender, /*LocationChangedEventArgs*/ e)
    {
        RefreshRoute(e.Location);
        StateHasChanged();
    }
    /*void*/ InjectServices(/*IServiceProvider*/ provider)
    {
        Navigation = provider.GetRequiredService(Microsoft.AspNetCore.Components.NavigationManager);
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ __frame0, { /*object*/ __key = null})
    {
        if (route !== null)
        {
            __frame0.Content(Found(), { sequenceNumber : 316143205 });
        }
        else 
        {
            __frame0.Content(NotFound, { sequenceNumber : 316143204 });
        }
    }
}


class Microsoft_AspNetCore_Components_RenderTree_Renderer extends object
{
    constructor()
    {
        super();
    }
    /*ResourceAssetCollection*/ _backingField_Assets = null;
    /*ResourceAssetCollection*/ get Assets()
    {
        return _backingField_Assets;
    }
    /*Dispatcher*/ _backingField_Dispatcher = null;
    /*Dispatcher*/ get Dispatcher()
    {
        return _backingField_Dispatcher;
    }
    /*bool*/ get Disposed()
    {
        return false;
    }
    /*IComponentRenderMode*/ GetComponentRenderMode(/*IComponent*/ component)
    {
        return null;
    }
    /*IComponentRenderMode*/ GetComponentRenderMode(/*int*/ componentId)
    {
        return null;
    }
    /*RendererInfo*/ _backingField_RendererInfo = null;
    /*RendererInfo*/ get RendererInfo()
    {
        return _backingField_RendererInfo;
    }
    /*void*/ HandleException(/*Exception*/ exception)
    {
    }
}

class Microsoft_AspNetCore_Components_Sections_SectionContent extends System_IDisposable(Microsoft_AspNetCore_Components_IComponent(Microsoft_AspNetCore_Components_ComponentBase))
{
    constructor()
    {
        super();
    }
    /*object*/ _registeredIdentifier = null;
    /*bool?*/ _registeredIsDefaultContent = null;
    /*SectionRegistry*/ _registry = BlazorJs.getDefault();
    /*string*/ _backingField_SectionName = null;
    /*string*/ get SectionName()
    {
        return _backingField_SectionName;
    }
    /*string*/ set SectionName(value)
    {
        _backingField_SectionName = value;
    }
    /*object*/ _backingField_SectionId = null;
    /*object*/ get SectionId()
    {
        return _backingField_SectionId;
    }
    /*object*/ set SectionId(value)
    {
        _backingField_SectionId = value;
    }
    /*bool*/ _backingField_IsDefaultContent = null;
    /*bool*/ get IsDefaultContent()
    {
        return _backingField_IsDefaultContent;
    }
    /*bool*/ set IsDefaultContent(value)
    {
        _backingField_IsDefaultContent = value;
    }
    /*RenderFragment*/ _backingField_ChildContent = null;
    /*RenderFragment*/ get ChildContent()
    {
        return _backingField_ChildContent;
    }
    /*RenderFragment*/ set ChildContent(value)
    {
        _backingField_ChildContent = value;
    }
    /*void*/ Attach(/*RenderHandle*/ renderHandle)
    {
        _registry = renderHandle.Dispatcher.SectionRegistry;
    }
    /*Task*/ SetParametersAsync(/*ParameterView*/ parameters)
    {
        SetParameterValues(parameters);
        /*object*/ let identifier;
        if (SectionName !== null && SectionId !== null)
        {
            throw new InvalidOperationException(`${nameof(SectionContent)} requires that '${nameof(SectionName)}' and '${nameof(SectionId)}' cannot both have non-null values.`);
        }
        else if (SectionName !== null)
        {
            identifier = SectionName;
        }
        else if (SectionId !== null)
        {
            identifier = SectionId;
        }
        else 
        {
            throw new InvalidOperationException(`${nameof(SectionContent)} requires a non-null value either for '${nameof(SectionName)}' or '${nameof(SectionId)}'.`);
        }
        if (object.Equals(identifier, _registeredIdentifier) || IsDefaultContent !== _registeredIsDefaultContent)
        {
            if (_registeredIdentifier !== null)
            {
                _registry.RemoveProvider(_registeredIdentifier, this);
            }
            _registry.AddProvider(identifier, this, IsDefaultContent);
            _registeredIdentifier = identifier;
            _registeredIsDefaultContent = IsDefaultContent;
        }
        _registry.NotifyContentProviderChanged(identifier, this);
        return Task.CompletedTask;
    }
    /*void*/ SetParameterValues(/*in ParameterView*/ parameters)
    {
        BlazorJs.forEach(parameters, function(param, $_i)
        {
            switch(param.Name)
            {
                case nameof(SectionContent.SectionName):
                {
                    SectionName = BlazorJs.Cast(param.Value, string);
                    break;
                }
                case nameof(SectionContent.SectionId):
                {
                    SectionId = param.Value;
                    break;
                }
                case nameof(SectionContent.IsDefaultContent):
                {
                    IsDefaultContent = BlazorJs.Cast(param.Value, bool);
                    break;
                }
                case nameof(SectionContent.ChildContent):
                {
                    ChildContent = BlazorJs.Cast(param.Value, RenderFragment);
                    break;
                }
                default:
                {
                    throw new ArgumentException(`Unknown parameter '${param.Name}'`);
                }
            }
        });
    }
    /*void*/ Dispose()
    {
        if (_registeredIdentifier !== null)
        {
            _registry.RemoveProvider(_registeredIdentifier, this);
        }
        super.Dispose();
    }
}

class Microsoft_AspNetCore_Components_Sections_SectionOutlet extends Microsoft_AspNetCore_Components_IComponent(object)
{
    constructor()
    {
        super();
    }
    /*RenderFragment*/ static _emptyRenderFragment = function(/**/ _, /**/ __)
    {
    };
    /*object*/ _subscribedIdentifier = null;
    /*RenderHandle*/ _renderHandle = null;
    /*SectionRegistry*/ _registry = BlazorJs.getDefault();
    /*SectionContent*/ _currentContentProvider = null;
    /*string*/ _backingField_SectionName = null;
    /*string*/ get SectionName()
    {
        return _backingField_SectionName;
    }
    /*string*/ set SectionName(value)
    {
        _backingField_SectionName = value;
    }
    /*object*/ _backingField_SectionId = null;
    /*object*/ get SectionId()
    {
        return _backingField_SectionId;
    }
    /*object*/ set SectionId(value)
    {
        _backingField_SectionId = value;
    }
    /*IComponent*/ get CurrentLogicalParent()
    {
        return _currentContentProvider;
    }
    /*void*/ Attach(/*RenderHandle*/ renderHandle)
    {
        _renderHandle = renderHandle;
        _registry = _renderHandle.Dispatcher.SectionRegistry;
    }
    /*Task*/ SetParametersAsync(/*ParameterView*/ parameters)
    {
        parameters.SetParameterProperties(this);
        /*object*/ let identifier;
        if (SectionName !== null && SectionId !== null)
        {
            throw new InvalidOperationException(`${nameof(SectionOutlet)} requires that '${nameof(SectionName)}' and '${nameof(SectionId)}' cannot both have non-null values.`);
        }
        else if (SectionName !== null)
        {
            identifier = SectionName;
        }
        else if (SectionId !== null)
        {
            identifier = SectionId;
        }
        else 
        {
            throw new InvalidOperationException(`${nameof(SectionOutlet)} requires a non-null value either for '${nameof(SectionName)}' or '${nameof(SectionId)}'.`);
        }
        if (object.Equals(identifier, _subscribedIdentifier))
        {
            if (_subscribedIdentifier !== null)
            {
                _registry.Unsubscribe(_subscribedIdentifier);
            }
            _registry.Subscribe(identifier, this);
            _subscribedIdentifier = identifier;
        }
        RenderContent();
        return Task.CompletedTask;
    }
    /*void*/ ContentUpdated(/*SectionContent*/ provider)
    {
        _currentContentProvider = provider;
        RenderContent();
    }
    /*void*/ RenderContent()
    {
        if (_renderHandle.IsRendererDisposed)
        {
            return ;
        }
        _renderHandle.Render(BuildRenderTree);
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ frame, /*object*/ key)
    {
        /*var*/ let fragment = _currentContentProvider?.ChildContent ?? _emptyRenderFragment;
        fragment(frame, key);
    }
    /*void*/ Dispose()
    {
        if (_subscribedIdentifier !== null)
        {
            _registry.Unsubscribe(_subscribedIdentifier);
        }
    }
}

class Microsoft_AspNetCore_Components_Sections_SectionRegistry extends object
{
    constructor()
    {
        super();
    }
    /*Dictionary<object, SectionOutlet>*/ _subscribersByIdentifier = new Dictionary(object, SectionOutlet)();
    /*Dictionary<object, List<SectionContent>>*/ _providersByIdentifier = new Dictionary(object, List(SectionContent))();
    /*void*/ AddProvider(/*object*/ identifier, /*SectionContent*/ provider, /*bool*/ isDefaultProvider)
    {
        let providers = null;
        let $ref1 = { set value(v){ providers = v } };
        if (_providersByIdentifier.TryGetValue(identifier, $ref1))
        {
            providers = new List(SectionContent)();
            _providersByIdentifier.Add(identifier, providers);
        }
        if (isDefaultProvider)
        {
            providers.Insert(0, provider);
        }
        else 
        {
            providers.Add(provider);
        }
    }
    /*void*/ RemoveProvider(/*object*/ identifier, /*SectionContent*/ provider)
    {
        let providers = null;
        let $ref1 = { set value(v){ providers = v } };
        if (_providersByIdentifier.TryGetValue(identifier, $ref1))
        {
            throw new InvalidOperationException(`There are no content providers with the given section ID '${identifier}'.`);
        }
        /*var*/ let index = providers.LastIndexOf(provider);
        if (index < 0)
        {
            throw new InvalidOperationException(`The provider was not found in the providers list of the given section ID '${identifier}'.`);
        }
        providers.RemoveAt(index);
        if (index === providers.Count)
        {
            /*// We just removed the most recently added provider, meaning we need to change
                // the current content to that of second most recently added provider.
                var*/ let contentProvider = GetCurrentProviderContentOrDefault(providers);
            NotifyContentChangedForSubscriber(identifier, contentProvider);
        }
    }
    /*void*/ Subscribe(/*object*/ identifier, /*SectionOutlet*/ subscriber)
    {
        if (_subscribersByIdentifier.ContainsKey(identifier))
        {
            throw new InvalidOperationException(`There is already a subscriber to the content with the given section ID '${identifier}'.`);
        }
        /*// Notify the new subscriber with any existing content.
            var*/ let provider = GetCurrentProviderContentOrDefault(identifier);
        subscriber.ContentUpdated(provider);
        _subscribersByIdentifier.Add(identifier, subscriber);
    }
    /*void*/ Unsubscribe(/*object*/ identifier)
    {
        if (_subscribersByIdentifier.Remove(identifier))
        {
            throw new InvalidOperationException(`The subscriber with the given section ID '${identifier}' is already unsubscribed.`);
        }
    }
    /*void*/ NotifyContentProviderChanged(/*object*/ identifier, /*SectionContent*/ provider)
    {
        let providers = null;
        let $ref1 = { set value(v){ providers = v } };
        if (_providersByIdentifier.TryGetValue(identifier, $ref1))
        {
            throw new InvalidOperationException(`There are no content providers with the given section ID '${identifier}'.`);
        }
        if (providers.Count  !== 0 && providers[providers.Count  - 1] === provider)
        {
            NotifyContentChangedForSubscriber(identifier, provider);
        }
    }
    /*SectionContent*/ static GetCurrentProviderContentOrDefault(/*List<SectionContent>*/ providers)
    {
        return providers.Count  !== 0 ? providers[providers.Count  - 1] : null;
    }
    /*SectionContent*/ GetCurrentProviderContentOrDefault(/*object*/ identifier)
    {
        let existingList = null;
        let $ref1 = { set value(v){ existingList = v } };
        return _providersByIdentifier.TryGetValue(identifier, $ref1) ? GetCurrentProviderContentOrDefault(existingList) : null;
    }
    /*void*/ NotifyContentChangedForSubscriber(/*object*/ identifier, /*SectionContent*/ provider)
    {
        let subscriber = null;
        let $ref1 = { set value(v){ subscriber = v } };
        if (_subscribersByIdentifier.TryGetValue(identifier, $ref1))
        {
            subscriber.ContentUpdated(provider);
        }
    }
}

class Microsoft_AspNetCore_Components_Forms_BrowserFile extends Microsoft_AspNetCore_Components_Forms_IBrowserFile(object)
{
    constructor()
    {
        super();
    }
    /*long*/ _size = null;
    /*InputFile*/ _backingField_Owner = null;
    /*InputFile*/ get Owner()
    {
        return _backingField_Owner;
    }
    /*InputFile*/ set Owner(value)
    {
        _backingField_Owner = value;
    }
    /*int*/ _backingField_Id = null;
    /*int*/ get Id()
    {
        return _backingField_Id;
    }
    /*int*/ set Id(value)
    {
        _backingField_Id = value;
    }
    /*string*/ _backingField_Name = null;
    /*string*/ get Name()
    {
        return _backingField_Name;
    }
    /*string*/ set Name(value)
    {
        _backingField_Name = value;
    }
    /*DateTimeOffset*/ _backingField_LastModified = null;
    /*DateTimeOffset*/ get LastModified()
    {
        return _backingField_LastModified;
    }
    /*DateTimeOffset*/ set LastModified(value)
    {
        _backingField_LastModified = value;
    }
    /*long*/ get Size()
    {
        return _size;
    }
    /*long*/ set Size(value)
    {
        if (value < 0)
        {
            throw new ArgumentOutOfRangeException(nameof(Size), `Size must be a non-negative value. Value provided: ${value}.`);
        }
        _size = value;
    }
    /*string*/ _backingField_ContentType = null;
    /*string*/ get ContentType()
    {
        return _backingField_ContentType;
    }
    /*string*/ set ContentType(value)
    {
        _backingField_ContentType = value;
    }
    /*string*/ _backingField_RelativePath = null;
    /*string*/ get RelativePath()
    {
        return _backingField_RelativePath;
    }
    /*string*/ set RelativePath(value)
    {
        _backingField_RelativePath = value;
    }
    /*Stream*/ OpenReadStream({ /*long*/ maxAllowedSize = 512000, /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        if (Size > maxAllowedSize)
        {
            throw new IOException(`Supplied file with size ${Size} bytes exceeds the maximum of ${maxAllowedSize} bytes.`);
        }
        return Owner.OpenReadStream(this, maxAllowedSize, cancellationToken);
    }
}

static class Microsoft_AspNetCore_Components_Forms_BrowserFileExtensions
{
    /*Task<IBrowserFile>*/ static RequestImageFileAsync(/*this IBrowserFile*/ browserFile, /*string*/ format, /*int*/ maxWidth, /*int*/ maxHeight)
    {
        if (browserFile instanceof BrowserFile, browserFileInternal = browserFile)
        {
            return browserFileInternal.Owner.ConvertToImageFileAsync(browserFileInternal, format, maxWidth, maxHeight);
        }
        throw new InvalidOperationException(`Cannot perform this operation on custom ${IBrowserFile} implementations.`);
    }
}

class Microsoft_AspNetCore_Components_Forms_BrowserFileStream extends System_IO_AsyncStream
{
    /*long*/ _position = null;
    /*HTMLInputElement*/ _inputFileElement = null;
    /*BrowserFile*/ _file = null;
    /*long*/ _maxAllowedSize = null;
    /*CancellationTokenSource*/ _openReadStreamCts = null;
    /*bool*/ _isDisposed = null;
    /*CancellationTokenSource*/ _copyFileDataCts = null;
    constructor(/*HTMLInputElement*/ inputFileElement, /*BrowserFile*/ file, /*long*/ maxAllowedSize, /*CancellationToken*/ cancellationToken)
    {
        super();
        _inputFileElement = inputFileElement;
        _file = file;
        _maxAllowedSize = maxAllowedSize;
        _openReadStreamCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
    }
    /*bool*/ get CanRead()
    {
        return true;
    }
    /*bool*/ get CanSeek()
    {
        return false;
    }
    /*bool*/ get CanWrite()
    {
        return false;
    }
    /*long*/ get Length()
    {
        return _file.Size;
    }
    /*long*/ get Position()
    {
        return _position;
    }
    /*long*/ set Position(value)
    {
        throw new NotSupportedException();
    }
    /*void*/ Flush()
    {
        throw new NotSupportedException();
    }
    /*int*/ Read(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count)
    {
        throw new NotSupportedException("Synchronous reads are not supported.");
    }
    /*long*/ Seek(/*long*/ offset, /*SeekOrigin*/ origin)
    {
        throw new NotSupportedException();
    }
    /*void*/ SetLength(/*long*/ value)
    {
        throw new NotSupportedException();
    }
    /*Task<int>*/ WriteAsync(/*ReadOnlySpan<byte>*/ buffer, /*CancellationToken*/ cancellationToken)
    {
        throw new NotImplementedException();
    }
    /*Task<int>*/ async ReadAsync(/*Span<byte>*/ buffer, { /*CancellationToken*/ cancellationToken = BlazorJs.getDefault()})
    {
        /*var*/ let bytesAvailableToRead = Length - Position;
        /*var*/ let maxBytesToRead = BlazorJs.Cast(Math.Min(bytesAvailableToRead, buffer.Length), int);
        if (maxBytesToRead <= 0)
        {
            return 0;
        }
        /*var*/ let bytesRead = await CopyFileDataIntoBuffer(buffer.Slice(0, maxBytesToRead), cancellationToken);
        _position += bytesRead;
        return bytesRead;
    }
    /*Task<int>*/ async CopyFileDataIntoBuffer(/*Span<byte>*/ destination, /*CancellationToken*/ cancellationToken)
    {
        /*var*/ let blob = (await Task.FromPromise(BlazorJs.TypeArray(Blob), InputFileInterop.ReadFileData(_inputFileElement, _file.Id).As(IPromise), null))[0];
        /*var*/ let reader = H5.Script.Write(FileReader, "new FileReader()");
        reader.readAsArrayBuffer(blob);
        destination.CopyFrom(reader.result.As(BlazorJs.TypeArray(byte)));
        return BlazorJs.Cast(blob.size, int);
    }
    /*void*/ Dispose(/*bool*/ disposing)
    {
        if (_isDisposed)
        {
            return ;
        }
        _openReadStreamCts.Cancel();
        _copyFileDataCts?.Cancel();
        _isDisposed = true;
        super.Dispose(disposing);
    }
}

const Microsoft_AspNetCore_Components_Forms_IBrowserFile = (Base) => class extends Base
{
    /*/// <summary>
        /// Gets the name of the file as specified by the browser.
        /// </summary>
        string*/ _backingField_Name = null;
    /*/// <summary>
        /// Gets the name of the file as specified by the browser.
        /// </summary>
        string*/ get Name()
    {
        return _backingField_Name;
    }
    /*/// <summary>
        /// Gets the last modified date as specified by the browser.
        /// </summary>
        DateTimeOffset*/ _backingField_LastModified = null;
    /*/// <summary>
        /// Gets the last modified date as specified by the browser.
        /// </summary>
        DateTimeOffset*/ get LastModified()
    {
        return _backingField_LastModified;
    }
    /*/// <summary>
        /// Gets the size of the file in bytes as specified by the browser.
        /// </summary>
        long*/ _backingField_Size = null;
    /*/// <summary>
        /// Gets the size of the file in bytes as specified by the browser.
        /// </summary>
        long*/ get Size()
    {
        return _backingField_Size;
    }
    /*/// <summary>
        /// Gets the MIME type of the file as specified by the browser.
        /// </summary>
        string*/ _backingField_ContentType = null;
    /*/// <summary>
        /// Gets the MIME type of the file as specified by the browser.
        /// </summary>
        string*/ get ContentType()
    {
        return _backingField_ContentType;
    }
}

const Microsoft_AspNetCore_Components_Forms_IInputFileJsCallbacks = (Base) => class extends Base
{
}

class Microsoft_AspNetCore_Components_Forms_InputFileChangeEventArgs extends System_EventArgs
{
    /*IReadOnlyList<IBrowserFile>*/ _files = null;
    constructor(/*IReadOnlyList<IBrowserFile>*/ files)
    {
        super();
        _files = BlazorJs.FirstOf(files, function(){ throw new ArgumentNullException(nameof(files)) });
    }
    /*int*/ get FileCount()
    {
        return _files.Count;
    }
    /*IBrowserFile*/ get File()
    {
        switch(_files.Count)
        {
            case 0:
            {
                throw new InvalidOperationException("No file was supplied.");
            }
            case 1:
            {
                return _files[0];
            }
            default:
            {
                throw new InvalidOperationException(`More than one file was supplied. Call ${nameof(GetMultipleFiles)} to receive multiple files.`);
            }
        }
    }
    /*IReadOnlyList<IBrowserFile>*/ GetMultipleFiles({ /*int*/ maximumFileCount = 10})
    {
        if (_files.Count  > maximumFileCount)
        {
            throw new InvalidOperationException(`The maximum number of files accepted is ${maximumFileCount}, but ${_files.Count} were supplied.`);
        }
        return _files;
    }
}

static class Microsoft_AspNetCore_Components_Forms_InputFileInterop
{
    /*void*/ static Init(/*IInputFileJsCallbacks*/ callbackWrapper, /*HTMLInputElement*/ elem)
    {
        elem["_blazorInputFileNextFileId"] = 0;
        elem.addEventListener("click", function()
        {
            elem.value  = "";
        });
        elem.addEventListener("change", function()
        {
            elem["_blazorFilesById"] = new object();
            /*var*/ let fileList = elem.files.Select(function(/**/ file)
            {
                /*var*/ let id = elem["_blazorInputFileNextFileId"].As(int);
                id++;
                elem["_blazorInputFileNextFileId"] = id;
                /*var*/ let result = BlazorJs.PopulateProperty(new BrowserFile(), function(/*BrowserFile*/ $obj)
                {
                    $obj.Id = id;
                    $obj.LastModified = DateTimeOffset.Parse(new Date(file.lastModified).toISOString());
                    $obj.Name = file.name;
                    $obj.Size = BlazorJs.Cast(file.size, long);
                    $obj.ContentType = file.type;
                });
                result["blob"] = file;
                elem["_blazorFilesById"][result.Id.ToString()] = result;
                return result;
            }).ToArray();
            callbackWrapper.NotifyChange(fileList);
        });
    }
    /*BrowserFile*/ static GetFileById(/*HTMLInputElement*/ elem, /*int*/ fileId)
    {
        /*var*/ let file = elem["_blazorFilesById"][fileId.ToString()].As(BrowserFile);
        if (file === null)
        {
            throw new Exception(`There is no file with ID ${fileId}.The file list may have changed.See https://aka.ms/aspnet/blazor-input-file-multiple-selections.`);
        }
        return file;
    }
    /*Promise<Blob>*/ static ReadFileData(/*HTMLInputElement*/ elem, /*int*/ fileId)
    {
        /*var*/ let file = GetFileById(elem, fileId);
        return file["blob"].As(Promise(Blob));
    }
    /*Task<BrowserFile>*/ static async ToImageFile(/*HTMLInputElement*/ elem, /*int*/ fileId, /*string*/ format, /*int*/ maxWidth, /*int*/ maxHeight)
    {
        /*var*/ let originalFile = GetFileById(elem, fileId);
        /*TaskCompletionSource<HTMLImageElement>*/ let tcs = new TaskCompletionSource(HTMLImageElement)();
        /*var*/ let originalFileImage = H5.Script.Write(object, "new Image()").As(HTMLImageElement);
        originalFileImage["onload"] = BlazorJs.Cast((function()
        {
            URL.revokeObjectURL(originalFileImage.src);
            tcs.SetResult(originalFileImage);
        }), Action);
        originalFileImage["onerror"] = BlazorJs.Cast((function()
        {
            originalFileImage.onerror  = null;
            URL.revokeObjectURL(originalFileImage.src);
        }), Action);
        originalFileImage["src"] = URL.createObjectURL(originalFile["blob"]);
        /*HTMLImageElement*/ let loadedImage = await tcs.Task;
        /*//HTMLImageElement loadedImage = new Promise((Action<HTMLImageElement> resolve) =>
            //{
            //    var originalFileImage = H5.Script.Write<object>("new Image()").As<HTMLImageElement>();
            //    originalFileImage["onload"] = () =>
            //    {
            //        URL.revokeObjectURL(originalFileImage.src);
            //        resolve(originalFileImage);
            //    };
            //    originalFileImage["onerror"] = () =>
            //    {
            //        originalFileImage.onerror = null;
            //        URL.revokeObjectURL(originalFileImage.src);
            //    };
            //    originalFileImage["src"] = URL.createObjectURL(originalFile["blob"]);
            //});

            TaskCompletionSource<Blob>*/ let tcs2 = new TaskCompletionSource(Blob)();
        /*var*/ let desiredWidthRatio = H5.Core.es5.Math.min(1, maxWidth / loadedImage.width);
        /*var*/ let desiredHeightRatio = H5.Core.es5.Math.min(1, maxHeight / loadedImage.height);
        /*var*/ let chosenSizeRatio = H5.Core.es5.Math.min(desiredWidthRatio, desiredHeightRatio);
        /*var*/ let canvas = document.createElement("canvas").As(HTMLCanvasElement);
        canvas.width  = H5.Core.es5.Math.round(loadedImage.width  * chosenSizeRatio).As(uint);
        canvas.height  = H5.Core.es5.Math.round(loadedImage.height  * chosenSizeRatio).As(uint);
        canvas.getContext("2d").As(CanvasRenderingContext2D)?.drawImage(loadedImage, 0, 0, canvas.width, canvas.height);
        canvas.toBlob(function(/**/ blob)
        {
            tcs2.SetResult(blob);
        }, format);
        /*var*/ let resizedImageBlob = await tcs2.Task;
        /*//var resizedImageBlob = new Promise((Action<BlobCallback> resolve) =>
            //{
            //    var desiredWidthRatio = Math.min(1, maxWidth / loadedImage.width);
            //    var desiredHeightRatio = Math.min(1, maxHeight / loadedImage.height);
            //    var chosenSizeRatio = Math.min(desiredWidthRatio, desiredHeightRatio);

            //    var canvas = document.createElement("canvas").As<HTMLCanvasElement>();
            //    canvas.width = Math.round(loadedImage.width * chosenSizeRatio);
            //    canvas.height = Math.round(loadedImage.height * chosenSizeRatio);
            //    canvas.getContext("2d").As<CanvasRenderingContext2D>()?.drawImage(loadedImage, 0, 0, canvas.width, canvas.height);
            //    canvas.toBlob(resolve, format);
            //});

            var*/ let id = elem["_blazorInputFileNextFileId"].As(int);
        id++;
        elem["_blazorInputFileNextFileId"] = id;
        /*var*/ let result = BlazorJs.PopulateProperty(new BrowserFile(), function(/*BrowserFile*/ $obj)
        {
            $obj.Id = id;
            $obj.LastModified = originalFile.LastModified;
            $obj.Name = originalFile.Name;
            $obj.Size = BlazorJs.Cast((resizedImageBlob?.size ?? 0), long);
            $obj.ContentType = format;
        });
        result["blob"] = resizedImageBlob ?? originalFile["blob"];
        elem["_blazorFilesById"][result.Id.ToString()] = result;
        return result;
    }
}



static class Microsoft_AspNetCore_Components_Forms_Mapping_EditContextFormMappingExtensions
{
    /*object*/ static _key = new object();
    /*IDisposable*/ static EnableFormMappingContextExtensions(/*this EditContext*/ context, /*FormMappingContext*/ mappingContext)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(context, nameof(context));
        ArgumentNullExceptionExtension.ThrowIfNull(mappingContext, nameof(mappingContext));
        context.Properties[_key] = mappingContext;
        return new MappingContextEventSubscriptions(context, mappingContext);
    }
    /*string*/ static GetAttemptedValue(/*this EditContext*/ context, /*string*/ fieldName)
    {
        let result = null;
        let $ref1 = { set value(v){ result = v } };
        ArgumentNullExceptionExtension.ThrowIfNull(context, nameof(context));
        ArgumentNullExceptionExtension.ThrowIfNull(fieldName, nameof(fieldName));
        if (context.Properties.TryGetValue(_key, $ref1) && result instanceof FormMappingContext, mappingContext = result)
        {
            return mappingContext.GetAttemptedValue(fieldName);
        }
        return null;
    }
    static Microsoft_AspNetCore_Components_Forms_Mapping_EditContextFormMappingExtensions_MappingContextEventSubscriptions = class extends System_IDisposable(object)
    {
        /*EditContext*/ _editContext = null;
        /*FormMappingContext*/ _mappingContext = null;
        /*ValidationMessageStore*/ _messages = null;
        /*bool*/ _hasmessages = null;
        constructor(/*EditContext*/ editContext, /*FormMappingContext*/ mappingContext)
        {
            super();
            _editContext = editContext;
            _mappingContext = mappingContext;
            _editContext.OnValidationRequested  += OnValidationRequested;
        }
        /*void*/ OnValidationRequested(/*object*/ sender, /*ValidationRequestedEventArgs*/ e)
        {
            if (_messages !== null)
            {
                return ;
            }
            _messages = new ValidationMessageStore(_editContext);
            /*var*/ let adddedMessages = false;
            BlazorJs.forEach(_mappingContext.GetAllErrors(), function(error, $_i)
            {
                /*var*/ let owner = error.Container;
                /*var*/ let key = error.Name;
                /*var*/ let errors = error.ErrorMessages;
                /*FieldIdentifier*/ let fieldIdentifier;
                fieldIdentifier = new FieldIdentifier(owner ?? _editContext.Model, key);
                BlazorJs.forEach(errors, function(errorMessage, $_i)
                {
                    adddedMessages = true;
                    _messages.Add(fieldIdentifier, errorMessage.ToString(CultureInfo.CurrentCulture));
                    _hasmessages = true;
                });
            });
            if (adddedMessages)
            {
                _editContext.NotifyValidationStateChanged();
            }
        }
        /*void*/ Dispose()
        {
            _messages?.Clear();
            _editContext.OnValidationRequested  -= OnValidationRequested;
            if (_hasmessages)
            {
                _editContext.NotifyValidationStateChanged();
            }
        }
    }
}

class Microsoft_AspNetCore_Components_Forms_FormMappingContext extends object
{
    /*Dictionary<string, FormMappingError>*/ _errors = null;
    /*List<KeyValuePair<string, FormMappingError>>*/ _pendingErrors = null;
    /*Dictionary<string, Dictionary<string, FormMappingError>>*/ _errorsByFormName = null;
    constructor(/*string*/ mappingScopeName)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(mappingScopeName);
        MappingScopeName = mappingScopeName;
    }
    /*string*/ _backingField_MappingScopeName = null;
    /*string*/ get MappingScopeName()
    {
        return _backingField_MappingScopeName;
    }
    /*FormMappingError*/ GetErrors(/*string*/ key)
    {
        let mappingError = null;
        let $ref1 = { set value(v){ mappingError = v } };
        return _errors?.TryGetValue(key, $ref1) === true ? mappingError : null;
    }
    /*FormMappingError*/ GetErrors(/*string*/ formName, /*string*/ key)
    {
        let formErrors = null;
        let $ref1 = { set value(v){ formErrors = v } };
        let mappingError = null;
        let $ref3 = { set value(v){ mappingError = v } };
        return _errorsByFormName?.TryGetValue(formName, $ref1) === true && formErrors.TryGetValue(key, $ref3) === true ? mappingError : null;
    }
    /*IEnumerable<FormMappingError>*/ GetAllErrors()
    {
        return GetAllErrorsCore(_errors);
    }
    /*IEnumerable<FormMappingError>*/ static GetAllErrorsCore(/*Dictionary<string, FormMappingError>*/ errors)
    {
        if (errors === null)
        {
            return Array.Empty(FormMappingError);
        }
        return errors.Values;
    }
    /*IEnumerable<FormMappingError>*/ GetAllErrors(/*string*/ formName)
    {
        let formErrors = null;
        let $ref1 = { set value(v){ formErrors = v } };
        return _errorsByFormName?.TryGetValue(formName, $ref1) === true ? GetAllErrorsCore(formErrors) : Array.Empty(FormMappingError);
    }
    /*string*/ GetAttemptedValue(/*string*/ key)
    {
        let mappingError = null;
        let $ref1 = { set value(v){ mappingError = v } };
        return _errors?.TryGetValue(key, $ref1) === true ? mappingError.AttemptedValue  : null;
    }
    /*string*/ GetAttemptedValue(/*string*/ formName, /*string*/ key)
    {
        let formErrors = null;
        let $ref1 = { set value(v){ formErrors = v } };
        let mappingError = null;
        let $ref3 = { set value(v){ mappingError = v } };
        return _errorsByFormName?.TryGetValue(formName, $ref1) === true && formErrors.TryGetValue(key, $ref3) ? mappingError.AttemptedValue  : null;
    }
    /*void*/ AddError(/*string*/ key, /*FormattableString*/ error, /*string*/ attemptedValue)
    {
        let $ref0 = { set value(v){ _pendingErrors = v } };
        _errors = _errors ?? new Dictionary(string, FormMappingError)();
        AddErrorCore(_errors, key, error, attemptedValue, $ref0);
    }
    /*void*/ static AddErrorCore(/*Dictionary<string, FormMappingError>*/ errors, /*string*/ key, /*FormattableString*/ error, /*string*/ attemptedValue, /*ref List<KeyValuePair<string, FormMappingError>>*/ pendingErrors)
    {
        let mappingError = null;
        let $ref1 = { set value(v){ mappingError = v } };
        if (errors.TryGetValue(key, $ref1))
        {
            mappingError = new FormMappingError(key, BlazorJs.PopulateProperty(new List(FormattableString)(), function(/*List(FormattableString)*/ $obj)
            {
                $obj.error;
            }), attemptedValue);
            errors.Add(key, mappingError);
            pendingErrors = pendingErrors ?? new List(KeyValuePair(string, FormMappingError))();
            pendingErrors.Add(new KeyValuePair(string, FormMappingError)(key, mappingError));
        }
        else 
        {
            mappingError.AddError(error);
        }
    }
    /*void*/ AddError(/*string*/ formName, /*string*/ key, /*FormattableString*/ error, /*string*/ attemptedValue)
    {
        let formErrors = null;
        let $ref1 = { set value(v){ formErrors = v } };
        let $ref2 = { set value(v){ _pendingErrors = v } };
        _errorsByFormName = _errorsByFormName ?? new Dictionary(string, Dictionary(string, FormMappingError))();
        if (_errorsByFormName.TryGetValue(formName, $ref1))
        {
            formErrors = new Dictionary(string, FormMappingError)();
            _errorsByFormName.Add(formName, formErrors);
        }
        AddErrorCore(formErrors, key, error, attemptedValue, $ref2);
    }
    /*void*/ AttachParentValue(/*string*/ key, /*object*/ value)
    {
        if (_pendingErrors === null)
        {
            return ;
        }
        for(/*var*/ let i = 0; i < _pendingErrors.Count; i++)
        {
            var [ errorKey, error ] = BlazorJs.Destructure(_pendingErrors[i]);
            if (errorKey.StartsWith(key, StringComparison.Ordinal))
            {
                throw new InvalidOperationException(`'${errorKey}' does must start with '${key}'`);
            }
            error.Container  = value;
        }
        _pendingErrors.Clear();
    }
    /*void*/ SetErrors(/*string*/ formName, /*FormMappingContext*/ childContext)
    {
        let formErrors = null;
        let $ref1 = { set value(v){ formErrors = v } };
        if (_errorsByFormName === null || _errorsByFormName.TryGetValue(formName, $ref1))
        {
            return ;
        }
        childContext._errors  = formErrors;
    }
}

class Microsoft_AspNetCore_Components_Forms_Mapping_FormMappingError extends object
{
    /*char[]*/ static Separators = [ '.', '[' ];
    /*List<FormattableString>*/ _errorMessages = null;
    constructor(/*string*/ path, /*List<FormattableString>*/ errorMessages, /*string*/ attemptedValue)
    {
        super();
        _errorMessages = errorMessages;
        AttemptedValue = attemptedValue;
        Path = path;
        Name = GetName(Path);
    }
    /*object*/ _backingField_Container = null;
    /*object*/ get Container()
    {
        return _backingField_Container;
    }
    /*object*/ set Container(value)
    {
        _backingField_Container = value;
    }
    /*string*/ _backingField_Name = null;
    /*string*/ get Name()
    {
        return _backingField_Name;
    }
    /*string*/ _backingField_Path = null;
    /*string*/ get Path()
    {
        return _backingField_Path;
    }
    /*IReadOnlyList<FormattableString>*/ get ErrorMessages()
    {
        return _errorMessages;
    }
    /*string*/ _backingField_AttemptedValue = null;
    /*string*/ get AttemptedValue()
    {
        return _backingField_AttemptedValue;
    }
    /*string*/ static GetName(/*string*/ path)
    {
        /*var*/ let errorKey = path;
        /*var*/ let lastSeparatorIndex = path.LastIndexOfAny(Separators);
        if (lastSeparatorIndex >= 0)
        {
            if (path[lastSeparatorIndex] === '[')
            {
                /*var*/ let closingBracket = path.IndexOf(']', lastSeparatorIndex);
                errorKey = path.AsSpan()[new System_Range((lastSeparatorIndex + 1), closingBracket)];
            }
            else 
            {
                errorKey = path.AsSpan()[new System_Range((lastSeparatorIndex + 1), 1)];
            }
        }
        return errorKey;
    }
    /*void*/ AddError(/*FormattableString*/ error)
    {
        _errorMessages.Add(error);
    }
}


class Microsoft_AspNetCore_Components_Forms_Mapping_FormMappingValidator extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
    }
    /*IDisposable*/ _subscriptions = null;
    /*EditContext*/ _originalEditContext = null;
    /*EditContext*/ _backingField_CurrentEditContext = null;
    /*EditContext*/ get CurrentEditContext()
    {
        return _backingField_CurrentEditContext;
    }
    /*EditContext*/ set CurrentEditContext(value)
    {
        _backingField_CurrentEditContext = value;
    }
    /*FormMappingContext*/ _backingField_MappingContext = null;
    /*FormMappingContext*/ get MappingContext()
    {
        return _backingField_MappingContext;
    }
    /*FormMappingContext*/ set MappingContext(value)
    {
        _backingField_MappingContext = value;
    }
    /*void*/ OnInitialized()
    {
        if (CurrentEditContext === null)
        {
            throw new InvalidOperationException(`${nameof(FormMappingValidator)} requires a ` + `parameter of type ${nameof(EditContext)}.`);
        }
        if (MappingContext === null)
        {
            return ;
        }
        _subscriptions = CurrentEditContext.EnableFormMappingContextExtensions(MappingContext);
        _originalEditContext = CurrentEditContext;
    }
    /*void*/ OnParametersSet()
    {
        if (MappingContext === null)
        {
            return ;
        }
        if (CurrentEditContext !== _originalEditContext)
        {
            throw new InvalidOperationException(`${GetType()} does not support changing the ` + `${nameof(EditContext)} dynamically.`);
        }
    }
    /*void*/ Dispose()
    {
        super.Dispose();
        _subscriptions?.Dispose();
        _subscriptions = null;
    }
    /*void*/ CascadeParameters()
    {
        RequestCascadingParameter(Microsoft_AspNetCore_Components_Forms_FormMappingContext)(Microsoft.AspNetCore.Components.Forms.FormMappingContext, function(/**/ e)
        {
            return MappingContext = e;
        }, { cascadingParameterName : null });
        super.CascadeParameters();
    }
}

class Microsoft_AspNetCore_Components_Forms_Mapping_FormValueMappingContext extends object
{
    /*bool*/ _resultSet = null;
    constructor(/*string*/ acceptMappingScopeName, /*string*/ acceptFormName, /*Type*/ valueType, /*string*/ parameterName)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(acceptMappingScopeName, nameof(acceptMappingScopeName));
        ArgumentNullExceptionExtension.ThrowIfNull(valueType, nameof(valueType));
        ArgumentNullExceptionExtension.ThrowIfNull(parameterName, nameof(parameterName));
        AcceptMappingScopeName = acceptMappingScopeName;
        AcceptFormName = acceptFormName;
        ParameterName = parameterName;
        ValueType = valueType;
    }
    /*string*/ _backingField_AcceptMappingScopeName = null;
    /*string*/ get AcceptMappingScopeName()
    {
        return _backingField_AcceptMappingScopeName;
    }
    /*string*/ _backingField_AcceptFormName = null;
    /*string*/ get AcceptFormName()
    {
        return _backingField_AcceptFormName;
    }
    /*string*/ _backingField_ParameterName = null;
    /*string*/ get ParameterName()
    {
        return _backingField_ParameterName;
    }
    /*Type*/ _backingField_ValueType = null;
    /*Type*/ get ValueType()
    {
        return _backingField_ValueType;
    }
    /*Action<string, FormattableString, string>*/ _backingField_OnError = null;
    /*Action<string, FormattableString, string>*/ get OnError()
    {
        return _backingField_OnError;
    }
    /*Action<string, FormattableString, string>*/ set OnError(value)
    {
        _backingField_OnError = value;
    }
    /*Action<string, object>*/ _backingField_MapErrorToContainer = null;
    /*Action<string, object>*/ get MapErrorToContainer()
    {
        return _backingField_MapErrorToContainer;
    }
    /*Action<string, object>*/ set MapErrorToContainer(value)
    {
        _backingField_MapErrorToContainer = value;
    }
    /*object*/ _backingField_Result = null;
    /*object*/ get Result()
    {
        return _backingField_Result;
    }
    /*object*/ set Result(value)
    {
        _backingField_Result = value;
    }
    /*void*/ SetResult(/*object*/ result)
    {
        if (_resultSet)
        {
            throw new InvalidOperationException(`The result has already been set to '${Result}'.`);
        }
        _resultSet = true;
        Result = result;
    }
}

const Microsoft_AspNetCore_Components_Forms_Mapping_IFormValueMapper = (Base) => class extends Base
{
}



class Microsoft_JSInterop_Implementation_JSInProcessObjectReference extends System_IDisposable(Microsoft_JSInterop_IJSObjectReference(Microsoft_JSInterop_IJSInProcessObjectReference(Microsoft_JSInterop_Implementation_JSObjectReference)))
{
    /*JSInProcessRuntime*/ _jsRuntime = null;
    constructor(/*JSInProcessRuntime*/ jsRuntime, /*long*/ id)
    {
        super(jsRuntime, id);
        _jsRuntime = jsRuntime;
    }
    /*TValue*/ Invoke(TValue, /*string*/ identifier, /*params object[]*/ args)
    {
        ThrowIfDisposed();
        return _jsRuntime.Invoke(TValue, identifier, Id, JSCallType.FunctionCall, args);
    }
    /*IJSInProcessObjectReference*/ InvokeNew(/*string*/ identifier, /*object[]*/ args)
    {
        ThrowIfDisposed();
        return _jsRuntime.Invoke(IJSInProcessObjectReference, identifier, Id, JSCallType.NewCall, args);
    }
    /*TValue*/ GetValue(TValue, /*string*/ identifier)
    {
        ThrowIfDisposed();
        return _jsRuntime.Invoke(TValue, identifier, Id, JSCallType.GetValue);
    }
    /*void*/ SetValue(TValue, /*string*/ identifier, /*TValue*/ value)
    {
        ThrowIfDisposed();
        _jsRuntime.Invoke(TValue, identifier, Id, JSCallType.SetValue, value);
    }
    /*void*/ Dispose()
    {
        if (Disposed)
        {
            Disposed = true;
            DisposeJSObjectReferenceById(Id);
        }
    }
    /*void*/ static DisposeJSObjectReferenceById(/*long*/ id)
    {
    }
}

class Microsoft_JSInterop_Implementation_JSObjectReference extends System_IDisposable(Microsoft_JSInterop_IJSObjectReference(object))
{
    /*JSRuntime*/ _jsRuntime = null;
    /*bool*/ _backingField_Disposed = null;
    /*bool*/ get Disposed()
    {
        return _backingField_Disposed;
    }
    /*bool*/ set Disposed(value)
    {
        _backingField_Disposed = value;
    }
    /*long*/ _backingField_Id = null;
    /*long*/ get Id()
    {
        return _backingField_Id;
    }
    constructor(/*JSRuntime*/ jsRuntime, /*long*/ id)
    {
        super();
        _jsRuntime = jsRuntime;
        Id = id;
    }
    /*Task<TValue>*/ InvokeAsync(TValue, /*string*/ identifier, /*object[]*/ args)
    {
        ThrowIfDisposed();
        return _jsRuntime.InvokeAsync(TValue, Id, identifier, JSCallType.FunctionCall, args);
    }
    /*Task<TValue>*/ InvokeAsync(TValue, /*string*/ identifier, /*CancellationToken*/ cancellationToken, /*object[]*/ args)
    {
        ThrowIfDisposed();
        return _jsRuntime.InvokeAsync(TValue, Id, identifier, JSCallType.FunctionCall, cancellationToken, args);
    }
    /*Task<IJSObjectReference>*/ InvokeNewAsync(/*string*/ identifier, /*object[]*/ args)
    {
        ThrowIfDisposed();
        return _jsRuntime.InvokeAsync(IJSObjectReference, Id, identifier, JSCallType.NewCall, args);
    }
    /*Task<IJSObjectReference>*/ InvokeNewAsync(/*string*/ identifier, /*CancellationToken*/ cancellationToken, /*object[]*/ args)
    {
        ThrowIfDisposed();
        return _jsRuntime.InvokeAsync(IJSObjectReference, Id, identifier, JSCallType.NewCall, cancellationToken, args);
    }
    /*Task<TValue>*/ GetValueAsync(TValue, /*string*/ identifier)
    {
        ThrowIfDisposed();
        return _jsRuntime.InvokeAsync(TValue, Id, identifier, JSCallType.GetValue, null);
    }
    /*Task<TValue>*/ GetValueAsync(TValue, /*string*/ identifier, /*CancellationToken*/ cancellationToken)
    {
        ThrowIfDisposed();
        return _jsRuntime.InvokeAsync(TValue, Id, identifier, JSCallType.GetValue, null);
    }
    /*Task*/ async SetValueAsync(TValue, /*string*/ identifier, /*TValue*/ value)
    {
        ThrowIfDisposed();
        await _jsRuntime.InvokeAsync(TValue, Id, identifier, JSCallType.SetValue, [ value ]);
    }
    /*Task*/ async SetValueAsync(TValue, /*string*/ identifier, /*TValue*/ value, /*CancellationToken*/ cancellationToken)
    {
        ThrowIfDisposed();
        await _jsRuntime.InvokeAsync(TValue, Id, identifier, JSCallType.SetValue, [ value ]);
    }
    /*void*/ async Dispose()
    {
        if (Disposed)
        {
            Disposed = true;
            await _jsRuntime.InvokeVoidAsync("DotNet.disposeJSObjectReferenceById", Id);
        }
    }
    /*void*/ ThrowIfDisposed()
    {
        if (Disposed)
        throw new ObjectDisposedException("disposed");
    }
}


class Microsoft_JSInterop_Implementation_JSStreamReference extends System_IDisposable(Microsoft_JSInterop_IJSStreamReference(Microsoft_JSInterop_Implementation_JSObjectReference))
{
    /*JSRuntime*/ _jsRuntime = null;
    /*long*/ _backingField_Length = null;
    /*long*/ get Length()
    {
        return _backingField_Length;
    }
    constructor(/*JSRuntime*/ jsRuntime, /*long*/ id, /*long*/ totalLength)
    {
        super(jsRuntime, id);
        if (totalLength <= 0)
        {
            throw new ArgumentOutOfRangeException(nameof(totalLength), totalLength, "Length must be a positive value.");
        }
        _jsRuntime = jsRuntime;
        Length = totalLength;
    }
    /*Task<Stream>*/ async OpenReadStreamAsync(/*long*/ maxAllowedSize, /*CancellationToken*/ cancellationToken)
    {
        if (Length > maxAllowedSize)
        {
            throw new ArgumentOutOfRangeException(nameof(maxAllowedSize), `The incoming data stream of length ${Length} exceeds the maximum allowed length ${maxAllowedSize}.`);
        }
        return await _jsRuntime.ReadJSDataAsStreamAsync(this, Length, cancellationToken);
    }
}


static class Microsoft_JSInterop_Infrastructure_DotNetDispatcher
{
    /*string*/ DisposeDotNetObjectReferenceMethodName = "__Dispose";
    /*ConcurrentDictionary<AssemblyKey, IReadOnlyDictionary<string, (MethodInfo, Type[])>>*/ static _cachedMethodsByAssembly = new ConcurrentDictionary(AssemblyKey, IReadOnlyDictionary(string, BlazorJs.TupleType(MethodInfo, Type)))();
    /*ConcurrentDictionary<Type, IReadOnlyDictionary<string, (MethodInfo, Type[])>>*/ static _cachedMethodsByType = new ConcurrentDictionary(Type, IReadOnlyDictionary(string, BlazorJs.TupleType(MethodInfo, Type)))();
    /*ConcurrentDictionary<Type, Func<object, Task>>*/ static _cachedConvertToTaskByType = new ConcurrentDictionary(Type, Func(object, Task))();
    /*MethodInfo*/ static _taskConverterMethodInfo = DotNetDispatcher.GetMethod(nameof(CreateValueTaskConverter), BindingFlags.NonPublic  | BindingFlags.Static);
    /*string*/ static Invoke(/*JSRuntime*/ jsRuntime, /*in DotNetInvocationInfo*/ invocationInfo, /*string*/ argsJson)
    {
        /*// This method doesn't need [JSInvokable] because the platform is responsible for having
            // some way to dispatch calls here. The logic inside here is the thing that checks whether
            // the targeted method has [JSInvokable]. It is not itself subject to that restriction,
            // because there would be nobody to police that. This method *is* the police.

            IDotNetObjectReference*/ let targetInstance = BlazorJs.getDefault();
        if (invocationInfo.DotNetObjectId  !== BlazorJs.getDefault())
        {
            targetInstance = jsRuntime.GetObjectReference(invocationInfo.DotNetObjectId);
        }
        /*var*/ let syncResult = InvokeSynchronously(jsRuntime, invocationInfo, targetInstance, argsJson);
        if (syncResult === null)
        {
            return null;
        }
        return JsonSerializer.Serialize(syncResult, jsRuntime.JsonSerializerOptions);
    }
    /*void*/ static BeginInvokeDotNet(/*JSRuntime*/ jsRuntime, /*DotNetInvocationInfo*/ invocationInfo, /*string*/ argsJson)
    {
        /*// This method doesn't need [JSInvokable] because the platform is responsible for having
            // some way to dispatch calls here. The logic inside here is the thing that checks whether
            // the targeted method has [JSInvokable]. It is not itself subject to that restriction,
            // because there would be nobody to police that. This method *is* the police.

            // Using ExceptionDispatchInfo here throughout because we want to always preserve
            // original stack traces.

            var*/ let callId = invocationInfo.CallId;
        /*object*/ let syncResult = null;
        /*//ExceptionDispatchInfo? syncException = null;
            Exception*/ let syncException = null;
        /*IDotNetObjectReference*/ let targetInstance = null;
        try
        {
            if (invocationInfo.DotNetObjectId  !== BlazorJs.getDefault())
            {
                targetInstance = jsRuntime.GetObjectReference(invocationInfo.DotNetObjectId);
            }
            syncResult = InvokeSynchronously(jsRuntime, invocationInfo, targetInstance, argsJson);
        }
        catch(ex)
        {
            syncException = ex;
        }
        if (callId === null)
        {
            return ;
        }
        else if (syncException !== null)
        {
            jsRuntime.EndInvokeDotNet(invocationInfo, new DotNetInvocationResult(syncException, "InvocationFailure"));
        }
        else if (syncResult instanceof Task, task = syncResult)
        {
            task.ContinueWith(function(/**/ t)
            {
                return EndInvokeDotNetAfterTask(t, jsRuntime, invocationInfo);
            });
        }
        else if (syncResult instanceof Task, TaskResult = syncResult)
        {
            TaskResult.ContinueWith(function(/**/ t)
            {
                return EndInvokeDotNetAfterTask(t, jsRuntime, invocationInfo);
            });
        }
        else if (syncResult !== null && syncResult.GetType().IsGenericType
 && syncResult.GetType().GetGenericTypeDefinition() === Task())
        {
            /*// It's a Task<T>. We'll coerce it to a Task so that we can attach a continuation.
                var*/ let innerTask = GetTaskByType(syncResult?.GetType().GetGenericArguments()[0], syncResult);
            innerTask.ContinueWith(function(/**/ t)
            {
                return EndInvokeDotNetAfterTask(t, jsRuntime, invocationInfo);
            });
        }
        else 
        {
            /*var*/ let syncResultJson = JsonSerializer.Serialize(syncResult, jsRuntime.JsonSerializerOptions);
            /*var*/ let dispatchResult = new DotNetInvocationResult(syncResultJson);
            jsRuntime.EndInvokeDotNet(invocationInfo, dispatchResult);
        }
    }
    /*void*/ static EndInvokeDotNetAfterTask(/*Task*/ task, /*JSRuntime*/ jsRuntime, /*in DotNetInvocationInfo*/ invocationInfo)
    {
        if (task.Exception  !== null)
        {
            /*var*/ let exceptionDispatchInfo = task.Exception.GetBaseException();
            /*var*/ let dispatchResult = new DotNetInvocationResult(exceptionDispatchInfo, "InvocationFailure");
            jsRuntime.EndInvokeDotNet(invocationInfo, dispatchResult);
        }
        /*var*/ let result = TaskGenericsUtil.GetTaskResult(task);
        /*var*/ let resultJson = JsonSerializer.Serialize(result, jsRuntime.JsonSerializerOptions);
        jsRuntime.EndInvokeDotNet(invocationInfo, new DotNetInvocationResult(resultJson));
    }
    /*object*/ static InvokeSynchronously(/*JSRuntime*/ jsRuntime, /*in DotNetInvocationInfo*/ callInfo, /*IDotNetObjectReference*/ objectReference, /*string*/ argsJson)
    {
        /*var*/ let assemblyName = callInfo.AssemblyName;
        /*var*/ let methodIdentifier = callInfo.MethodIdentifier;
        /*AssemblyKey*/ let assemblyKey;
        /*MethodInfo*/ let methodInfo;
        /*Type[]*/ let parameterTypes;
        if (objectReference)
        {
            assemblyKey = new AssemblyKey(assemblyName);
            BlazorJs.TupleValue({ Item1: methodInfo, Item2: parameterTypes }) = GetCachedMethodInfo(assemblyKey, methodIdentifier);
        }
        else 
        {
            if (assemblyName !== null)
            {
                throw new ArgumentException(`For instance method calls, '${nameof(assemblyName)}' should be null. Value received: '${assemblyName}'.`);
            }
            if (string.Equals(DisposeDotNetObjectReferenceMethodName, methodIdentifier, StringComparison.Ordinal))
            {
                objectReference.Dispose();
                return BlazorJs.getDefault();
            }
            BlazorJs.TupleValue({ Item1: methodInfo, Item2: parameterTypes }) = GetCachedMethodInfo(objectReference, methodIdentifier);
        }
        /*var*/ let suppliedArgs = ParseArguments(jsRuntime, methodIdentifier, argsJson, parameterTypes);
        try
        {
            return methodInfo.Invoke(objectReference?.Value, suppliedArgs);
        }
        catch(tie)
        {
            if (tie.InnerException  !== null)
            {
                throw tie.InnerException;
            }
            throw tie;
        }
        finally
        {
            {
                jsRuntime.ByteArraysToBeRevived.Clear();
            }
        }
    }
    /*object[]*/ static ParseArguments(/*JSRuntime*/ jsRuntime, /*string*/ methodIdentifier, /*string*/ $arguments, /*Type[]*/ parameterTypes)
    {
        if (parameterTypes.Length  === 0)
        {
            return Array.Empty(object);
        }
        /*var*/ let count = Encoding.UTF8.GetByteCount($arguments);
        try
        {
            /*var*/ let datas = JsonSerializer.DeserializeImpl($arguments).As(BlazorJs.TypeArray(object));
            /*var*/ let suppliedArgs = new Array(parameterTypes.Length);
            /*var*/ let index = 0;
            while(index < parameterTypes.Length)
            {
                /*var*/ let parameterType = parameterTypes[index];
                suppliedArgs[index] = JsonSerializer.Convert(datas[index], parameterType);
                index++;
            }
            if (index < parameterTypes.Length)
            {
                throw new ArgumentException(`The call to '${methodIdentifier}' expects '${parameterTypes.Length}' parameters, but received '${index}'.`);
            }
            return suppliedArgs;
        }
        finally
        {
            {
            }
        }
    }
    /*void*/ static EndInvokeJS(/*JSRuntime*/ jsRuntime, /*string*/ $arguments)
    {
        /*var*/ let data = JsonSerializer.DeserializeImpl($arguments).As(BlazorJs.TypeArray(object));
        /*var*/ let taskId = data[0].As(long);
        /*var*/ let success = data[1].As(bool);
        jsRuntime.EndInvokeJS(taskId, success, data[2]);
    }
    /*void*/ static ReceiveByteArray(/*JSRuntime*/ jsRuntime, /*int*/ id, /*byte[]*/ data)
    {
        jsRuntime.ReceiveByteArray(id, data);
    }
    /*(MethodInfo, Type[])*/ static GetCachedMethodInfo(/*AssemblyKey*/ assemblyKey, /*string*/ methodIdentifier)
    {
        let result = null;
        let $ref1 = { set value(v){ result = v } };
        ArgumentExceptionExtension.ThrowIfNullOrWhiteSpace(assemblyKey.AssemblyName);
        ArgumentExceptionExtension.ThrowIfNullOrWhiteSpace(methodIdentifier);
        /*var*/ let assemblyMethods = _cachedMethodsByAssembly.GetOrAdd(assemblyKey, ScanAssemblyForCallableMethods);
        if (assemblyMethods.TryGetValue(methodIdentifier, $ref1))
        {
            return result;
        }
        else 
        {
            throw new ArgumentException(`The assembly '${assemblyKey.AssemblyName}' does not contain a public invokable method with [${nameof(JSInvokableAttribute)}(\"${methodIdentifier}\")].`);
        }
    }
    /*Task*/ static GetTaskByType(/*Type*/ type, /*object*/ obj)
    {
        /*var*/ let converterDelegate = _cachedConvertToTaskByType.GetOrAdd(type, function(/*Type*/ t, /*MethodInfo*/ taskConverterMethodInfo)
        {
            return BlazorJs.Cast(taskConverterMethodInfo.MakeGenericMethod(t).CreateDelegate/*<Func<object, Task>>*/(), Func(object, Task));
        }, _taskConverterMethodInfo);
        return converterDelegate.Invoke(obj);
    }
    /*Task*/ static CreateValueTaskConverter(T, /*object*/ result)
    {
        return BlazorJs.Cast(result, Task(T));
    }
    /*(MethodInfo methodInfo, Type[] parameterTypes)*/ static GetCachedMethodInfo(/*IDotNetObjectReference*/ objectReference, /*string*/ methodIdentifier)
    {
        let result = null;
        let $ref1 = { set value(v){ result = v } };
        /*var*/ let type = objectReference.Value.GetType();
        /*// Suppressed with "pragma warning disable" in addition to WarningSuppressions.xml so ILLink Roslyn Anayzer doesn't report the warning.
#pragma warning disable IL2111 // Method with parameters or return value with `DynamicallyAccessedMembersAttribute` is accessed via reflection. Trimmer can't guarantee availability of the requirements of the method.
            var*/ let assemblyMethods = _cachedMethodsByType.GetOrAdd(type, ScanTypeForCallableMethods);
        if (assemblyMethods.TryGetValue(methodIdentifier, $ref1))
        {
            return result;
        }
        else 
        {
            throw new ArgumentException(`The type '${type.Name}' does not contain a public invokable method with [${nameof(JSInvokableAttribute)}(\"${methodIdentifier}\")].`);
        }
        /*Dictionary<string, (MethodInfo, Type[])>*/ function ScanTypeForCallableMethods(/*Type*/ itype)
        {
            /*var*/ let iresult = new Dictionary(string, BlazorJs.TupleType(MethodInfo, Type))(StringComparer.Ordinal);
            BlazorJs.forEach(itype.GetMethods(BindingFlags.Instance  | BindingFlags.Public), function(method, $_i)
            {
                if (method.ContainsGenericParameters  || method.IsDefined(JSInvokableAttribute, { inherit : false }))
                {
                }
                BlazorJs.forEach(method.GetCustomAttributes(JSInvokableAttribute, false), function(attr, $_i)
                {
                    /*var*/ let identifier = attr.Identifier  ?? method.Name;
                    /*var*/ let parameterTypes = GetParameterTypes(method);
                    if (iresult.ContainsKey(identifier))
                    {
                        throw new InvalidOperationException(`The type ${itype.Name} contains more than one ` + `[JSInvokable] method with identifier '${identifier}'. All [JSInvokable] methods within the same ` + "type must have different identifiers. You can pass a custom identifier as a parameter to " + `the [JSInvokable] attribute.`);
                    }
                    iresult.Add(identifier, BlazorJs.TupleValue({ Item1: method, Item2: parameterTypes }));
                });
            });
            return iresult;
        }
    }
    /*Dictionary<string, (MethodInfo, Type[])>*/ static ScanAssemblyForCallableMethods(/*AssemblyKey*/ assemblyKey)
    {
        /*// TODO: Consider looking first for assembly-level attributes (i.e., if there are any,
            // only use those) to avoid scanning, especially for framework assemblies.
            var*/ let result = new Dictionary(string, BlazorJs.TupleType(MethodInfo, Type))(StringComparer.Ordinal);
        /*var*/ let exportedTypes = GetRequiredLoadedAssembly(assemblyKey).GetTypes();
        BlazorJs.forEach(exportedTypes, function(type, $_i)
        {
            BlazorJs.forEach(type.GetMethods(BindingFlags.Public  | BindingFlags.Static), function(method, $_i)
            {
                if (method.ContainsGenericParameters  || method.IsDefined(JSInvokableAttribute, { inherit : false }))
                {
                }
                BlazorJs.forEach(method.GetCustomAttributes(JSInvokableAttribute, false), function(attr, $_i)
                {
                    /*var*/ let identifier = attr.Identifier  ?? method.Name;
                    /*var*/ let parameterTypes = GetParameterTypes(method);
                    if (result.ContainsKey(identifier))
                    {
                        throw new InvalidOperationException(`The assembly '${assemblyKey.AssemblyName}' contains more than one ` + `[JSInvokable] method with identifier '${identifier}'. All [JSInvokable] methods within the same ` + `assembly must have different identifiers. You can pass a custom identifier as a parameter to ` + `the [JSInvokable] attribute.`);
                    }
                    result.Add(identifier, BlazorJs.TupleValue({ Item1: method, Item2: parameterTypes }));
                });
            });
        });
        return result;
    }
    /*Type[]*/ static GetParameterTypes(/*MethodInfo*/ method)
    {
        /*var*/ let parameters = method.GetParameters();
        if (parameters.Length  === 0)
        {
            return Array.Empty(Type);
        }
        /*var*/ let parameterTypes = new Array(parameters.Length);
        for(/*var*/ let i = 0; i < parameters.Length; i++)
        {
            parameterTypes[i] = parameters[i].ParameterType;
        }
        return parameterTypes;
    }
    /*Assembly*/ static GetRequiredLoadedAssembly(/*AssemblyKey*/ assemblyKey)
    {
        /*// We don't want to load assemblies on demand here, because we don't necessarily trust
            // "assemblyName" to be something the developer intended to load. So only pick from the
            // set of already-loaded assemblies.
            // In some edge cases this might force developers to explicitly call something on the
            // target assembly (from .NET) before they can invoke its allowed methods from JS.

            // Using the last to workaround https://github.com/dotnet/arcade/issues/2816.
            // In most ordinary scenarios, we wouldn't have two instances of the same Assembly in the AppDomain
            // so this doesn't change the outcome.
            Assembly*/ let assembly = null;
        BlazorJs.forEach(AppDomain.CurrentDomain.GetAssemblies(), function(a, $_i)
        {
            if (new AssemblyKey(a).Equals(assemblyKey))
            {
                assembly = a;
            }
        });
        return BlazorJs.FirstOf(assembly, function(){ throw new ArgumentException(`There is no loaded assembly with the name '${assemblyKey.AssemblyName}'.`) });
    }
    static Microsoft_JSInterop_Infrastructure_DotNetDispatcher_MetadataUpdateHandler = class
    {
        /*void*/ static ClearCache(/*Type[]*/ _)
        {
            _cachedMethodsByAssembly.Clear();
            _cachedMethodsByType.Clear();
            _cachedConvertToTaskByType.Clear();
        }
    }
    static Microsoft_JSInterop_Infrastructure_DotNetDispatcher_AssemblyKey = class extends H5_IH5Class(System_IEquatable(Microsoft_JSInterop_Infrastructure_DotNetDispatcher_AssemblyKey)(System_ValueType))
    {
        constructor(/*Assembly*/ assembly)
        {
            super();
            Assembly = assembly;
            AssemblyName = assembly.GetName().Name;
        }
        constructor(/*string*/ assemblyName)
        {
            super();
            Assembly = null;
            AssemblyName = assemblyName;
        }
        /*Assembly*/ _backingField_Assembly = null;
        /*Assembly*/ get Assembly()
        {
            return _backingField_Assembly;
        }
        /*string*/ _backingField_AssemblyName = null;
        /*string*/ get AssemblyName()
        {
            return _backingField_AssemblyName;
        }
        /*bool*/ Equals(/*AssemblyKey*/ other)
        {
            if (Assembly !== null && other.Assembly  !== null)
            {
                return Assembly === other.Assembly;
            }
            return AssemblyName.Equals(other.AssemblyName, StringComparison.Ordinal);
        }
        /*int*/ GetHashCode()
        {
            return StringComparer.Ordinal.GetHashCode(AssemblyName);
        }
    }
}

class Microsoft_JSInterop_Infrastructure_DotNetInvocationInfo extends System_ValueType
{
    constructor(/*string*/ assemblyName, /*string*/ methodIdentifier, /*long*/ dotNetObjectId, /*string*/ callId)
    {
        super();
        CallId = callId;
        AssemblyName = assemblyName;
        MethodIdentifier = methodIdentifier;
        DotNetObjectId = dotNetObjectId;
    }
    /*string*/ _backingField_AssemblyName = null;
    /*string*/ get AssemblyName()
    {
        return _backingField_AssemblyName;
    }
    /*string*/ _backingField_MethodIdentifier = null;
    /*string*/ get MethodIdentifier()
    {
        return _backingField_MethodIdentifier;
    }
    /*long*/ _backingField_DotNetObjectId = null;
    /*long*/ get DotNetObjectId()
    {
        return _backingField_DotNetObjectId;
    }
    /*string*/ _backingField_CallId = null;
    /*string*/ get CallId()
    {
        return _backingField_CallId;
    }
}

class Microsoft_JSInterop_Infrastructure_DotNetInvocationResult extends System_ValueType
{
    constructor(/*Exception*/ exception, /*string*/ errorKind)
    {
        super();
        ResultJson = BlazorJs.getDefault();
        Exception = BlazorJs.FirstOf(exception, function(){ throw new ArgumentNullException(nameof(exception)) });
        ErrorKind = errorKind;
        Success = false;
    }
    constructor(/*string*/ resultJson)
    {
        super();
        ResultJson = resultJson;
        Exception = BlazorJs.getDefault();
        ErrorKind = BlazorJs.getDefault();
        Success = true;
    }
    /*Exception*/ _backingField_Exception = null;
    /*Exception*/ get Exception()
    {
        return _backingField_Exception;
    }
    /*string*/ _backingField_ErrorKind = null;
    /*string*/ get ErrorKind()
    {
        return _backingField_ErrorKind;
    }
    /*string*/ _backingField_ResultJson = null;
    /*string*/ get ResultJson()
    {
        return _backingField_ResultJson;
    }
    /*bool*/ _backingField_Success = null;
    /*bool*/ get Success()
    {
        return _backingField_Success;
    }
}




const Microsoft_JSInterop_Infrastructure_IDotNetObjectReference = (Base) => class extends Base
{
    /*object*/ _backingField_Value = null;
    /*object*/ get Value()
    {
        return _backingField_Value;
    }
}

const Microsoft_JSInterop_Infrastructure_IJSVoidResult = (Base) => class extends Base
{
}

static class Microsoft_JSInterop_Infrastructure_JSCallType
{
    FunctionCall = 1;
    NewCall = 2;
    GetValue = 3;
    SetValue = 4;
}

class Microsoft_JSInterop_Infrastructure_JSInvocationInfo extends System_ValueType
{
    constructor()
    {
        super();
    }
    /*string*/ _argsJson = null;
    /*long*/ _backingField_AsyncHandle = null;
    /*long*/ get AsyncHandle()
    {
        return _backingField_AsyncHandle;
    }
    /*long*/ set AsyncHandle(value)
    {
        _backingField_AsyncHandle = value;
    }
    /*long*/ _backingField_TargetInstanceId = null;
    /*long*/ get TargetInstanceId()
    {
        return _backingField_TargetInstanceId;
    }
    /*long*/ set TargetInstanceId(value)
    {
        _backingField_TargetInstanceId = value;
    }
    /*string*/ _backingField_Identifier = null;
    /*string*/ get Identifier()
    {
        return _backingField_Identifier;
    }
    /*string*/ set Identifier(value)
    {
        _backingField_Identifier = value;
    }
    /*JSCallType*/ _backingField_CallType = null;
    /*JSCallType*/ get CallType()
    {
        return _backingField_CallType;
    }
    /*JSCallType*/ set CallType(value)
    {
        _backingField_CallType = value;
    }
    /*JSCallResultType*/ _backingField_ResultType = null;
    /*JSCallResultType*/ get ResultType()
    {
        return _backingField_ResultType;
    }
    /*JSCallResultType*/ set ResultType(value)
    {
        _backingField_ResultType = value;
    }
    /*string*/ get ArgsJson()
    {
        return _argsJson ?? "[]";
    }
    /*string*/ set ArgsJson(value)
    {
        _argsJson = value;
    }
}



static class Microsoft_JSInterop_Infrastructure_TaskGenericsUtil
{
    /*ConcurrentDictionary<Type, ITaskResultGetter>*/ static _cachedResultGetters = new ConcurrentDictionary(Type, ITaskResultGetter)();
    /*ConcurrentDictionary<Type, ITcsResultSetter>*/ static _cachedResultSetters = new ConcurrentDictionary(Type, ITcsResultSetter)();
    /*void*/ static SetTaskCompletionSourceResult(/*object*/ taskCompletionSource, /*object*/ result)
    {
        return CreateResultSetter(taskCompletionSource).SetResult(taskCompletionSource, result);
    }
    /*void*/ static SetTaskCompletionSourceException(/*object*/ taskCompletionSource, /*Exception*/ exception)
    {
        return CreateResultSetter(taskCompletionSource).SetException(taskCompletionSource, exception);
    }
    /*Type*/ static GetTaskCompletionSourceResultType(/*object*/ taskCompletionSource)
    {
        return CreateResultSetter(taskCompletionSource).ResultType;
    }
    /*object*/ static GetTaskResult(/*Task*/ task)
    {
        /*var*/ let getter = _cachedResultGetters.GetOrAdd(task.GetType(), function(/**/ taskInstanceType)
        {
            /*var*/ let resultType = GetTaskResultType(taskInstanceType);
            return resultType === null ? new VoidTaskResultGetter() : BlazorJs.Cast(Activator.CreateInstance(TaskResultGetter().MakeGenericType(resultType)), ITaskResultGetter);
        });
        return getter.GetResult(task);
    }
    /*Type*/ static GetTaskResultType(/*Type*/ taskType)
    {
        while(taskType !== Task && (taskType.IsGenericType  || taskType.GetGenericTypeDefinition() !== Task()))
        {
            taskType = BlazorJs.FirstOf(taskType.BaseType
, function(){ throw new ArgumentException(`The type '${taskType.FullName}' is not inherited from '${Task.FullName}'.`) });
        }
        return taskType.IsGenericType
 ? taskType.GetGenericArguments()[0] : null;
    }
    static Microsoft_JSInterop_Infrastructure_TaskGenericsUtil_ITcsResultSetter = (Base) => class extends Base
    {
        /*Type*/ _backingField_ResultType = null;
        /*Type*/ get ResultType()
        {
            return _backingField_ResultType;
        }
    }
    static Microsoft_JSInterop_Infrastructure_TaskGenericsUtil_ITaskResultGetter = (Base) => class extends Base
    {
    }
    static Microsoft_JSInterop_Infrastructure_TaskGenericsUtil_TaskResultGetter = (T) => class extends Microsoft_JSInterop_Infrastructure_TaskGenericsUtil_ITaskResultGetter(object)
    {
        constructor()
        {
            super();
        }
        /*object*/ GetResult(/*Task*/ task)
        {
            return (BlazorJs.Cast(task, Task(T))).Result;
        }
    }
    static Microsoft_JSInterop_Infrastructure_TaskGenericsUtil_VoidTaskResultGetter = class extends Microsoft_JSInterop_Infrastructure_TaskGenericsUtil_ITaskResultGetter(object)
    {
        constructor()
        {
            super();
        }
        /*object*/ GetResult(/*Task*/ task)
        {
            task.Wait();
            return null;
        }
    }
    static Microsoft_JSInterop_Infrastructure_TaskGenericsUtil_TcsResultSetter = (T) => class extends Microsoft_JSInterop_Infrastructure_TaskGenericsUtil_ITcsResultSetter(object)
    {
        constructor()
        {
            super();
        }
        /*Type*/ get ResultType()
        {
            return T;
        }
        /*void*/ SetResult(/*object*/ tcs, /*object*/ result)
        {
            /*var*/ let typedTcs = BlazorJs.Cast(tcs, TaskCompletionSource(T));
            /*// If necessary, attempt a cast
                var*/ let typedResult = result instanceof T, resultT = result ? resultT : result === null && T.IsGenericType  && T.GetGenericTypeDefinition() === Nullable() ? T?.default() ?? null : BlazorJs.Cast(Convert.ChangeType(result, T, CultureInfo.InvariantCulture), T);
            typedTcs.SetResult(typedResult);
        }
        /*void*/ SetException(/*object*/ tcs, /*Exception*/ exception)
        {
            /*var*/ let typedTcs = BlazorJs.Cast(tcs, TaskCompletionSource(T));
            typedTcs.SetException(exception);
        }
    }
    /*ITcsResultSetter*/ static CreateResultSetter(/*object*/ taskCompletionSource)
    {
        return _cachedResultSetters.GetOrAdd(taskCompletionSource.GetType(), function(/**/ tcsType)
        {
            /*var*/ let resultType = tcsType.GetGenericArguments()[0];
            return BlazorJs.Cast(Activator.CreateInstance(TcsResultSetter().MakeGenericType(resultType)), ITcsResultSetter);
        });
    }
}

class System_ComponentModel_DataAnnotations_Schema_ColumnAttribute extends System_Attribute
{
    /*string*/ _name = null;
    /*string*/ _typeName = null;
    /*int*/ _order = 1;
    constructor()
    {
        super();
    }
    constructor(/*string*/ name)
    {
        super();
        if (string.IsNullOrWhiteSpace(name))
        {
            throw new ArgumentException("ArgumentIsNullOrWhitespace", nameof(name));
        }
        _name = name;
    }
    /*string*/ get Name()
    {
        return _name;
    }
    /*int*/ get Order()
    {
        return _order;
    }
    /*int*/ set Order(value)
    {
        if (value < 0)
        {
            throw new ArgumentOutOfRangeException("value");
        }
        _order = value;
    }
    /*string*/ get TypeName()
    {
        return _typeName;
    }
    /*string*/ set TypeName(value)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            throw new ArgumentException("ArgumentIsNullOrWhitespace", nameof(value));
        }
        _typeName = value;
    }
}

class System_ComponentModel_DataAnnotations_Schema_ComplexTypeAttribute extends System_Attribute
{
    constructor()
    {
        super();
    }
}

class System_ComponentModel_DataAnnotations_Schema_DatabaseGeneratedAttribute extends System_Attribute
{
    constructor(/*DatabaseGeneratedOption*/ databaseGeneratedOption)
    {
        super();
        if ((Enum.IsDefined(DatabaseGeneratedOption, databaseGeneratedOption)))
        {
            throw new ArgumentOutOfRangeException("databaseGeneratedOption");
        }
        DatabaseGeneratedOption = databaseGeneratedOption;
    }
    /*DatabaseGeneratedOption*/ _backingField_DatabaseGeneratedOption = null;
    /*DatabaseGeneratedOption*/ get DatabaseGeneratedOption()
    {
        return _backingField_DatabaseGeneratedOption;
    }
    /*DatabaseGeneratedOption*/ set DatabaseGeneratedOption(value)
    {
        _backingField_DatabaseGeneratedOption = value;
    }
}

static class System_ComponentModel_DataAnnotations_Schema_DatabaseGeneratedOption
{
    None = 0;
    Identity = 1;
    Computed = 2;
}

class System_ComponentModel_DataAnnotations_Schema_ForeignKeyAttribute extends System_Attribute
{
    /*string*/ _name = null;
    constructor(/*string*/ name)
    {
        super();
        if (string.IsNullOrWhiteSpace(name))
        {
            throw new ArgumentException("ArgumentIsNullOrWhitespace", nameof(name));
        }
        _name = name;
    }
    /*string*/ get Name()
    {
        return _name;
    }
}

class System_ComponentModel_DataAnnotations_Schema_InversePropertyAttribute extends System_Attribute
{
    /*string*/ _property = null;
    constructor(/*string*/ property)
    {
        super();
        if (string.IsNullOrWhiteSpace(property))
        {
            throw new ArgumentException("ArgumentIsNullOrWhitespace", nameof(property));
        }
        _property = property;
    }
    /*string*/ get Property()
    {
        return _property;
    }
}

class System_ComponentModel_DataAnnotations_Schema_NotMappedAttribute extends System_Attribute
{
    constructor()
    {
        super();
    }
}

class System_ComponentModel_DataAnnotations_Schema_TableAttribute extends System_Attribute
{
    /*string*/ _name = null;
    /*string*/ _schema = null;
    constructor(/*string*/ name)
    {
        super();
        if (string.IsNullOrWhiteSpace(name))
        {
            throw new ArgumentException("ArgumentIsNullOrWhitespace", nameof(name));
        }
        _name = name;
    }
    /*string*/ get Name()
    {
        return _name;
    }
    /*string*/ get Schema()
    {
        return _schema;
    }
    /*string*/ set Schema(value)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            throw new ArgumentException("ArgumentIsNullOrWhitespace", nameof(value));
        }
        _schema = value;
    }
}

class System_Net_Http_BrowserHttpContent extends System_Net_Http_HttpContent
{
    /*byte[]*/ _data = null;
    /*int*/ _length = 1;
    /*Response*/ _response = null;
    constructor(/*Response*/ response)
    {
        super();
        _response = response;
    }
    /*Task<byte[]>*/ async GetResponseData(/*CancellationToken*/ cancellationToken)
    {
        if (_data !== null)
        {
            return _data;
        }
        /*ArrayBuffer*/ let buffer = (await Task.FromPromise(BlazorJs.TypeArray(ArrayBuffer), _response.arrayBuffer().As(IPromise), null))[0];
        _length = BlazorJs.Cast(buffer.byteLength, int);
        _data = new Array(_length);
        return new Uint8Array(buffer).As(BlazorJs.TypeArray(byte));
    }
    /*Task<Stream>*/ async CreateContentReadStreamAsync()
    {
        /*byte[]*/ let data = await GetResponseData(CancellationToken.None);
        return new MemoryStream(data, { writable : false });
    }
    /*Task*/ SerializeToStreamAsync(/*Stream*/ stream)
    {
        return SerializeToStreamAsync(stream, CancellationToken.None);
    }
    /*Task*/ async SerializeToStreamAsync(/*Stream*/ stream, /*CancellationToken*/ cancellationToken)
    {
        if (stream === null)
        throw new ArgumentNullException(nameof(stream));
        /*byte[]*/ let data = await GetResponseData(cancellationToken);
        await stream.WriteAsync(data, cancellationToken);
    }
    /*bool*/ TryComputeLength(/*out long*/ length)
    {
        if (_length !== 1)
        {
            length = _length;
            return true;
        }
        length = 0;
        return false;
    }
}


class System_Net_Http_BrowserHttpHandler extends System_Net_Http_HttpMessageHandler
{
    constructor()
    {
        super();
    }
    /*bool*/ _allowAutoRedirect = true;
    /*bool*/ _isAllowAutoRedirectTouched = null;
    /*bool*/ get AllowAutoRedirect()
    {
        return _allowAutoRedirect;
    }
    /*bool*/ set AllowAutoRedirect(value)
    {
        _allowAutoRedirect = value;
        _isAllowAutoRedirectTouched = true;
    }
    /*bool*/ SupportsAutomaticDecompression = false;
    /*bool*/ SupportsProxy = false;
    /*bool*/ SupportsRedirectConfiguration = true;
    /*Dictionary<string, object>*/ _properties = null;
    /*IDictionary<string, object>*/ get Properties()
    {
        return _properties = _properties ?? new Dictionary(string, object)();
    }
    /*HttpResponseMessage*/ Send(/*HttpRequestMessage*/ request, /*CancellationToken*/ cancellationToken)
    {
        throw new InvalidOperationException();
    }
    /*Request*/ CreateFetchRequest(/*HttpRequestMessage*/ mrequest)
    {
        /*int*/ let headerCount = mrequest.Headers.Count  + (mrequest.Content?.Headers.Count  ?? 0);
        /*var*/ let headerNames = new List(string)(headerCount);
        /*var*/ let headerValues = new List(string)(headerCount);
        BlazorJs.forEach(mrequest.Headers, function(header, $_i)
        {
            BlazorJs.forEach(header.Value, function(value, $_i)
            {
                headerNames.Add(header.Key);
                headerValues.Add(value);
            });
        });
        if (mrequest.Content  !== null)
        {
            BlazorJs.forEach(mrequest.Content.Headers, function(header, $_i)
            {
                BlazorJs.forEach(header.Value, function(value, $_i)
                {
                    headerNames.Add(header.Key);
                    headerValues.Add(value);
                });
            });
        }
        /*var*/ let stream = mrequest.Content?.ReadAsStream();
        /*byte[]*/ let bts = stream !== null ? new Array(stream.Length) : null;
        stream?.Read(bts, 0, bts.Length);
        /*var*/ let init = BlazorJs.PopulateProperty(new RequestInit(), function(/*RequestInit*/ $obj)
        {
            $obj.method = mrequest.Method.Method;
        });
        if (headerNames.Count  > 0)
        {
            init.headers  = HeadersInit.Create(headerNames.ToArray(), headerValues.ToArray());
        }
        if (bts !== null)
        {
            init.body  = Int8Array.from(BlazorJs.Cast(BlazorJs.Cast(bts, object), ArrayLike(sbyte)));
        }
        return new Request(mrequest.RequestUri.ToString(), init);
    }
    /*HttpResponseMessage*/ ConvertResponse(/*HttpRequestMessage*/ mrequest, /*Response*/ mresponse)
    {
        //lock
        {
            /*string*/ let responseType = mresponse.type;
            /*int*/ let status = mresponse.status;
            /*HttpResponseMessage*/ let responseMessage = new HttpResponseMessage(BlazorJs.Cast(status, HttpStatusCode));
            responseMessage.RequestMessage  = mrequest;
            if (responseType === "opaqueredirect")
            {
                responseMessage.SetReasonPhraseWithoutValidation(responseType);
            }
            /*bool*/ let streamingResponseEnabled = false;
            responseMessage.Content  = streamingResponseEnabled ? new StreamContent(new BrowserHttpReadStream(mresponse)) : BlazorJs.Cast(new BrowserHttpContent(mresponse), HttpContent);
            mresponse.headers.forEach(function()
            {
            });
            return responseMessage;
        }
    }
    /*Task<HttpResponseMessage>*/ async SendAsync(/*HttpRequestMessage*/ request, /*CancellationToken*/ cancellationToken)
    {
        /*bool?*/ let allowAutoRedirect = _isAllowAutoRedirectTouched ? AllowAutoRedirect : BlazorJs.Cast(null, bool);
        if (request === null)
        throw new ArgumentNullException(nameof(request));
        if (request.RequestUri  === null)
        throw new ArgumentNullException(nameof(request.RequestUri));
        /*//JSObject httpController = BrowserHttpInterop.CreateController();
            //CancellationTokenRegistration abortRegistration = cancellationToken.Register(static s =>
            //{
            //    JSObject _httpController = (JSObject)s!;

            //    if (!_httpController.IsDisposed)
            //    {
            //        BrowserHttpInterop.Abort(_httpController);
            //    }
            //}, httpController);


            //_jsController = httpController;
            //_abortRegistration = abortRegistration;

            var*/ let uri = request.RequestUri.ToString();
        CancellationHelper.ThrowIfCancellationRequested(cancellationToken);
        try
        {
            /*var*/ let promise = fetch(CreateFetchRequest(request));
            /*var*/ let response = await Task.FromPromise(BlazorJs.TypeArray(Response), promise.As(IPromise), null);
            return ConvertResponse(request, response[0]);
        }
        finally
        {
            {
                Dispose();
            }
        }
    }
    /*void*/ ThrowIfDisposed()
    {
    }
}

class System_Net_Http_BrowserHttpReadStream extends System_IO_Stream
{
    /*Response*/ _response = null;
    constructor(/*Response*/ response)
    {
        super();
        _response = response;
    }
    /*int*/ Read(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count)
    {
        return 0;
    }
    /*bool*/ get CanRead()
    {
        return true;
    }
    /*bool*/ get CanSeek()
    {
        return false;
    }
    /*bool*/ get CanWrite()
    {
        return false;
    }
    /*void*/ Flush()
    {
    }
    /*long*/ get Position()
    {
        throw new NotSupportedException();
    }
    /*long*/ set Position(value)
    {
        throw new NotSupportedException();
    }
    /*long*/ get Length()
    {
        throw new NotSupportedException();
    }
    /*long*/ Seek(/*long*/ offset, /*SeekOrigin*/ origin)
    {
        throw new NotSupportedException();
    }
    /*void*/ SetLength(/*long*/ value)
    {
        throw new NotSupportedException();
    }
    /*void*/ Write(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count)
    {
        throw new NotSupportedException();
    }
}


class System_Net_Http_Headers_AltSvcHeaderParser extends System_Net_Http_Headers_BaseHeaderParser
{
    /*long*/ DefaultMaxAgeTicks = 24 * TimeSpan.TicksPerHour;
    /*AltSvcHeaderParser*/ _backingField_Parser = null;
    /*AltSvcHeaderParser*/ static get Parser()
    {
        return _backingField_Parser;
    }
    constructor()
    {
        super({supportsMultipleValues : true});
    }
    /*int*/ GetParsedValueLength(/*string*/ value, /*int*/ startIndex, /*object*/ storeValue, /*out object*/ parsedValue)
    {
        let alpnProtocolName = null;
        let $ref1 = { set value(v){ alpnProtocolName = v } };
        let alpnProtocolNameLength = null;
        let $ref3 = { set value(v){ alpnProtocolNameLength = v } };
        let altAuthorityHost = null;
        let $ref5 = { set value(v){ altAuthorityHost = v } };
        let altAuthorityPort = null;
        let $ref7 = { set value(v){ altAuthorityPort = v } };
        let altAuthorityLength = null;
        let $ref9 = { set value(v){ altAuthorityLength = v } };
        Debug.Assert(startIndex >= 0);
        Debug.Assert(startIndex < value.Length);
        if (string.IsNullOrEmpty(value))
        {
            parsedValue = null;
            return 0;
        }
        /*int*/ let idx = startIndex;
        if (TryReadPercentEncodedAlpnProtocolName(value, idx, $ref1, $ref3))
        {
            parsedValue = null;
            return 0;
        }
        idx += alpnProtocolNameLength;
        if (alpnProtocolName === "clear")
        {
            if (idx !== value.Length)
            {
                parsedValue = null;
                return 0;
            }
            parsedValue = AltSvcHeaderValue.Clear;
            return idx - startIndex;
        }
        if (idx + 1 >= value.Length  || value[idx++] !== '=')
        {
            parsedValue = null;
            return 0;
        }
        if (TryReadQuotedAltAuthority(value, idx, $ref5, $ref7, $ref9))
        {
            parsedValue = null;
            return 0;
        }
        idx += altAuthorityLength;
        /*// Parse parameters: *( OWS ";" OWS parameter )
            int?*/ let maxAge = null;
        /*bool*/ let persist = false;
        while(idx < value.Length)
        {
            while(idx < value.Length  && IsOptionalWhiteSpace(value[idx]))
            {
                idx;
            }
            if (idx === value.Length)
            {
                parsedValue = null;
                return 0;
            }
            /*char*/ let ch = value[idx];
            if (ch === ',')
            {
                break;
            }
            if (ch !== ';')
            {
                parsedValue = null;
                return 0;
            }
            idx;
            while(idx < value.Length  && IsOptionalWhiteSpace(value[idx]))
            {
                idx;
            }
            /*// Get the parameter key length.
                int*/ let tokenLength = HttpRuleParser.GetTokenLength(value, idx);
            if (tokenLength === 0)
            {
                parsedValue = null;
                return 0;
            }
            if ((idx + tokenLength) >= value.Length  || value[idx + tokenLength] !== '=')
            {
                parsedValue = null;
                return 0;
            }
            if (tokenLength === 2 && value[idx] === 'm' && value[idx + 1] === 'a')
            {
                let maxAgeTmp = null;
                let $ref1 = { set value(v){ maxAgeTmp = v } };
                let parameterLength = null;
                let $ref3 = { set value(v){ parameterLength = v } };
                idx += 3;
                if (TryReadTokenOrQuotedInt32(value, idx, $ref1, $ref3))
                {
                    parsedValue = null;
                    return 0;
                }
                if (maxAge === null)
                {
                    maxAge = maxAgeTmp;
                }
                else 
                {
                    maxAge = Math.Min(maxAge.GetValueOrDefault(), maxAgeTmp);
                }
                idx += parameterLength;
            }
            else if (value.AsSpan(idx).StartsWith("persist="))
            {
                let persistInt = null;
                let $ref1 = { set value(v){ persistInt = v } };
                let parameterLength = null;
                let $ref3 = { set value(v){ parameterLength = v } };
                let $ref4 = { set value(v){ parameterLength = v } };
                idx += 8;
                if (TryReadTokenOrQuotedInt32(value, idx, $ref1, $ref3))
                {
                    persist = persistInt === 1;
                }
                else if (TrySkipTokenOrQuoted(value, idx, $ref4))
                {
                    parsedValue = null;
                    return 0;
                }
                idx += parameterLength;
            }
            else 
            {
                let parameterLength = null;
                let $ref1 = { set value(v){ parameterLength = v } };
                idx += tokenLength + 1;
                if (TrySkipTokenOrQuoted(value, idx, $ref1))
                {
                    parsedValue = null;
                    return 0;
                }
                idx += parameterLength;
            }
        }
        /*// If no "ma" parameter present, use the default.
            TimeSpan*/ let maxAgeTimeSpan = TimeSpan.FromTicks(maxAge * TimeSpan.TicksPerSecond  ?? DefaultMaxAgeTicks);
        parsedValue = new AltSvcHeaderValue(alpnProtocolName, altAuthorityHost, altAuthorityPort, maxAgeTimeSpan, persist);
        return idx - startIndex;
    }
    /*bool*/ static IsOptionalWhiteSpace(/*char*/ ch)
    {
        return ch === ' ' || ch === '\t';
    }
    /*bool*/ static TryReadPercentEncodedAlpnProtocolName(/*string*/ value, /*int*/ startIndex, /*out string*/ result, /*out int*/ readLength)
    {
        let $ref0 = { set value(v){ result = v } };
        /*int*/ let tokenLength = HttpRuleParser.GetTokenLength(value, startIndex);
        if (tokenLength === 0)
        {
            result = null;
            readLength = 0;
            return false;
        }
        /*ReadOnlySpan<char>*/ let span = value.AsSpan(startIndex, tokenLength);
        readLength = tokenLength;
        switch(span.Length?.GetType())
        {
            case 2:
            {
                result = "h3";
                return true;
            }
            case 2:
            {
                result = "h2";
                return true;
            }
            case 3:
            {
                result = "h2c";
                readLength = 3;
                return true;
            }
            case 5:
            {
                result = "clear";
                return true;
            }
            case 10:
            {
                /*char*/ let ch = span[9];
                if (ch === '1')
                {
                    result = "http/1.1";
                    return true;
                }
                if (ch === '0')
                {
                    result = "http/1.0";
                    return true;
                }
                break;
            }
        }
        return TryReadUnknownPercentEncodedAlpnProtocolName(span, $ref0);
    }
    /*bool*/ static TryReadUnknownPercentEncodedAlpnProtocolName(/*ReadOnlySpan<char>*/ value, /*out string*/ result)
    {
        /*int*/ let idx = value.IndexOf('%');
        if (idx < 0)
        {
            result = value.ToString();
            return true;
        }
        /*var*/ let builder = new StringBuilder(value.Length);
        do
        {
            let hi = null;
            let $ref1 = { set value(v){ hi = v } };
            let lo = null;
            let $ref3 = { set value(v){ lo = v } };
            if (idx !== 0)
            {
                builder.Append(value.Slice(0, idx));
            }
            if ((value.Length  - idx) < 3 || TryReadAlpnHexDigit(value[1], $ref1) || TryReadAlpnHexDigit(value[2], $ref3))
            {
                result = null;
                return false;
            }
            builder.Append(BlazorJs.Cast(((hi << 8) | lo), char));
            value = value.Slice(idx + 3);
            idx = value.IndexOf('%');
        } while(idx !== 1);
        if (value.Length  !== 0)
        {
            builder.Append(value);
        }
        result = builder.ToString();
        return true;
    }
    /*bool*/ static TryReadAlpnHexDigit(/*char*/ ch, /*out int*/ nibble)
    {
        /*int*/ let result = ch >= '0' && ch < '9' ? ch - '0' : ch >= 'A' && ch <= 'F' ? (ch - 'A' + 10) : 0xFF;
        if (result === 0xFF)
        {
            nibble = 0;
            return false;
        }
        nibble = result;
        return true;
    }
    /*bool*/ static TryReadQuotedAltAuthority(/*string*/ value, /*int*/ startIndex, /*out string*/ host, /*out int*/ port, /*out int*/ readLength)
    {
        let quotedLength = null;
        let $ref1 = { set value(v){ quotedLength = v } };
        let $ref2 = { set value(v){ port = v } };
        let $ref3 = { set value(v){ host = v } };
        if (HttpRuleParser.GetQuotedStringLength(value, startIndex, $ref1) !== HttpParseResult.Parsed)
        {
parseError        }
        Debug.Assert(value[startIndex] === '"' && value[startIndex + quotedLength - 1] === '"', `${nameof(HttpRuleParser.GetQuotedStringLength)} should return ${nameof(HttpParseResult.NotParsed)} if the opening/closing quotes are missing.`);
        /*ReadOnlySpan<char>*/ let quoted = value.AsSpan(startIndex + 1, quotedLength - 2);
        /*int*/ let idx = quoted.IndexOf(':');
        if (idx === 1)
        {
parseError        }
        if (TryReadQuotedInt32Value(quoted.Slice(idx + 1), $ref2))
        {
parseError        }
        if (idx === 0)
        {
            host = null;
        }
        else if (TryReadQuotedValue(quoted.Slice(0, idx), $ref3))
        {
parseError        }
        readLength = quotedLength;
        return true;
        host = null;
        port = 0;
        readLength = 0;
        return false;
    }
    /*bool*/ static TryReadQuotedValue(/*ReadOnlySpan<char>*/ value, /*out string*/ result)
    {
        /*int*/ let idx = value.IndexOf('\\');
        if (idx === 1)
        {
            result = value.Length  !== 0 ? value.ToString() : null;
            return true;
        }
        /*var*/ let builder = new StringBuilder();
        do
        {
            if (idx + 1 === value.Length)
            {
                result = null;
                return false;
            }
            if (idx !== 0)
            {
                builder.Append(value.Slice(0, idx));
            }
            builder.Append(value[idx + 1]);
            value = value.Slice(idx + 2);
            idx = value.IndexOf('\\');
        } while(idx !== 1);
        if (value.Length  !== 0)
        {
            builder.Append(value);
        }
        result = builder.ToString();
        return true;
    }
    /*bool*/ static TryReadTokenOrQuotedInt32(/*string*/ value, /*int*/ startIndex, /*out int*/ result, /*out int*/ readLength)
    {
        let quotedLength = null;
        let $ref1 = { set value(v){ quotedLength = v } };
        if (startIndex >= value.Length)
        {
            result = 0;
            readLength = 0;
            return false;
        }
        /*int*/ let tokenLength = HttpRuleParser.GetTokenLength(value, startIndex);
        if (tokenLength > 0)
        {
            let $ref0 = { set value(v){ result = v } };
            readLength = tokenLength;
            return HeaderUtilities.TryParseInt32(value, startIndex, tokenLength, $ref0);
        }
        if (HttpRuleParser.GetQuotedStringLength(value, startIndex, $ref1) === HttpParseResult.Parsed)
        {
            let $ref0 = { set value(v){ result = v } };
            readLength = quotedLength;
            return TryReadQuotedInt32Value(value.AsSpan(1, quotedLength - 2), $ref0);
        }
        result = 0;
        readLength = 0;
        return false;
    }
    /*bool*/ static TryReadQuotedInt32Value(/*ReadOnlySpan<char>*/ value, /*out int*/ result)
    {
        if (value.Length  === 0)
        {
            result = 0;
            return false;
        }
        /*int*/ let port = 0;
        BlazorJs.forEach(value, function(ch, $_i)
        {
            if (ch === '\\')
            if (char.IsDigit(ch))
            {
                result = 0;
                return false;
            }
            /*long*/ let portTmp = port * 10 + (ch - '0');
            if (portTmp > int.MaxValue)
            {
                result = 0;
                return false;
            }
            port = BlazorJs.Cast(portTmp, int);
        });
        result = port;
        return true;
    }
    /*bool*/ static TrySkipTokenOrQuoted(/*string*/ value, /*int*/ startIndex, /*out int*/ readLength)
    {
        let quotedLength = null;
        let $ref1 = { set value(v){ quotedLength = v } };
        if (startIndex >= value.Length)
        {
            readLength = 0;
            return false;
        }
        /*int*/ let tokenLength = HttpRuleParser.GetTokenLength(value, startIndex);
        if (tokenLength > 0)
        {
            readLength = tokenLength;
            return true;
        }
        if (HttpRuleParser.GetQuotedStringLength(value, startIndex, $ref1) === HttpParseResult.Parsed)
        {
            readLength = quotedLength;
            return true;
        }
        readLength = 0;
        return false;
    }
}

class System_Net_Http_Headers_AltSvcHeaderValue extends object
{
    /*AltSvcHeaderValue*/ _backingField_Clear = null;
    /*AltSvcHeaderValue*/ static get Clear()
    {
        return _backingField_Clear;
    }
    constructor(/*string*/ alpnProtocolName, /*string*/ host, /*int*/ port, /*TimeSpan*/ maxAge, /*bool*/ persist)
    {
        super();
        AlpnProtocolName = alpnProtocolName;
        Host = host;
        Port = port;
        MaxAge = maxAge;
        Persist = persist;
    }
    /*string*/ _backingField_AlpnProtocolName = null;
    /*string*/ get AlpnProtocolName()
    {
        return _backingField_AlpnProtocolName;
    }
    /*string*/ _backingField_Host = null;
    /*string*/ get Host()
    {
        return _backingField_Host;
    }
    /*int*/ _backingField_Port = null;
    /*int*/ get Port()
    {
        return _backingField_Port;
    }
    /*TimeSpan*/ _backingField_MaxAge = null;
    /*TimeSpan*/ get MaxAge()
    {
        return _backingField_MaxAge;
    }
    /*bool*/ _backingField_Persist = null;
    /*bool*/ get Persist()
    {
        return _backingField_Persist;
    }
    /*string*/ ToString()
    {
        /*var*/ let sb = new StringBuilder();
        sb.Append(AlpnProtocolName);
        sb.Append("=\"");
        if (Host !== null)
        {
            sb.Append(Host);
        }
        sb.Append(':');
        sb.Append(BlazorJs.Cast(Port, uint));
        sb.Append('"');
        if (MaxAge !== TimeSpan.FromTicks(AltSvcHeaderParser.DefaultMaxAgeTicks))
        {
            sb.Append("; ma=");
            sb.Append(MaxAge.Ticks  / TimeSpan.TicksPerSecond);
        }
        if (Persist)
        {
            sb.Append("; persist=1");
        }
        return sb.ToString();
    }
}

class System_Net_Http_Headers_AuthenticationHeaderValue extends H5_IH5Class(System_ICloneable(object))
{
    /*string*/ _scheme = null;
    /*string*/ _parameter = null;
    /*string*/ get Scheme()
    {
        return _scheme;
    }
    /*string*/ get Parameter()
    {
        return _parameter;
    }
    constructor(/*string*/ scheme)
    {
        super(scheme, null);
    }
    constructor(/*string*/ scheme, /*string*/ parameter)
    {
        super();
        HeaderUtilities.CheckValidToken(scheme);
        HttpHeaders.CheckContainsNewLine(parameter);
        _scheme = scheme;
        _parameter = parameter;
    }
    constructor(/*AuthenticationHeaderValue*/ source)
    {
        super();
        Debug.Assert(source !== null);
        _scheme = source._scheme;
        _parameter = source._parameter;
    }
    /*string*/ ToString()
    {
        if (string.IsNullOrEmpty(_parameter))
        {
            return _scheme;
        }
        return _scheme + " " + _parameter;
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        /*AuthenticationHeaderValue*/ let other = BlazorJs.As(obj, AuthenticationHeaderValue);
        if (other === null)
        {
            return false;
        }
        if (string.IsNullOrEmpty(_parameter) && string.IsNullOrEmpty(other._parameter))
        {
            return (string.Equals(_scheme, other._scheme, StringComparison.OrdinalIgnoreCase));
        }
        else 
        {
            return string.Equals(_scheme, other._scheme, StringComparison.OrdinalIgnoreCase) && string.Equals(_parameter, other._parameter, StringComparison.Ordinal);
        }
    }
    /*int*/ GetHashCode()
    {
        /*int*/ let result = StringComparer.OrdinalIgnoreCase.GetHashCode(_scheme);
        if (string.IsNullOrEmpty(_parameter))
        {
            result ^= _parameter.GetHashCode();
        }
        return result;
    }
    /*AuthenticationHeaderValue*/ static Parse(/*string*/ input)
    {
        let $ref0 = { set value(v){ index = v } };
        /*int*/ let index = 0;
        return BlazorJs.Cast(GenericHeaderParser.SingleValueAuthenticationParser.ParseValue(input, null, $ref0), AuthenticationHeaderValue);
    }
    /*bool*/ static TryParse(/*string*/ input, /*out AuthenticationHeaderValue*/ parsedValue)
    {
        let $ref0 = { set value(v){ index = v } };
        let output = null;
        let $ref2 = { set value(v){ output = v } };
        /*int*/ let index = 0;
        parsedValue = null;
        if (GenericHeaderParser.SingleValueAuthenticationParser.TryParseValue(input, null, $ref0, $ref2))
        {
            parsedValue = BlazorJs.Cast(output, AuthenticationHeaderValue);
            return true;
        }
        return false;
    }
    /*int*/ static GetAuthenticationLength(/*string*/ input, /*int*/ startIndex, /*out object*/ parsedValue)
    {
        let $ref0 = { set value(v){ current = v } };
        let $ref1 = { set value(v){ parameterEndIndex = v } };
        Debug.Assert(startIndex >= 0);
        parsedValue = null;
        if (string.IsNullOrEmpty(input) || (startIndex >= input.Length) || HttpRuleParser.ContainsNewLine(input, startIndex))
        {
            return 0;
        }
        /*// Parse the scheme string: <scheme> in '<scheme> <parameter>'
            int*/ let schemeLength = HttpRuleParser.GetTokenLength(input, startIndex);
        if (schemeLength === 0)
        {
            return 0;
        }
        /*string*/ let targetScheme = null;
        switch(schemeLength)
        {
            case 5:
            {
                targetScheme = "Basic";
                break;
            }
            case 6:
            {
                targetScheme = "Digest";
                break;
            }
            case 4:
            {
                targetScheme = "NTLM";
                break;
            }
            case 9:
            {
                targetScheme = "Negotiate";
                break;
            }
        }
        /*//string scheme = targetScheme != null && string.CompareOrdinal(input, startIndex, targetScheme, 0, schemeLength) == 0 ?
            //    targetScheme :
            //    input.Substring(startIndex, schemeLength);
            string*/ let scheme = targetScheme !== null && string.Compare(input, startIndex, targetScheme, 0, schemeLength) === 0 ? targetScheme : input.Substring(startIndex, schemeLength);
        /*int*/ let current = startIndex + schemeLength;
        /*int*/ let whitespaceLength = HttpRuleParser.GetWhitespaceLength(input, current);
        current += whitespaceLength;
        if ((current === input.Length) || (input[current] === ','))
        {
            parsedValue = new AuthenticationHeaderValue(scheme);
            return current - startIndex;
        }
        if (whitespaceLength === 0)
        {
            return 0;
        }
        /*// If we get here, we have a <scheme> followed by a whitespace. Now we expect the following:
            // '<scheme> <blob>[,<name>=<value>]*[, <otherscheme>...]*': <blob> potentially contains one
            // or more '=' characters, optionally followed by additional name/value pairs, optionally followed by
            // other schemes. <blob> may be a quoted string.
            // We look at the value after ',': if it is <token>=<value> then we have a parameter for <scheme>.
            // If we have either a <token>-only or <token><whitespace><blob> then we have another scheme.
            int*/ let parameterStartIndex = current;
        /*int*/ let parameterEndIndex = current;
        if (TrySkipFirstBlob(input, $ref0, $ref1))
        {
            return 0;
        }
        if (current < input.Length)
        {
            let $ref0 = { set value(v){ current = v } };
            let $ref1 = { set value(v){ parameterEndIndex = v } };
            if (TryGetParametersEndIndex(input, $ref0, $ref1))
            {
                return 0;
            }
        }
        /*string*/ let parameter = input.Substring(parameterStartIndex, parameterEndIndex - parameterStartIndex + 1);
        parsedValue = new AuthenticationHeaderValue(scheme, parameter);
        return current - startIndex;
    }
    /*bool*/ static TrySkipFirstBlob(/*string*/ input, /*ref int*/ current, /*ref int*/ parameterEndIndex)
    {
        while((current < input.Length) && (input[current] !== ','))
        {
            if (input[current] === '"')
            {
                let $ref0 = { set value(v){ quotedStringLength = v } };
                /*int*/ let quotedStringLength;
                if (HttpRuleParser.GetQuotedStringLength(input, current, $ref0) !== HttpParseResult.Parsed)
                {
                    return false;
                }
                current += quotedStringLength;
                parameterEndIndex = current - 1;
            }
            else 
            {
                /*int*/ let whitespaceLength = HttpRuleParser.GetWhitespaceLength(input, current);
                if (whitespaceLength === 0)
                {
                    parameterEndIndex = current;
                    current++;
                }
                else 
                {
                    current += whitespaceLength;
                }
            }
        }
        return true;
    }
    /*bool*/ static TryGetParametersEndIndex(/*string*/ input, /*ref int*/ parseEndIndex, /*ref int*/ parameterEndIndex)
    {
        Debug.Assert(parseEndIndex < input.Length, "Expected string to have at least 1 char");
        Debug.Assert(input[parseEndIndex] === ',');
        /*int*/ let current = parseEndIndex;
        do
        {
            let $ref0 = { set value(v){ _ = v } };
            current++;
            current = HeaderUtilities.GetNextNonEmptyOrWhitespaceIndex(input, current, true, $ref0);
            if (current === input.Length)
            {
                return true;
            }
            /*// Now we have to determine if after ',' we have a list of <name>=<value> pairs that are part of
                // the auth scheme parameters OR if we have another auth scheme. Either way, after ',' we expect a
                // valid token that is either the <name> in a <name>=<value> pair OR <scheme> of another scheme.
                int*/ let tokenLength = HttpRuleParser.GetTokenLength(input, current);
            if (tokenLength === 0)
            {
                return false;
            }
            current += tokenLength;
            current += HttpRuleParser.GetWhitespaceLength(input, current);
            if ((current === input.Length) || (input[current] !== '='))
            {
                return true;
            }
            current++;
            current += HttpRuleParser.GetWhitespaceLength(input, current);
            /*int*/ let valueLength = NameValueHeaderValue.GetValueLength(input, current);
            if (valueLength === 0)
            {
                return false;
            }
            current += valueLength;
            parameterEndIndex = current - 1;
            current += HttpRuleParser.GetWhitespaceLength(input, current);
            parseEndIndex = current;
        } while((current < input.Length) && (input[current] === ','));
        return true;
    }
    /*object*/ Clone()
    {
        return new AuthenticationHeaderValue(this);
    }
}

class System_Net_Http_Headers_BaseHeaderParser extends System_Net_Http_Headers_HttpHeaderParser
{
    constructor(/*bool*/ supportsMultipleValues)
    {
        super(supportsMultipleValues);
    }
    /*bool*/ TryParseValue(/*string*/ value, /*object*/ storeValue, /*ref int*/ index, /*out object*/ parsedValue)
    {
        let $ref0 = { set value(v){ separatorFound = v } };
        let result = null;
        let $ref2 = { set value(v){ result = v } };
        let $ref3 = { set value(v){ separatorFound = v } };
        parsedValue = null;
        if (string.IsNullOrEmpty(value) || (index === value.Length))
        {
            return SupportsMultipleValues;
        }
        /*bool*/ let separatorFound;
        /*int*/ let current = HeaderUtilities.GetNextNonEmptyOrWhitespaceIndex(value, index, SupportsMultipleValues, $ref0);
        if (separatorFound && SupportsMultipleValues)
        {
            return false;
        }
        if (current === value.Length)
        {
            if (SupportsMultipleValues)
            {
                index = current;
            }
            return SupportsMultipleValues;
        }
        /*int*/ let length = GetParsedValueLength(value, current, storeValue, $ref2);
        if (length === 0)
        {
            return false;
        }
        current += length;
        current = HeaderUtilities.GetNextNonEmptyOrWhitespaceIndex(value, current, SupportsMultipleValues, $ref3);
        if ((separatorFound && SupportsMultipleValues) || (separatorFound && (current < value.Length)))
        {
            return false;
        }
        index = current;
        parsedValue = result;
        return true;
    }
}

class System_Net_Http_Headers_ByteArrayHeaderParser extends System_Net_Http_Headers_HttpHeaderParser
{
    /*ByteArrayHeaderParser*/ static Parser = new ByteArrayHeaderParser();
    constructor()
    {
        super(false);
    }
    /*string*/ ToString(/*object*/ value)
    {
        Debug.Assert(value instanceof byte);
        return Convert.ToBase64String(BlazorJs.Cast(value, byte));
    }
    /*bool*/ TryParseValue(/*string*/ value, /*object*/ storeValue, /*ref int*/ index, /*out object*/ parsedValue)
    {
        parsedValue = null;
        if (string.IsNullOrEmpty(value) || (index === value.Length))
        {
            return false;
        }
        /*string*/ let base64String = value;
        if (index > 0)
        {
            base64String = value.Substring(index);
        }
        try
        {
            parsedValue = Convert.FromBase64String(base64String);
            index = value.Length;
            return true;
        }
        catch(e)
        {
        }
        return false;
    }
}

class System_Net_Http_Headers_CacheControlHeaderParser extends System_Net_Http_Headers_BaseHeaderParser
{
    /*CacheControlHeaderParser*/ static Parser = new CacheControlHeaderParser();
    constructor()
    {
        super(true);
    }
    /*int*/ GetParsedValueLength(/*string*/ value, /*int*/ startIndex, /*object*/ storeValue, /*out object*/ parsedValue)
    {
        let $ref0 = { set value(v){ temp = v } };
        /*CacheControlHeaderValue*/ let temp = null;
        /*bool*/ let isInvalidValue = true;
        if (storeValue instanceof List(object), list = storeValue)
        {
            BlazorJs.forEach(list, function(item, $_i)
            {
                if ((item instanceof HttpHeaders_InvalidValue))
                {
                    isInvalidValue = false;
                    temp = BlazorJs.As(item, CacheControlHeaderValue);
                    break;
                }
            });
        }
        else 
        {
            if ((storeValue instanceof HttpHeaders_InvalidValue))
            {
                isInvalidValue = false;
                temp = BlazorJs.As(storeValue, CacheControlHeaderValue);
            }
        }
        Debug.Assert(isInvalidValue || storeValue === null || temp !== null, "'storeValue' is not of type CacheControlHeaderValue");
        /*int*/ let resultLength = CacheControlHeaderValue.GetCacheControlLength(value, startIndex, temp, $ref0);
        parsedValue = temp;
        return resultLength;
    }
}

class System_Net_Http_Headers_CacheControlHeaderValue extends H5_IH5Class(System_ICloneable(object))
{
    /*string*/ maxAgeString = "max-age";
    /*string*/ maxStaleString = "max-stale";
    /*string*/ minFreshString = "min-fresh";
    /*string*/ mustRevalidateString = "must-revalidate";
    /*string*/ noCacheString = "no-cache";
    /*string*/ noStoreString = "no-store";
    /*string*/ noTransformString = "no-transform";
    /*string*/ onlyIfCachedString = "only-if-cached";
    /*string*/ privateString = "private";
    /*string*/ proxyRevalidateString = "proxy-revalidate";
    /*string*/ publicString = "public";
    /*string*/ sharedMaxAgeString = "s-maxage";
    /*GenericHeaderParser*/ static s_nameValueListParser = GenericHeaderParser.MultipleValueNameValueParser;
    static System_Net_Http_Headers_CacheControlHeaderValue_Flags = class
    {
        None = 0;
        MaxAgeHasValue = 1 << 0;
        SharedMaxAgeHasValue = 1 << 1;
        MaxStaleLimitHasValue = 1 << 2;
        MinFreshHasValue = 1 << 3;
        NoCache = 1 << 4;
        NoStore = 1 << 5;
        MaxStale = 1 << 6;
        NoTransform = 1 << 7;
        OnlyIfCached = 1 << 8;
        Public = 1 << 9;
        Private = 1 << 10;
        MustRevalidate = 1 << 11;
        ProxyRevalidate = 1 << 12;
    }
    /*Flags*/ _flags = null;
    /*TokenObjectCollection*/ _noCacheHeaders = null;
    /*TimeSpan*/ _maxAge = null;
    /*TimeSpan*/ _sharedMaxAge = null;
    /*TimeSpan*/ _maxStaleLimit = null;
    /*TimeSpan*/ _minFresh = null;
    /*TokenObjectCollection*/ _privateHeaders = null;
    /*UnvalidatedObjectCollection<NameValueHeaderValue>*/ _extensions = null;
    /*void*/ SetTimeSpan(/*ref TimeSpan*/ fieldRef, /*Flags*/ flag, /*TimeSpan?*/ value)
    {
        fieldRef = value.GetValueOrDefault();
        SetFlag(flag, value.HasValue);
    }
    /*void*/ SetFlag(/*Flags*/ flag, /*bool*/ value)
    {
        Debug.Assert(Flags === int);
        if (value)
        {
            _flags |= flag;
        }
        else 
        {
            _flags &= flag;
        }
    }
    /*bool*/ get NoCache()
    {
        return (_flags & Flags.NoCache) !== 0;
    }
    /*bool*/ set NoCache(value)
    {
        SetFlag(Flags.NoCache, value);
    }
    /*ICollection<string>*/ get NoCacheHeaders()
    {
        return _noCacheHeaders = _noCacheHeaders ?? new TokenObjectCollection();
    }
    /*bool*/ get NoStore()
    {
        return (_flags & Flags.NoStore) !== 0;
    }
    /*bool*/ set NoStore(value)
    {
        SetFlag(Flags.NoStore, value);
    }
    /*TimeSpan?*/ get MaxAge()
    {
        return (_flags & Flags.MaxAgeHasValue) === 0 ? BlazorJs.Cast(null, TimeSpan) : _maxAge;
    }
    /*TimeSpan?*/ set MaxAge(value)
    {
        let $ref0 = { set value(v){ _maxAge = v } };
        SetTimeSpan($ref0, Flags.MaxAgeHasValue, value);
    }
    /*TimeSpan?*/ get SharedMaxAge()
    {
        return (_flags & Flags.SharedMaxAgeHasValue) === 0 ? BlazorJs.Cast(null, TimeSpan) : _sharedMaxAge;
    }
    /*TimeSpan?*/ set SharedMaxAge(value)
    {
        let $ref0 = { set value(v){ _sharedMaxAge = v } };
        SetTimeSpan($ref0, Flags.SharedMaxAgeHasValue, value);
    }
    /*bool*/ get MaxStale()
    {
        return (_flags & Flags.MaxStale) !== 0;
    }
    /*bool*/ set MaxStale(value)
    {
        SetFlag(Flags.MaxStale, value);
    }
    /*TimeSpan?*/ get MaxStaleLimit()
    {
        return (_flags & Flags.MaxStaleLimitHasValue) === 0 ? BlazorJs.Cast(null, TimeSpan) : _maxStaleLimit;
    }
    /*TimeSpan?*/ set MaxStaleLimit(value)
    {
        let $ref0 = { set value(v){ _maxStaleLimit = v } };
        SetTimeSpan($ref0, Flags.MaxStaleLimitHasValue, value);
    }
    /*TimeSpan?*/ get MinFresh()
    {
        return (_flags & Flags.MinFreshHasValue) === 0 ? BlazorJs.Cast(null, TimeSpan) : _minFresh;
    }
    /*TimeSpan?*/ set MinFresh(value)
    {
        let $ref0 = { set value(v){ _minFresh = v } };
        SetTimeSpan($ref0, Flags.MinFreshHasValue, value);
    }
    /*bool*/ get NoTransform()
    {
        return (_flags & Flags.NoTransform) !== 0;
    }
    /*bool*/ set NoTransform(value)
    {
        SetFlag(Flags.NoTransform, value);
    }
    /*bool*/ get OnlyIfCached()
    {
        return (_flags & Flags.OnlyIfCached) !== 0;
    }
    /*bool*/ set OnlyIfCached(value)
    {
        SetFlag(Flags.OnlyIfCached, value);
    }
    /*bool*/ get Public()
    {
        return (_flags & Flags.Public) !== 0;
    }
    /*bool*/ set Public(value)
    {
        SetFlag(Flags.Public, value);
    }
    /*bool*/ get Private()
    {
        return (_flags & Flags.Private) !== 0;
    }
    /*bool*/ set Private(value)
    {
        SetFlag(Flags.Private, value);
    }
    /*ICollection<string>*/ get PrivateHeaders()
    {
        return _privateHeaders = _privateHeaders ?? new TokenObjectCollection();
    }
    /*bool*/ get MustRevalidate()
    {
        return (_flags & Flags.MustRevalidate) !== 0;
    }
    /*bool*/ set MustRevalidate(value)
    {
        SetFlag(Flags.MustRevalidate, value);
    }
    /*bool*/ get ProxyRevalidate()
    {
        return (_flags & Flags.ProxyRevalidate) !== 0;
    }
    /*bool*/ set ProxyRevalidate(value)
    {
        SetFlag(Flags.ProxyRevalidate, value);
    }
    /*ICollection<NameValueHeaderValue>*/ get Extensions()
    {
        return _extensions = _extensions ?? new UnvalidatedObjectCollection(NameValueHeaderValue)();
    }
    constructor()
    {
        super();
    }
    constructor(/*CacheControlHeaderValue*/ source)
    {
        super();
        Debug.Assert(source !== null);
        _flags = source._flags;
        _maxAge = source._maxAge;
        _sharedMaxAge = source._sharedMaxAge;
        _maxStaleLimit = source._maxStaleLimit;
        _minFresh = source._minFresh;
        if (source._noCacheHeaders  !== null)
        {
            BlazorJs.forEach(source._noCacheHeaders, function(noCacheHeader, $_i)
            {
                NoCacheHeaders.Add(noCacheHeader);
            });
        }
        if (source._privateHeaders  !== null)
        {
            BlazorJs.forEach(source._privateHeaders, function(privateHeader, $_i)
            {
                PrivateHeaders.Add(privateHeader);
            });
        }
        _extensions = source._extensions.Clone();
    }
    /*string*/ ToString()
    {
        /*StringBuilder*/ let sb = new StringBuilder();
        AppendValueIfRequired(sb, NoStore, noStoreString);
        AppendValueIfRequired(sb, NoTransform, noTransformString);
        AppendValueIfRequired(sb, OnlyIfCached, onlyIfCachedString);
        AppendValueIfRequired(sb, Public, publicString);
        AppendValueIfRequired(sb, MustRevalidate, mustRevalidateString);
        AppendValueIfRequired(sb, ProxyRevalidate, proxyRevalidateString);
        if (NoCache)
        {
            AppendValueWithSeparatorIfRequired(sb, noCacheString);
            if ((_noCacheHeaders !== null) && (_noCacheHeaders.Count  > 0))
            {
                sb.Append("=\"");
                AppendValues(sb, _noCacheHeaders);
                sb.Append('\"');
            }
        }
        if ((_flags & Flags.MaxAgeHasValue) !== 0)
        {
            AppendValueWithSeparatorIfRequired(sb, maxAgeString);
            sb.Append('=');
            /*int*/ let maxAge = BlazorJs.Cast(_maxAge.TotalSeconds, int);
            if (maxAge >= 0)
            {
                sb.Append(maxAge);
            }
            else 
            {
                sb.Append(`${maxAge}`);
            }
        }
        if ((_flags & Flags.SharedMaxAgeHasValue) !== 0)
        {
            AppendValueWithSeparatorIfRequired(sb, sharedMaxAgeString);
            sb.Append('=');
            /*int*/ let sharedMaxAge = BlazorJs.Cast(_sharedMaxAge.TotalSeconds, int);
            if (sharedMaxAge >= 0)
            {
                sb.Append(sharedMaxAge);
            }
            else 
            {
                sb.Append(`${sharedMaxAge}`);
            }
        }
        if (MaxStale)
        {
            AppendValueWithSeparatorIfRequired(sb, maxStaleString);
            if ((_flags & Flags.MaxStaleLimitHasValue) !== 0)
            {
                sb.Append('=');
                /*int*/ let maxStaleLimit = BlazorJs.Cast(_maxStaleLimit.TotalSeconds, int);
                if (maxStaleLimit >= 0)
                {
                    sb.Append(maxStaleLimit);
                }
                else 
                {
                    sb.Append(`${maxStaleLimit}`);
                }
            }
        }
        if ((_flags & Flags.MinFreshHasValue) !== 0)
        {
            AppendValueWithSeparatorIfRequired(sb, minFreshString);
            sb.Append('=');
            /*int*/ let minFresh = BlazorJs.Cast(_minFresh.TotalSeconds, int);
            if (minFresh >= 0)
            {
                sb.Append(minFresh);
            }
            else 
            {
                sb.Append(`${minFresh}`);
            }
        }
        if (Private)
        {
            AppendValueWithSeparatorIfRequired(sb, privateString);
            if ((_privateHeaders !== null) && (_privateHeaders.Count  > 0))
            {
                sb.Append("=\"");
                AppendValues(sb, _privateHeaders);
                sb.Append('\"');
            }
        }
        NameValueHeaderValue.ToString(_extensions, ',', false, sb);
        return sb.ToString();
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        return obj instanceof CacheControlHeaderValue, other = obj && _flags === other._flags  && _maxAge === other._maxAge  && _sharedMaxAge === other._sharedMaxAge  && _maxStaleLimit === other._maxStaleLimit  && _minFresh === other._minFresh  && HeaderUtilities.AreEqualCollections(_noCacheHeaders, other._noCacheHeaders, StringComparer.OrdinalIgnoreCase) && HeaderUtilities.AreEqualCollections(_privateHeaders, other._privateHeaders, StringComparer.OrdinalIgnoreCase) && HeaderUtilities.AreEqualCollections(_extensions, other._extensions);
    }
    /*int*/ GetHashCode()
    {
        return HashCode.Combine(_flags, _maxAge, _sharedMaxAge, _maxStaleLimit, _minFresh, (_noCacheHeaders ? 0 : _noCacheHeaders.GetHashCode(StringComparer.OrdinalIgnoreCase)), (_privateHeaders ? 0 : _privateHeaders.GetHashCode(StringComparer.OrdinalIgnoreCase)), NameValueHeaderValue.GetHashCode(_extensions));
    }
    /*CacheControlHeaderValue*/ static Parse(/*string*/ input)
    {
        let $ref0 = { set value(v){ index = v } };
        /*int*/ let index = 0;
        return BlazorJs.Cast(CacheControlHeaderParser.Parser.ParseValue(input, null, $ref0), CacheControlHeaderValue) ?? new CacheControlHeaderValue();
    }
    /*bool*/ static TryParse(/*string*/ input, /*out CacheControlHeaderValue*/ parsedValue)
    {
        let $ref0 = { set value(v){ index = v } };
        let output = null;
        let $ref2 = { set value(v){ output = v } };
        /*int*/ let index = 0;
        parsedValue = null;
        if (CacheControlHeaderParser.Parser.TryParseValue(input, null, $ref0, $ref2))
        {
            parsedValue = BlazorJs.Cast(output, CacheControlHeaderValue) ?? new CacheControlHeaderValue();
            return true;
        }
        return false;
    }
    /*int*/ static GetCacheControlLength(/*string*/ input, /*int*/ startIndex, /*CacheControlHeaderValue*/ storeValue, /*out CacheControlHeaderValue*/ parsedValue)
    {
        Debug.Assert(startIndex >= 0);
        parsedValue = null;
        if (string.IsNullOrEmpty(input) || (startIndex >= input.Length))
        {
            return 0;
        }
        /*// Cache-Control header consists of a list of name/value pairs, where the value is optional. So use an
            // instance of NameValueHeaderParser to parse the string.
            int*/ let current = startIndex;
        /*List<NameValueHeaderValue>*/ let nameValueList = new List(NameValueHeaderValue)();
        while(current < input.Length)
        {
            let $ref0 = { set value(v){ current = v } };
            let nameValue = null;
            let $ref2 = { set value(v){ nameValue = v } };
            if (s_nameValueListParser.TryParseValue(input, null, $ref0, $ref2))
            {
                return 0;
            }
            Debug.Assert((nameValue));
            nameValueList.Add(BlazorJs.Cast(nameValue, NameValueHeaderValue));
        }
        /*// If we get here, we were able to successfully parse the string as list of name/value pairs. Now analyze
            // the name/value pairs.

            // Cache-Control is a header supporting lists of values. However, expose the header as an instance of
            // CacheControlHeaderValue. So if we already have an instance of CacheControlHeaderValue, add the values
            // from this string to the existing instances.
            CacheControlHeaderValue*/ let result = storeValue ?? new CacheControlHeaderValue();
        if (TrySetCacheControlValues(result, nameValueList))
        {
            return 0;
        }
        if (storeValue === null)
        {
            parsedValue = result;
        }
        return input.Length  - startIndex;
    }
    /*bool*/ static TrySetCacheControlValues(/*CacheControlHeaderValue*/ cc, /*List<NameValueHeaderValue>*/ nameValueList)
    {
        BlazorJs.forEach(nameValueList, function(nameValue, $_i)
        {
            /*string*/ let name = nameValue.Name.ToLower();
            /*//string name = nameValue.Name.ToLowerInvariant();
                string*/ let value = nameValue.Value;
            /*Flags*/ let flagsToSet = Flags.None;
            /*bool*/ let success = value;
            switch(name)
            {
                case noCacheString:
                {
                    let $ref0 = { set value(v){ cc._noCacheHeaders = v } };
                    flagsToSet = Flags.NoCache;
                    success = TrySetOptionalTokenList(nameValue, $ref0);
                    break;
                }
                case noStoreString:
                {
                    flagsToSet = Flags.NoStore;
                    break;
                }
                case maxAgeString:
                {
                    let $ref0 = { set value(v){ cc._maxAge = v } };
                    flagsToSet = Flags.MaxAgeHasValue;
                    success = TrySetTimeSpan(value, $ref0);
                    break;
                }
                case maxStaleString:
                {
                    let $ref0 = { set value(v){ cc._maxStaleLimit = v } };
                    flagsToSet = Flags.MaxStale;
                    if (TrySetTimeSpan(value, $ref0))
                    {
                        success = true;
                        flagsToSet = Flags.MaxStale  | Flags.MaxStaleLimitHasValue;
                    }
                    break;
                }
                case minFreshString:
                {
                    let $ref0 = { set value(v){ cc._minFresh = v } };
                    flagsToSet = Flags.MinFreshHasValue;
                    success = TrySetTimeSpan(value, $ref0);
                    break;
                }
                case noTransformString:
                {
                    flagsToSet = Flags.NoTransform;
                    break;
                }
                case onlyIfCachedString:
                {
                    flagsToSet = Flags.OnlyIfCached;
                    break;
                }
                case publicString:
                {
                    flagsToSet = Flags.Public;
                    break;
                }
                case privateString:
                {
                    let $ref0 = { set value(v){ cc._privateHeaders = v } };
                    flagsToSet = Flags.Private;
                    success = TrySetOptionalTokenList(nameValue, $ref0);
                    break;
                }
                case mustRevalidateString:
                {
                    flagsToSet = Flags.MustRevalidate;
                    break;
                }
                case proxyRevalidateString:
                {
                    flagsToSet = Flags.ProxyRevalidate;
                    break;
                }
                case sharedMaxAgeString:
                {
                    let $ref0 = { set value(v){ cc._sharedMaxAge = v } };
                    flagsToSet = Flags.SharedMaxAgeHasValue;
                    success = TrySetTimeSpan(value, $ref0);
                    break;
                }
                default:
                {
                    success = true;
                    cc.Extensions.Add(nameValue);
                    break;
                }
            }
            if (success)
            {
                cc._flags  |= flagsToSet;
            }
            else 
            {
                return false;
            }
        });
        return true;
    }
    /*bool*/ static TrySetOptionalTokenList(/*NameValueHeaderValue*/ nameValue, /*ref TokenObjectCollection*/ destination)
    {
        Debug.Assert(nameValue !== null);
        if (nameValue.Value  === null)
        {
            return true;
        }
        /*// We need the string to be at least 3 chars long: 2x quotes and at least 1 character. Also make sure we
            // have a quoted string. Note that NameValueHeaderValue will never have leading/trailing whitespace.
            string*/ let valueString = nameValue.Value;
        if ((valueString.Length  < 3) || valueString.StartsWith("\"") || valueString.EndsWith("\""))
        {
            return false;
        }
        /*// We have a quoted string. Now verify that the string contains a list of valid tokens separated by ','.
            int*/ let current = 1;
        /*int*/ let maxLength = valueString.Length  - 1;
        /*int*/ let originalValueCount = destination === null ? 0 : destination.Count;
        while(current < maxLength)
        {
            let $ref0 = { set value(v){ _ = v } };
            current = HeaderUtilities.GetNextNonEmptyOrWhitespaceIndex(valueString, current, true, $ref0);
            if (current === maxLength)
            {
                break;
            }
            /*int*/ let tokenLength = HttpRuleParser.GetTokenLength(valueString, current);
            if (tokenLength === 0)
            {
                return false;
            }
            destination = destination ?? new TokenObjectCollection();
            destination.Add(valueString.Substring(current, tokenLength));
            current += tokenLength;
        }
        if ((destination !== null) && (destination.Count  > originalValueCount))
        {
            return true;
        }
        return false;
    }
    /*bool*/ static TrySetTimeSpan(/*string*/ value, /*ref TimeSpan*/ timeSpan)
    {
        let seconds = null;
        let $ref1 = { set value(v){ seconds = v } };
        if (value || HeaderUtilities.TryParseInt32(value, $ref1))
        {
            return false;
        }
        timeSpan = new TimeSpan(0, 0, seconds);
        return true;
    }
    /*void*/ static AppendValueIfRequired(/*StringBuilder*/ sb, /*bool*/ appendValue, /*string*/ value)
    {
        if (appendValue)
        {
            AppendValueWithSeparatorIfRequired(sb, value);
        }
    }
    /*void*/ static AppendValueWithSeparatorIfRequired(/*StringBuilder*/ sb, /*string*/ value)
    {
        if (sb.Length  > 0)
        {
            sb.Append(", ");
        }
        sb.Append(value);
    }
    /*void*/ static AppendValues(/*StringBuilder*/ sb, /*TokenObjectCollection*/ values)
    {
        /*bool*/ let first = true;
        BlazorJs.forEach(values, function(value, $_i)
        {
            if (first)
            {
                first = false;
            }
            else 
            {
                sb.Append(", ");
            }
            sb.Append(value);
        });
    }
    /*object*/ Clone()
    {
        return new CacheControlHeaderValue(this);
    }
    static System_Net_Http_Headers_CacheControlHeaderValue_TokenObjectCollection = class extends System_Net_Http_Headers_ObjectCollection(string)(string)
    {
        constructor()
        {
            super();
        }
        /*void*/ Validate(/*string*/ item)
        {
            return HeaderUtilities.CheckValidToken(item);
        }
        /*int*/ GetHashCode(/*StringComparer*/ comparer)
        {
            /*int*/ let hashcode = 0;
            BlazorJs.forEach(this, function(value, $_i)
            {
                hashcode ^= comparer.GetHashCode(value);
            });
            return hashcode;
        }
    }
}

class System_Net_Http_Headers_ContentDispositionHeaderValue extends H5_IH5Class(System_ICloneable(object))
{
    /*string*/ fileName = "filename";
    /*string*/ name = "name";
    /*string*/ fileNameStar = "filename*";
    /*string*/ creationDate = "creation-date";
    /*string*/ modificationDate = "modification-date";
    /*string*/ readDate = "read-date";
    /*string*/ size = "size";
    /*UnvalidatedObjectCollection<NameValueHeaderValue>*/ _parameters = null;
    /*string*/ _dispositionType = null;
    /*string*/ get DispositionType()
    {
        return _dispositionType;
    }
    /*string*/ set DispositionType(value)
    {
        HeaderUtilities.CheckValidToken(value);
        _dispositionType = value;
    }
    /*ICollection<NameValueHeaderValue>*/ get Parameters()
    {
        return _parameters = _parameters ?? new UnvalidatedObjectCollection(NameValueHeaderValue)();
    }
    /*string*/ get Name()
    {
        return GetName(name);
    }
    /*string*/ set Name(value)
    {
        SetName(name, value);
    }
    /*string*/ get FileName()
    {
        return GetName(fileName);
    }
    /*string*/ set FileName(value)
    {
        SetName(fileName, value);
    }
    /*string*/ get FileNameStar()
    {
        return GetName(fileNameStar);
    }
    /*string*/ set FileNameStar(value)
    {
        SetName(fileNameStar, value);
    }
    /*DateTimeOffset?*/ get CreationDate()
    {
        return GetDate(creationDate);
    }
    /*DateTimeOffset?*/ set CreationDate(value)
    {
        SetDate(creationDate, value);
    }
    /*DateTimeOffset?*/ get ModificationDate()
    {
        return GetDate(modificationDate);
    }
    /*DateTimeOffset?*/ set ModificationDate(value)
    {
        SetDate(modificationDate, value);
    }
    /*DateTimeOffset?*/ get ReadDate()
    {
        return GetDate(readDate);
    }
    /*DateTimeOffset?*/ set ReadDate(value)
    {
        SetDate(readDate, value);
    }
    /*long?*/ get Size()
    {
        /*NameValueHeaderValue*/ let sizeParameter = NameValueHeaderValue.Find(_parameters, size);
        /*ulong*/ let value;
        if (sizeParameter !== null)
        {
            let $ref0 = { set value(v){ value = v } };
            /*string*/ let sizeString = sizeParameter.Value;
            if (ulong.TryParse(sizeString, $ref0))
            {
                return BlazorJs.Cast(value, long);
            }
        }
        return null;
    }
    /*long?*/ set Size(value)
    {
        /*NameValueHeaderValue*/ let sizeParameter = NameValueHeaderValue.Find(_parameters, size);
        if (value === null)
        {
            if (sizeParameter !== null)
            {
                _parameters.Remove(sizeParameter);
            }
        }
        else 
        {
            if (value.GetValueOrDefault() < 0)
            {
                throw new ArgumentOutOfRangeException();
            }
            if (sizeParameter !== null)
            {
                sizeParameter.Value  = value.Value.ToString();
            }
            else 
            {
                /*string*/ let sizeString = value.Value.ToString();
                Parameters.Add(new NameValueHeaderValue(size, sizeString));
            }
        }
    }
    constructor()
    {
        super();
    }
    constructor(/*ContentDispositionHeaderValue*/ source)
    {
        super();
        Debug.Assert(source !== null);
        _dispositionType = source._dispositionType;
        _parameters = source._parameters.Clone();
    }
    constructor(/*string*/ dispositionType)
    {
        super();
        HeaderUtilities.CheckValidToken(dispositionType);
        _dispositionType = dispositionType;
    }
    /*string*/ ToString()
    {
        /*StringBuilder*/ let sb = new StringBuilder();
        sb.Append(_dispositionType);
        NameValueHeaderValue.ToString(_parameters, ';', true, sb);
        return sb.ToString();
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        /*ContentDispositionHeaderValue*/ let other = BlazorJs.As(obj, ContentDispositionHeaderValue);
        if (other === null)
        {
            return false;
        }
        return string.Equals(_dispositionType, other._dispositionType, StringComparison.OrdinalIgnoreCase) && HeaderUtilities.AreEqualCollections(_parameters, other._parameters);
    }
    /*int*/ GetHashCode()
    {
        return StringComparer.OrdinalIgnoreCase.GetHashCode(_dispositionType) ^ NameValueHeaderValue.GetHashCode(_parameters);
    }
    /*// Implement ICloneable explicitly to allow derived types to "override" the implementation.
        object*/ Clone()
    {
        return new ContentDispositionHeaderValue(this);
    }
    /*ContentDispositionHeaderValue*/ static Parse(/*string*/ input)
    {
        let $ref0 = { set value(v){ index = v } };
        /*int*/ let index = 0;
        return BlazorJs.Cast(GenericHeaderParser.ContentDispositionParser.ParseValue(input, null, $ref0), ContentDispositionHeaderValue);
    }
    /*bool*/ static TryParse(/*string*/ input, /*out ContentDispositionHeaderValue*/ parsedValue)
    {
        let $ref0 = { set value(v){ index = v } };
        let output = null;
        let $ref2 = { set value(v){ output = v } };
        /*int*/ let index = 0;
        parsedValue = null;
        if (GenericHeaderParser.ContentDispositionParser.TryParseValue(input, null, $ref0, $ref2))
        {
            parsedValue = BlazorJs.Cast(output, ContentDispositionHeaderValue);
            return true;
        }
        return false;
    }
    /*int*/ static GetDispositionTypeLength(/*string*/ input, /*int*/ startIndex, /*out object*/ parsedValue)
    {
        let $ref0 = { set value(v){ dispositionType = v } };
        Debug.Assert(startIndex >= 0);
        parsedValue = null;
        if (string.IsNullOrEmpty(input) || (startIndex >= input.Length))
        {
            return 0;
        }
        /*// Caller must remove leading whitespace. If not, we'll return 0.
            string*/ let dispositionType;
        /*int*/ let dispositionTypeLength = GetDispositionTypeExpressionLength(input, startIndex, $ref0);
        if (dispositionTypeLength === 0)
        {
            return 0;
        }
        /*int*/ let current = startIndex + dispositionTypeLength;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        /*ContentDispositionHeaderValue*/ let contentDispositionHeader = new ContentDispositionHeaderValue();
        contentDispositionHeader._dispositionType  = dispositionType;
        if ((current < input.Length) && (input[current] === ';'))
        {
            current++;
            /*int*/ let parameterLength = NameValueHeaderValue.GetNameValueListLength(input, current, ';', BlazorJs.Cast(contentDispositionHeader.Parameters, UnvalidatedObjectCollection(NameValueHeaderValue)));
            if (parameterLength === 0)
            {
                return 0;
            }
            parsedValue = contentDispositionHeader;
            return current + parameterLength - startIndex;
        }
        parsedValue = contentDispositionHeader;
        return current - startIndex;
    }
    /*int*/ static GetDispositionTypeExpressionLength(/*string*/ input, /*int*/ startIndex, /*out string*/ dispositionType)
    {
        Debug.Assert((input !== null) && (input.Length  > 0) && (startIndex < input.Length));
        dispositionType = null;
        /*// Parse the disposition type, i.e. <dispositiontype> in content-disposition string
            // "<dispositiontype>; param1=value1; param2=value2".
            int*/ let typeLength = HttpRuleParser.GetTokenLength(input, startIndex);
        if (typeLength === 0)
        {
            return 0;
        }
        dispositionType = input.Substring(startIndex, typeLength);
        return typeLength;
    }
    /*DateTimeOffset?*/ GetDate(/*string*/ parameter)
    {
        /*NameValueHeaderValue*/ let dateParameter = NameValueHeaderValue.Find(_parameters, parameter);
        /*DateTimeOffset*/ let date;
        if (dateParameter !== null)
        {
            let $ref0 = { set value(v){ date = v } };
            /*ReadOnlySpan<char>*/ let dateString = dateParameter.Value.AsSpan();
            if (IsQuoted(dateString))
            {
                dateString = dateString.Slice(1, dateString.Length  - 2);
            }
            if (DateTimeOffset.TryParse(dateString, $ref0))
            {
                return date;
            }
        }
        return null;
    }
    /*void*/ SetDate(/*string*/ parameter, /*DateTimeOffset?*/ date)
    {
        /*NameValueHeaderValue*/ let dateParameter = NameValueHeaderValue.Find(_parameters, parameter);
        if (date === null)
        {
            if (dateParameter !== null)
            {
                _parameters.Remove(dateParameter);
            }
        }
        else 
        {
            /*// Must always be quoted.
                string*/ let dateString = `\"${date.GetValueOrDefault()}\"`;
            if (dateParameter !== null)
            {
                dateParameter.Value  = dateString;
            }
            else 
            {
                Parameters.Add(new NameValueHeaderValue(parameter, dateString));
            }
        }
    }
    /*string*/ GetName(/*string*/ parameter)
    {
        /*NameValueHeaderValue*/ let nameParameter = NameValueHeaderValue.Find(_parameters, parameter);
        if (nameParameter !== null)
        {
            let $ref0 = { set value(v){ result = v } };
            /*string*/ let result;
            if (parameter.EndsWith("*"))
            {
                let $ref0 = { set value(v){ result = v } };
                Debug.Assert(nameParameter.Value  !== null);
                if (TryDecode5987(nameParameter.Value, $ref0))
                {
                    return result;
                }
                return null;
            }
            if (TryDecodeMime(nameParameter.Value, $ref0))
            {
                return result;
            }
            return nameParameter.Value;
        }
        return null;
    }
    /*void*/ SetName(/*string*/ parameter, /*string*/ value)
    {
        /*NameValueHeaderValue*/ let nameParameter = NameValueHeaderValue.Find(_parameters, parameter);
        if (string.IsNullOrEmpty(value))
        {
            if (nameParameter !== null)
            {
                _parameters.Remove(nameParameter);
            }
        }
        else 
        {
            /*string*/ let processedValue;
            if (parameter.EndsWith("*"))
            {
                processedValue = HeaderUtilities.Encode5987(value);
            }
            else 
            {
                processedValue = EncodeAndQuoteMime(value);
            }
            if (nameParameter !== null)
            {
                nameParameter.Value  = processedValue;
            }
            else 
            {
                Parameters.Add(new NameValueHeaderValue(parameter, processedValue));
            }
        }
    }
    /*string*/ static EncodeAndQuoteMime(/*string*/ input)
    {
        /*string*/ let result = input;
        /*bool*/ let needsQuotes = false;
        if (IsQuoted(result.AsSpan()))
        {
            result = result.Substring(1, result.Length  - 2);
            needsQuotes = true;
        }
        if (result.Contains("\""))
        {
            throw new ArgumentException("net_http_headers_invalid_value");
        }
        else if (Ascii.IsValid(result))
        {
            needsQuotes = true;
            result = EncodeMime(result);
        }
        else if (needsQuotes && HttpRuleParser.GetTokenLength(result, 0) !== result.Length)
        {
            needsQuotes = true;
        }
        if (needsQuotes)
        {
            result = "\"" + result + "\"";
        }
        return result;
    }
    /*bool*/ static IsQuoted(/*ReadOnlySpan<char>*/ value)
    {
        return value.Length  > 1 && value[0] === '"' && value[value.Length  - 1] === '"';
    }
    /*string*/ static EncodeMime(/*string*/ input)
    {
        /*byte[]*/ let buffer = Encoding.UTF8.GetBytes(input);
        /*string*/ let encodedName = Convert.ToBase64String(buffer);
        return "=?utf-8?B?" + encodedName + "?=";
    }
    /*bool*/ static TryDecodeMime(/*string*/ input, /*out string*/ output)
    {
        Debug.Assert(input !== null);
        output = null;
        /*string*/ let processedInput = input;
        if (IsQuoted(processedInput.AsSpan()) || processedInput.Length  < 10)
        {
            return false;
        }
        /*Span<Range>*/ let parts = new Span(Range)(new Array(6));
        /*ReadOnlySpan<char>*/ let processedInputSpan = processedInput.AsSpan();
        if (processedInputSpan.Split(parts, '?') !== 5 || (processedInputSpan[parts[0]].IsEqual("\"=")) || (processedInputSpan[parts[0]].IsEqual("=\"")) || processedInputSpan[parts[2]].IsEqual("b", StringComparison.OrdinalIgnoreCase))
        {
            return false;
        }
        try
        {
            /*Encoding*/ let encoding = Encoding.GetEncoding(processedInput.AsSpan()[parts[1]]);
            /*byte[]*/ let bytes = Convert.FromBase64String(processedInput.AsSpan()[parts[3]]);
            output = encoding.GetString(bytes, 0, bytes.Length);
            return true;
        }
        catch($e)
        {
            if($e instanceof ArgumentException)
            {
            }
            if($e instanceof FormatException)
            {
            }
        }
        return false;
    }
    /*bool*/ static TryDecode5987(/*string*/ input, /*out string*/ output)
    {
        output = null;
        /*int*/ let quoteIndex = input.IndexOf('\'');
        if (quoteIndex === 1)
        {
            return false;
        }
        /*int*/ let lastQuoteIndex = input.LastIndexOf('\'');
        if (quoteIndex === lastQuoteIndex || input.IndexOf('\'', quoteIndex + 1) !== lastQuoteIndex)
        {
            return false;
        }
        /*string*/ let encodingString = input.Substring(0, quoteIndex);
        /*string*/ let dataString = input.Substring(lastQuoteIndex + 1);
        /*StringBuilder*/ let decoded = new StringBuilder();
        try
        {
            /*Encoding*/ let encoding = Encoding.GetEncoding(encodingString);
            /*byte[]*/ let unescapedBytes = new Array(dataString.Length);
            /*int*/ let unescapedBytesCount = 0;
            for(/*int*/ let index = 0; index < dataString.Length; index++)
            {
                if (UriExtension.IsHexEncoding(dataString, index))
                {
                    let $ref0 = { set value(v){ index = v } };
                    unescapedBytes[unescapedBytesCount++] = BlazorJs.Cast(UriExtension.HexUnescape(dataString, $ref0), byte);
                    index--;
                }
                else 
                {
                    if (unescapedBytesCount > 0)
                    {
                        decoded.Append(encoding.GetString(unescapedBytes, 0, unescapedBytesCount));
                        unescapedBytesCount = 0;
                    }
                    decoded.Append(dataString[index]);
                }
            }
            if (unescapedBytesCount > 0)
            {
                decoded.Append(encoding.GetString(unescapedBytes, 0, unescapedBytesCount));
            }
        }
        catch($e)
        {
            return false;
        }
        output = decoded.ToString();
        return true;
    }
}

class System_Net_Http_Headers_ContentRangeHeaderValue extends H5_IH5Class(System_ICloneable(object))
{
    /*string*/ _unit = null;
    /*long*/ _from = null;
    /*long*/ _to = null;
    /*long*/ _length = null;
    /*string*/ get Unit()
    {
        return _unit;
    }
    /*string*/ set Unit(value)
    {
        HeaderUtilities.CheckValidToken(value);
        _unit = value;
    }
    /*long?*/ get From()
    {
        return HasRange ? _from : BlazorJs.Cast(null, long);
    }
    /*long?*/ get To()
    {
        return HasRange ? _to : BlazorJs.Cast(null, long);
    }
    /*long?*/ get Length()
    {
        return HasLength ? _length : BlazorJs.Cast(null, long);
    }
    /*bool*/ get HasLength()
    {
        return _length >= 0;
    }
    /*bool*/ get HasRange()
    {
        return _from >= 0;
    }
    constructor(/*long*/ from, /*long*/ to, /*long*/ length)
    {
        super();
        if (length < 0)
        throw new ArgumentOutOfRangeException(nameof(length));
        if (to < 0)
        throw new ArgumentOutOfRangeException(nameof(to));
        if (from < 0)
        throw new ArgumentOutOfRangeException(nameof(from));
        if (from > to)
        throw new ArgumentOutOfRangeException(nameof(from));
        if (to > length)
        throw new ArgumentOutOfRangeException(nameof(to));
        _from = from;
        _to = to;
        _length = length;
        _unit = HeaderUtilities.BytesUnit;
    }
    constructor(/*long*/ length)
    {
        super();
        if (length < 0)
        throw new ArgumentOutOfRangeException(nameof(length));
        _length = length;
        _unit = HeaderUtilities.BytesUnit;
        _from = 1;
    }
    constructor(/*long*/ from, /*long*/ to)
    {
        super();
        if (to < 0)
        throw new ArgumentOutOfRangeException(nameof(to));
        if (from < 0)
        throw new ArgumentOutOfRangeException(nameof(from));
        if (from > to)
        throw new ArgumentOutOfRangeException(nameof(from));
        _from = from;
        _to = to;
        _unit = HeaderUtilities.BytesUnit;
        _length = 1;
    }
    constructor()
    {
        super();
        _from = 1;
        _length = 1;
    }
    constructor(/*ContentRangeHeaderValue*/ source)
    {
        super();
        Debug.Assert(source !== null);
        _from = source._from;
        _to = source._to;
        _length = source._length;
        _unit = source._unit;
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        return obj instanceof ContentRangeHeaderValue, other = obj && _from === other._from  && _to === other._to  && _length === other._length  && string.Equals(_unit, other._unit, StringComparison.OrdinalIgnoreCase);
    }
    /*int*/ GetHashCode()
    {
        return HashCode.Combine(StringComparer.OrdinalIgnoreCase.GetHashCode(_unit), _from, _to, _length);
    }
    /*string*/ ToString()
    {
        /*var*/ let sb = new StringBuilder(256);
        sb.Append(_unit);
        sb.Append(' ');
        if (HasRange)
        {
            sb.Append(_from);
            sb.Append('-');
            sb.Append(_to);
        }
        else 
        {
            sb.Append('*');
        }
        sb.Append('/');
        if (HasLength)
        {
            sb.Append(_length);
        }
        else 
        {
            sb.Append('*');
        }
        return sb.ToString();
    }
    /*ContentRangeHeaderValue*/ static Parse(/*string*/ input)
    {
        let $ref0 = { set value(v){ index = v } };
        /*int*/ let index = 0;
        return BlazorJs.Cast(GenericHeaderParser.ContentRangeParser.ParseValue(input, null, $ref0), ContentRangeHeaderValue);
    }
    /*bool*/ static TryParse(/*string*/ input, /*out ContentRangeHeaderValue*/ parsedValue)
    {
        let $ref0 = { set value(v){ index = v } };
        let output = null;
        let $ref2 = { set value(v){ output = v } };
        /*int*/ let index = 0;
        parsedValue = null;
        if (GenericHeaderParser.ContentRangeParser.TryParseValue(input, null, $ref0, $ref2))
        {
            parsedValue = BlazorJs.Cast(output, ContentRangeHeaderValue);
            return true;
        }
        return false;
    }
    /*int*/ static GetContentRangeLength(/*string*/ input, /*int*/ startIndex, /*out object*/ parsedValue)
    {
        let $ref0 = { set value(v){ current = v } };
        let $ref1 = { set value(v){ fromLength = v } };
        let $ref2 = { set value(v){ toStartIndex = v } };
        let $ref3 = { set value(v){ toLength = v } };
        let $ref4 = { set value(v){ current = v } };
        let $ref5 = { set value(v){ lengthLength = v } };
        let $ref6 = { set value(v){ parsedValue = v } };
        Debug.Assert(startIndex >= 0);
        parsedValue = null;
        if (string.IsNullOrEmpty(input) || (startIndex >= input.Length))
        {
            return 0;
        }
        /*// Parse the unit string: <unit> in '<unit> <from>-<to>/<length>'
            int*/ let unitLength = HttpRuleParser.GetTokenLength(input, startIndex);
        if (unitLength === 0)
        {
            return 0;
        }
        /*string*/ let unit = input.Substring(startIndex, unitLength);
        /*int*/ let current = startIndex + unitLength;
        /*int*/ let separatorLength = HttpRuleParser.GetWhitespaceLength(input, current);
        if (separatorLength === 0)
        {
            return 0;
        }
        current += separatorLength;
        if (current === input.Length)
        {
            return 0;
        }
        /*// Read range values <from> and <to> in '<unit> <from>-<to>/<length>'
            int*/ let fromStartIndex = current;
        /*int*/ let fromLength;
        /*int*/ let toStartIndex;
        /*int*/ let toLength;
        if (TryGetRangeLength(input, $ref0, $ref1, $ref2, $ref3))
        {
            return 0;
        }
        if ((current === input.Length) || (input[current] !== '/'))
        {
            return 0;
        }
        current++;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        if (current === input.Length)
        {
            return 0;
        }
        /*// We may not have a length (e.g. 'bytes 1-2/*'). But if we do, parse the length now.
            int*/ let lengthStartIndex = current;
        /*int*/ let lengthLength;
        if (TryGetLengthLength(input, $ref4, $ref5))
        {
            return 0;
        }
        if (TryCreateContentRange(input, unit, fromStartIndex, fromLength, toStartIndex, toLength, lengthStartIndex, lengthLength, $ref6))
        {
            return 0;
        }
        return current - startIndex;
    }
    /*bool*/ static TryGetLengthLength(/*string*/ input, /*ref int*/ current, /*out int*/ lengthLength)
    {
        lengthLength = 0;
        if (input[current] === '*')
        {
            current++;
        }
        else 
        {
            lengthLength = HttpRuleParser.GetNumberLength(input, current, false);
            if ((lengthLength === 0) || (lengthLength > HttpRuleParser.MaxInt64Digits))
            {
                return false;
            }
            current += lengthLength;
        }
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        return true;
    }
    /*bool*/ static TryGetRangeLength(/*string*/ input, /*ref int*/ current, /*out int*/ fromLength, /*out int*/ toStartIndex, /*out int*/ toLength)
    {
        fromLength = 0;
        toStartIndex = 0;
        toLength = 0;
        if (input[current] === '*')
        {
            current++;
        }
        else 
        {
            fromLength = HttpRuleParser.GetNumberLength(input, current, false);
            if ((fromLength === 0) || (fromLength > HttpRuleParser.MaxInt64Digits))
            {
                return false;
            }
            current += fromLength;
            current += HttpRuleParser.GetWhitespaceLength(input, current);
            if ((current === input.Length) || (input[current] !== '-'))
            {
                return false;
            }
            current++;
            current += HttpRuleParser.GetWhitespaceLength(input, current);
            if (current === input.Length)
            {
                return false;
            }
            toStartIndex = current;
            toLength = HttpRuleParser.GetNumberLength(input, current, false);
            if ((toLength === 0) || (toLength > HttpRuleParser.MaxInt64Digits))
            {
                return false;
            }
            current += toLength;
        }
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        return true;
    }
    /*bool*/ static TryCreateContentRange(/*string*/ input, /*string*/ unit, /*int*/ fromStartIndex, /*int*/ fromLength, /*int*/ toStartIndex, /*int*/ toLength, /*int*/ lengthStartIndex, /*int*/ lengthLength, /*out object*/ parsedValue)
    {
        let $ref0 = { set value(v){ from = v } };
        let $ref1 = { set value(v){ to = v } };
        let $ref2 = { set value(v){ length = v } };
        parsedValue = null;
        /*long*/ let from = 0;
        if ((fromLength > 0) && HeaderUtilities.TryParseInt64(input, fromStartIndex, fromLength, $ref0))
        {
            return false;
        }
        /*long*/ let to = 0;
        if ((toLength > 0) && HeaderUtilities.TryParseInt64(input, toStartIndex, toLength, $ref1))
        {
            return false;
        }
        if ((fromLength > 0) && (toLength > 0) && (from > to))
        {
            return false;
        }
        /*long*/ let length = 0;
        if ((lengthLength > 0) && HeaderUtilities.TryParseInt64(input, lengthStartIndex, lengthLength, $ref2))
        {
            return false;
        }
        if ((toLength > 0) && (lengthLength > 0) && (to >= length))
        {
            return false;
        }
        /*ContentRangeHeaderValue*/ let result = new ContentRangeHeaderValue();
        result._unit  = unit;
        if (fromLength > 0)
        {
            result._from  = from;
            result._to  = to;
        }
        if (lengthLength > 0)
        {
            result._length  = length;
        }
        parsedValue = result;
        return true;
    }
    /*object*/ Clone()
    {
        return new ContentRangeHeaderValue(this);
    }
}

class System_Net_Http_Headers_CookieHeaderParser extends System_Net_Http_Headers_HttpHeaderParser
{
    /*CookieHeaderParser*/ static Parser = new CookieHeaderParser();
    constructor()
    {
        super(true, "; ");
    }
    /*bool*/ TryParseValue(/*string*/ value, /*object*/ storeValue, /*ref int*/ index, /*out object*/ parsedValue)
    {
        if (string.IsNullOrEmpty(value) || (index === value.Length))
        {
            parsedValue = null;
            return false;
        }
        parsedValue = value;
        index = value.Length;
        return true;
    }
}

class System_Net_Http_Headers_DateHeaderParser extends System_Net_Http_Headers_HttpHeaderParser
{
    /*DateHeaderParser*/ static Parser = new DateHeaderParser();
    constructor()
    {
        super(false);
    }
    /*string*/ ToString(/*object*/ value)
    {
        Debug.Assert(value instanceof DateTimeOffset);
        return (BlazorJs.Cast(value, DateTimeOffset)).ToString("r");
    }
    /*bool*/ TryParseValue(/*string*/ value, /*object*/ storeValue, /*ref int*/ index, /*out object*/ parsedValue)
    {
        let $ref0 = { set value(v){ date = v } };
        parsedValue = null;
        if (string.IsNullOrEmpty(value) || (index === value.Length))
        {
            return false;
        }
        /*ReadOnlySpan<char>*/ let dateString = value.AsSpan();
        if (index > 0)
        {
            dateString = value.AsSpan(index);
        }
        /*DateTimeOffset*/ let date;
        if (DateTimeOffset.TryParse(dateString, $ref0))
        {
            return false;
        }
        index = value.Length;
        parsedValue = date;
        return true;
    }
}

class System_Net_Http_Headers_EntityTagHeaderValue extends H5_IH5Class(System_ICloneable(object))
{
    /*string*/ _backingField_Tag = null;
    /*string*/ get Tag()
    {
        return _backingField_Tag;
    }
    /*string*/ set Tag(value)
    {
        _backingField_Tag = value;
    }
    /*bool*/ _backingField_IsWeak = null;
    /*bool*/ get IsWeak()
    {
        return _backingField_IsWeak;
    }
    /*bool*/ set IsWeak(value)
    {
        _backingField_IsWeak = value;
    }
    /*EntityTagHeaderValue*/ _backingField_Any = null;
    /*EntityTagHeaderValue*/ static get Any()
    {
        return _backingField_Any;
    }
    constructor(/*string*/ tag, /*bool*/ isWeak, /*bool*/ _)
    {
        super();
        Tag = tag;
        IsWeak = isWeak;
    }
    constructor(/*string*/ tag)
    {
        super(tag, false);
    }
    constructor(/*string*/ tag, /*bool*/ isWeak)
    {
        super();
        HeaderUtilities.CheckValidQuotedString(tag);
        Tag = tag;
        IsWeak = isWeak;
    }
    constructor(/*EntityTagHeaderValue*/ source)
    {
        super();
        Debug.Assert(source !== null);
        Tag = source.Tag;
        IsWeak = source.IsWeak;
    }
    /*string*/ ToString()
    {
        return IsWeak ? `W/${Tag}` : Tag;
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        return obj instanceof EntityTagHeaderValue, other = obj && IsWeak === other.IsWeak  && // Since the tag is a quoted-string we treat it case-sensitive.
            string.Equals(Tag, other.Tag, StringComparison.Ordinal);
    }
    /*int*/ GetHashCode()
    {
        return HashCode.Combine(Tag, IsWeak);
    }
    /*EntityTagHeaderValue*/ static Parse(/*string*/ input)
    {
        let $ref0 = { set value(v){ index = v } };
        /*int*/ let index = 0;
        return BlazorJs.Cast(GenericHeaderParser.SingleValueEntityTagParser.ParseValue(input, null, $ref0), EntityTagHeaderValue);
    }
    /*bool*/ static TryParse(/*string*/ input, /*out EntityTagHeaderValue*/ parsedValue)
    {
        let $ref0 = { set value(v){ index = v } };
        let output = null;
        let $ref2 = { set value(v){ output = v } };
        /*int*/ let index = 0;
        parsedValue = null;
        if (GenericHeaderParser.SingleValueEntityTagParser.TryParseValue(input, null, $ref0, $ref2))
        {
            parsedValue = BlazorJs.Cast(output, EntityTagHeaderValue);
            return true;
        }
        return false;
    }
    /*int*/ static GetEntityTagLength(/*string*/ input, /*int*/ startIndex, /*out EntityTagHeaderValue*/ parsedValue)
    {
        Debug.Assert(startIndex >= 0);
        parsedValue = null;
        if (string.IsNullOrEmpty(input) || (startIndex >= input.Length))
        {
            return 0;
        }
        /*// Caller must remove leading whitespace. If not, we'll return 0.
            bool*/ let isWeak = false;
        /*int*/ let current = startIndex;
        /*char*/ let firstChar = input[startIndex];
        if (firstChar === '*')
        {
            parsedValue = Any;
            current++;
        }
        else 
        {
            let tagLength = null;
            let $ref1 = { set value(v){ tagLength = v } };
            if ((firstChar === 'W') || (firstChar === 'w'))
            {
                current++;
                if ((current + 2 >= input.Length) || (input[current] !== '/'))
                {
                    return 0;
                }
                isWeak = true;
                current++;
                current += HttpRuleParser.GetWhitespaceLength(input, current);
            }
            if (current === input.Length  || HttpRuleParser.GetQuotedStringLength(input, current, $ref1) !== HttpParseResult.Parsed)
            {
                return 0;
            }
            Debug.Assert(tagLength !== input.Length  || (startIndex === 0 && isWeak));
            parsedValue = new EntityTagHeaderValue(input.Substring(current, tagLength), isWeak, false);
            current += tagLength;
        }
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        return current - startIndex;
    }
    /*object*/ Clone()
    {
        return ReferenceEquals(this, Any) ? Any : new EntityTagHeaderValue(this);
    }
}

class System_Net_Http_Headers_GenericHeaderParser extends System_Net_Http_Headers_BaseHeaderParser
{
    /*GenericHeaderParser*/ static HostParser = new GenericHeaderParser(false, ParseHost);
    /*GenericHeaderParser*/ static TokenListParser = new GenericHeaderParser(true, ParseTokenList);
    /*GenericHeaderParser*/ static SingleValueNameValueWithParametersParser = new GenericHeaderParser(false, NameValueWithParametersHeaderValue.GetNameValueWithParametersLength);
    /*GenericHeaderParser*/ static MultipleValueNameValueWithParametersParser = new GenericHeaderParser(true, NameValueWithParametersHeaderValue.GetNameValueWithParametersLength);
    /*GenericHeaderParser*/ static SingleValueNameValueParser = new GenericHeaderParser(false, ParseNameValue);
    /*GenericHeaderParser*/ static MultipleValueNameValueParser = new GenericHeaderParser(true, ParseNameValue);
    /*GenericHeaderParser*/ static SingleValueParserWithoutValidation = new GenericHeaderParser(false, ParseWithoutValidation);
    /*GenericHeaderParser*/ static SingleValueProductParser = new GenericHeaderParser(false, ParseProduct);
    /*GenericHeaderParser*/ static MultipleValueProductParser = new GenericHeaderParser(true, ParseProduct);
    /*GenericHeaderParser*/ static RangeConditionParser = new GenericHeaderParser(false, RangeConditionHeaderValue.GetRangeConditionLength);
    /*GenericHeaderParser*/ static SingleValueAuthenticationParser = new GenericHeaderParser(false, AuthenticationHeaderValue.GetAuthenticationLength);
    /*GenericHeaderParser*/ static MultipleValueAuthenticationParser = new GenericHeaderParser(true, AuthenticationHeaderValue.GetAuthenticationLength);
    /*GenericHeaderParser*/ static RangeParser = new GenericHeaderParser(false, RangeHeaderValue.GetRangeLength);
    /*GenericHeaderParser*/ static RetryConditionParser = new GenericHeaderParser(false, RetryConditionHeaderValue.GetRetryConditionLength);
    /*GenericHeaderParser*/ static ContentRangeParser = new GenericHeaderParser(false, ContentRangeHeaderValue.GetContentRangeLength);
    /*GenericHeaderParser*/ static ContentDispositionParser = new GenericHeaderParser(false, ContentDispositionHeaderValue.GetDispositionTypeLength);
    /*GenericHeaderParser*/ static SingleValueStringWithQualityParser = new GenericHeaderParser(false, StringWithQualityHeaderValue.GetStringWithQualityLength);
    /*GenericHeaderParser*/ static MultipleValueStringWithQualityParser = new GenericHeaderParser(true, StringWithQualityHeaderValue.GetStringWithQualityLength);
    /*GenericHeaderParser*/ static SingleValueEntityTagParser = new GenericHeaderParser(false, ParseSingleEntityTag);
    /*GenericHeaderParser*/ static MultipleValueEntityTagParser = new GenericHeaderParser(true, ParseMultipleEntityTags);
    /*GenericHeaderParser*/ static SingleValueViaParser = new GenericHeaderParser(false, ViaHeaderValue.GetViaLength);
    /*GenericHeaderParser*/ static MultipleValueViaParser = new GenericHeaderParser(true, ViaHeaderValue.GetViaLength);
    /*GenericHeaderParser*/ static SingleValueWarningParser = new GenericHeaderParser(false, WarningHeaderValue.GetWarningLength);
    /*GenericHeaderParser*/ static MultipleValueWarningParser = new GenericHeaderParser(true, WarningHeaderValue.GetWarningLength);
    /*GetParsedValueLengthDelegate*/ _getParsedValueLength = null;
    /*IEqualityComparer*/ _comparer = null;
    /*IEqualityComparer*/ get Comparer()
    {
        return _comparer;
    }
    constructor(/*bool*/ supportsMultipleValues, /*GetParsedValueLengthDelegate*/ getParsedValueLength)
    {
        super(supportsMultipleValues, getParsedValueLength, null);
    }
    constructor(/*bool*/ supportsMultipleValues, /*GetParsedValueLengthDelegate*/ getParsedValueLength, /*IEqualityComparer*/ comparer)
    {
        super(supportsMultipleValues);
        Debug.Assert(getParsedValueLength !== null);
        _getParsedValueLength = getParsedValueLength;
        _comparer = comparer;
    }
    /*int*/ GetParsedValueLength(/*string*/ value, /*int*/ startIndex, /*object*/ storeValue, /*out object*/ parsedValue)
    {
        let $ref0 = { set value(v){ parsedValue = v } };
        return _getParsedValueLength(value, startIndex, $ref0);
    }
    /*int*/ static ParseNameValue(/*string*/ value, /*int*/ startIndex, /*out object*/ parsedValue)
    {
        let temp = null;
        let $ref1 = { set value(v){ temp = v } };
        /*int*/ let resultLength = NameValueHeaderValue.GetNameValueLength(value, startIndex, $ref1);
        parsedValue = temp;
        return resultLength;
    }
    /*int*/ static ParseProduct(/*string*/ value, /*int*/ startIndex, /*out object*/ parsedValue)
    {
        let temp = null;
        let $ref1 = { set value(v){ temp = v } };
        /*int*/ let resultLength = ProductHeaderValue.GetProductLength(value, startIndex, $ref1);
        parsedValue = temp;
        return resultLength;
    }
    /*int*/ static ParseSingleEntityTag(/*string*/ value, /*int*/ startIndex, /*out object*/ parsedValue)
    {
        let temp = null;
        let $ref1 = { set value(v){ temp = v } };
        parsedValue = null;
        /*int*/ let resultLength = EntityTagHeaderValue.GetEntityTagLength(value, startIndex, $ref1);
        if (temp === EntityTagHeaderValue.Any)
        {
            return 0;
        }
        parsedValue = temp;
        return resultLength;
    }
    /*int*/ static ParseMultipleEntityTags(/*string*/ value, /*int*/ startIndex, /*out object*/ parsedValue)
    {
        let temp = null;
        let $ref1 = { set value(v){ temp = v } };
        /*int*/ let resultLength = EntityTagHeaderValue.GetEntityTagLength(value, startIndex, $ref1);
        parsedValue = temp;
        return resultLength;
    }
    /*int*/ static ParseWithoutValidation(/*string*/ value, /*int*/ startIndex, /*out object*/ parsedValue)
    {
        if (HttpRuleParser.ContainsNewLine(value, startIndex))
        {
            parsedValue = null;
            return 0;
        }
        /*string*/ let result = value.Substring(startIndex);
        parsedValue = result;
        return result.Length;
    }
    /*int*/ static ParseHost(/*string*/ value, /*int*/ startIndex, /*out object*/ parsedValue)
    {
        /*int*/ let hostLength = HttpRuleParser.GetHostLength(value, startIndex, false);
        parsedValue = value.Substring(startIndex, hostLength);
        return hostLength;
    }
    /*int*/ static ParseTokenList(/*string*/ value, /*int*/ startIndex, /*out object*/ parsedValue)
    {
        /*int*/ let resultLength = HttpRuleParser.GetTokenLength(value, startIndex);
        parsedValue = value.Substring(startIndex, resultLength);
        return resultLength;
    }
}

class System_Net_Http_Headers_HeaderDescriptor extends H5_IH5Class(System_IEquatable(System_Net_Http_Headers_HeaderDescriptor)(System_ValueType))
{
    /*object*/ _descriptor = null;
    constructor(/*KnownHeader*/ knownHeader)
    {
        super();
        _descriptor = knownHeader;
    }
    constructor(/*string*/ headerName, /*bool*/ customHeader)
    {
        super();
        Debug.Assert(customHeader || KnownHeaders.TryGetKnownHeader(headerName), `The ${nameof(KnownHeader)} overload should be used for ${headerName}`);
        _descriptor = headerName;
    }
    /*string*/ get Name()
    {
        return _descriptor instanceof KnownHeader, header = _descriptor ? header.Name  : (BlazorJs.As(_descriptor, string));
    }
    /*HttpHeaderParser*/ get Parser()
    {
        return (BlazorJs.As(_descriptor, KnownHeader))?.Parser;
    }
    /*HttpHeaderType*/ get HeaderType()
    {
        return _descriptor instanceof KnownHeader, knownHeader = _descriptor ? knownHeader.HeaderType  : HttpHeaderType.Custom;
    }
    /*KnownHeader*/ get KnownHeader()
    {
        return BlazorJs.As(_descriptor, KnownHeader);
    }
    /*bool*/ Equals(/*KnownHeader*/ other)
    {
        return ReferenceEquals(_descriptor, other);
    }
    /*bool*/ Equals(/*HeaderDescriptor*/ other)
    {
        if (_descriptor instanceof string, headerName = _descriptor)
        {
            return string.Equals(headerName, BlazorJs.As(other._descriptor , string), StringComparison.OrdinalIgnoreCase);
        }
        else 
        {
            return ReferenceEquals(_descriptor, other._descriptor);
        }
    }
    /*int*/ GetHashCode()
    {
        return _descriptor instanceof KnownHeader, knownHeader = _descriptor ? knownHeader.GetHashCode() : StringComparer.OrdinalIgnoreCase.GetHashCode(_descriptor);
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        throw new InvalidOperationException();
    }
    /*bool*/ static TryGet(/*string*/ headerName, /*out HeaderDescriptor*/ descriptor)
    {
        Debug.Assert(string.IsNullOrEmpty(headerName));
        /*KnownHeader*/ let knownHeader = KnownHeaders.TryGetKnownHeader(headerName);
        if (knownHeader !== null)
        {
            descriptor = new HeaderDescriptor(knownHeader);
            return true;
        }
        if (HttpRuleParser.IsToken(headerName.AsSpan()))
        {
            descriptor = HeaderDescriptor?.default() ?? null;
            return false;
        }
        descriptor = new HeaderDescriptor(headerName);
        return true;
    }
    /*bool*/ static TryGet(/*ReadOnlySpan<byte>*/ headerName, /*out HeaderDescriptor*/ descriptor)
    {
        Debug.Assert(headerName.Length  > 0);
        /*KnownHeader*/ let knownHeader = KnownHeaders.TryGetKnownHeader(headerName);
        if (knownHeader !== null)
        {
            descriptor = new HeaderDescriptor(knownHeader);
            return true;
        }
        if (HttpRuleParser.IsToken(headerName))
        {
            descriptor = HeaderDescriptor?.default() ?? null;
            return false;
        }
        descriptor = new HeaderDescriptor(HttpRuleParser.GetTokenString(headerName));
        return true;
    }
    /*bool*/ static TryGetStaticQPackHeader(/*int*/ index, /*out HeaderDescriptor*/ descriptor, /*out string*/ knownValue)
    {
        Debug.Assert(index >= 0);
        /*// Micro-opt: store field to variable to prevent Length re-read and use unsigned to avoid bounds check.
            (HeaderDescriptor descriptor, string value)[]*/ let qpackStaticTable = QPackStaticTable.HeaderLookup;
        Debug.Assert(qpackStaticTable.Length  === 99);
        /*uint*/ let uindex = BlazorJs.Cast(index, uint);
        if (uindex < BlazorJs.Cast(qpackStaticTable.Length, uint))
        {
            BlazorJs.TupleValue({ Item1: descriptor, Item2: knownValue }) = qpackStaticTable[uindex];
            return true;
        }
        else 
        {
            descriptor = BlazorJs.getDefault();
            knownValue = null;
            return false;
        }
    }
    /*HeaderDescriptor*/ AsCustomHeader()
    {
        Debug.Assert(_descriptor instanceof KnownHeader);
        Debug.Assert(HeaderType !== HttpHeaderType.Custom);
        return new HeaderDescriptor(Name, { customHeader : true });
    }
    /*string*/ GetHeaderValue(/*ReadOnlySpan<byte>*/ headerValue, /*Encoding*/ valueEncoding)
    {
        if (headerValue.Length  === 0)
        {
            return string.Empty;
        }
        if (_descriptor instanceof KnownHeader, knownHeader = _descriptor)
        {
            if (knownHeader.KnownValues  instanceof string)
            {
                for(/*int*/ let i = 0; i < knownValues.Length; i++)
                {
                    if (Ascii.Equals(headerValue, knownValues[i]))
                    {
                        return knownValues[i];
                    }
                }
            }
            if (knownHeader === KnownHeaders.ContentType)
            {
                /*string*/ let contentType = GetKnownContentType(headerValue);
                if (contentType !== null)
                {
                    return contentType;
                }
            }
            else if (knownHeader === KnownHeaders.Location)
            {
                let decoded = null;
                let $ref1 = { set value(v){ decoded = v } };
                if (valueEncoding && TryDecodeUtf8(headerValue, $ref1))
                {
                    return decoded;
                }
            }
        }
        return (valueEncoding ?? HttpRuleParser.DefaultHttpEncoding).GetString(headerValue.ToArray());
    }
    /*string*/ static GetKnownContentType(/*ReadOnlySpan<byte>*/ contentTypeValue)
    {
        /*string*/ let candidate = null;
        switch(contentTypeValue.Length)
        {
            case 8:
            {
                switch(contentTypeValue[7])
                {
                    case BlazorJs.Cast('l', byte):
                    {
                        candidate = "text/xml";
                        break;
                    }
                    case BlazorJs.Cast('s', byte):
                    {
                        candidate = "text/css";
                        break;
                    }
                    case BlazorJs.Cast('v', byte):
                    {
                        candidate = "text/csv";
                        break;
                    }
                }
                break;
            }
            case 9:
            {
                switch(contentTypeValue[6])
                {
                    case BlazorJs.Cast('g', byte):
                    {
                        candidate = "image/gif";
                        break;
                    }
                    case BlazorJs.Cast('p', byte):
                    {
                        candidate = "image/png";
                        break;
                    }
                    case BlazorJs.Cast('t', byte):
                    {
                        candidate = "text/html";
                        break;
                    }
                }
                break;
            }
            case 10:
            {
                switch(contentTypeValue[0])
                {
                    case BlazorJs.Cast('t', byte):
                    {
                        candidate = "text/plain";
                        break;
                    }
                    case BlazorJs.Cast('i', byte):
                    {
                        candidate = "image/jpeg";
                        break;
                    }
                }
                break;
            }
            case 15:
            {
                switch(contentTypeValue[12])
                {
                    case BlazorJs.Cast('p', byte):
                    {
                        candidate = "application/pdf";
                        break;
                    }
                    case BlazorJs.Cast('x', byte):
                    {
                        candidate = "application/xml";
                        break;
                    }
                    case BlazorJs.Cast('z', byte):
                    {
                        candidate = "application/zip";
                        break;
                    }
                }
                break;
            }
            case 16:
            {
                switch(contentTypeValue[12])
                {
                    case BlazorJs.Cast('g', byte):
                    {
                        candidate = "application/grpc";
                        break;
                    }
                    case BlazorJs.Cast('j', byte):
                    {
                        candidate = "application/json";
                        break;
                    }
                }
                break;
            }
            case 19:
            {
                candidate = "multipart/form-data";
                break;
            }
            case 22:
            {
                candidate = "application/javascript";
                break;
            }
            case 24:
            {
                switch(contentTypeValue[19])
                {
                    case BlazorJs.Cast('t', byte):
                    {
                        candidate = "application/octet-stream";
                        break;
                    }
                    case BlazorJs.Cast('u', byte):
                    {
                        candidate = "text/html; charset=utf-8";
                        break;
                    }
                    case BlazorJs.Cast('U', byte):
                    {
                        candidate = "text/html; charset=UTF-8";
                        break;
                    }
                }
                break;
            }
            case 25:
            {
                candidate = "text/plain; charset=utf-8";
                break;
            }
            case 31:
            {
                candidate = "application/json; charset=utf-8";
                break;
            }
            case 33:
            {
                candidate = "application/x-www-form-urlencoded";
                break;
            }
        }
        Debug.Assert(candidate || candidate.Length  === contentTypeValue.Length);
        return candidate !== null && Ascii.Equals(contentTypeValue, candidate) ? candidate : null;
    }
    /*bool*/ static TryDecodeUtf8(/*ReadOnlySpan<byte>*/ input, /*out string*/ decoded)
    {
        /*char[]*/ let rented = ArrayPool(char).Shared.Rent(input.Length);
        try
        {
            let $ref0 = { set value(v){ _ = v } };
            let charsWritten = null;
            let $ref2 = { set value(v){ charsWritten = v } };
            if (Utf8.ToUtf16(input, rented, $ref0, $ref2, { replaceInvalidSequences : false }) === OperationStatus.Done)
            {
                decoded = new string(rented, 0, charsWritten);
                return true;
            }
        }
        finally
        {
            {
                ArrayPool(char).Shared.Return(rented);
            }
        }
        decoded = null;
        return false;
    }
    /*string*/ get Separator()
    {
        return Parser?.Separator ?? HttpHeaderParser.DefaultSeparator;
    }
    /*byte[]*/ get SeparatorBytes()
    {
        return Parser?.SeparatorBytes ?? HttpHeaderParser.DefaultSeparatorBytes;
    }
}

class System_Net_Http_Headers_HeaderStringValues extends H5_IH5Class(System_Collections_IEnumerable(System_Collections_Generic_IEnumerable(string)(System_Collections_Generic_IReadOnlyCollection(string)(System_ValueType))))
{
    /*HeaderDescriptor*/ _header = null;
    /*object*/ _value = null;
    constructor(/*HeaderDescriptor*/ descriptor, /*string*/ value)
    {
        super();
        _header = descriptor;
        _value = value;
    }
    constructor(/*HeaderDescriptor*/ descriptor, /*string[]*/ values)
    {
        super();
        _header = descriptor;
        _value = values;
    }
    /*int*/ get Count()
    {
        switch(_value?.GetType())
        {
            case s = string:
            {
                return 1;
            }
            case ss = string:
            {
                return ss.Length;
            }
        }
        return 0;
    }
    /*string*/ ToString()
    {
        switch(_value?.GetType())
        {
            case value = string:
            {
                return value;
            }
            case values = string:
            {
                return string.Join(_header.Separator, values);
            }
        }
        return string.Empty;
    }
    /*Enumerator*/ GetEnumerator()
    {
        return new Enumerator(_value);
    }
    /*/// <inheritdoc/>
        IEnumerator<string>*/ GetEnumerator()
    {
        return GetEnumerator();
    }
    /*/// <inheritdoc/>
        IEnumerator*/ GetEnumerator()
    {
        return GetEnumerator();
    }
    static System_Net_Http_Headers_HeaderStringValues_Enumerator = class extends System_Collections_IEnumerator(System_IDisposable(System_Collections_Generic_IEnumerator(string)(System_ValueType)))
    {
        /*string[]*/ _values = null;
        /*string*/ _current = null;
        /*int*/ _index = null;
        constructor(/*object*/ value)
        {
            super();
            if (value instanceof string, s = value)
            {
                _values = null;
                _current = s;
            }
            else 
            {
                _values = BlazorJs.As(value, string);
                _current = null;
            }
            _index = 0;
        }
        /*bool*/ MoveNext()
        {
            /*int*/ let index = _index;
            if (index < 0)
            {
                return false;
            }
            /*string[]*/ let values = _values;
            if (values !== null)
            {
                if (BlazorJs.Cast(index, uint) < BlazorJs.Cast(values.Length, uint))
                {
                    _index = index + 1;
                    _current = values[index];
                    return true;
                }
                _index = 1;
                return false;
            }
            _index = 1;
            return _current !== null;
        }
        /*string*/ get Current()
        {
            return _current;
        }
        /*/// <inheritdoc/>
            object*/ get Current()
        {
            return Current;
        }
        /*void*/ Dispose()
        {
        }
        /*/// <inheritdoc/>
            void*/ Reset()
        {
            throw new NotSupportedException();
        }
    }
}

static class System_Net_Http_Headers_HeaderUtilities
{
    /*string*/ qualityName = "q";
    /*string*/ ConnectionClose = "close";
    /*TransferCodingHeaderValue*/ static TransferEncodingChunked = new TransferCodingHeaderValue("chunked");
    /*NameValueWithParametersHeaderValue*/ static ExpectContinue = new NameValueWithParametersHeaderValue("100-continue");
    /*string*/ BytesUnit = "bytes";
    /*string*/ static s_rfc5987AttrBytes = "!#$&+-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ^_`abcdefghijklmnopqrstuvwxyz|~";
    /*void*/ static SetQuality(/*UnvalidatedObjectCollection<NameValueHeaderValue>*/ parameters, /*double?*/ value)
    {
        Debug.Assert(parameters !== null);
        /*NameValueHeaderValue*/ let qualityParameter = NameValueHeaderValue.Find(parameters, qualityName);
        if (value.HasValue)
        {
            /*// Note that even if we check the value here, we can't prevent a user from adding an invalid quality
                // value using Parameters.Add(). Even if we would prevent the user from adding an invalid value
                // using Parameters.Add() they could always add invalid values using HttpHeaders.AddWithoutValidation().
                // So this check is really for convenience to show users that they're trying to add an invalid
                // value.
                double*/ let d = value.GetValueOrDefault();
            if (d < 0 || d > 1)
            throw new ArgumentOutOfRangeException();
            /*string*/ let qualityString = d.ToString("0.0##", NumberFormatInfo.InvariantInfo);
            if (qualityParameter !== null)
            {
                qualityParameter.Value  = qualityString;
            }
            else 
            {
                parameters.Add(new NameValueHeaderValue(qualityName, qualityString));
            }
        }
        else 
        {
            if (qualityParameter !== null)
            {
                parameters.Remove(qualityParameter);
            }
        }
    }
    /*string*/ static Encode5987(/*string*/ input)
    {
        /*var*/ let builder = new StringBuilder(256);
        /*byte[]*/ let utf8bytes = ArrayPool(byte).Shared.Rent(Encoding.UTF8.GetMaxByteCount(input.Length));
        /*int*/ let utf8length = Encoding.UTF8.GetBytes(input, 0, input.Length, utf8bytes, 0);
        builder.Append("utf-8\'\'");
        /*ReadOnlySpan<byte>*/ let utf8 = utf8bytes.AsReadOnlySpan(0, utf8length);
        do
        {
            /*int*/ let length = utf8.IndexOfAnyExcept(Encoding.ASCII.GetBytes(s_rfc5987AttrBytes));
            if (length < 0)
            {
                length = utf8.Length;
            }
            BlazorJs.forEach(utf8.Slice(0, length), function(b, $_i)
            {
                builder.Append(b);
            });
            utf8 = utf8.Slice(length);
            if (utf8.IsEmpty)
            {
                break;
            }
            length = utf8.IndexOfAny(Encoding.ASCII.GetBytes(s_rfc5987AttrBytes));
            if (length < 0)
            {
                length = utf8.Length;
            }
            BlazorJs.forEach(utf8.Slice(0, length), function(b, $_i)
            {
                let $ref0 = { set value(v){ builder = v } };
                AddHexEscaped(b, $ref0);
            });
            utf8 = utf8.Slice(length);
        } while(utf8.IsEmpty);
        ArrayPool(byte).Shared.Return(utf8bytes);
        return builder.ToString();
    }
    /*void*/ static AddHexEscaped(/*byte*/ c, /*ref StringBuilder*/ destination)
    {
        destination.Append('%');
        destination.Append(HexConverter.ToCharUpper(c >> 4));
        destination.Append(HexConverter.ToCharUpper(c));
    }
    /*double?*/ static GetQuality(/*UnvalidatedObjectCollection<NameValueHeaderValue>*/ parameters)
    {
        Debug.Assert(parameters !== null);
        /*NameValueHeaderValue*/ let qualityParameter = NameValueHeaderValue.Find(parameters, qualityName);
        if (qualityParameter !== null)
        {
            let $ref0 = { set value(v){ qualityValue = v } };
            /*// Note that the RFC requires decimal '.' regardless of the culture. I.e. using ',' as decimal
                // separator is considered invalid (even if the current culture would allow it).
                double*/ let qualityValue;
            if (double.TryParse(qualityParameter.Value, $ref0))
            {
                return qualityValue;
            }
        }
        return null;
    }
    /*void*/ static CheckValidToken(/*string*/ value, { /*string*/ parameterName = null})
    {
        if (string.IsNullOrEmpty(value))
        throw new ArgumentException(nameof(value));
        if (HttpRuleParser.IsToken(value.AsSpan()))
        {
            throw new FormatException("net_http_headers_invalid_value");
        }
    }
    /*void*/ static CheckValidComment(/*string*/ value, { /*string*/ parameterName = null})
    {
        let length = null;
        let $ref1 = { set value(v){ length = v } };
        if (string.IsNullOrEmpty(value))
        throw new ArgumentException(nameof(value));
        if ((HttpRuleParser.GetCommentLength(value, 0, $ref1) !== HttpParseResult.Parsed) || (length !== value.Length))
        {
            throw new FormatException("net_http_headers_invalid_value");
        }
    }
    /*void*/ static CheckValidQuotedString(/*string*/ value, { /*string*/ parameterName = null})
    {
        let length = null;
        let $ref1 = { set value(v){ length = v } };
        if (string.IsNullOrEmpty(value))
        throw new ArgumentException(nameof(value));
        if ((HttpRuleParser.GetQuotedStringLength(value, 0, $ref1) !== HttpParseResult.Parsed) || (length !== value.Length))
        {
            throw new FormatException("net_http_headers_invalid_value");
        }
    }
    /*bool*/ static AreEqualCollections(T, /*ObjectCollection<T>*/ x, /*ObjectCollection<T>*/ y)
    {
        return AreEqualCollections(x, y, null);
    }
    /*bool*/ static AreEqualCollections(T, /*ObjectCollection<T>*/ x, /*ObjectCollection<T>*/ y, /*IEqualityComparer<T>*/ comparer)
    {
        if (x === null)
        {
            return (y === null) || (y.Count  === 0);
        }
        if (y === null)
        {
            return (x.Count  === 0);
        }
        if (x.Count  !== y.Count)
        {
            return false;
        }
        if (x.Count  === 0)
        {
            return true;
        }
        /*// We have two unordered lists. So comparison is an O(n*m) operation which is expensive. Usually
            // headers have 1-2 parameters (if any), so this comparison shouldn't be too expensive.
            bool[]*/ let alreadyFound = new Array(x.Count);
        /*int*/ let i = 0;
        BlazorJs.forEach(x, function(xItem, $_i)
        {
            Debug.Assert(xItem !== null);
            i = 0;
            /*bool*/ let found = false;
            BlazorJs.forEach(y, function(yItem, $_i)
            {
                if (alreadyFound[i])
                {
                    if (((comparer === null) && xItem.Equals(yItem)) || ((comparer !== null) && comparer.Equals(xItem, yItem)))
                    {
                        alreadyFound[i] = true;
                        found = true;
                        break;
                    }
                }
                i++;
            });
            if (found)
            {
                return false;
            }
        });
        Debug.Assert(Array.TrueForAll(alreadyFound, function(/**/ value)
        {
            return value;
        }), "Expected all values in 'alreadyFound' to be true since collections are considered equal.");
        return true;
    }
    /*int*/ static GetNextNonEmptyOrWhitespaceIndex(/*string*/ input, /*int*/ startIndex, /*bool*/ skipEmptyValues, /*out bool*/ separatorFound)
    {
        Debug.Assert(input !== null);
        Debug.Assert(startIndex <= input.Length);
        separatorFound = false;
        /*int*/ let current = startIndex + HttpRuleParser.GetWhitespaceLength(input, startIndex);
        if ((current === input.Length) || (input[current] !== ','))
        {
            return current;
        }
        separatorFound = true;
        current++;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        if (skipEmptyValues)
        {
            while((current < input.Length) && (input[current] === ','))
            {
                current++;
                current += HttpRuleParser.GetWhitespaceLength(input, current);
            }
        }
        return current;
    }
    /*DateTimeOffset?*/ static GetDateTimeOffsetValue(/*HeaderDescriptor*/ descriptor, /*HttpHeaders*/ store, { /*DateTimeOffset?*/ defaultValue = null})
    {
        Debug.Assert(store !== null);
        /*object*/ let storedValue = store.GetSingleParsedValue(descriptor);
        if (storedValue !== null)
        {
            return BlazorJs.Cast(storedValue, DateTimeOffset);
        }
        else if (defaultValue !== null && store.Contains(descriptor))
        {
            return defaultValue;
        }
        return null;
    }
    /*TimeSpan?*/ static GetTimeSpanValue(/*HeaderDescriptor*/ descriptor, /*HttpHeaders*/ store)
    {
        Debug.Assert(store !== null);
        /*object*/ let storedValue = store.GetSingleParsedValue(descriptor);
        if (storedValue !== null)
        {
            return BlazorJs.Cast(storedValue, TimeSpan);
        }
        return null;
    }
    /*bool*/ static TryParseInt32(/*string*/ value, /*out int*/ result)
    {
        let $ref0 = { set value(v){ result = v } };
        return int.TryParse(value, $ref0);
    }
    /*bool*/ static TryParseInt32(/*string*/ value, /*int*/ offset, /*int*/ length, /*out int*/ result)
    {
        let $ref0 = { set value(v){ result = v } };
        if (offset < 0 || length < 0 || offset > value.Length  - length)
        {
            result = 0;
            return false;
        }
        return int.TryParse(value.AsSpan(offset, length), $ref0);
    }
    /*bool*/ static TryParseInt64(/*string*/ value, /*int*/ offset, /*int*/ length, /*out long*/ result)
    {
        let $ref0 = { set value(v){ result = v } };
        if (offset < 0 || length < 0 || offset > value.Length  - length)
        {
            result = 0;
            return false;
        }
        return long.TryParse(value.AsSpan(offset, length), $ref0);
    }
    /*void*/ static DumpHeaders(/*StringBuilder*/ sb, /*params HttpHeaders[]*/ headers)
    {
        sb.AppendLine("{");
        for(/*int*/ let i = 0; i < headers.Length; i++)
        {
            if (headers[i] instanceof HttpHeaders)
            {
                BlazorJs.forEach(hh.NonValidated, function(header, $_i)
                {
                    BlazorJs.forEach(header.Value, function(headerValue, $_i)
                    {
                        sb.Append("  ");
                        sb.Append(header.Key);
                        sb.Append(": ");
                        sb.AppendLine(headerValue);
                    });
                });
            }
        }
        sb.Append('}');
    }
    /*UnvalidatedObjectCollection<NameValueHeaderValue>*/ static Clone(/*this UnvalidatedObjectCollection<NameValueHeaderValue>*/ source)
    {
        if (source === null)
        return null;
        /*var*/ let copy = new UnvalidatedObjectCollection(NameValueHeaderValue)();
        BlazorJs.forEach(source, function(item, $_i)
        {
            copy.Add(new NameValueHeaderValue(item));
        });
        return copy;
    }
}

class System_Net_Http_Headers_HttpContentHeaders extends System_Net_Http_Headers_HttpHeaders
{
    /*HttpContent*/ _parent = null;
    /*bool*/ _contentLengthSet = null;
    /*HttpHeaderValueCollection<string>*/ _allow = null;
    /*HttpHeaderValueCollection<string>*/ _contentEncoding = null;
    /*HttpHeaderValueCollection<string>*/ _contentLanguage = null;
    /*ICollection<string>*/ get Allow()
    {
        return _allow = _allow ?? new HttpHeaderValueCollection(string)(KnownHeaders.Allow.Descriptor, this);
    }
    /*ContentDispositionHeaderValue*/ get ContentDisposition()
    {
        return BlazorJs.Cast(GetSingleParsedValue(KnownHeaders.ContentDisposition.Descriptor), ContentDispositionHeaderValue);
    }
    /*ContentDispositionHeaderValue*/ set ContentDisposition(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.ContentDisposition.Descriptor, value);
    }
    /*ICollection<string>*/ get ContentEncoding()
    {
        return _contentEncoding = _contentEncoding ?? new HttpHeaderValueCollection(string)(KnownHeaders.ContentEncoding.Descriptor, this);
    }
    /*ICollection<string>*/ get ContentLanguage()
    {
        return _contentLanguage = _contentLanguage ?? new HttpHeaderValueCollection(string)(KnownHeaders.ContentLanguage.Descriptor, this);
    }
    /*long?*/ get ContentLength()
    {
        /*// 'Content-Length' can only hold one value. So either we get 'null' back or a boxed long value.
                object*/ let storedValue = GetSingleParsedValue(KnownHeaders.ContentLength.Descriptor);
        if (_contentLengthSet && (storedValue === null))
        {
            /*// If we don't have a value for Content-Length in the store, try to let the content calculate
                    // it's length. If the content object is able to calculate the length, we'll store it in the
                    // store.
                    long?*/ let calculatedLength = _parent.GetComputedOrBufferLength();
            if (calculatedLength !== null)
            {
                SetParsedValue(KnownHeaders.ContentLength.Descriptor, BlazorJs.Cast(calculatedLength.Value, object));
            }
            return calculatedLength;
        }
        if (storedValue === null)
        {
            return null;
        }
        else 
        {
            return BlazorJs.Cast(storedValue, long);
        }
    }
    /*long?*/ set ContentLength(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.ContentLength.Descriptor, value);
        _contentLengthSet = true;
    }
    /*Uri*/ get ContentLocation()
    {
        return BlazorJs.Cast(GetSingleParsedValue(KnownHeaders.ContentLocation.Descriptor), Uri);
    }
    /*Uri*/ set ContentLocation(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.ContentLocation.Descriptor, value);
    }
    /*byte[]*/ get ContentMD5()
    {
        return BlazorJs.Cast(GetSingleParsedValue(KnownHeaders.ContentMD5.Descriptor), byte);
    }
    /*byte[]*/ set ContentMD5(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.ContentMD5.Descriptor, value);
    }
    /*ContentRangeHeaderValue*/ get ContentRange()
    {
        return BlazorJs.Cast(GetSingleParsedValue(KnownHeaders.ContentRange.Descriptor), ContentRangeHeaderValue);
    }
    /*ContentRangeHeaderValue*/ set ContentRange(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.ContentRange.Descriptor, value);
    }
    /*MediaTypeHeaderValue*/ get ContentType()
    {
        return BlazorJs.Cast(GetSingleParsedValue(KnownHeaders.ContentType.Descriptor), MediaTypeHeaderValue);
    }
    /*MediaTypeHeaderValue*/ set ContentType(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.ContentType.Descriptor, value);
    }
    /*DateTimeOffset?*/ get Expires()
    {
        return HeaderUtilities.GetDateTimeOffsetValue(KnownHeaders.Expires.Descriptor, this, DateTimeOffset.MinValue);
    }
    /*DateTimeOffset?*/ set Expires(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.Expires.Descriptor, value);
    }
    /*DateTimeOffset?*/ get LastModified()
    {
        return HeaderUtilities.GetDateTimeOffsetValue(KnownHeaders.LastModified.Descriptor, this);
    }
    /*DateTimeOffset?*/ set LastModified(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.LastModified.Descriptor, value);
    }
    constructor(/*HttpContent*/ parent)
    {
        super(HttpHeaderType.Content  | HttpHeaderType.Custom, HttpHeaderType.None);
        _parent = parent;
    }
}

class System_Net_Http_Headers_HttpGeneralHeaders extends object
{
    /*HttpHeaderValueCollection<string>*/ _connection = null;
    /*HttpHeaderValueCollection<string>*/ _trailer = null;
    /*HttpHeaderValueCollection<TransferCodingHeaderValue>*/ _transferEncoding = null;
    /*HttpHeaderValueCollection<ProductHeaderValue>*/ _upgrade = null;
    /*HttpHeaderValueCollection<ViaHeaderValue>*/ _via = null;
    /*HttpHeaderValueCollection<WarningHeaderValue>*/ _warning = null;
    /*HttpHeaderValueCollection<NameValueHeaderValue>*/ _pragma = null;
    /*HttpHeaders*/ _parent = null;
    /*bool*/ _transferEncodingChunkedSet = null;
    /*bool*/ _connectionCloseSet = null;
    /*CacheControlHeaderValue*/ get CacheControl()
    {
        return BlazorJs.Cast(_parent.GetSingleParsedValue(KnownHeaders.CacheControl.Descriptor), CacheControlHeaderValue);
    }
    /*CacheControlHeaderValue*/ set CacheControl(value)
    {
        _parent.SetOrRemoveParsedValue(KnownHeaders.CacheControl.Descriptor, value);
    }
    /*bool?*/ get ConnectionClose()
    {
        return GetConnectionClose(_parent, this);
    }
    /*bool?*/ set ConnectionClose(value)
    {
        if (value === true)
        {
            _connectionCloseSet = true;
            if (_parent.ContainsParsedValue(KnownHeaders.Connection.Descriptor, HeaderUtilities.ConnectionClose))
            {
                _parent.AddParsedValue(KnownHeaders.Connection.Descriptor, HeaderUtilities.ConnectionClose);
            }
        }
        else 
        {
            _connectionCloseSet = value !== null;
            _parent.RemoveParsedValue(KnownHeaders.Connection.Descriptor, HeaderUtilities.ConnectionClose);
        }
    }
    /*bool?*/ static GetConnectionClose(/*HttpHeaders*/ parent, /*HttpGeneralHeaders*/ headers)
    {
        if (parent.ContainsParsedValue(KnownHeaders.Connection.Descriptor, HeaderUtilities.ConnectionClose))
        {
            return true;
        }
        if (headers !== null && headers._connectionCloseSet)
        {
            return false;
        }
        return null;
    }
    /*DateTimeOffset?*/ get Date()
    {
        return HeaderUtilities.GetDateTimeOffsetValue(KnownHeaders.Date.Descriptor, _parent);
    }
    /*DateTimeOffset?*/ set Date(value)
    {
        _parent.SetOrRemoveParsedValue(KnownHeaders.Date.Descriptor, value);
    }
    /*HttpHeaderValueCollection<NameValueHeaderValue>*/ get Pragma()
    {
        return _pragma = _pragma ?? new HttpHeaderValueCollection(NameValueHeaderValue)(KnownHeaders.Pragma.Descriptor, _parent);
    }
    /*HttpHeaderValueCollection<string>*/ get Trailer()
    {
        return _trailer = _trailer ?? new HttpHeaderValueCollection(string)(KnownHeaders.Trailer.Descriptor, _parent);
    }
    /*bool?*/ static GetTransferEncodingChunked(/*HttpHeaders*/ parent, /*HttpGeneralHeaders*/ headers)
    {
        let value = null;
        let $ref1 = { set value(v){ value = v } };
        if (parent.TryGetHeaderValue(KnownHeaders.TransferEncoding.Descriptor, $ref1))
        {
            if (value.Value  instanceof string && stringValue.Equals("chunked", StringComparison.OrdinalIgnoreCase))
            {
                return true;
            }
            if (parent.ContainsParsedValue(KnownHeaders.TransferEncoding.Descriptor, HeaderUtilities.TransferEncodingChunked))
            {
                return true;
            }
        }
        if (headers !== null && headers._transferEncodingChunkedSet)
        {
            return false;
        }
        return null;
    }
    /*bool?*/ get TransferEncodingChunked()
    {
        return GetTransferEncodingChunked(_parent, this);
    }
    /*bool?*/ set TransferEncodingChunked(value)
    {
        if (value === true)
        {
            _transferEncodingChunkedSet = true;
            if (_parent.ContainsParsedValue(KnownHeaders.TransferEncoding.Descriptor, HeaderUtilities.TransferEncodingChunked))
            {
                _parent.AddParsedValue(KnownHeaders.TransferEncoding.Descriptor, HeaderUtilities.TransferEncodingChunked);
            }
        }
        else 
        {
            _transferEncodingChunkedSet = value !== null;
            _parent.RemoveParsedValue(KnownHeaders.TransferEncoding.Descriptor, HeaderUtilities.TransferEncodingChunked);
        }
    }
    /*HttpHeaderValueCollection<ProductHeaderValue>*/ get Upgrade()
    {
        return _upgrade = _upgrade ?? new HttpHeaderValueCollection(ProductHeaderValue)(KnownHeaders.Upgrade.Descriptor, _parent);
    }
    /*HttpHeaderValueCollection<ViaHeaderValue>*/ get Via()
    {
        return _via = _via ?? new HttpHeaderValueCollection(ViaHeaderValue)(KnownHeaders.Via.Descriptor, _parent);
    }
    /*HttpHeaderValueCollection<WarningHeaderValue>*/ get Warning()
    {
        return _warning = _warning ?? new HttpHeaderValueCollection(WarningHeaderValue)(KnownHeaders.Warning.Descriptor, _parent);
    }
    /*HttpHeaderValueCollection<string>*/ get Connection()
    {
        return _connection = _connection ?? new HttpHeaderValueCollection(string)(KnownHeaders.Connection.Descriptor, _parent);
    }
    /*HttpHeaderValueCollection<TransferCodingHeaderValue>*/ get TransferEncoding()
    {
        return _transferEncoding = _transferEncoding ?? new HttpHeaderValueCollection(TransferCodingHeaderValue)(KnownHeaders.TransferEncoding.Descriptor, _parent);
    }
    constructor(/*HttpHeaders*/ parent)
    {
        super();
        Debug.Assert(parent !== null);
        _parent = parent;
    }
    /*void*/ AddSpecialsFrom(/*HttpGeneralHeaders*/ sourceHeaders)
    {
        /*// Copy special values, but do not overwrite
            bool?*/ let chunked = TransferEncodingChunked;
        if (chunked.HasValue)
        {
            TransferEncodingChunked = sourceHeaders.TransferEncodingChunked;
        }
        /*bool?*/ let close = ConnectionClose;
        if (close.HasValue)
        {
            ConnectionClose = sourceHeaders.ConnectionClose;
        }
    }
}

class System_Net_Http_Headers_HttpHeaderParser extends object
{
    /*string*/ DefaultSeparator = ", ";
    /*byte[]*/ static DefaultSeparatorBytes = [ BlazorJs.Cast(',', byte), BlazorJs.Cast(' ', byte) ];
    /*bool*/ _backingField_SupportsMultipleValues = null;
    /*bool*/ get SupportsMultipleValues()
    {
        return _backingField_SupportsMultipleValues;
    }
    /*string*/ _backingField_Separator = null;
    /*string*/ get Separator()
    {
        return _backingField_Separator;
    }
    /*byte[]*/ _backingField_SeparatorBytes = null;
    /*byte[]*/ get SeparatorBytes()
    {
        return _backingField_SeparatorBytes;
    }
    /*IEqualityComparer*/ get Comparer()
    {
        return null;
    }
    constructor(/*bool*/ supportsMultipleValues)
    {
        super();
        SupportsMultipleValues = supportsMultipleValues;
        Separator = DefaultSeparator;
        SeparatorBytes = DefaultSeparatorBytes;
    }
    constructor(/*bool*/ supportsMultipleValues, /*string*/ separator)
    {
        super(supportsMultipleValues);
        Debug.Assert(string.IsNullOrEmpty(separator));
        Debug.Assert(Ascii.IsValid(separator));
        if (supportsMultipleValues)
        {
            Separator = separator;
            SeparatorBytes = Encoding.ASCII.GetBytes(separator);
        }
    }
    /*object*/ ParseValue(/*string*/ value, /*object*/ storeValue, /*ref int*/ index)
    {
        let $ref0 = { set value(v){ index = v } };
        let result = null;
        let $ref2 = { set value(v){ result = v } };
        Debug.Assert((value === null) || ((index >= 0) && (index <= value.Length)));
        if (TryParseValue(value, storeValue, $ref0, $ref2))
        {
            throw new FormatException("net_http_headers_invalid_value");
        }
        return result;
    }
    /*string*/ ToString(/*object*/ value)
    {
        Debug.Assert(value !== null);
        return value.ToString();
    }
}

class System_Net_Http_Headers_HeaderEntry extends object
{
    /*HeaderDescriptor*/ Key = null;
    /*object*/ Value = null;
    constructor()
    {
        super();
    }
    constructor(/*HeaderDescriptor*/ key, /*object*/ value)
    {
        super();
        Key = key;
        Value = value;
    }
}
class System_Net_Http_Headers_HttpHeaders extends H5_IH5Class(System_Collections_IEnumerable(System_Collections_Generic_IEnumerable(System_Collections_Generic_KeyValuePair(string, System_Collections_Generic_IEnumerable(string)))(object)))
{
    /*object*/ _headerStore = null;
    /*int*/ _count = null;
    /*HttpHeaderType*/ _allowedHeaderTypes = null;
    /*HttpHeaderType*/ _treatAsCustomHeaderTypes = null;
    constructor()
    {
        super(HttpHeaderType.All, HttpHeaderType.None);
    }
    constructor(/*HttpHeaderType*/ allowedHeaderTypes, /*HttpHeaderType*/ treatAsCustomHeaderTypes)
    {
        super();
        Debug.Assert((allowedHeaderTypes & treatAsCustomHeaderTypes) === 0);
        _allowedHeaderTypes = allowedHeaderTypes & HttpHeaderType.NonTrailing;
        _treatAsCustomHeaderTypes = treatAsCustomHeaderTypes & HttpHeaderType.NonTrailing;
    }
    /*HttpHeadersNonValidated*/ get NonValidated()
    {
        return new HttpHeadersNonValidated(this);
    }
    /*void*/ Add(/*string*/ name, /*string*/ value)
    {
        return Add(GetHeaderDescriptor(name), value);
    }
    /*void*/ Add(/*HeaderDescriptor*/ descriptor, /*string*/ value)
    {
        let info = null;
        let $ref1 = { set value(v){ info = v } };
        let addToStore = null;
        let $ref3 = { set value(v){ addToStore = v } };
        PrepareHeaderInfoForAdd(descriptor, $ref1, $ref3);
        ParseAndAddValue(descriptor, info, value);
        if (addToStore && (info.ParsedAndInvalidValues  !== null))
        {
            info.AssertContainsNoInvalidValues();
            Debug.Assert(Contains(descriptor));
            AddEntryToStore(new HeaderEntry(descriptor, info));
        }
    }
    /*void*/ Add(/*string*/ name, /*IEnumerable<string>*/ values)
    {
        return Add(GetHeaderDescriptor(name), values);
    }
    /*void*/ Add(/*HeaderDescriptor*/ descriptor, /*IEnumerable<string>*/ values)
    {
        let info = null;
        let $ref1 = { set value(v){ info = v } };
        let addToStore = null;
        let $ref3 = { set value(v){ addToStore = v } };
        if (values === null)
        throw new ArgumentNullException(nameof(values));
        PrepareHeaderInfoForAdd(descriptor, $ref1, $ref3);
        try
        {
            BlazorJs.forEach(values, function(value, $_i)
            {
                ParseAndAddValue(descriptor, info, value);
            });
        }
        finally
        {
            {
                if (addToStore && (info.ParsedAndInvalidValues  !== null))
                {
                    info.AssertContainsNoInvalidValues();
                    Debug.Assert(Contains(descriptor));
                    AddEntryToStore(new HeaderEntry(descriptor, info));
                }
            }
        }
    }
    /*bool*/ TryAddWithoutValidation(/*string*/ name, /*string*/ value)
    {
        let descriptor = null;
        let $ref1 = { set value(v){ descriptor = v } };
        return TryGetHeaderDescriptor(name, $ref1) && TryAddWithoutValidation(descriptor, value);
    }
    /*bool*/ TryAddWithoutValidation(/*HeaderDescriptor*/ descriptor, /*string*/ value)
    {
        value = value ?? string.Empty;
        /*var*/ let storeValueRef = GetValueRefOrAddDefault(descriptor);
        /*object*/ let currentValue = storeValueRef.Value;
        if (currentValue)
        {
            storeValueRef.Value  = value;
        }
        else 
        {
            if ((currentValue instanceof HeaderStoreItemInfo, info = currentValue))
            {
                Debug.Assert(currentValue instanceof string);
                storeValueRef.Value  = info = BlazorJs.PopulateProperty(new HeaderStoreItemInfo(), function(/*HeaderStoreItemInfo*/ $obj)
                {
                    $obj.RawValue = currentValue;
                });
            }
            AddRawValue(info, value);
        }
        return true;
    }
    /*bool*/ TryAddWithoutValidation(/*string*/ name, /*IEnumerable<string>*/ values)
    {
        let descriptor = null;
        let $ref1 = { set value(v){ descriptor = v } };
        return TryGetHeaderDescriptor(name, $ref1) && TryAddWithoutValidation(descriptor, values);
    }
    /*bool*/ TryAddWithoutValidation(/*HeaderDescriptor*/ descriptor, /*IEnumerable<string>*/ values)
    {
        if (values === null)
        throw new ArgumentNullException(nameof(values));
        if (values instanceof IList(string), valuesList = values)
        {
            /*int*/ let count = valuesList.Count;
            if (count > 0)
            {
                /*// The store value is either a string (a single unparsed value) or a HeaderStoreItemInfo.
                    // The RawValue on HeaderStoreItemInfo can likewise be either a single string or a List<string>.

                    var*/ let storeValueRef = GetValueRefOrAddDefault(descriptor);
                /*object*/ let storeValue = storeValueRef.Value;
                if ((storeValue) || count > 1)
                {
                    if ((storeValue instanceof HeaderStoreItemInfo, info = storeValue))
                    {
                        storeValueRef.Value  = info = BlazorJs.PopulateProperty(new HeaderStoreItemInfo(), function(/*HeaderStoreItemInfo*/ $obj)
                        {
                            $obj.RawValue = storeValue;
                        });
                    }
                    /*object*/ let rawValue = info.RawValue;
                    if ((rawValue instanceof List(string), rawValues = rawValue))
                    {
                        info.RawValue  = rawValues = new List(string)();
                        if (rawValue !== null)
                        {
                            rawValues.Add(BlazorJs.Cast(rawValue, string));
                        }
                    }
                    for(/*int*/ let i = 0; i < count; i++)
                    {
                        rawValues.Add(valuesList[i] ?? string.Empty);
                    }
                }
                else 
                {
                    storeValueRef.Value  = valuesList[0] ?? string.Empty;
                }
            }
        }
        else 
        {
            BlazorJs.forEach(values, function(value, $_i)
            {
                TryAddWithoutValidation(descriptor, value ?? string.Empty);
            });
        }
        return true;
    }
    /*IEnumerable<string>*/ GetValues(/*string*/ name)
    {
        return GetValues(GetHeaderDescriptor(name));
    }
    /*IEnumerable<string>*/ GetValues(/*HeaderDescriptor*/ descriptor)
    {
        let values = null;
        let $ref1 = { set value(v){ values = v } };
        if (TryGetValues(descriptor, $ref1))
        {
            return values;
        }
        throw new InvalidOperationException("net_http_headers_not_found");
    }
    /*bool*/ TryGetValues(/*string*/ name, /*out IEnumerable<string>*/ values)
    {
        let descriptor = null;
        let $ref1 = { set value(v){ descriptor = v } };
        if (TryGetHeaderDescriptor(name, $ref1))
        {
            let $ref0 = { set value(v){ values = v } };
            return TryGetValues(descriptor, $ref0);
        }
        values = null;
        return false;
    }
    /*bool*/ TryGetValues(/*HeaderDescriptor*/ descriptor, /*out IEnumerable<string>*/ values)
    {
        let info = null;
        let $ref1 = { set value(v){ info = v } };
        if (TryGetAndParseHeaderInfo(descriptor, $ref1))
        {
            values = GetStoreValuesAsStringArray(descriptor, info);
            return true;
        }
        values = null;
        return false;
    }
    /*bool*/ Contains(/*string*/ name)
    {
        return Contains(GetHeaderDescriptor(name));
    }
    /*string*/ ToString()
    {
        /*// Return all headers as string similar to:
            // HeaderName1: Value1, Value2
            // HeaderName2: Value1
            // ...

            var*/ let vsb = new StringBuilder(512);
        BlazorJs.forEach(GetEntries(), function(entry, $_i)
        {
            let singleValue = null;
            let $ref1 = { set value(v){ singleValue = v } };
            let multiValue = null;
            let $ref3 = { set value(v){ multiValue = v } };
            vsb.Append(entry.Key.Name);
            vsb.Append(": ");
            GetStoreValuesAsStringOrStringArray(entry.Key, entry.Value, $ref1, $ref3);
            Debug.Assert((singleValue) ^ (multiValue));
            if ((singleValue))
            {
                vsb.Append(singleValue);
            }
            else 
            {
                /*// Note that if we get multiple values for a header that doesn't support multiple values, we'll
                    // just separate the values using a comma (default separator).
                    string*/ let separator = entry.Key.Separator;
                Debug.Assert((multiValue) && multiValue.Length  > 0);
                vsb.Append(multiValue[0]);
                for(/*int*/ let i = 1; i < multiValue.Length; i++)
                {
                    vsb.Append(separator);
                    vsb.Append(multiValue[i]);
                }
            }
            vsb.Append(Environment.NewLine);
        });
        return vsb.ToString();
    }
    /*string*/ GetHeaderString(/*HeaderDescriptor*/ descriptor)
    {
        let info = null;
        let $ref1 = { set value(v){ info = v } };
        if (TryGetHeaderValue(descriptor, $ref1))
        {
            let singleValue = null;
            let $ref1 = { set value(v){ singleValue = v } };
            let multiValue = null;
            let $ref3 = { set value(v){ multiValue = v } };
            GetStoreValuesAsStringOrStringArray(descriptor, info, $ref1, $ref3);
            Debug.Assert((singleValue) ^ (multiValue));
            if ((singleValue))
            {
                return singleValue;
            }
            return string.Join(descriptor.Separator, multiValue);
        }
        return string.Empty;
    }
    /*IEnumerator<KeyValuePair<string, IEnumerable<string>>>*/ GetEnumerator()
    {
        return _count === 0 ? (BlazorJs.Cast(Array.Empty(KeyValuePair(string, IEnumerable(string))), IEnumerable(KeyValuePair(string, IEnumerable(string))))).GetEnumerator() : GetEnumeratorCore();
    }
    /*IEnumerator<KeyValuePair<string, IEnumerable<string>>>*/ GetEnumeratorCore()
    {
        /*HeaderEntry[]*/ let entries = GetEntriesArray();
        Debug.Assert(_count !== 0 && (entries), "Caller should have validated the collection is not empty");
        for(/*int*/ let i = 0; i < _count; i++)
        {
            /*HeaderEntry*/ let entry = entries[i];
            if ((entry.Value  instanceof HeaderStoreItemInfo))
            {
                /*// To retain consistent semantics, we need to upgrade a raw string to a HeaderStoreItemInfo
                    // during enumeration so that we can parse the raw value in order to a) return
                    // the correct set of parsed values, and b) update the instance for subsequent enumerations
                    // to reflect that parsing.

                    //#nullable disable // https://github.com/dotnet/roslyn/issues/73928
                    var*/ let storeValueRef = EntriesAreLiveView ? entries[i] : (BlazorJs.Cast(_headerStore, Dictionary(HeaderDescriptor, HeaderEntry))).GetValueOrDefault(entry.Key);
                info = ReplaceWithHeaderStoreItemInfo(storeValueRef, entry.Value);
            }
            ParseRawHeaderValues(entry.Key, info);
            /*string[]*/ let values = GetStoreValuesAsStringArray(entry.Key, info);
new KeyValuePair(string, IEnumerable(string))(entry.Key.Name, values)        }
    }
    /*#endregion

        #region IEnumerable Members

        Collections.IEnumerator*/ GetEnumerator()
    {
        return GetEnumerator();
    }
    /*void*/ AddParsedValue(/*HeaderDescriptor*/ descriptor, /*object*/ value)
    {
        Debug.Assert(value !== null);
        Debug.Assert(descriptor.Parser  !== null, "Can't add parsed value if there is no parser available.");
        /*HeaderStoreItemInfo*/ let info = GetOrCreateHeaderInfo(descriptor);
        Debug.Assert(descriptor.Parser.SupportsMultipleValues, `Header '${descriptor.Name}' doesn't support multiple values`);
        AddParsedValue(info, value);
    }
    /*void*/ SetParsedValue(/*HeaderDescriptor*/ descriptor, /*object*/ value)
    {
        Debug.Assert(value !== null);
        Debug.Assert(descriptor.Parser  !== null, "Can't add parsed value if there is no parser available.");
        /*// This method will first clear all values. This is used e.g. when setting the 'Date' or 'Host' header.
            // i.e. headers not supporting collections.
            HeaderStoreItemInfo*/ let info = GetOrCreateHeaderInfo(descriptor);
        info.ParsedAndInvalidValues  = null;
        info.RawValue  = null;
        AddParsedValue(info, value);
    }
    /*void*/ SetOrRemoveParsedValue(/*HeaderDescriptor*/ descriptor, /*object*/ value)
    {
        if (value === null)
        {
            Remove(descriptor);
        }
        else 
        {
            SetParsedValue(descriptor, value);
        }
    }
    /*bool*/ Remove(/*string*/ name)
    {
        return Remove(GetHeaderDescriptor(name));
    }
    /*bool*/ RemoveParsedValue(/*HeaderDescriptor*/ descriptor, /*object*/ value)
    {
        let info = null;
        let $ref1 = { set value(v){ info = v } };
        Debug.Assert(value !== null);
        if (TryGetAndParseHeaderInfo(descriptor, $ref1))
        {
            Debug.Assert(descriptor.Parser  !== null, "Can't add parsed value if there is no parser available.");
            Debug.Assert(descriptor.Parser.SupportsMultipleValues, "This method should not be used for single-value headers. Use Remove(string) instead.");
            /*// If there is no entry, just return.
                var*/ let parsedValue = info.ParsedAndInvalidValues;
            if (parsedValue === null)
            {
                return false;
            }
            /*bool*/ let result = false;
            /*IEqualityComparer*/ let comparer = descriptor.Parser.Comparer;
            /*List<object>*/ let parsedValues = BlazorJs.As(parsedValue, List(object));
            if (parsedValues === null)
            {
                if ((parsedValue instanceof InvalidValue))
                {
                    Debug.Assert(parsedValue.GetType() === value.GetType(), "Stored value does not have the same type as 'value'.");
                    if (AreEqual(value, parsedValue, comparer))
                    {
                        info.ParsedAndInvalidValues  = null;
                        result = true;
                    }
                }
            }
            else 
            {
                BlazorJs.forEach(parsedValues, function(item, $_i)
                {
                    if ((item instanceof InvalidValue))
                    {
                        Debug.Assert(item.GetType() === value.GetType(), "One of the stored values does not have the same type as 'value'.");
                        if (AreEqual(value, item, comparer))
                        {
                            result = parsedValues.Remove(item);
                            break;
                        }
                    }
                });
                if (parsedValues.Count  === 0)
                {
                    info.AssertContainsNoInvalidValues();
                    info.ParsedAndInvalidValues  = null;
                }
            }
            if (info.IsEmpty)
            {
                /*bool*/ let headerRemoved = Remove(descriptor);
                Debug.Assert(headerRemoved, `Existing header '${descriptor.Name}' couldn't be removed.`);
            }
            return result;
        }
        return false;
    }
    /*bool*/ ContainsParsedValue(/*HeaderDescriptor*/ descriptor, /*object*/ value)
    {
        let info = null;
        let $ref1 = { set value(v){ info = v } };
        Debug.Assert(value !== null);
        if (TryGetAndParseHeaderInfo(descriptor, $ref1))
        {
            Debug.Assert(descriptor.Parser  !== null, "Can't add parsed value if there is no parser available.");
            Debug.Assert(descriptor.Parser.SupportsMultipleValues, "This method should not be used for single-value headers. Use equality comparer instead.");
            /*// If there is no entry, just return.
                var*/ let parsedValue = info.ParsedAndInvalidValues;
            if (parsedValue === null)
            {
                return false;
            }
            /*List<object>*/ let parsedValues = BlazorJs.As(parsedValue, List(object));
            /*IEqualityComparer*/ let comparer = descriptor.Parser.Comparer;
            if (parsedValues === null)
            {
                if ((parsedValue instanceof InvalidValue))
                {
                    Debug.Assert(parsedValue.GetType() === value.GetType(), "Stored value does not have the same type as 'value'.");
                    return AreEqual(value, parsedValue, comparer);
                }
            }
            else 
            {
                BlazorJs.forEach(parsedValues, function(item, $_i)
                {
                    if ((item instanceof InvalidValue))
                    {
                        Debug.Assert(item.GetType() === value.GetType(), "One of the stored values does not have the same type as 'value'.");
                        if (AreEqual(value, item, comparer))
                        {
                            return true;
                        }
                    }
                });
                return false;
            }
        }
        return false;
    }
    /*void*/ AddHeaders(/*HttpHeaders*/ sourceHeaders)
    {
        Debug.Assert(sourceHeaders !== null);
        Debug.Assert(GetType() === sourceHeaders.GetType(), "Can only copy headers from an instance of the same type.");
        if (_count === 0 && sourceHeaders._headerStore  instanceof HeaderEntry)
        {
            _count = sourceHeaders._count;
            if ((_headerStore instanceof HeaderEntry, entries = _headerStore) || entries.Length  < _count)
            {
                entries = new Array(sourceEntries.Length);
                _headerStore = entries;
            }
            for(/*int*/ let i = 0; i < _count && i < sourceEntries.Length; i++)
            {
                /*HeaderEntry*/ let entry = sourceEntries[i];
                if (entry.Value  instanceof HeaderStoreItemInfo)
                {
                    entry.Value  = CloneHeaderInfo(entry.Key, info);
                }
                entries[i] = entry;
            }
        }
        else 
        {
            BlazorJs.forEach(sourceHeaders.GetEntries(), function(entry, $_i)
            {
                /*var*/ let storeValueRef = GetValueRefOrAddDefault(entry.Key);
                if (storeValueRef)
                {
                    /*object*/ let sourceValue = entry.Value;
                    if (sourceValue instanceof HeaderStoreItemInfo, info = sourceValue)
                    {
                        storeValueRef.Value  = CloneHeaderInfo(entry.Key, info);
                    }
                    else 
                    {
                        Debug.Assert(sourceValue instanceof string);
                        storeValueRef.Value  = sourceValue;
                    }
                }
            });
        }
    }
    /*HeaderStoreItemInfo*/ static CloneHeaderInfo(/*HeaderDescriptor*/ descriptor, /*HeaderStoreItemInfo*/ sourceInfo)
    {
        //lock
        {
            /*var*/ let destinationInfo = BlazorJs.PopulateProperty(new HeaderStoreItemInfo(), function(/*HeaderStoreItemInfo*/ $obj)
            {
                $obj.RawValue = CloneStringHeaderInfoValues(sourceInfo.RawValue);
            });
            if (descriptor.Parser  === null)
            {
                sourceInfo.AssertContainsNoInvalidValues();
                destinationInfo.ParsedAndInvalidValues  = CloneStringHeaderInfoValues(sourceInfo.ParsedAndInvalidValues);
            }
            else 
            {
                if (sourceInfo.ParsedAndInvalidValues  !== null)
                {
                    /*List<object>*/ let sourceValues = BlazorJs.As(sourceInfo.ParsedAndInvalidValues , List(object));
                    if (sourceValues === null)
                    {
                        CloneAndAddValue(destinationInfo, sourceInfo.ParsedAndInvalidValues);
                    }
                    else 
                    {
                        BlazorJs.forEach(sourceValues, function(item, $_i)
                        {
                            CloneAndAddValue(destinationInfo, item);
                        });
                    }
                }
            }
            return destinationInfo;
        }
    }
    /*void*/ static CloneAndAddValue(/*HeaderStoreItemInfo*/ destinationInfo, /*object*/ source)
    {
        if (source instanceof ICloneable, cloneableValue = source)
        {
            Debug.Assert((source instanceof InvalidValue));
            AddParsedValue(destinationInfo, cloneableValue.Clone());
        }
        else 
        {
            AddParsedValue(destinationInfo, source);
        }
    }
    /*object*/ static CloneStringHeaderInfoValues(/*object*/ source)
    {
        if (source === null)
        {
            return null;
        }
        /*List<object>*/ let sourceValues = BlazorJs.As(source, List(object));
        if (sourceValues === null)
        {
            return source;
        }
        else 
        {
            return new List(object)(sourceValues);
        }
    }
    /*HeaderStoreItemInfo*/ GetOrCreateHeaderInfo(/*HeaderDescriptor*/ descriptor)
    {
        let info = null;
        let $ref1 = { set value(v){ info = v } };
        if (TryGetAndParseHeaderInfo(descriptor, $ref1))
        {
            return info;
        }
        else 
        {
            return CreateAndAddHeaderToStore(descriptor);
        }
    }
    /*HeaderStoreItemInfo*/ CreateAndAddHeaderToStore(/*HeaderDescriptor*/ descriptor)
    {
        Debug.Assert(Contains(descriptor));
        /*// If we don't have the header in the store yet, add it now.
            HeaderStoreItemInfo*/ let result = new HeaderStoreItemInfo();
        Debug.Assert((descriptor.HeaderType  & _treatAsCustomHeaderTypes) === 0);
        AddEntryToStore(new HeaderEntry(descriptor, result));
        return result;
    }
    /*bool*/ TryGetHeaderValue(/*HeaderDescriptor*/ descriptor, /*out HeaderEntry*/ value)
    {
        /*//ref object storeValueRef = ref GetValueRefOrNullRef(descriptor);
            var*/ let storeValueRef = GetValueRefOrNullRef(descriptor);
        if (storeValueRef === null)
        {
            value = null;
            return false;
        }
        else 
        {
            value = storeValueRef;
            return true;
        }
    }
    /*bool*/ TryGetAndParseHeaderInfo(/*HeaderDescriptor*/ key, /*out HeaderStoreItemInfo*/ info)
    {
        /*var*/ let storeValueRef = GetValueRefOrNullRef(key);
        if ((storeValueRef === null))
        {
            /*object*/ let value = storeValueRef.Value;
            info = value instanceof HeaderStoreItemInfo, hsi = value ? hsi : ReplaceWithHeaderStoreItemInfo(storeValueRef, value);
            ParseRawHeaderValues(key, info);
            return true;
        }
        info = null;
        return false;
    }
    /*HeaderStoreItemInfo*/ static ReplaceWithHeaderStoreItemInfo(/*HeaderEntry*/ storeValueRef, /*object*/ value)
    {
        let $ref0 = { set value(v){ storeValueRef.Value = v } };
        Debug.Assert(value instanceof string);
        /*var*/ let info = BlazorJs.PopulateProperty(new HeaderStoreItemInfo(), function(/*HeaderStoreItemInfo*/ $obj)
        {
            $obj.RawValue = value;
        });
        /*object*/ let previousValue = InterlockedExtension.CompareExchange($ref0, info, value);
        if (ReferenceEquals(previousValue, value))
        {
            return info;
        }
        return BlazorJs.Cast(previousValue, HeaderStoreItemInfo);
    }
    /*void*/ static ParseRawHeaderValues(/*HeaderDescriptor*/ descriptor, /*HeaderStoreItemInfo*/ info)
    {
        //lock
        {
            Debug.Assert(info.IsEmpty);
            if (info.RawValue  !== null)
            {
                if (info.RawValue  instanceof List(string))
                {
                    BlazorJs.forEach(rawValues, function(rawValue, $_i)
                    {
                        ParseSingleRawHeaderValue(info, descriptor, rawValue);
                    });
                }
                else 
                {
                    /*string*/ let rawValue = BlazorJs.As(info.RawValue , string);
                    Debug.Assert((rawValue));
                    ParseSingleRawHeaderValue(info, descriptor, rawValue);
                }
                Debug.Assert((info.ParsedAndInvalidValues ));
                info.RawValue  = null;
            }
        }
    }
    /*void*/ static ParseSingleRawHeaderValue(/*HeaderStoreItemInfo*/ info, /*HeaderDescriptor*/ descriptor, /*string*/ rawValue)
    {
        if (descriptor.Parser  === null)
        {
            if (HttpRuleParser.ContainsNewLine(rawValue))
            {
                AddInvalidValue(info, rawValue);
            }
            else 
            {
                AddParsedValue(info, rawValue);
            }
        }
        else 
        {
            if (TryParseAndAddRawHeaderValue(descriptor, info, rawValue, true))
            {
            }
        }
    }
    /*bool*/ TryParseAndAddValue(/*HeaderDescriptor*/ descriptor, /*string*/ value)
    {
        let $ref0 = { set value(v){ info = v } };
        let $ref1 = { set value(v){ addToStore = v } };
        /*// We don't use GetOrCreateHeaderInfo() here, since this would create a new header in the store. If parsing
            // the value then throws, we would have to remove the header from the store again. So just get a
            // HeaderStoreItemInfo object and try to parse the value. If it works, we'll add the header.
            HeaderStoreItemInfo*/ let info;
        /*bool*/ let addToStore;
        PrepareHeaderInfoForAdd(descriptor, $ref0, $ref1);
        /*bool*/ let result = TryParseAndAddRawHeaderValue(descriptor, info, value, false);
        if (result && addToStore && (info.ParsedAndInvalidValues  !== null))
        {
            info.AssertContainsNoInvalidValues();
            Debug.Assert(Contains(descriptor));
            AddEntryToStore(new HeaderEntry(descriptor, info));
        }
        return result;
    }
    /*bool*/ static TryParseAndAddRawHeaderValue(/*HeaderDescriptor*/ descriptor, /*HeaderStoreItemInfo*/ info, /*string*/ value, /*bool*/ addWhenInvalid)
    {
        let $ref0 = { set value(v){ index = v } };
        let parsedValue = null;
        let $ref2 = { set value(v){ parsedValue = v } };
        Debug.Assert(info !== null);
        Debug.Assert(descriptor.Parser  !== null);
        if (info.CanAddParsedValue(descriptor.Parser))
        {
            if (addWhenInvalid)
            {
                AddInvalidValue(info, value ?? string.Empty);
            }
            return false;
        }
        /*int*/ let index = 0;
        if (descriptor.Parser.TryParseValue(value, info.ParsedAndInvalidValues, $ref0, $ref2))
        {
            if ((value === null) || (index === value.Length))
            {
                if (parsedValue !== null)
                {
                    AddParsedValue(info, parsedValue);
                }
                else if (addWhenInvalid && info.ParsedAndInvalidValues )
                {
                    AddInvalidValue(info, value ?? string.Empty);
                }
                return true;
            }
            Debug.Assert(index < value.Length, "Parser must return an index value within the string length.");
            /*// If we successfully parsed a value, but there are more left to read, store the results in a temp
                // list. Only when all values are parsed successfully write the list to the store.
                List<object>*/ let parsedValues = new List(object)();
            if (parsedValue !== null)
            {
                parsedValues.Add(parsedValue);
            }
            while(index < value.Length)
            {
                let $ref0 = { set value(v){ index = v } };
                let $ref1 = { set value(v){ parsedValue = v } };
                if (descriptor.Parser.TryParseValue(value, info.ParsedAndInvalidValues, $ref0, $ref1))
                {
                    if (parsedValue !== null)
                    {
                        parsedValues.Add(parsedValue);
                    }
                }
                else 
                {
                    if (addWhenInvalid)
                    {
                        AddInvalidValue(info, value);
                    }
                    return false;
                }
            }
            BlazorJs.forEach(parsedValues, function(item, $_i)
            {
                AddParsedValue(info, item);
            });
            if (parsedValues.Count  === 0 && addWhenInvalid && info.ParsedAndInvalidValues )
            {
                AddInvalidValue(info, value);
            }
            return true;
        }
        Debug.Assert(value !== null);
        if (addWhenInvalid)
        {
            AddInvalidValue(info, value ?? string.Empty);
        }
        return false;
    }
    /*void*/ static AddParsedValue(/*HeaderStoreItemInfo*/ info, /*object*/ value)
    {
        let $ref0 = { set value(v){ info.ParsedAndInvalidValues = v } };
        Debug.Assert((value instanceof List(object)), "Header value types must not derive from List<object> since this type is used internally to store " + "lists of values. So we would not be able to distinguish between a single value and a list of values.");
        AddValueToStoreValue(object)(object, value, $ref0);
    }
    /*void*/ static AddInvalidValue(/*HeaderStoreItemInfo*/ info, /*string*/ value)
    {
        let $ref0 = { set value(v){ info.ParsedAndInvalidValues = v } };
        AddValueToStoreValue(object)(object, new InvalidValue(value), $ref0);
    }
    /*void*/ static AddRawValue(/*HeaderStoreItemInfo*/ info, /*string*/ value)
    {
        let $ref0 = { set value(v){ info.RawValue = v } };
        AddValueToStoreValue(string)(string, value, $ref0);
    }
    /*void*/ static AddValueToStoreValue(T, /*T*/ value, /*ref object*/ currentStoreValue)
    {
        if (currentStoreValue === null)
        {
            currentStoreValue = value;
        }
        else 
        {
            /*List<T>*/ let storeValues = BlazorJs.As(currentStoreValue, List(T));
            if (storeValues === null)
            {
                storeValues = new List(T)(2);
                Debug.Assert(currentStoreValue instanceof T);
                storeValues.Add(BlazorJs.Cast(currentStoreValue, T));
                currentStoreValue = storeValues;
            }
            Debug.Assert(value instanceof T);
            storeValues.Add(BlazorJs.Cast(value, T));
        }
    }
    /*object*/ GetSingleParsedValue(/*HeaderDescriptor*/ descriptor)
    {
        let info = null;
        let $ref1 = { set value(v){ info = v } };
        if (TryGetAndParseHeaderInfo(descriptor, $ref1))
        {
            return null;
        }
        return info.GetSingleParsedValue();
    }
    /*object*/ GetParsedAndInvalidValues(/*HeaderDescriptor*/ descriptor)
    {
        let info = null;
        let $ref1 = { set value(v){ info = v } };
        if (TryGetAndParseHeaderInfo(descriptor, $ref1))
        {
            return null;
        }
        return info.ParsedAndInvalidValues;
    }
    /*bool*/ IsAllowedHeaderName(/*HeaderDescriptor*/ descriptor)
    {
        return true;
    }
    /*void*/ PrepareHeaderInfoForAdd(/*HeaderDescriptor*/ descriptor, /*out HeaderStoreItemInfo*/ info, /*out bool*/ addToStore)
    {
        let $ref0 = { set value(v){ info = v } };
        if (IsAllowedHeaderName(descriptor))
        {
            throw new InvalidOperationException("net_http_headers_not_allowed_header_name");
        }
        addToStore = false;
        if (TryGetAndParseHeaderInfo(descriptor, $ref0))
        {
            info = new HeaderStoreItemInfo();
            addToStore = true;
        }
    }
    /*void*/ static ParseAndAddValue(/*HeaderDescriptor*/ descriptor, /*HeaderStoreItemInfo*/ info, /*string*/ value)
    {
        let $ref0 = { set value(v){ index = v } };
        Debug.Assert(info !== null);
        if (descriptor.Parser  === null)
        {
            CheckContainsNewLine(value);
            AddParsedValue(info, value ?? string.Empty);
            return ;
        }
        if (info.CanAddParsedValue(descriptor.Parser))
        {
            throw new FormatException("net_http_headers_single_value_header");
        }
        /*int*/ let index = 0;
        /*object*/ let parsedValue = descriptor.Parser.ParseValue(value, info.ParsedAndInvalidValues, $ref0);
        if ((value === null) || (index === value.Length))
        {
            if (parsedValue !== null)
            {
                AddParsedValue(info, parsedValue);
            }
            return ;
        }
        Debug.Assert(index < value.Length, "Parser must return an index value within the string length.");
        /*// If we successfully parsed a value, but there are more left to read, store the results in a temp
            // list. Only when all values are parsed successfully write the list to the store.
            List<object>*/ let parsedValues = new List(object)();
        if (parsedValue !== null)
        {
            parsedValues.Add(parsedValue);
        }
        while(index < value.Length)
        {
            let $ref0 = { set value(v){ index = v } };
            parsedValue = descriptor.Parser.ParseValue(value, info.ParsedAndInvalidValues, $ref0);
            if (parsedValue !== null)
            {
                parsedValues.Add(parsedValue);
            }
        }
        BlazorJs.forEach(parsedValues, function(item, $_i)
        {
            AddParsedValue(info, item);
        });
    }
    /*HeaderDescriptor*/ GetHeaderDescriptor(/*string*/ name)
    {
        let descriptor = null;
        let $ref1 = { set value(v){ descriptor = v } };
        if (string.IsNullOrEmpty(name))
        throw new ArgumentException(nameof(name));
        if (HeaderDescriptor.TryGet(name, $ref1))
        {
            throw new FormatException("net_http_headers_invalid_header_name");
        }
        if ((descriptor.HeaderType  & _allowedHeaderTypes) !== 0)
        {
            return descriptor;
        }
        else if ((descriptor.HeaderType  & _treatAsCustomHeaderTypes) !== 0)
        {
            return descriptor.AsCustomHeader();
        }
        throw new InvalidOperationException("net_http_headers_not_allowed_header_name");
    }
    /*bool*/ TryGetHeaderDescriptor(/*string*/ name, /*out HeaderDescriptor*/ descriptor)
    {
        let $ref0 = { set value(v){ descriptor = v } };
        if (string.IsNullOrEmpty(name))
        {
            descriptor = BlazorJs.getDefault();
            return false;
        }
        if (HeaderDescriptor.TryGet(name, $ref0))
        {
            /*HttpHeaderType*/ let headerType = descriptor.HeaderType;
            if ((headerType & _allowedHeaderTypes) !== 0)
            {
                return true;
            }
            if ((headerType & _treatAsCustomHeaderTypes) !== 0)
            {
                descriptor = descriptor.AsCustomHeader();
                return true;
            }
        }
        return false;
    }
    /*void*/ static CheckContainsNewLine(/*string*/ value)
    {
        if (value === null)
        {
            return ;
        }
        if (HttpRuleParser.ContainsNewLine(value))
        {
            throw new FormatException("net_http_headers_no_newlines");
        }
    }
    /*string[]*/ static GetStoreValuesAsStringArray(/*HeaderDescriptor*/ descriptor, /*HeaderStoreItemInfo*/ info)
    {
        let singleValue = null;
        let $ref1 = { set value(v){ singleValue = v } };
        let multiValue = null;
        let $ref3 = { set value(v){ multiValue = v } };
        GetStoreValuesAsStringOrStringArray(descriptor, info, $ref1, $ref3);
        Debug.Assert((singleValue) ^ (multiValue));
        return multiValue ?? singleValue;
    }
    /*void*/ static GetStoreValuesAsStringOrStringArray(/*HeaderDescriptor*/ descriptor, /*object*/ sourceValues, /*out string*/ singleValue, /*out string[]*/ multiValue)
    {
        /*HeaderStoreItemInfo*/ let info = BlazorJs.As(sourceValues, HeaderStoreItemInfo);
        if (info)
        {
            /*HeaderEntry*/ let entry = BlazorJs.Cast(sourceValues, HeaderEntry);
            Debug.Assert(entry.Value  instanceof string);
            singleValue = BlazorJs.Cast(entry.Value, string);
            multiValue = null;
            return ;
        }
        //lock
        {
            let $ref0 = { set value(v){ currentIndex = v } };
            let $ref1 = { set value(v){ currentIndex = v } };
            /*int*/ let length = GetValueCount(info);
            /*Span<string>*/ let values;
            singleValue = null;
            if (length === 1)
            {
                multiValue = null;
                values = new Span(string)(singleValue);
            }
            else 
            {
                Debug.Assert(length > 1, "The header should have been removed when it became empty");
                values = (multiValue = new Array(length));
            }
            /*int*/ let currentIndex = 0;
            ReadStoreValues(object)(object, values, info.ParsedAndInvalidValues, descriptor.Parser, $ref0);
            ReadStoreValues(string)(string, values, info.RawValue, null, $ref1);
            Debug.Assert(currentIndex === length);
        }
    }
    /*int*/ static GetStoreValuesIntoStringArray(/*HeaderDescriptor*/ descriptor, /*object*/ sourceValues, /*ref string[]*/ values)
    {
        values = values ?? Array.Empty(string);
        /*HeaderStoreItemInfo*/ let info = BlazorJs.As(sourceValues, HeaderStoreItemInfo);
        if (info)
        {
            Debug.Assert(sourceValues instanceof string);
            if (values.Length  === 0)
            {
                values = new Array(1);
            }
            values[0] = BlazorJs.Cast(sourceValues, string);
            return 1;
        }
        //lock
        {
            let $ref0 = { set value(v){ currentIndex = v } };
            let $ref1 = { set value(v){ currentIndex = v } };
            /*int*/ let length = GetValueCount(info);
            Debug.Assert(length > 0);
            if (values.Length  < length)
            {
                values = new Array(length);
            }
            /*int*/ let currentIndex = 0;
            ReadStoreValues(object)(object, values, info.ParsedAndInvalidValues, descriptor.Parser, $ref0);
            ReadStoreValues(string)(string, values, info.RawValue, null, $ref1);
            Debug.Assert(currentIndex === length);
            return length;
        }
    }
    /*int*/ static CountObj(T, /*object*/ valueStore)
    {
        return valueStore ? 0 : valueStore instanceof List(T), list = valueStore ? list.Count  : 1;
    }
    /*int*/ static GetValueCount(/*HeaderStoreItemInfo*/ info)
    {
        Debug.Assert(info !== null);
        return CountObj(object)(object, info.ParsedAndInvalidValues) + CountObj(string)(string, info.RawValue);
    }
    /*void*/ static ReadStoreValues(T, /*Span<string>*/ values, /*object*/ storeValue, /*HttpHeaderParser*/ parser, /*ref int*/ currentIndex)
    {
        if (storeValue !== null)
        {
            /*List<T>*/ let storeValues = BlazorJs.As(storeValue, List(T));
            if (storeValues === null)
            {
                values[currentIndex] = parser === null || storeValue instanceof InvalidValue ? storeValue.ToString() : parser.ToString(storeValue);
                currentIndex++;
            }
            else 
            {
                BlazorJs.forEach(storeValues, function(item, $_i)
                {
                    Debug.Assert(item !== null);
                    values[currentIndex] = parser === null || item instanceof InvalidValue ? item.ToString() : parser.ToString(item);
                    currentIndex++;
                });
            }
        }
    }
    /*bool*/ static AreEqual(/*object*/ value, /*object*/ storeValue, /*IEqualityComparer*/ comparer)
    {
        Debug.Assert(value !== null);
        if (comparer !== null)
        {
            return comparer.Equals(value, storeValue);
        }
        return value.Equals(storeValue);
    }
    static System_Net_Http_Headers_HttpHeaders_InvalidValue = class extends object
    {
        /*string*/ _value = null;
        constructor(/*string*/ value)
        {
            super();
            Debug.Assert((value));
            _value = value;
        }
        /*string*/ ToString()
        {
            return _value;
        }
    }
    static System_Net_Http_Headers_HttpHeaders_HeaderStoreItemInfo = class extends object
    {
        constructor()
        {
            super();
        }
        /*object*/ RawValue = null;
        /*object*/ ParsedAndInvalidValues = null;
        /*bool*/ CanAddParsedValue(/*HttpHeaderParser*/ parser)
        {
            Debug.Assert(parser !== null, "There should be no reason to call CanAddValue if there is no parser for the current header.");
            return parser.SupportsMultipleValues  || ParsedAndInvalidValues;
        }
        /*void*/ AssertContainsNoInvalidValues()
        {
            if ((ParsedAndInvalidValues))
            {
                if (ParsedAndInvalidValues instanceof List(object), list = ParsedAndInvalidValues)
                {
                    BlazorJs.forEach(list, function(item, $_i)
                    {
                        Debug.Assert((item instanceof InvalidValue));
                    });
                }
                else 
                {
                    Debug.Assert((ParsedAndInvalidValues instanceof InvalidValue));
                }
            }
        }
        /*object*/ GetSingleParsedValue()
        {
            if ((ParsedAndInvalidValues))
            {
                if (ParsedAndInvalidValues instanceof List(object), list = ParsedAndInvalidValues)
                {
                    AssertContainsSingleParsedValue(list);
                    BlazorJs.forEach(list, function(item, $_i)
                    {
                        if ((item instanceof InvalidValue))
                        {
                            return item;
                        }
                    });
                }
                else 
                {
                    if ((ParsedAndInvalidValues instanceof InvalidValue))
                    {
                        return ParsedAndInvalidValues;
                    }
                }
            }
            return null;
        }
        /*void*/ static AssertContainsSingleParsedValue(/*List<object>*/ list)
        {
            /*int*/ let count = 0;
            BlazorJs.forEach(list, function(item, $_i)
            {
                if ((item instanceof InvalidValue))
                {
                    count++;
                }
            });
            Debug.Assert(count === 1, "Only a single parsed value should be stored for this parser");
        }
        /*bool*/ get IsEmpty()
        {
            return RawValue === null && ParsedAndInvalidValues === null;
        }
    }
    /*int*/ InitialCapacity = 4;
    /*int*/ ArrayThreshold = 64;
    /*HeaderEntry[]*/ GetEntriesArray()
    {
        /*object*/ let store = _headerStore;
        if (store)
        {
            return null;
        }
        else if (store instanceof HeaderEntry, entries = store)
        {
            return entries;
        }
        else 
        {
            return GetEntriesFromDictionary();
        }
        /*HeaderEntry[]*/ function GetEntriesFromDictionary()
        {
            /*var*/ let dictionary = BlazorJs.Cast(_headerStore, Dictionary(HeaderDescriptor, object));
            /*var*/ let entries = new Array(dictionary.Count);
            /*int*/ let i = 0;
            BlazorJs.forEach(dictionary, function(entry, $_i)
            {
                entries[i++] = BlazorJs.PopulateProperty(new HeaderEntry(), function(/*HeaderEntry*/ $obj)
                {
                    $obj.Key = entry.Key;
                    $obj.Value = entry.Value
;
                });
            });
            return entries;
        }
    }
    /*ReadOnlySpan<HeaderEntry>*/ GetEntries()
    {
        return new ReadOnlySpan(HeaderEntry)(GetEntriesArray(), 0, _count);
    }
    /*int*/ get Count()
    {
        return _count;
    }
    /*bool*/ get EntriesAreLiveView()
    {
        return _headerStore instanceof HeaderEntry;
    }
    /*HeaderEntry*/ GetValueRefOrNullRef(/*HeaderDescriptor*/ key)
    {
        /*HeaderEntry*/ let valueRef = null;
        /*object*/ let store = _headerStore;
        if (store instanceof HeaderEntry, entries = store)
        {
            for(/*int*/ let i = 0; i < _count && i < entries.Length; i++)
            {
                if (key.Equals(entries[i].Key))
                {
                    valueRef = entries[i];
                    break;
                }
            }
        }
        else if ((store))
        {
            valueRef = (BlazorJs.Cast(store, Dictionary(HeaderDescriptor, HeaderEntry))).GetValueOrDefault(key);
        }
        return valueRef;
    }
    /*HeaderEntry*/ GetValueRefOrAddDefault(/*HeaderDescriptor*/ key)
    {
        /*object*/ let store = _headerStore;
        if (store instanceof HeaderEntry, entries = store)
        {
            for(/*int*/ let i = 0; i < _count && i < entries.Length; i++)
            {
                if (key.Equals(entries[i].Key))
                {
                    return entries[i];
                }
            }
            /*int*/ let count = _count;
            _count++;
            if (BlazorJs.Cast(count, uint) < BlazorJs.Cast(entries.Length, uint))
            {
                entries[count].Key  = key;
                return entries[count];
            }
            return GrowEntriesAndAddDefault(key);
        }
        else if (store)
        {
            _count++;
            entries = new Array(InitialCapacity);
            _headerStore = entries;
            /*HeaderEntry*/ let firstEntry = entries[0];
            firstEntry.Key  = key;
            return firstEntry;
        }
        else 
        {
            return DictionaryGetValueRefOrAddDefault(key);
        }
        /*HeaderEntry*/ function GrowEntriesAndAddDefault(/*HeaderDescriptor*/ mkey)
        {
            /*var*/ let mentries = BlazorJs.Cast(_headerStore, HeaderEntry);
            if (mentries.Length  === ArrayThreshold)
            {
                return ConvertToDictionaryAndAddDefault(mkey);
            }
            else 
            {
                let $ref0 = { set value(v){ mentries = v } };
                Array.Resize($ref0, mentries.Length  << 1);
                _headerStore = mentries;
                /*HeaderEntry*/ let firstNewEntry = mentries[mentries.Length  >> 1];
                firstNewEntry.Key  = mkey;
                return firstNewEntry;
            }
        }
        /*HeaderEntry*/ function ConvertToDictionaryAndAddDefault(/*HeaderDescriptor*/ mkey)
        {
            let value = null;
            let $ref1 = { set value(v){ value = v } };
            /*var*/ let mentries = BlazorJs.Cast(_headerStore, HeaderEntry);
            /*var*/ let dictionary = new Dictionary(HeaderDescriptor, HeaderEntry)(ArrayThreshold);
            _headerStore = dictionary;
            BlazorJs.forEach(mentries, function(entry, $_i)
            {
                dictionary.Add(entry.Key, entry);
            });
            Debug.Assert(dictionary.Count  === _count - 1);
            if (dictionary.TryGetValue(mkey, $ref1))
            {
                value = BlazorJs.PopulateProperty(new HeaderEntry(), function(/*HeaderEntry*/ $obj)
                {
                    $obj.Key = mkey;
                });
                dictionary[mkey] = value;
            }
            return value;
        }
        /*HeaderEntry*/ function DictionaryGetValueRefOrAddDefault(/*HeaderDescriptor*/ mkey)
        {
            let value = null;
            let $ref1 = { set value(v){ value = v } };
            /*var*/ let dictionary = BlazorJs.Cast(_headerStore, Dictionary(HeaderDescriptor, HeaderEntry));
            if (dictionary.TryGetValue(mkey, $ref1))
            {
                value = BlazorJs.PopulateProperty(new HeaderEntry(), function(/*HeaderEntry*/ $obj)
                {
                    $obj.Key = mkey;
                });
                dictionary[mkey] = value;
            }
            if (value.Value )
            {
                _count++;
            }
            return value;
        }
    }
    /*void*/ AddEntryToStore(/*HeaderEntry*/ entry)
    {
        Debug.Assert(Contains(entry.Key));
        if (_headerStore instanceof HeaderEntry, entries = _headerStore)
        {
            /*int*/ let count = _count;
            if (BlazorJs.Cast(count, uint) < BlazorJs.Cast(entries.Length, uint))
            {
                entries[count] = entry;
                _count++;
                return ;
            }
        }
        /*var*/ let val = GetValueRefOrAddDefault(entry.Key);
        if (val !== null)
        val.Value  = entry.Value;
    }
    /*bool*/ Contains(/*HeaderDescriptor*/ key)
    {
        return GetValueRefOrNullRef(key) !== null;
    }
    /*void*/ Clear()
    {
        if (_headerStore instanceof HeaderEntry, entries = _headerStore)
        {
            Array.Clear(entries, 0, _count);
        }
        else 
        {
            _headerStore = null;
        }
        _count = 0;
    }
    /*bool*/ Remove(/*HeaderDescriptor*/ key)
    {
        /*bool*/ let removed = false;
        /*object*/ let store = _headerStore;
        if (store instanceof HeaderEntry, entries = store)
        {
            for(/*int*/ let i = 0; i < _count && i < entries.Length; i++)
            {
                if (key.Equals(entries[i].Key))
                {
                    while(i + 1 < _count && BlazorJs.Cast((i + 1), uint) < BlazorJs.Cast(entries.Length, uint))
                    {
                        entries[i] = entries[i + 1];
                        i++;
                    }
                    entries[i] = BlazorJs.getDefault();
                    removed = true;
                    break;
                }
            }
        }
        else if ((store))
        {
            removed = (BlazorJs.Cast(store, Dictionary(HeaderDescriptor, HeaderEntry))).Remove(key);
        }
        if (removed)
        {
            _count--;
        }
        return removed;
    }
}

class System_Net_Http_Headers_HttpHeadersNonValidated extends H5_IH5Class(System_Collections_IEnumerable(System_Collections_Generic_IEnumerable(System_Collections_Generic_KeyValuePair(string, System_Net_Http_Headers_HeaderStringValues))(System_Collections_Generic_IReadOnlyCollection(System_Collections_Generic_KeyValuePair(string, System_Net_Http_Headers_HeaderStringValues))(System_Collections_Generic_IReadOnlyDictionary(string, System_Net_Http_Headers_HeaderStringValues)(System_ValueType)))))
{
    /*HttpHeaders*/ _headers = null;
    constructor(/*HttpHeaders*/ headers)
    {
        super();
    }
    /*int*/ get Count()
    {
        return _headers?.Count ?? 0;
    }
    /*bool*/ Contains(/*string*/ headerName)
    {
        let descriptor = null;
        let $ref1 = { set value(v){ descriptor = v } };
        return _headers instanceof HttpHeaders, headers = _headers && headers.TryGetHeaderDescriptor(headerName, $ref1) && headers.Contains(descriptor);
    }
    /*HeaderStringValues*/ getItem(/*string*/ headerName)
    {
        let values = null;
        let $ref1 = { set value(v){ values = v } };
        if (TryGetValues(headerName, $ref1))
        {
            return values;
        }
        throw new KeyNotFoundException("net_http_headers_not_found");
    }
    /*/// <inheritdoc/>
        bool*/ ContainsKey(/*string*/ key)
    {
        return Contains(key);
    }
    /*bool*/ TryGetValues(/*string*/ headerName, /*out HeaderStringValues*/ values)
    {
        let descriptor = null;
        let $ref1 = { set value(v){ descriptor = v } };
        let info = null;
        let $ref3 = { set value(v){ info = v } };
        if (_headers instanceof HttpHeaders, headers = _headers && headers.TryGetHeaderDescriptor(headerName, $ref1) && headers.TryGetHeaderValue(descriptor, $ref3))
        {
            let singleValue = null;
            let $ref1 = { set value(v){ singleValue = v } };
            let multiValue = null;
            let $ref3 = { set value(v){ multiValue = v } };
            HttpHeaders.GetStoreValuesAsStringOrStringArray(descriptor, info, $ref1, $ref3);
            Debug.Assert((singleValue) ^ (multiValue));
            values = (singleValue) ? new HeaderStringValues(descriptor, singleValue) : new HeaderStringValues(descriptor, multiValue);
            return true;
        }
        values = BlazorJs.getDefault();
        return false;
    }
    /*/// <inheritdoc/>
        bool*/ TryGetValue(/*string*/ key, /*out HeaderStringValues*/ value)
    {
        let $ref0 = { set value(v){ value = v } };
        return TryGetValues(key, $ref0);
    }
    /*Enumerator*/ GetEnumerator()
    {
        return _headers instanceof HttpHeaders, headers = _headers && headers.GetEntriesArray() instanceof HeaderEntry ? new Enumerator(entries, headers.Count) : BlazorJs.getDefault();
    }
    /*/// <inheritdoc/>
        IEnumerator<KeyValuePair<string, HeaderStringValues>>*/ GetEnumerator()
    {
        return GetEnumerator();
    }
    /*/// <inheritdoc/>
        IEnumerator*/ GetEnumerator()
    {
        return GetEnumerator();
    }
    /*/// <inheritdoc/>
        IEnumerable<string>*/ get Keys()
    {
        BlazorJs.forEach(this, function(header, $_i)
        {
header.Key        });
    }
    /*/// <inheritdoc/>
        IEnumerable<HeaderStringValues>*/ get Values()
    {
        BlazorJs.forEach(this, function(header, $_i)
        {
header.Value        });
    }
    static System_Net_Http_Headers_HttpHeadersNonValidated_Enumerator = class extends System_Collections_IEnumerator(System_IDisposable(System_Collections_Generic_IEnumerator(System_Collections_Generic_KeyValuePair(string, System_Net_Http_Headers_HeaderStringValues))(System_ValueType)))
    {
        /*HeaderEntry[]*/ _entries = null;
        /*int*/ _numberOfEntries = null;
        /*int*/ _index = null;
        /*KeyValuePair<string, HeaderStringValues>*/ _current = null;
        constructor(/*HeaderEntry[]*/ entries, /*int*/ numberOfEntries)
        {
            super();
            _entries = entries;
            _numberOfEntries = numberOfEntries;
            _index = 0;
            _current = BlazorJs.getDefault();
        }
        /*bool*/ MoveNext()
        {
            /*int*/ let index = _index;
            if (_entries instanceof HeaderEntry, entries = _entries && index < _numberOfEntries && BlazorJs.Cast(index, uint) < BlazorJs.Cast(entries.Length, uint))
            {
                let singleValue = null;
                let $ref1 = { set value(v){ singleValue = v } };
                let multiValue = null;
                let $ref3 = { set value(v){ multiValue = v } };
                /*HeaderEntry*/ let entry = entries[index];
                _index++;
                HttpHeaders.GetStoreValuesAsStringOrStringArray(entry.Key, entry.Value, $ref1, $ref3);
                Debug.Assert((singleValue) ^ (multiValue));
                _current = new KeyValuePair(string, HeaderStringValues)(entry.Key.Name, (singleValue) ? new HeaderStringValues(entry.Key, singleValue) : new HeaderStringValues(entry.Key, multiValue));
                return true;
            }
            _current = BlazorJs.getDefault();
            return false;
        }
        /*KeyValuePair<string, HeaderStringValues>*/ get Current()
        {
            return _current;
        }
        /*/// <inheritdoc/>
            object*/ get Current()
        {
            return _current;
        }
        /*void*/ Dispose()
        {
        }
        /*/// <inheritdoc/>
            void*/ Reset()
        {
            throw new NotSupportedException();
        }
    }
}

static class System_Net_Http_Headers_HttpHeaderType
{
    General = 0b1;
    Request = 0b10;
    Response = 0b100;
    Content = 0b1000;
    Custom = 0b10000;
    NonTrailing = 0b100000;
    All = 0b111111;
    None = 0
;
}

const System_Net_Http_Headers_HttpHeaderValueCollection = (T) => class extends H5_IH5Class(System_Collections_IEnumerable(System_Collections_Generic_IEnumerable(T)(System_Collections_Generic_ICollection(T)(object))))
{
    /*HeaderDescriptor*/ _descriptor = null;
    /*HttpHeaders*/ _store = null;
    /*int*/ get Count()
    {
        return GetCount();
    }
    /*bool*/ get IsReadOnly()
    {
        return false;
    }
    constructor(/*HeaderDescriptor*/ descriptor, /*HttpHeaders*/ store)
    {
        super();
        _store = store;
        _descriptor = descriptor;
    }
    /*void*/ Add(/*T*/ item)
    {
        CheckValue(item);
        _store.AddParsedValue(_descriptor, item);
    }
    /*void*/ ParseAdd(/*string*/ input)
    {
        _store.Add(_descriptor, input);
    }
    /*bool*/ TryParseAdd(/*string*/ input)
    {
        return _store.TryParseAndAddValue(_descriptor, input);
    }
    /*void*/ Clear()
    {
        _store.Remove(_descriptor);
    }
    /*bool*/ Contains(/*T*/ item)
    {
        CheckValue(item);
        return _store.ContainsParsedValue(_descriptor, item);
    }
    /*void*/ CopyTo(/*T[]*/ array, /*int*/ arrayIndex)
    {
        if (array === null)
        throw new ArgumentNullException(nameof(array));
        if (arrayIndex < 0 || arrayIndex > array.Length)
        {
            throw new ArgumentOutOfRangeException(nameof(arrayIndex));
        }
        /*//// Allow arrayIndex == array.Length in case our own collection is empty
            //ArgumentOutOfRangeException.ThrowIfNegative(arrayIndex);
            //ArgumentOutOfRangeException.ThrowIfGreaterThan(arrayIndex, array.Length);

            object*/ let storeValue = _store.GetParsedAndInvalidValues(_descriptor);
        if (storeValue === null)
        {
            return ;
        }
        /*List<object>*/ let storeValues = BlazorJs.As(storeValue, List(object));
        if (storeValues === null)
        {
            if ((storeValue instanceof HttpHeaders_InvalidValue))
            {
                Debug.Assert(storeValue instanceof T);
                if (arrayIndex === array.Length)
                {
                    throw new ArgumentException("net_http_copyto_array_too_small");
                }
                array[arrayIndex] = BlazorJs.Cast(storeValue, T);
            }
        }
        else 
        {
            BlazorJs.forEach(storeValues, function(item, $_i)
            {
                if ((item instanceof HttpHeaders_InvalidValue))
                {
                    Debug.Assert(item instanceof T);
                    if (arrayIndex === array.Length)
                    {
                        throw new ArgumentException("net_http_copyto_array_too_small");
                    }
                    array[arrayIndex++] = BlazorJs.Cast(item, T);
                }
            });
        }
    }
    /*bool*/ Remove(/*T*/ item)
    {
        CheckValue(item);
        return _store.RemoveParsedValue(_descriptor, item);
    }
    /*IEnumerator<T>*/ GetEnumerator()
    {
        /*object*/ let storeValue = _store.GetParsedAndInvalidValues(_descriptor);
        return storeValue || storeValue instanceof HttpHeaders_InvalidValue ? (BlazorJs.Cast(Array.Empty(T), IEnumerable(T))).GetEnumerator() : Iterate(storeValue);
        /*IEnumerator<T>*/ function Iterate(/*object*/ mstoreValue)
        {
            if (mstoreValue instanceof List(object), storeValues = mstoreValue)
            {
                BlazorJs.forEach(storeValues, function(item, $_i)
                {
                    if (item instanceof HttpHeaders_InvalidValue)
                    {
                    }
                    Debug.Assert(item instanceof T);
BlazorJs.Cast(item, T)                });
            }
            else 
            {
                Debug.Assert(mstoreValue instanceof T);
BlazorJs.Cast(mstoreValue, T)            }
        }
    }
    /*#endregion

        #region IEnumerable Members

        Collections.IEnumerator*/ GetEnumerator()
    {
        return GetEnumerator();
    }
    /*string*/ ToString()
    {
        return _store.GetHeaderString(_descriptor);
    }
    /*void*/ CheckValue(/*T*/ item)
    {
        if (item === null)
        throw new ArgumentNullException(nameof(item));
        if (_descriptor.Parser  === GenericHeaderParser.TokenListParser)
        {
            Debug.Assert(T === string);
            HeaderUtilities.CheckValidToken(BlazorJs.Cast(BlazorJs.Cast(item, object), string), nameof(item));
        }
    }
    /*int*/ GetCount()
    {
        /*// This is an O(n) operation.

            object*/ let storeValue = _store.GetParsedAndInvalidValues(_descriptor);
        if (storeValue === null)
        {
            return 0;
        }
        /*List<object>*/ let storeValues = BlazorJs.As(storeValue, List(object));
        if (storeValues === null)
        {
            if ((storeValue instanceof HttpHeaders_InvalidValue))
            {
                return 1;
            }
            return 0;
        }
        else 
        {
            /*int*/ let count = 0;
            BlazorJs.forEach(storeValues, function(item, $_i)
            {
                if ((item instanceof HttpHeaders_InvalidValue))
                {
                    count++;
                }
            });
            return count;
        }
    }
}

class System_Net_Http_Headers_HttpRequestHeaders extends System_Net_Http_Headers_HttpHeaders
{
    /*int*/ AcceptSlot = 0;
    /*int*/ AcceptCharsetSlot = 1;
    /*int*/ AcceptEncodingSlot = 2;
    /*int*/ AcceptLanguageSlot = 3;
    /*int*/ IfMatchSlot = 4;
    /*int*/ IfNoneMatchSlot = 5;
    /*int*/ TransferEncodingSlot = 6;
    /*int*/ UserAgentSlot = 7;
    /*int*/ ExpectSlot = 8;
    /*int*/ ProtocolSlot = 9;
    /*int*/ NumCollectionsSlots = 10;
    /*object[]*/ _specialCollectionsSlots = null;
    /*HttpGeneralHeaders*/ _generalHeaders = null;
    /*bool*/ _expectContinueSet = null;
    /*T*/ GetSpecializedCollection(T, /*int*/ slot, /*Func<HttpRequestHeaders, T>*/ creationFunc)
    {
        _specialCollectionsSlots = _specialCollectionsSlots ?? new Array(NumCollectionsSlots);
        return BlazorJs.Cast((_specialCollectionsSlots[slot] = _specialCollectionsSlots[slot] ?? creationFunc(this)), T);
    }
    /*HttpHeaderValueCollection<MediaTypeWithQualityHeaderValue>*/ get Accept()
    {
        return GetSpecializedCollection(AcceptSlot, function(/**/ thisRef)
        {
            return new HttpHeaderValueCollection(MediaTypeWithQualityHeaderValue)(KnownHeaders.Accept.Descriptor, thisRef);
        });
    }
    /*HttpHeaderValueCollection<StringWithQualityHeaderValue>*/ get AcceptCharset()
    {
        return GetSpecializedCollection(AcceptCharsetSlot, function(/**/ thisRef)
        {
            return new HttpHeaderValueCollection(StringWithQualityHeaderValue)(KnownHeaders.AcceptCharset.Descriptor, thisRef);
        });
    }
    /*HttpHeaderValueCollection<StringWithQualityHeaderValue>*/ get AcceptEncoding()
    {
        return GetSpecializedCollection(AcceptEncodingSlot, function(/**/ thisRef)
        {
            return new HttpHeaderValueCollection(StringWithQualityHeaderValue)(KnownHeaders.AcceptEncoding.Descriptor, thisRef);
        });
    }
    /*HttpHeaderValueCollection<StringWithQualityHeaderValue>*/ get AcceptLanguage()
    {
        return GetSpecializedCollection(AcceptLanguageSlot, function(/**/ thisRef)
        {
            return new HttpHeaderValueCollection(StringWithQualityHeaderValue)(KnownHeaders.AcceptLanguage.Descriptor, thisRef);
        });
    }
    /*AuthenticationHeaderValue*/ get Authorization()
    {
        return BlazorJs.Cast(GetSingleParsedValue(KnownHeaders.Authorization.Descriptor), AuthenticationHeaderValue);
    }
    /*AuthenticationHeaderValue*/ set Authorization(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.Authorization.Descriptor, value);
    }
    /*bool?*/ get ExpectContinue()
    {
        if (ContainsParsedValue(KnownHeaders.Expect.Descriptor, HeaderUtilities.ExpectContinue))
        {
            return true;
        }
        if (_expectContinueSet)
        {
            return false;
        }
        return null;
    }
    /*bool?*/ set ExpectContinue(value)
    {
        if (value === true)
        {
            _expectContinueSet = true;
            if (ContainsParsedValue(KnownHeaders.Expect.Descriptor, HeaderUtilities.ExpectContinue))
            {
                AddParsedValue(KnownHeaders.Expect.Descriptor, HeaderUtilities.ExpectContinue);
            }
        }
        else 
        {
            _expectContinueSet = value !== null;
            RemoveParsedValue(KnownHeaders.Expect.Descriptor, HeaderUtilities.ExpectContinue);
        }
    }
    /*string*/ get From()
    {
        return BlazorJs.Cast(GetSingleParsedValue(KnownHeaders.From.Descriptor), string);
    }
    /*string*/ set From(value)
    {
        if (value === string.Empty)
        {
            value = null;
        }
        CheckContainsNewLine(value);
        SetOrRemoveParsedValue(KnownHeaders.From.Descriptor, value);
    }
    /*string*/ get Host()
    {
        return BlazorJs.Cast(GetSingleParsedValue(KnownHeaders.Host.Descriptor), string);
    }
    /*string*/ set Host(value)
    {
        if (value === string.Empty)
        {
            value = null;
        }
        if ((value !== null) && (HttpRuleParser.GetHostLength(value, 0, false) !== value.Length))
        {
            throw new FormatException("net_http_headers_invalid_host_header");
        }
        SetOrRemoveParsedValue(KnownHeaders.Host.Descriptor, value);
    }
    /*HttpHeaderValueCollection<EntityTagHeaderValue>*/ get IfMatch()
    {
        return GetSpecializedCollection(IfMatchSlot, function(/**/ thisRef)
        {
            return new HttpHeaderValueCollection(EntityTagHeaderValue)(KnownHeaders.IfMatch.Descriptor, thisRef);
        });
    }
    /*DateTimeOffset?*/ get IfModifiedSince()
    {
        return HeaderUtilities.GetDateTimeOffsetValue(KnownHeaders.IfModifiedSince.Descriptor, this);
    }
    /*DateTimeOffset?*/ set IfModifiedSince(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.IfModifiedSince.Descriptor, value);
    }
    /*HttpHeaderValueCollection<EntityTagHeaderValue>*/ get IfNoneMatch()
    {
        return GetSpecializedCollection(IfNoneMatchSlot, function(/**/ thisRef)
        {
            return new HttpHeaderValueCollection(EntityTagHeaderValue)(KnownHeaders.IfNoneMatch.Descriptor, thisRef);
        });
    }
    /*RangeConditionHeaderValue*/ get IfRange()
    {
        return BlazorJs.Cast(GetSingleParsedValue(KnownHeaders.IfRange.Descriptor), RangeConditionHeaderValue);
    }
    /*RangeConditionHeaderValue*/ set IfRange(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.IfRange.Descriptor, value);
    }
    /*DateTimeOffset?*/ get IfUnmodifiedSince()
    {
        return HeaderUtilities.GetDateTimeOffsetValue(KnownHeaders.IfUnmodifiedSince.Descriptor, this);
    }
    /*DateTimeOffset?*/ set IfUnmodifiedSince(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.IfUnmodifiedSince.Descriptor, value);
    }
    /*int?*/ get MaxForwards()
    {
        /*object*/ let storedValue = GetSingleParsedValue(KnownHeaders.MaxForwards.Descriptor);
        if (storedValue !== null)
        {
            return BlazorJs.Cast(storedValue, int);
        }
        return null;
    }
    /*int?*/ set MaxForwards(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.MaxForwards.Descriptor, value);
    }
    /*string*/ get Protocol()
    {
        return _specialCollectionsSlots ? null : BlazorJs.Cast(_specialCollectionsSlots[ProtocolSlot], string);
    }
    /*string*/ set Protocol(value)
    {
        CheckContainsNewLine(value);
        _specialCollectionsSlots = _specialCollectionsSlots ?? new Array(NumCollectionsSlots);
        _specialCollectionsSlots[ProtocolSlot] = value;
    }
    /*AuthenticationHeaderValue*/ get ProxyAuthorization()
    {
        return BlazorJs.Cast(GetSingleParsedValue(KnownHeaders.ProxyAuthorization.Descriptor), AuthenticationHeaderValue);
    }
    /*AuthenticationHeaderValue*/ set ProxyAuthorization(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.ProxyAuthorization.Descriptor, value);
    }
    /*RangeHeaderValue*/ get Range()
    {
        return BlazorJs.Cast(GetSingleParsedValue(KnownHeaders.Range.Descriptor), RangeHeaderValue);
    }
    /*RangeHeaderValue*/ set Range(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.Range.Descriptor, value);
    }
    /*Uri*/ get Referrer()
    {
        return BlazorJs.Cast(GetSingleParsedValue(KnownHeaders.Referer.Descriptor), Uri);
    }
    /*Uri*/ set Referrer(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.Referer.Descriptor, value);
    }
    /*HttpHeaderValueCollection<TransferCodingWithQualityHeaderValue>*/ get TE()
    {
        return GetSpecializedCollection(TransferEncodingSlot, function(/**/ thisRef)
        {
            return new HttpHeaderValueCollection(TransferCodingWithQualityHeaderValue)(KnownHeaders.TE.Descriptor, thisRef);
        });
    }
    /*HttpHeaderValueCollection<ProductInfoHeaderValue>*/ get UserAgent()
    {
        return GetSpecializedCollection(UserAgentSlot, function(/**/ thisRef)
        {
            return new HttpHeaderValueCollection(ProductInfoHeaderValue)(KnownHeaders.UserAgent.Descriptor, thisRef);
        });
    }
    /*HttpHeaderValueCollection<NameValueWithParametersHeaderValue>*/ get Expect()
    {
        return GetSpecializedCollection(ExpectSlot, function(/**/ thisRef)
        {
            return new HttpHeaderValueCollection(NameValueWithParametersHeaderValue)(KnownHeaders.Expect.Descriptor, thisRef);
        });
    }
    /*CacheControlHeaderValue*/ get CacheControl()
    {
        return GeneralHeaders.CacheControl;
    }
    /*CacheControlHeaderValue*/ set CacheControl(value)
    {
        GeneralHeaders.CacheControl  = value;
    }
    /*HttpHeaderValueCollection<string>*/ get Connection()
    {
        return GeneralHeaders.Connection;
    }
    /*bool?*/ get ConnectionClose()
    {
        return HttpGeneralHeaders.GetConnectionClose(this, _generalHeaders);
    }
    /*bool?*/ set ConnectionClose(value)
    {
        GeneralHeaders.ConnectionClose  = value;
    }
    /*DateTimeOffset?*/ get Date()
    {
        return GeneralHeaders.Date;
    }
    /*DateTimeOffset?*/ set Date(value)
    {
        GeneralHeaders.Date  = value;
    }
    /*HttpHeaderValueCollection<NameValueHeaderValue>*/ get Pragma()
    {
        return GeneralHeaders.Pragma;
    }
    /*HttpHeaderValueCollection<string>*/ get Trailer()
    {
        return GeneralHeaders.Trailer;
    }
    /*HttpHeaderValueCollection<TransferCodingHeaderValue>*/ get TransferEncoding()
    {
        return GeneralHeaders.TransferEncoding;
    }
    /*bool?*/ get TransferEncodingChunked()
    {
        return HttpGeneralHeaders.GetTransferEncodingChunked(this, _generalHeaders);
    }
    /*bool?*/ set TransferEncodingChunked(value)
    {
        GeneralHeaders.TransferEncodingChunked  = value;
    }
    /*HttpHeaderValueCollection<ProductHeaderValue>*/ get Upgrade()
    {
        return GeneralHeaders.Upgrade;
    }
    /*HttpHeaderValueCollection<ViaHeaderValue>*/ get Via()
    {
        return GeneralHeaders.Via;
    }
    /*HttpHeaderValueCollection<WarningHeaderValue>*/ get Warning()
    {
        return GeneralHeaders.Warning;
    }
    constructor()
    {
        super(HttpHeaderType.General  | HttpHeaderType.Request  | HttpHeaderType.Custom, HttpHeaderType.Response);
    }
    /*void*/ AddHeaders(/*HttpHeaders*/ sourceHeaders)
    {
        super.AddHeaders(sourceHeaders);
        /*HttpRequestHeaders*/ let sourceRequestHeaders = BlazorJs.As(sourceHeaders, HttpRequestHeaders);
        Debug.Assert(sourceRequestHeaders !== null);
        if (sourceRequestHeaders._generalHeaders  !== null)
        {
            GeneralHeaders.AddSpecialsFrom(sourceRequestHeaders._generalHeaders);
        }
        /*bool?*/ let expectContinue = ExpectContinue;
        if (expectContinue.HasValue)
        {
            ExpectContinue = sourceRequestHeaders.ExpectContinue;
        }
    }
    /*HttpGeneralHeaders*/ get GeneralHeaders()
    {
        return _generalHeaders = _generalHeaders ?? new HttpGeneralHeaders(this);
    }
}

class System_Net_Http_Headers_HttpResponseHeaders extends System_Net_Http_Headers_HttpHeaders
{
    /*int*/ AcceptRangesSlot = 0;
    /*int*/ ProxyAuthenticateSlot = 1;
    /*int*/ ServerSlot = 2;
    /*int*/ VarySlot = 3;
    /*int*/ WwwAuthenticateSlot = 4;
    /*int*/ NumCollectionsSlots = 5;
    /*object[]*/ _specialCollectionsSlots = null;
    /*HttpGeneralHeaders*/ _generalHeaders = null;
    /*bool*/ _containsTrailingHeaders = null;
    /*T*/ GetSpecializedCollection(T, /*int*/ slot, /*Func<HttpResponseHeaders, T>*/ creationFunc)
    {
        /*// 5 properties each lazily allocate a collection to store the value(s) for that property.
            // Rather than having a field for each of these, store them untyped in an array that's lazily
            // allocated.  Then we only pay for the 45 bytes for those fields when any is actually accessed.
            object[]*/ let collections = _specialCollectionsSlots = _specialCollectionsSlots ?? new Array(NumCollectionsSlots);
        return BlazorJs.Cast((collections[slot] = collections[slot] ?? creationFunc(this)), T);
    }
    /*HttpHeaderValueCollection<string>*/ get AcceptRanges()
    {
        return GetSpecializedCollection(AcceptRangesSlot, function(/**/ thisRef)
        {
            return new HttpHeaderValueCollection(string)(KnownHeaders.AcceptRanges.Descriptor, thisRef);
        });
    }
    /*TimeSpan?*/ get Age()
    {
        return HeaderUtilities.GetTimeSpanValue(KnownHeaders.Age.Descriptor, this);
    }
    /*TimeSpan?*/ set Age(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.Age.Descriptor, value);
    }
    /*EntityTagHeaderValue*/ get ETag()
    {
        return BlazorJs.Cast(GetSingleParsedValue(KnownHeaders.ETag.Descriptor), EntityTagHeaderValue);
    }
    /*EntityTagHeaderValue*/ set ETag(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.ETag.Descriptor, value);
    }
    /*Uri*/ get Location()
    {
        return BlazorJs.Cast(GetSingleParsedValue(KnownHeaders.Location.Descriptor), Uri);
    }
    /*Uri*/ set Location(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.Location.Descriptor, value);
    }
    /*HttpHeaderValueCollection<AuthenticationHeaderValue>*/ get ProxyAuthenticate()
    {
        return GetSpecializedCollection(ProxyAuthenticateSlot, function(/**/ thisRef)
        {
            return new HttpHeaderValueCollection(AuthenticationHeaderValue)(KnownHeaders.ProxyAuthenticate.Descriptor, thisRef);
        });
    }
    /*RetryConditionHeaderValue*/ get RetryAfter()
    {
        return BlazorJs.Cast(GetSingleParsedValue(KnownHeaders.RetryAfter.Descriptor), RetryConditionHeaderValue);
    }
    /*RetryConditionHeaderValue*/ set RetryAfter(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.RetryAfter.Descriptor, value);
    }
    /*HttpHeaderValueCollection<ProductInfoHeaderValue>*/ get Server()
    {
        return GetSpecializedCollection(ServerSlot, function(/**/ thisRef)
        {
            return new HttpHeaderValueCollection(ProductInfoHeaderValue)(KnownHeaders.Server.Descriptor, thisRef);
        });
    }
    /*HttpHeaderValueCollection<string>*/ get Vary()
    {
        return GetSpecializedCollection(VarySlot, function(/**/ thisRef)
        {
            return new HttpHeaderValueCollection(string)(KnownHeaders.Vary.Descriptor, thisRef);
        });
    }
    /*HttpHeaderValueCollection<AuthenticationHeaderValue>*/ get WwwAuthenticate()
    {
        return GetSpecializedCollection(WwwAuthenticateSlot, function(/**/ thisRef)
        {
            return new HttpHeaderValueCollection(AuthenticationHeaderValue)(KnownHeaders.WWWAuthenticate.Descriptor, thisRef);
        });
    }
    /*CacheControlHeaderValue*/ get CacheControl()
    {
        return GeneralHeaders.CacheControl;
    }
    /*CacheControlHeaderValue*/ set CacheControl(value)
    {
        GeneralHeaders.CacheControl  = value;
    }
    /*HttpHeaderValueCollection<string>*/ get Connection()
    {
        return GeneralHeaders.Connection;
    }
    /*bool?*/ get ConnectionClose()
    {
        return HttpGeneralHeaders.GetConnectionClose(this, _generalHeaders);
    }
    /*bool?*/ set ConnectionClose(value)
    {
        GeneralHeaders.ConnectionClose  = value;
    }
    /*DateTimeOffset?*/ get Date()
    {
        return GeneralHeaders.Date;
    }
    /*DateTimeOffset?*/ set Date(value)
    {
        GeneralHeaders.Date  = value;
    }
    /*HttpHeaderValueCollection<NameValueHeaderValue>*/ get Pragma()
    {
        return GeneralHeaders.Pragma;
    }
    /*HttpHeaderValueCollection<string>*/ get Trailer()
    {
        return GeneralHeaders.Trailer;
    }
    /*HttpHeaderValueCollection<TransferCodingHeaderValue>*/ get TransferEncoding()
    {
        return GeneralHeaders.TransferEncoding;
    }
    /*bool?*/ get TransferEncodingChunked()
    {
        return HttpGeneralHeaders.GetTransferEncodingChunked(this, _generalHeaders);
    }
    /*bool?*/ set TransferEncodingChunked(value)
    {
        GeneralHeaders.TransferEncodingChunked  = value;
    }
    /*HttpHeaderValueCollection<ProductHeaderValue>*/ get Upgrade()
    {
        return GeneralHeaders.Upgrade;
    }
    /*HttpHeaderValueCollection<ViaHeaderValue>*/ get Via()
    {
        return GeneralHeaders.Via;
    }
    /*HttpHeaderValueCollection<WarningHeaderValue>*/ get Warning()
    {
        return GeneralHeaders.Warning;
    }
    constructor(/*bool*/ containsTrailingHeaders)
    {
        super(containsTrailingHeaders ? HttpHeaderType.All  ^ HttpHeaderType.Request  : HttpHeaderType.General  | HttpHeaderType.Response  | HttpHeaderType.Custom, HttpHeaderType.Request);
        _containsTrailingHeaders = containsTrailingHeaders;
    }
    /*bool*/ get ContainsTrailingHeaders()
    {
        return _containsTrailingHeaders;
    }
    /*void*/ AddHeaders(/*HttpHeaders*/ sourceHeaders)
    {
        super.AddHeaders(sourceHeaders);
        /*HttpResponseHeaders*/ let sourceResponseHeaders = BlazorJs.As(sourceHeaders, HttpResponseHeaders);
        Debug.Assert(sourceResponseHeaders !== null);
        if (sourceResponseHeaders._generalHeaders  !== null)
        {
            GeneralHeaders.AddSpecialsFrom(sourceResponseHeaders._generalHeaders);
        }
    }
    /*bool*/ IsAllowedHeaderName(/*HeaderDescriptor*/ descriptor)
    {
        if (_containsTrailingHeaders)
        return true;
        /*KnownHeader*/ let knownHeader = KnownHeaders.TryGetKnownHeader(descriptor.Name);
        if (knownHeader === null)
        return true;
        return (knownHeader.HeaderType  & HttpHeaderType.NonTrailing) === 0;
    }
    /*HttpGeneralHeaders*/ get GeneralHeaders()
    {
        return _generalHeaders = _generalHeaders ?? new HttpGeneralHeaders(this);
    }
}

class System_Net_Http_Headers_Int32NumberHeaderParser extends System_Net_Http_Headers_BaseHeaderParser
{
    /*Int32NumberHeaderParser*/ static Parser = new Int32NumberHeaderParser();
    constructor()
    {
        super(false);
    }
    /*string*/ ToString(/*object*/ value)
    {
        Debug.Assert(value instanceof int);
        return (BlazorJs.Cast(value, int)).ToString();
    }
    /*int*/ GetParsedValueLength(/*string*/ value, /*int*/ startIndex, /*object*/ storeValue, /*out object*/ parsedValue)
    {
        let $ref0 = { set value(v){ result = v } };
        parsedValue = null;
        /*int*/ let numberLength = HttpRuleParser.GetNumberLength(value, startIndex, false);
        if ((numberLength === 0) || (numberLength > HttpRuleParser.MaxInt32Digits))
        {
            return 0;
        }
        /*int*/ let result;
        if (HeaderUtilities.TryParseInt32(value, startIndex, numberLength, $ref0))
        {
            return 0;
        }
        parsedValue = result;
        return numberLength;
    }
}

class System_Net_Http_Headers_Int64NumberHeaderParser extends System_Net_Http_Headers_BaseHeaderParser
{
    /*Int64NumberHeaderParser*/ static Parser = new Int64NumberHeaderParser();
    constructor()
    {
        super(false);
    }
    /*string*/ ToString(/*object*/ value)
    {
        Debug.Assert(value instanceof long);
        return (BlazorJs.Cast(value, long)).ToString();
    }
    /*int*/ GetParsedValueLength(/*string*/ value, /*int*/ startIndex, /*object*/ storeValue, /*out object*/ parsedValue)
    {
        let $ref0 = { set value(v){ result = v } };
        parsedValue = null;
        /*int*/ let numberLength = HttpRuleParser.GetNumberLength(value, startIndex, false);
        if ((numberLength === 0) || (numberLength > HttpRuleParser.MaxInt64Digits))
        {
            return 0;
        }
        /*long*/ let result;
        if (HeaderUtilities.TryParseInt64(value, startIndex, numberLength, $ref0))
        {
            return 0;
        }
        parsedValue = result;
        return numberLength;
    }
}

class System_Net_Http_Headers_KnownHeader extends object
{
    constructor(/*string*/ name, /*int?*/ http2StaticTableIndex, /*int?*/ http3StaticTableIndex)
    {
        super(name, HttpHeaderType.Custom, {parser : null, knownValues : null, http2StaticTableIndex : http2StaticTableIndex, http3StaticTableIndex : http3StaticTableIndex});
        Debug.Assert(string.IsNullOrEmpty(name));
        Debug.Assert(name[0] === ':' || HttpRuleParser.IsToken(name.AsSpan()));
    }
    constructor(/*string*/ name, /*HttpHeaderType*/ headerType, /*HttpHeaderParser*/ parser, /*string[]*/ knownValues, /*int?*/ http2StaticTableIndex, /*int?*/ http3StaticTableIndex)
    {
        super();
        Debug.Assert(string.IsNullOrEmpty(name));
        Debug.Assert(name[0] === ':' || HttpRuleParser.IsToken(name.AsSpan()));
        Name = name;
        HeaderType = headerType;
        Parser = parser;
        KnownValues = knownValues;
        Initialize(http2StaticTableIndex, http3StaticTableIndex);
        AsciiBytesWithColonSpace = Encoding.ASCII.GetBytes(name + ": ");
    }
    /*string*/ _backingField_Name = null;
    /*string*/ get Name()
    {
        return _backingField_Name;
    }
    /*HttpHeaderParser*/ _backingField_Parser = null;
    /*HttpHeaderParser*/ get Parser()
    {
        return _backingField_Parser;
    }
    /*HttpHeaderType*/ _backingField_HeaderType = null;
    /*HttpHeaderType*/ get HeaderType()
    {
        return _backingField_HeaderType;
    }
    /*string[]*/ _backingField_KnownValues = null;
    /*string[]*/ get KnownValues()
    {
        return _backingField_KnownValues;
    }
    /*byte[]*/ _backingField_AsciiBytesWithColonSpace = null;
    /*byte[]*/ get AsciiBytesWithColonSpace()
    {
        return _backingField_AsciiBytesWithColonSpace;
    }
    /*HeaderDescriptor*/ get Descriptor()
    {
        return new HeaderDescriptor(this);
    }
}


static class System_Net_Http_Headers_KnownHeaders
{
    /*KnownHeader*/ static PseudoStatus = new KnownHeader(":status", HttpHeaderType.Response, { parser : null });
    /*KnownHeader*/ static Accept = new KnownHeader("Accept", HttpHeaderType.Request, MediaTypeHeaderParser.MultipleValuesParser, null);
    /*KnownHeader*/ static AcceptCharset = new KnownHeader("Accept-Charset", HttpHeaderType.Request, GenericHeaderParser.MultipleValueStringWithQualityParser, null);
    /*KnownHeader*/ static AcceptEncoding = new KnownHeader("Accept-Encoding", HttpHeaderType.Request, GenericHeaderParser.MultipleValueStringWithQualityParser, null);
    /*KnownHeader*/ static AcceptLanguage = new KnownHeader("Accept-Language", HttpHeaderType.Request, GenericHeaderParser.MultipleValueStringWithQualityParser, null);
    /*KnownHeader*/ static AcceptPatch = new KnownHeader("Accept-Patch");
    /*KnownHeader*/ static AcceptRanges = new KnownHeader("Accept-Ranges", HttpHeaderType.Response, GenericHeaderParser.TokenListParser, null);
    /*KnownHeader*/ static AccessControlAllowCredentials = new KnownHeader("Access-Control-Allow-Credentials", HttpHeaderType.Response, { parser : null, knownValues : [ "true" ] });
    /*KnownHeader*/ static AccessControlAllowHeaders = new KnownHeader("Access-Control-Allow-Headers", HttpHeaderType.Response, { parser : null, knownValues : [ "*" ] });
    /*KnownHeader*/ static AccessControlAllowMethods = new KnownHeader("Access-Control-Allow-Methods", HttpHeaderType.Response, { parser : null, knownValues : [ "*" ] });
    /*KnownHeader*/ static AccessControlAllowOrigin = new KnownHeader("Access-Control-Allow-Origin", HttpHeaderType.Response, { parser : null, knownValues : [ "*", "null" ] });
    /*KnownHeader*/ static AccessControlExposeHeaders = new KnownHeader("Access-Control-Expose-Headers", HttpHeaderType.Response, { parser : null, knownValues : [ "*" ] });
    /*KnownHeader*/ static AccessControlMaxAge = new KnownHeader("Access-Control-Max-Age");
    /*KnownHeader*/ static Age = new KnownHeader("Age", HttpHeaderType.Response  | HttpHeaderType.NonTrailing, TimeSpanHeaderParser.Parser, null);
    /*KnownHeader*/ static Allow = new KnownHeader("Allow", HttpHeaderType.Content, GenericHeaderParser.TokenListParser, null);
    /*KnownHeader*/ static AltSvc = new KnownHeader("Alt-Svc", HttpHeaderType.Response, GetAltSvcHeaderParser());
    /*KnownHeader*/ static AltUsed = new KnownHeader("Alt-Used", HttpHeaderType.Request, { parser : null });
    /*KnownHeader*/ static Authorization = new KnownHeader("Authorization", HttpHeaderType.Request  | HttpHeaderType.NonTrailing, GenericHeaderParser.SingleValueAuthenticationParser, null);
    /*KnownHeader*/ static CacheControl = new KnownHeader("Cache-Control", HttpHeaderType.General  | HttpHeaderType.NonTrailing, CacheControlHeaderParser.Parser, [ "must-revalidate", "no-cache", "no-store", "no-transform", "private", "proxy-revalidate", "public" ]);
    /*KnownHeader*/ static Connection = new KnownHeader("Connection", HttpHeaderType.General, GenericHeaderParser.TokenListParser, [ "close" ]);
    /*KnownHeader*/ static ContentDisposition = new KnownHeader("Content-Disposition", HttpHeaderType.Content  | HttpHeaderType.NonTrailing, GenericHeaderParser.ContentDispositionParser, [ "inline", "attachment" ]);
    /*KnownHeader*/ static ContentEncoding = new KnownHeader("Content-Encoding", HttpHeaderType.Content  | HttpHeaderType.NonTrailing, GenericHeaderParser.TokenListParser, [ "gzip", "deflate", "br", "compress", "identity" ]);
    /*KnownHeader*/ static ContentLanguage = new KnownHeader("Content-Language", HttpHeaderType.Content, GenericHeaderParser.TokenListParser, null);
    /*KnownHeader*/ static ContentLength = new KnownHeader("Content-Length", HttpHeaderType.Content  | HttpHeaderType.NonTrailing, Int64NumberHeaderParser.Parser, null);
    /*KnownHeader*/ static ContentLocation = new KnownHeader("Content-Location", HttpHeaderType.Content  | HttpHeaderType.NonTrailing, UriHeaderParser.RelativeOrAbsoluteUriParser, null);
    /*KnownHeader*/ static ContentMD5 = new KnownHeader("Content-MD5", HttpHeaderType.Content, ByteArrayHeaderParser.Parser);
    /*KnownHeader*/ static ContentRange = new KnownHeader("Content-Range", HttpHeaderType.Content  | HttpHeaderType.NonTrailing, GenericHeaderParser.ContentRangeParser, null);
    /*KnownHeader*/ static ContentSecurityPolicy = new KnownHeader("Content-Security-Policy");
    /*KnownHeader*/ static ContentType = new KnownHeader("Content-Type", HttpHeaderType.Content  | HttpHeaderType.NonTrailing, MediaTypeHeaderParser.SingleValueParser, null);
    /*KnownHeader*/ static Cookie = new KnownHeader("Cookie", HttpHeaderType.Custom, CookieHeaderParser.Parser, null);
    /*KnownHeader*/ static Cookie2 = new KnownHeader("Cookie2");
    /*KnownHeader*/ static Date = new KnownHeader("Date", HttpHeaderType.General  | HttpHeaderType.NonTrailing, DateHeaderParser.Parser, null);
    /*KnownHeader*/ static ETag = new KnownHeader("ETag", HttpHeaderType.Response, GenericHeaderParser.SingleValueEntityTagParser, null);
    /*KnownHeader*/ static Expect = new KnownHeader("Expect", HttpHeaderType.Request  | HttpHeaderType.NonTrailing, GenericHeaderParser.MultipleValueNameValueWithParametersParser, [ "100-continue" ]);
    /*KnownHeader*/ static ExpectCT = new KnownHeader("Expect-CT");
    /*KnownHeader*/ static Expires = new KnownHeader("Expires", HttpHeaderType.Content  | HttpHeaderType.NonTrailing, DateHeaderParser.Parser, null);
    /*KnownHeader*/ static From = new KnownHeader("From", HttpHeaderType.Request, GenericHeaderParser.SingleValueParserWithoutValidation, null);
    /*KnownHeader*/ static GrpcEncoding = new KnownHeader("grpc-encoding", HttpHeaderType.Custom, null, [ "identity", "gzip", "deflate" ]);
    /*KnownHeader*/ static GrpcMessage = new KnownHeader("grpc-message");
    /*KnownHeader*/ static GrpcStatus = new KnownHeader("grpc-status", HttpHeaderType.Custom, null, [ "0" ]);
    /*KnownHeader*/ static Host = new KnownHeader("Host", HttpHeaderType.Request  | HttpHeaderType.NonTrailing, GenericHeaderParser.HostParser, null);
    /*KnownHeader*/ static IfMatch = new KnownHeader("If-Match", HttpHeaderType.Request  | HttpHeaderType.NonTrailing, GenericHeaderParser.MultipleValueEntityTagParser, null);
    /*KnownHeader*/ static IfModifiedSince = new KnownHeader("If-Modified-Since", HttpHeaderType.Request  | HttpHeaderType.NonTrailing, DateHeaderParser.Parser, null);
    /*KnownHeader*/ static IfNoneMatch = new KnownHeader("If-None-Match", HttpHeaderType.Request  | HttpHeaderType.NonTrailing, GenericHeaderParser.MultipleValueEntityTagParser, null);
    /*KnownHeader*/ static IfRange = new KnownHeader("If-Range", HttpHeaderType.Request  | HttpHeaderType.NonTrailing, GenericHeaderParser.RangeConditionParser, null);
    /*KnownHeader*/ static IfUnmodifiedSince = new KnownHeader("If-Unmodified-Since", HttpHeaderType.Request  | HttpHeaderType.NonTrailing, DateHeaderParser.Parser, null);
    /*KnownHeader*/ static KeepAlive = new KnownHeader("Keep-Alive");
    /*KnownHeader*/ static LastModified = new KnownHeader("Last-Modified", HttpHeaderType.Content, DateHeaderParser.Parser, null);
    /*KnownHeader*/ static Link = new KnownHeader("Link");
    /*KnownHeader*/ static Location = new KnownHeader("Location", HttpHeaderType.Response  | HttpHeaderType.NonTrailing, UriHeaderParser.RelativeOrAbsoluteUriParser, null);
    /*KnownHeader*/ static MaxForwards = new KnownHeader("Max-Forwards", HttpHeaderType.Request  | HttpHeaderType.NonTrailing, Int32NumberHeaderParser.Parser, null);
    /*KnownHeader*/ static Origin = new KnownHeader("Origin");
    /*KnownHeader*/ static P3P = new KnownHeader("P3P");
    /*KnownHeader*/ static Pragma = new KnownHeader("Pragma", HttpHeaderType.General  | HttpHeaderType.NonTrailing, GenericHeaderParser.MultipleValueNameValueParser, [ "no-cache" ]);
    /*KnownHeader*/ static ProxyAuthenticate = new KnownHeader("Proxy-Authenticate", HttpHeaderType.Response  | HttpHeaderType.NonTrailing, GenericHeaderParser.MultipleValueAuthenticationParser, null);
    /*KnownHeader*/ static ProxyAuthorization = new KnownHeader("Proxy-Authorization", HttpHeaderType.Request  | HttpHeaderType.NonTrailing, GenericHeaderParser.SingleValueAuthenticationParser, null);
    /*KnownHeader*/ static ProxyConnection = new KnownHeader("Proxy-Connection");
    /*KnownHeader*/ static ProxySupport = new KnownHeader("Proxy-Support");
    /*KnownHeader*/ static PublicKeyPins = new KnownHeader("Public-Key-Pins");
    /*KnownHeader*/ static Range = new KnownHeader("Range", HttpHeaderType.Request  | HttpHeaderType.NonTrailing, GenericHeaderParser.RangeParser, null);
    /*KnownHeader*/ static Referer = new KnownHeader("Referer", HttpHeaderType.Request, UriHeaderParser.RelativeOrAbsoluteUriParser, null);
    /*KnownHeader*/ static ReferrerPolicy = new KnownHeader("Referrer-Policy", HttpHeaderType.Custom, null, [ "strict-origin-when-cross-origin", "origin-when-cross-origin", "strict-origin", "origin", "same-origin", "no-referrer-when-downgrade", "no-referrer", "unsafe-url" ]);
    /*KnownHeader*/ static Refresh = new KnownHeader("Refresh");
    /*KnownHeader*/ static RetryAfter = new KnownHeader("Retry-After", HttpHeaderType.Response  | HttpHeaderType.NonTrailing, GenericHeaderParser.RetryConditionParser, null);
    /*KnownHeader*/ static SecWebSocketAccept = new KnownHeader("Sec-WebSocket-Accept");
    /*KnownHeader*/ static SecWebSocketExtensions = new KnownHeader("Sec-WebSocket-Extensions");
    /*KnownHeader*/ static SecWebSocketKey = new KnownHeader("Sec-WebSocket-Key");
    /*KnownHeader*/ static SecWebSocketProtocol = new KnownHeader("Sec-WebSocket-Protocol");
    /*KnownHeader*/ static SecWebSocketVersion = new KnownHeader("Sec-WebSocket-Version");
    /*KnownHeader*/ static Server = new KnownHeader("Server", HttpHeaderType.Response, ProductInfoHeaderParser.MultipleValueParser, null);
    /*KnownHeader*/ static ServerTiming = new KnownHeader("Server-Timing");
    /*KnownHeader*/ static SetCookie = new KnownHeader("Set-Cookie", HttpHeaderType.Custom  | HttpHeaderType.NonTrailing, null, null);
    /*KnownHeader*/ static SetCookie2 = new KnownHeader("Set-Cookie2", HttpHeaderType.Custom  | HttpHeaderType.NonTrailing, null, null);
    /*KnownHeader*/ static StrictTransportSecurity = new KnownHeader("Strict-Transport-Security");
    /*KnownHeader*/ static TE = new KnownHeader("TE", HttpHeaderType.Request  | HttpHeaderType.NonTrailing, TransferCodingHeaderParser.MultipleValueWithQualityParser, [ "trailers", "compress", "deflate", "gzip" ]);
    /*KnownHeader*/ static TSV = new KnownHeader("TSV");
    /*KnownHeader*/ static Trailer = new KnownHeader("Trailer", HttpHeaderType.General  | HttpHeaderType.NonTrailing, GenericHeaderParser.TokenListParser);
    /*KnownHeader*/ static TransferEncoding = new KnownHeader("Transfer-Encoding", HttpHeaderType.General  | HttpHeaderType.NonTrailing, TransferCodingHeaderParser.MultipleValueParser, [ "chunked", "compress", "deflate", "gzip", "identity" ]);
    /*KnownHeader*/ static Upgrade = new KnownHeader("Upgrade", HttpHeaderType.General, GenericHeaderParser.MultipleValueProductParser);
    /*KnownHeader*/ static UpgradeInsecureRequests = new KnownHeader("Upgrade-Insecure-Requests", HttpHeaderType.Custom, null, [ "1" ]);
    /*KnownHeader*/ static UserAgent = new KnownHeader("User-Agent", HttpHeaderType.Request, ProductInfoHeaderParser.MultipleValueParser, null);
    /*KnownHeader*/ static Vary = new KnownHeader("Vary", HttpHeaderType.Response  | HttpHeaderType.NonTrailing, GenericHeaderParser.TokenListParser, [ "*" ]);
    /*KnownHeader*/ static Via = new KnownHeader("Via", HttpHeaderType.General, GenericHeaderParser.MultipleValueViaParser, null);
    /*KnownHeader*/ static WWWAuthenticate = new KnownHeader("WWW-Authenticate", HttpHeaderType.Response  | HttpHeaderType.NonTrailing, GenericHeaderParser.MultipleValueAuthenticationParser, null);
    /*KnownHeader*/ static Warning = new KnownHeader("Warning", HttpHeaderType.General  | HttpHeaderType.NonTrailing, GenericHeaderParser.MultipleValueWarningParser);
    /*KnownHeader*/ static XAspNetVersion = new KnownHeader("X-AspNet-Version");
    /*KnownHeader*/ static XCache = new KnownHeader("X-Cache");
    /*KnownHeader*/ static XContentDuration = new KnownHeader("X-Content-Duration");
    /*KnownHeader*/ static XContentTypeOptions = new KnownHeader("X-Content-Type-Options", HttpHeaderType.Custom, null, [ "nosniff" ]);
    /*KnownHeader*/ static XFrameOptions = new KnownHeader("X-Frame-Options", HttpHeaderType.Custom, null, [ "DENY", "SAMEORIGIN" ]);
    /*KnownHeader*/ static XMSEdgeRef = new KnownHeader("X-MSEdge-Ref");
    /*KnownHeader*/ static XPoweredBy = new KnownHeader("X-Powered-By");
    /*KnownHeader*/ static XRequestID = new KnownHeader("X-Request-ID");
    /*KnownHeader*/ static XUACompatible = new KnownHeader("X-UA-Compatible");
    /*KnownHeader*/ static XXssProtection = new KnownHeader("X-XSS-Protection", HttpHeaderType.Custom, null, [ "0", "1", "1; mode=block" ]);
    /*AltSvcHeaderParser*/ static GetAltSvcHeaderParser()
    {
        return AltSvcHeaderParser.Parser;
    }
    static System_Net_Http_Headers_KnownHeaders_IHeaderNameAccessor = (Base) => class extends Base
    {
        /*int*/ _backingField_Length = null;
        /*int*/ get Length()
        {
            return _backingField_Length;
        }
        /*char*/ getItem(/*int*/ index)
        {
        }
    }
    static System_Net_Http_Headers_KnownHeaders_StringAccessor = class extends System_Net_Http_Headers_KnownHeaders_IHeaderNameAccessor(System_ValueType)
    {
        /*string*/ _string = null;
        constructor(/*string*/ s)
        {
            super();
            _string = s;
        }
        /*int*/ get Length()
        {
            return _string.Length;
        }
        /*char*/ getItem(/*int*/ index)
        {
            return _string[index];
        }
    }
    static System_Net_Http_Headers_KnownHeaders_BytePtrAccessor = class extends System_Net_Http_Headers_KnownHeaders_IHeaderNameAccessor(System_ValueType)
    {
        /*byte[]*/ _p = null;
        /*int*/ _length = null;
        constructor(/*byte[]*/ p, /*int*/ length)
        {
            super();
            _p = p;
            _length = length;
        }
        /*int*/ get Length()
        {
            return _length;
        }
        /*char*/ getItem(/*int*/ index)
        {
            return BlazorJs.Cast(_p[index], char);
        }
    }
    /*KnownHeader*/ static GetCandidate(T, /*T*/ key)
    {
        /*// Lookup is performed by first switching on the header name's length, and then switching
            // on the most unique position in that length's string.

            int*/ let length = key.Length;
        switch(length)
        {
            case 2:
            {
                return TE;
            }
            case 3:
            {
                switch(key[0] | 0x20)
                {
                    case 'a':
                    {
                        return Age;
                    }
                    case 'p':
                    {
                        return P3P;
                    }
                    case 't':
                    {
                        return TSV;
                    }
                    case 'v':
                    {
                        return Via;
                    }
                }
                break;
            }
            case 4:
            {
                switch(key[0] | 0x20)
                {
                    case 'd':
                    {
                        return Date;
                    }
                    case 'e':
                    {
                        return ETag;
                    }
                    case 'f':
                    {
                        return From;
                    }
                    case 'h':
                    {
                        return Host;
                    }
                    case 'l':
                    {
                        return Link;
                    }
                    case 'v':
                    {
                        return Vary;
                    }
                }
                break;
            }
            case 5:
            {
                switch(key[0] | 0x20)
                {
                    case 'a':
                    {
                        return Allow;
                    }
                    case 'r':
                    {
                        return Range;
                    }
                }
                break;
            }
            case 6:
            {
                switch(key[0] | 0x20)
                {
                    case 'a':
                    {
                        return Accept;
                    }
                    case 'c':
                    {
                        return Cookie;
                    }
                    case 'e':
                    {
                        return Expect;
                    }
                    case 'o':
                    {
                        return Origin;
                    }
                    case 'p':
                    {
                        return Pragma;
                    }
                    case 's':
                    {
                        return Server;
                    }
                }
                break;
            }
            case 7:
            {
                switch(key[0] | 0x20)
                {
                    case ':':
                    {
                        return PseudoStatus;
                    }
                    case 'a':
                    {
                        return AltSvc;
                    }
                    case 'c':
                    {
                        return Cookie2;
                    }
                    case 'e':
                    {
                        return Expires;
                    }
                    case 'r':
                    {
                        switch(key[3] | 0x20)
                        {
                            case 'e':
                            {
                                return Referer;
                            }
                            case 'r':
                            {
                                return Refresh;
                            }
                        }
                        break;
                    }
                    case 't':
                    {
                        return Trailer;
                    }
                    case 'u':
                    {
                        return Upgrade;
                    }
                    case 'w':
                    {
                        return Warning;
                    }
                    case 'x':
                    {
                        return XCache;
                    }
                }
                break;
            }
            case 8:
            {
                switch(key[3] | 0x20)
                {
                    case '-':
                    {
                        return AltUsed;
                    }
                    case 'a':
                    {
                        return Location;
                    }
                    case 'm':
                    {
                        return IfMatch;
                    }
                    case 'r':
                    {
                        return IfRange;
                    }
                }
                break;
            }
            case 9:
            {
                return ExpectCT;
            }
            case 10:
            {
                switch(key[0] | 0x20)
                {
                    case 'c':
                    {
                        return Connection;
                    }
                    case 'k':
                    {
                        return KeepAlive;
                    }
                    case 's':
                    {
                        return SetCookie;
                    }
                    case 'u':
                    {
                        return UserAgent;
                    }
                }
                break;
            }
            case 11:
            {
                switch(key[0] | 0x20)
                {
                    case 'c':
                    {
                        return ContentMD5;
                    }
                    case 'g':
                    {
                        return GrpcStatus;
                    }
                    case 'r':
                    {
                        return RetryAfter;
                    }
                    case 's':
                    {
                        return SetCookie2;
                    }
                }
                break;
            }
            case 12:
            {
                switch(key[5] | 0x20)
                {
                    case 'd':
                    {
                        return XMSEdgeRef;
                    }
                    case 'e':
                    {
                        return XPoweredBy;
                    }
                    case 'm':
                    {
                        return GrpcMessage;
                    }
                    case 'n':
                    {
                        return ContentType;
                    }
                    case 'o':
                    {
                        return MaxForwards;
                    }
                    case 't':
                    {
                        return AcceptPatch;
                    }
                    case 'u':
                    {
                        return XRequestID;
                    }
                }
                break;
            }
            case 13:
            {
                switch(key[12] | 0x20)
                {
                    case 'd':
                    {
                        return LastModified;
                    }
                    case 'e':
                    {
                        return ContentRange;
                    }
                    case 'g':
                    {
                        switch(key[0] | 0x20)
                        {
                            case 's':
                            {
                                return ServerTiming;
                            }
                            case 'g':
                            {
                                return GrpcEncoding;
                            }
                        }
                        break;
                    }
                    case 'h':
                    {
                        return IfNoneMatch;
                    }
                    case 'l':
                    {
                        return CacheControl;
                    }
                    case 'n':
                    {
                        return Authorization;
                    }
                    case 's':
                    {
                        return AcceptRanges;
                    }
                    case 't':
                    {
                        return ProxySupport;
                    }
                }
                break;
            }
            case 14:
            {
                switch(key[0] | 0x20)
                {
                    case 'a':
                    {
                        return AcceptCharset;
                    }
                    case 'c':
                    {
                        return ContentLength;
                    }
                }
                break;
            }
            case 15:
            {
                switch(key[7] | 0x20)
                {
                    case '-':
                    {
                        return XFrameOptions;
                    }
                    case 'e':
                    {
                        return AcceptEncoding;
                    }
                    case 'k':
                    {
                        return PublicKeyPins;
                    }
                    case 'l':
                    {
                        return AcceptLanguage;
                    }
                    case 'm':
                    {
                        return XUACompatible;
                    }
                    case 'r':
                    {
                        return ReferrerPolicy;
                    }
                }
                break;
            }
            case 16:
            {
                switch(key[11] | 0x20)
                {
                    case 'a':
                    {
                        return ContentLocation;
                    }
                    case 'c':
                    {
                        switch(key[0] | 0x20)
                        {
                            case 'p':
                            {
                                return ProxyConnection;
                            }
                            case 'x':
                            {
                                return XXssProtection;
                            }
                        }
                        break;
                    }
                    case 'g':
                    {
                        return ContentLanguage;
                    }
                    case 'i':
                    {
                        return WWWAuthenticate;
                    }
                    case 'o':
                    {
                        return ContentEncoding;
                    }
                    case 'r':
                    {
                        return XAspNetVersion;
                    }
                }
                break;
            }
            case 17:
            {
                switch(key[0] | 0x20)
                {
                    case 'i':
                    {
                        return IfModifiedSince;
                    }
                    case 's':
                    {
                        return SecWebSocketKey;
                    }
                    case 't':
                    {
                        return TransferEncoding;
                    }
                }
                break;
            }
            case 18:
            {
                switch(key[0] | 0x20)
                {
                    case 'p':
                    {
                        return ProxyAuthenticate;
                    }
                    case 'x':
                    {
                        return XContentDuration;
                    }
                }
                break;
            }
            case 19:
            {
                switch(key[0] | 0x20)
                {
                    case 'c':
                    {
                        return ContentDisposition;
                    }
                    case 'i':
                    {
                        return IfUnmodifiedSince;
                    }
                    case 'p':
                    {
                        return ProxyAuthorization;
                    }
                }
                break;
            }
            case 20:
            {
                return SecWebSocketAccept;
            }
            case 21:
            {
                return SecWebSocketVersion;
            }
            case 22:
            {
                switch(key[0] | 0x20)
                {
                    case 'a':
                    {
                        return AccessControlMaxAge;
                    }
                    case 's':
                    {
                        return SecWebSocketProtocol;
                    }
                    case 'x':
                    {
                        return XContentTypeOptions;
                    }
                }
                break;
            }
            case 23:
            {
                return ContentSecurityPolicy;
            }
            case 24:
            {
                return SecWebSocketExtensions;
            }
            case 25:
            {
                switch(key[0] | 0x20)
                {
                    case 's':
                    {
                        return StrictTransportSecurity;
                    }
                    case 'u':
                    {
                        return UpgradeInsecureRequests;
                    }
                }
                break;
            }
            case 27:
            {
                return AccessControlAllowOrigin;
            }
            case 28:
            {
                switch(key[21] | 0x20)
                {
                    case 'h':
                    {
                        return AccessControlAllowHeaders;
                    }
                    case 'm':
                    {
                        return AccessControlAllowMethods;
                    }
                }
                break;
            }
            case 29:
            {
                return AccessControlExposeHeaders;
            }
            case 32:
            {
                return AccessControlAllowCredentials;
            }
        }
        return null;
    }
    /*KnownHeader*/ static TryGetKnownHeader(/*string*/ name)
    {
        /*KnownHeader*/ let candidate = GetCandidate(new StringAccessor(name));
        if (candidate !== null && StringComparer.OrdinalIgnoreCase.Equals(name, candidate.Name))
        {
            return candidate;
        }
        return null;
    }
    /*KnownHeader*/ static TryGetKnownHeader(/*ReadOnlySpan<byte>*/ name)
    {
        /*var*/ let p = name.ToArray();
        /*KnownHeader*/ let candidate = GetCandidate(new BytePtrAccessor(p, name.Length));
        if (candidate !== null && Ascii.EqualsIgnoreCase(name, candidate.Name))
        {
            return candidate;
        }
        return null;
    }
}

class System_Net_Http_Headers_MediaTypeHeaderParser extends System_Net_Http_Headers_BaseHeaderParser
{
    /*Func<MediaTypeHeaderValue>*/ _mediaTypeCreator = null;
    /*MediaTypeHeaderParser*/ static SingleValueParser = new MediaTypeHeaderParser(false, CreateMediaType);
    /*MediaTypeHeaderParser*/ static SingleValueWithQualityParser = new MediaTypeHeaderParser(false, CreateMediaTypeWithQuality);
    /*MediaTypeHeaderParser*/ static MultipleValuesParser = new MediaTypeHeaderParser(true, CreateMediaTypeWithQuality);
    constructor(/*bool*/ supportsMultipleValues, /*Func<MediaTypeHeaderValue>*/ mediaTypeCreator)
    {
        super(supportsMultipleValues);
        Debug.Assert(mediaTypeCreator !== null);
        _mediaTypeCreator = mediaTypeCreator;
    }
    /*int*/ GetParsedValueLength(/*string*/ value, /*int*/ startIndex, /*object*/ storeValue, /*out object*/ parsedValue)
    {
        let temp = null;
        let $ref1 = { set value(v){ temp = v } };
        /*int*/ let resultLength = MediaTypeHeaderValue.GetMediaTypeLength(value, startIndex, _mediaTypeCreator, $ref1);
        parsedValue = temp;
        return resultLength;
    }
    /*MediaTypeHeaderValue*/ static CreateMediaType()
    {
        return new MediaTypeHeaderValue();
    }
    /*MediaTypeWithQualityHeaderValue*/ static CreateMediaTypeWithQuality()
    {
        return new MediaTypeWithQualityHeaderValue();
    }
}

class System_Net_Http_Headers_MediaTypeHeaderValue extends H5_IH5Class(System_ICloneable(object))
{
    /*string*/ CharSetName = "charset";
    /*UnvalidatedObjectCollection<NameValueHeaderValue>*/ _parameters = null;
    /*string*/ _mediaType = null;
    /*string*/ get CharSet()
    {
        return NameValueHeaderValue.Find(_parameters, CharSetName)?.Value;
    }
    /*string*/ set CharSet(value)
    {
        /*// We don't prevent a user from setting whitespace-only charsets. Like we can't prevent a user from
                // setting a non-existing charset.
                NameValueHeaderValue*/ let charSetParameter = NameValueHeaderValue.Find(_parameters, CharSetName);
        if (string.IsNullOrEmpty(value))
        {
            if (charSetParameter !== null)
            {
                _parameters.Remove(charSetParameter);
            }
        }
        else 
        {
            if (charSetParameter !== null)
            {
                charSetParameter.Value  = value;
            }
            else 
            {
                Parameters.Add(new NameValueHeaderValue(CharSetName, value));
            }
        }
    }
    /*ICollection<NameValueHeaderValue>*/ get Parameters()
    {
        return _parameters = _parameters ?? new UnvalidatedObjectCollection(NameValueHeaderValue)();
    }
    /*string*/ get MediaType()
    {
        return _mediaType;
    }
    /*string*/ set MediaType(value)
    {
        CheckMediaTypeFormat(value);
        _mediaType = value;
    }
    constructor()
    {
        super();
    }
    constructor(/*MediaTypeHeaderValue*/ source)
    {
        super();
        Debug.Assert(source !== null);
        _mediaType = source._mediaType;
        _parameters = source._parameters.Clone();
    }
    constructor(/*string*/ mediaType)
    {
        super(mediaType, {charSet : null});
    }
    constructor(/*string*/ mediaType, /*string*/ charSet)
    {
        super();
        CheckMediaTypeFormat(mediaType);
        _mediaType = mediaType;
        if (string.IsNullOrEmpty(charSet))
        {
            CharSet = charSet;
        }
    }
    /*string*/ ToString()
    {
        if (_parameters || _parameters.Count  === 0)
        {
            return _mediaType ?? string.Empty;
        }
        /*var*/ let sb = new StringBuilder();
        sb.Append(_mediaType);
        NameValueHeaderValue.ToString(_parameters, ';', true, sb);
        return sb.ToString();
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        return obj instanceof MediaTypeHeaderValue, other = obj && string.Equals(_mediaType, other._mediaType, StringComparison.OrdinalIgnoreCase) && HeaderUtilities.AreEqualCollections(_parameters, other._parameters);
    }
    /*int*/ GetHashCode()
    {
        return StringComparer.OrdinalIgnoreCase.GetHashCode(_mediaType) ^ NameValueHeaderValue.GetHashCode(_parameters);
    }
    /*MediaTypeHeaderValue*/ static Parse(/*string*/ input)
    {
        let $ref0 = { set value(v){ index = v } };
        /*int*/ let index = 0;
        return BlazorJs.Cast(MediaTypeHeaderParser.SingleValueParser.ParseValue(input, null, $ref0), MediaTypeHeaderValue);
    }
    /*bool*/ static TryParse(/*string*/ input, /*out MediaTypeHeaderValue*/ parsedValue)
    {
        let $ref0 = { set value(v){ index = v } };
        let output = null;
        let $ref2 = { set value(v){ output = v } };
        /*int*/ let index = 0;
        parsedValue = null;
        if (MediaTypeHeaderParser.SingleValueParser.TryParseValue(input, null, $ref0, $ref2))
        {
            parsedValue = BlazorJs.Cast(output, MediaTypeHeaderValue);
            return true;
        }
        return false;
    }
    /*int*/ static GetMediaTypeLength(/*string*/ input, /*int*/ startIndex, /*Func<MediaTypeHeaderValue>*/ mediaTypeCreator, /*out MediaTypeHeaderValue*/ parsedValue)
    {
        let mediaType = null;
        let $ref1 = { set value(v){ mediaType = v } };
        Debug.Assert(mediaTypeCreator !== null);
        Debug.Assert(startIndex >= 0);
        parsedValue = null;
        if (string.IsNullOrEmpty(input) || (startIndex >= input.Length))
        {
            return 0;
        }
        /*// Caller must remove leading whitespace. If not, we'll return 0.
            int*/ let mediaTypeLength = MediaTypeHeaderValue.GetMediaTypeExpressionLength(input, startIndex, $ref1);
        if (mediaTypeLength === 0)
        {
            return 0;
        }
        /*int*/ let current = startIndex + mediaTypeLength;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        /*MediaTypeHeaderValue*/ let mediaTypeHeader;
        if ((current < input.Length) && (input[current] === ';'))
        {
            mediaTypeHeader = mediaTypeCreator();
            mediaTypeHeader._mediaType  = mediaType;
            current++;
            /*int*/ let parameterLength = NameValueHeaderValue.GetNameValueListLength(input, current, ';', BlazorJs.Cast(mediaTypeHeader.Parameters, UnvalidatedObjectCollection(NameValueHeaderValue)));
            if (parameterLength === 0)
            {
                return 0;
            }
            parsedValue = mediaTypeHeader;
            return current + parameterLength - startIndex;
        }
        mediaTypeHeader = mediaTypeCreator();
        mediaTypeHeader._mediaType  = mediaType;
        parsedValue = mediaTypeHeader;
        return current - startIndex;
    }
    /*int*/ static GetMediaTypeExpressionLength(/*string*/ input, /*int*/ startIndex, /*out string*/ mediaType)
    {
        Debug.Assert((input !== null) && (input.Length  > 0) && (startIndex < input.Length));
        mediaType = null;
        /*// Parse the type, i.e. <type> in media type string "<type>/<subtype>; param1=value1; param2=value2"
            int*/ let typeLength = HttpRuleParser.GetTokenLength(input, startIndex);
        if (typeLength === 0)
        {
            return 0;
        }
        /*int*/ let current = startIndex + typeLength;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        if ((current >= input.Length) || (input[current] !== '/'))
        {
            return 0;
        }
        current++;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        /*// Parse the subtype, i.e. <subtype> in media type string "<type>/<subtype>; param1=value1; param2=value2"
            int*/ let subtypeLength = HttpRuleParser.GetTokenLength(input, current);
        if (subtypeLength === 0)
        {
            return 0;
        }
        /*// If there is no whitespace between <type> and <subtype> in <type>/<subtype> get the media type using
            // one Substring call. Otherwise get substrings for <type> and <subtype> and combine them.
            int*/ let mediaTypeLength = current + subtypeLength - startIndex;
        if (typeLength + subtypeLength + 1 === mediaTypeLength)
        {
            mediaType = input.Substring(startIndex, mediaTypeLength);
        }
        else 
        {
            mediaType = string.Concat(input.AsSpan(startIndex, typeLength), "/", input.AsSpan(current, subtypeLength));
        }
        return mediaTypeLength;
    }
    /*void*/ static CheckMediaTypeFormat(/*string*/ mediaType, { /*string*/ parameterName = null})
    {
        let tempMediaType = null;
        let $ref1 = { set value(v){ tempMediaType = v } };
        if (string.IsNullOrEmpty(mediaType))
        throw new ArgumentException(nameof(mediaType));
        /*// When adding values using strongly typed objects, no leading/trailing LWS (whitespace) are allowed.
            // Also no LWS between type and subtype are allowed.
            int*/ let mediaTypeLength = GetMediaTypeExpressionLength(mediaType, 0, $ref1);
        if ((mediaTypeLength === 0) || (tempMediaType.Length  !== mediaType.Length))
        {
            throw new FormatException("net_http_headers_invalid_value");
        }
    }
    /*// Implement ICloneable explicitly to allow derived types to "override" the implementation.
        object*/ Clone()
    {
        return new MediaTypeHeaderValue(this);
    }
}

class System_Net_Http_Headers_MediaTypeWithQualityHeaderValue extends H5_IH5Class(System_ICloneable(System_Net_Http_Headers_MediaTypeHeaderValue))
{
    /*double?*/ get Quality()
    {
        return HeaderUtilities.GetQuality(BlazorJs.Cast(Parameters, UnvalidatedObjectCollection(NameValueHeaderValue)));
    }
    /*double?*/ set Quality(value)
    {
        HeaderUtilities.SetQuality(BlazorJs.Cast(Parameters, UnvalidatedObjectCollection(NameValueHeaderValue)), value);
    }
    constructor()
    {
        super();
    }
    constructor(/*string*/ mediaType)
    {
        super(mediaType);
    }
    constructor(/*string*/ mediaType, /*double*/ quality)
    {
        super(mediaType);
        Quality = quality;
    }
    constructor(/*MediaTypeWithQualityHeaderValue*/ source)
    {
        super(source);
    }
    /*object*/ Clone()
    {
        return new MediaTypeWithQualityHeaderValue(this);
    }
    /*MediaTypeWithQualityHeaderValue*/ static Parse(/*string*/ input)
    {
        let $ref0 = { set value(v){ index = v } };
        /*int*/ let index = 0;
        return BlazorJs.Cast(MediaTypeHeaderParser.SingleValueWithQualityParser.ParseValue(input, null, $ref0), MediaTypeWithQualityHeaderValue);
    }
    /*bool*/ static TryParse(/*string*/ input, /*out MediaTypeWithQualityHeaderValue*/ parsedValue)
    {
        let $ref0 = { set value(v){ index = v } };
        let output = null;
        let $ref2 = { set value(v){ output = v } };
        /*int*/ let index = 0;
        parsedValue = null;
        if (MediaTypeHeaderParser.SingleValueWithQualityParser.TryParseValue(input, null, $ref0, $ref2))
        {
            parsedValue = BlazorJs.Cast(output, MediaTypeWithQualityHeaderValue);
            return true;
        }
        return false;
    }
}

class System_Net_Http_Headers_NameValueHeaderValue extends H5_IH5Class(System_ICloneable(object))
{
    /*Func<NameValueHeaderValue>*/ static s_defaultNameValueCreator = CreateNameValue;
    /*string*/ _name = null;
    /*string*/ _value = null;
    /*string*/ get Name()
    {
        return _name;
    }
    /*string*/ get Value()
    {
        return _value;
    }
    /*string*/ set Value(value)
    {
        CheckValueFormat(value);
        _value = value;
    }
    constructor()
    {
        super();
    }
    constructor(/*string*/ name)
    {
        super(name, null);
    }
    constructor(/*string*/ name, /*string*/ value)
    {
        super();
        CheckNameValueFormat(name, value);
        _name = name;
        _value = value;
    }
    constructor(/*NameValueHeaderValue*/ source)
    {
        super();
        Debug.Assert(source !== null);
        _name = source._name;
        _value = source._value;
    }
    /*int*/ GetHashCode()
    {
        Debug.Assert(_name !== null);
        /*int*/ let nameHashCode = StringComparer.OrdinalIgnoreCase.GetHashCode(_name);
        if (string.IsNullOrEmpty(_value))
        {
            if (_value[0] === '"')
            {
                return nameHashCode ^ _value.GetHashCode();
            }
            return nameHashCode ^ StringComparer.OrdinalIgnoreCase.GetHashCode(_value);
        }
        return nameHashCode;
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        /*NameValueHeaderValue*/ let other = BlazorJs.As(obj, NameValueHeaderValue);
        if (other === null)
        {
            return false;
        }
        if (string.Equals(_name, other._name, StringComparison.OrdinalIgnoreCase))
        {
            return false;
        }
        if (string.IsNullOrEmpty(_value))
        {
            return string.IsNullOrEmpty(other._value);
        }
        if (_value[0] === '"')
        {
            return string.Equals(_value, other._value, StringComparison.Ordinal);
        }
        else 
        {
            return string.Equals(_value, other._value, StringComparison.OrdinalIgnoreCase);
        }
    }
    /*NameValueHeaderValue*/ static Parse(/*string*/ input)
    {
        let $ref0 = { set value(v){ index = v } };
        /*int*/ let index = 0;
        return BlazorJs.Cast(GenericHeaderParser.SingleValueNameValueParser.ParseValue(input, null, $ref0), NameValueHeaderValue);
    }
    /*bool*/ static TryParse(/*string*/ input, /*out NameValueHeaderValue*/ parsedValue)
    {
        let $ref0 = { set value(v){ index = v } };
        let output = null;
        let $ref2 = { set value(v){ output = v } };
        /*int*/ let index = 0;
        parsedValue = null;
        if (GenericHeaderParser.SingleValueNameValueParser.TryParseValue(input, null, $ref0, $ref2))
        {
            parsedValue = BlazorJs.Cast(output, NameValueHeaderValue);
            return true;
        }
        return false;
    }
    /*string*/ ToString()
    {
        if (string.IsNullOrEmpty(_value))
        {
            return _name + "=" + _value;
        }
        return _name;
    }
    /*void*/ AddToStringBuilder(/*StringBuilder*/ sb)
    {
        if (GetType() !== NameValueHeaderValue)
        {
            sb.Append(ToString());
        }
        else 
        {
            sb.Append(_name);
            if (string.IsNullOrEmpty(_value))
            {
                sb.Append('=');
                sb.Append(_value);
            }
        }
    }
    /*void*/ static ToString(/*UnvalidatedObjectCollection<NameValueHeaderValue>*/ values, /*char*/ separator, /*bool*/ leadingSeparator, /*StringBuilder*/ destination)
    {
        Debug.Assert(destination !== null);
        if ((values === null) || (values.Count  === 0))
        {
            return ;
        }
        BlazorJs.forEach(values, function(value, $_i)
        {
            if (leadingSeparator || (destination.Length  > 0))
            {
                destination.Append(separator);
                destination.Append(' ');
            }
            value.AddToStringBuilder(destination);
        });
    }
    /*int*/ static GetHashCode(/*UnvalidatedObjectCollection<NameValueHeaderValue>*/ values)
    {
        if ((values === null) || (values.Count  === 0))
        {
            return 0;
        }
        /*int*/ let result = 0;
        BlazorJs.forEach(values, function(value, $_i)
        {
            result ^= value.GetHashCode();
        });
        return result;
    }
    /*int*/ static GetNameValueLength(/*string*/ input, /*int*/ startIndex, /*out NameValueHeaderValue*/ parsedValue)
    {
        let $ref0 = { set value(v){ parsedValue = v } };
        return GetNameValueLength(input, startIndex, s_defaultNameValueCreator, $ref0);
    }
    /*int*/ static GetNameValueLength(/*string*/ input, /*int*/ startIndex, /*Func<NameValueHeaderValue>*/ nameValueCreator, /*out NameValueHeaderValue*/ parsedValue)
    {
        Debug.Assert(input !== null);
        Debug.Assert(startIndex >= 0);
        Debug.Assert(nameValueCreator !== null);
        parsedValue = null;
        if (string.IsNullOrEmpty(input) || (startIndex >= input.Length))
        {
            return 0;
        }
        /*// Parse the name, i.e. <name> in name/value string "<name>=<value>". Caller must remove
            // leading whitespace.
            int*/ let nameLength = HttpRuleParser.GetTokenLength(input, startIndex);
        if (nameLength === 0)
        {
            return 0;
        }
        /*string*/ let name = input.Substring(startIndex, nameLength);
        /*int*/ let current = startIndex + nameLength;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        if ((current === input.Length) || (input[current] !== '='))
        {
            parsedValue = nameValueCreator();
            parsedValue._name  = name;
            current += HttpRuleParser.GetWhitespaceLength(input, current);
            return current - startIndex;
        }
        current++;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        /*// Parse the value, i.e. <value> in name/value string "<name>=<value>"
            int*/ let valueLength = GetValueLength(input, current);
        if (valueLength === 0)
        {
            return 0;
        }
        parsedValue = nameValueCreator();
        parsedValue._name  = name;
        parsedValue._value  = input.Substring(current, valueLength);
        current += valueLength;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        return current - startIndex;
    }
    /*int*/ static GetNameValueListLength(/*string*/ input, /*int*/ startIndex, /*char*/ delimiter, /*UnvalidatedObjectCollection<NameValueHeaderValue>*/ nameValueCollection)
    {
        Debug.Assert(nameValueCollection !== null);
        Debug.Assert(startIndex >= 0);
        if ((string.IsNullOrEmpty(input)) || (startIndex >= input.Length))
        {
            return 0;
        }
        /*int*/ let current = startIndex + HttpRuleParser.GetWhitespaceLength(input, startIndex);
        while(true)
        {
            let $ref0 = { set value(v){ parameter = v } };
            /*NameValueHeaderValue*/ let parameter;
            /*int*/ let nameValueLength = NameValueHeaderValue.GetNameValueLength(input, current, s_defaultNameValueCreator, $ref0);
            if (nameValueLength === 0)
            {
                return 0;
            }
            nameValueCollection.Add(parameter);
            current += nameValueLength;
            current += HttpRuleParser.GetWhitespaceLength(input, current);
            if ((current === input.Length) || (input[current] !== delimiter))
            {
                return current - startIndex;
            }
            current++;
            current += HttpRuleParser.GetWhitespaceLength(input, current);
        }
    }
    /*NameValueHeaderValue*/ static Find(/*UnvalidatedObjectCollection<NameValueHeaderValue>*/ values, /*string*/ name)
    {
        Debug.Assert((name !== null) && (name.Length  > 0));
        if ((values === null) || (values.Count  === 0))
        {
            return null;
        }
        BlazorJs.forEach(values, function(value, $_i)
        {
            if (string.Equals(value.Name, name, StringComparison.OrdinalIgnoreCase))
            {
                return value;
            }
        });
        return null;
    }
    /*int*/ static GetValueLength(/*string*/ input, /*int*/ startIndex)
    {
        Debug.Assert(input !== null);
        if (startIndex >= input.Length)
        {
            return 0;
        }
        /*int*/ let valueLength = HttpRuleParser.GetTokenLength(input, startIndex);
        if (valueLength === 0)
        {
            let $ref0 = { set value(v){ valueLength = v } };
            if (HttpRuleParser.GetQuotedStringLength(input, startIndex, $ref0) !== HttpParseResult.Parsed)
            {
                return 0;
            }
        }
        return valueLength;
    }
    /*void*/ static CheckNameValueFormat(/*string*/ name, /*string*/ value)
    {
        HeaderUtilities.CheckValidToken(name);
        CheckValueFormat(value);
    }
    /*void*/ static CheckValueFormat(/*string*/ value)
    {
        if (string.IsNullOrEmpty(value))
        {
            return ;
        }
        if (value.StartsWith(" ") || value.StartsWith("\t") || value.EndsWith(" ") || value.EndsWith("\t"))
        {
            throw new FormatException("net_http_headers_invalid_value");
        }
        if (value[0] === '"')
        {
            let valueLength = null;
            let $ref1 = { set value(v){ valueLength = v } };
            /*HttpParseResult*/ let parseResult = HttpRuleParser.GetQuotedStringLength(value, 0, $ref1);
            if (parseResult !== HttpParseResult.Parsed  || valueLength !== value.Length)
            {
                throw new FormatException("net_http_headers_invalid_value");
            }
        }
        else if (HttpRuleParser.ContainsNewLine(value))
        {
            throw new FormatException("net_http_headers_invalid_value");
        }
    }
    /*NameValueHeaderValue*/ static CreateNameValue()
    {
        return new NameValueHeaderValue();
    }
    /*// Implement ICloneable explicitly to allow derived types to "override" the implementation.
        object*/ Clone()
    {
        return new NameValueHeaderValue(this);
    }
}

class System_Net_Http_Headers_NameValueWithParametersHeaderValue extends H5_IH5Class(System_ICloneable(System_Net_Http_Headers_NameValueHeaderValue))
{
    /*Func<NameValueHeaderValue>*/ static s_nameValueCreator = CreateNameValue;
    /*UnvalidatedObjectCollection<NameValueHeaderValue>*/ _parameters = null;
    /*ICollection<NameValueHeaderValue>*/ get Parameters()
    {
        return _parameters = _parameters ?? new UnvalidatedObjectCollection(NameValueHeaderValue)();
    }
    constructor(/*string*/ name)
    {
        super(name);
    }
    constructor(/*string*/ name, /*string*/ value)
    {
        super(name, value);
    }
    constructor()
    {
        super();
    }
    constructor(/*NameValueWithParametersHeaderValue*/ source)
    {
        super(source);
        _parameters = source._parameters.Clone();
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        /*bool*/ let result = super.Equals(obj);
        if (result)
        {
            /*NameValueWithParametersHeaderValue*/ let other = BlazorJs.As(obj, NameValueWithParametersHeaderValue);
            if (other === null)
            {
                return false;
            }
            return HeaderUtilities.AreEqualCollections(_parameters, other._parameters);
        }
        return false;
    }
    /*int*/ GetHashCode()
    {
        return super.GetHashCode() ^ NameValueHeaderValue.GetHashCode(_parameters);
    }
    /*string*/ ToString()
    {
        /*string*/ let baseString = super.ToString();
        /*StringBuilder*/ let sb = new StringBuilder();
        sb.Append(baseString);
        NameValueHeaderValue.ToString(_parameters, ';', true, sb);
        return sb.ToString();
    }
    /*NameValueWithParametersHeaderValue*/ static Parse(/*string*/ input)
    {
        let $ref0 = { set value(v){ index = v } };
        /*int*/ let index = 0;
        return BlazorJs.Cast(GenericHeaderParser.SingleValueNameValueWithParametersParser
.ParseValue(input, null, $ref0), NameValueWithParametersHeaderValue);
    }
    /*bool*/ static TryParse(/*string*/ input, /*out NameValueWithParametersHeaderValue*/ parsedValue)
    {
        let $ref0 = { set value(v){ index = v } };
        let output = null;
        let $ref2 = { set value(v){ output = v } };
        /*int*/ let index = 0;
        parsedValue = null;
        if (GenericHeaderParser.SingleValueNameValueWithParametersParser.TryParseValue(input, null, $ref0, $ref2))
        {
            parsedValue = BlazorJs.Cast(output, NameValueWithParametersHeaderValue);
            return true;
        }
        return false;
    }
    /*int*/ static GetNameValueWithParametersLength(/*string*/ input, /*int*/ startIndex, /*out object*/ parsedValue)
    {
        let nameValue = null;
        let $ref1 = { set value(v){ nameValue = v } };
        Debug.Assert(input !== null);
        Debug.Assert(startIndex >= 0);
        parsedValue = null;
        if (string.IsNullOrEmpty(input) || (startIndex >= input.Length))
        {
            return 0;
        }
        /*int*/ let nameValueLength = NameValueHeaderValue.GetNameValueLength(input, startIndex, s_nameValueCreator, $ref1);
        if (nameValueLength === 0)
        {
            return 0;
        }
        /*int*/ let current = startIndex + nameValueLength;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        /*NameValueWithParametersHeaderValue*/ let nameValueWithParameters = BlazorJs.As(nameValue, NameValueWithParametersHeaderValue);
        Debug.Assert(nameValueWithParameters !== null);
        if ((current < input.Length) && (input[current] === ';'))
        {
            current++;
            /*int*/ let parameterLength = NameValueHeaderValue.GetNameValueListLength(input, current, ';', BlazorJs.Cast(nameValueWithParameters.Parameters, UnvalidatedObjectCollection(NameValueHeaderValue)));
            if (parameterLength === 0)
            {
                return 0;
            }
            parsedValue = nameValueWithParameters;
            return current + parameterLength - startIndex;
        }
        parsedValue = nameValueWithParameters;
        return current - startIndex;
    }
    /*NameValueHeaderValue*/ static CreateNameValue()
    {
        return new NameValueWithParametersHeaderValue();
    }
    /*object*/ Clone()
    {
        return new NameValueWithParametersHeaderValue(this);
    }
}

const System_Net_Http_Headers_UnvalidatedObjectCollection = (T) => class extends System_Net_Http_Headers_ObjectCollection(T)(T)
{
    constructor()
    {
        super();
    }
    /*void*/ Validate(/*T*/ item)
    {
        if (item === null)
        throw new ArgumentNullException(nameof(item));
    }
}
const System_Net_Http_Headers_ObjectCollection = (T) => class extends H5_IH5Class(System_Collections_IEnumerable(System_Collections_Generic_IEnumerable(T)(System_Collections_Generic_ICollection(T)(object))))
{
    /*int*/ DefaultSize = 4;
    /*object*/ _items = null;
    /*int*/ _size = null;
    constructor()
    {
        super();
    }
    /*int*/ get Count()
    {
        return _size;
    }
    /*bool*/ get IsReadOnly()
    {
        return false;
    }
    /*void*/ Add(/*T*/ item)
    {
        Validate(item);
        Debug.Assert(item !== null);
        if (_items)
        {
            _items = item;
            _size = 1;
        }
        else if (_items instanceof T, existingItem = _items)
        {
            Debug.Assert(_size === 1);
            /*T[]*/ let items = new Array(DefaultSize);
            items[0] = existingItem;
            items[1] = item;
            _items = items;
            _size = 2;
        }
        else 
        {
            /*T[]*/ let array = BlazorJs.Cast(_items, T);
            /*int*/ let size = _size;
            if (BlazorJs.Cast(size, uint) < BlazorJs.Cast(array.Length, uint))
            {
                array[size] = item;
            }
            else 
            {
                Debug.Assert(_size > 0);
                Debug.Assert(_size === array.Length);
                /*var*/ let newItems = new Array(array.Length  * 2);
                Array.Copy(array, newItems, size);
                _items = newItems;
                newItems[size] = item;
            }
            _size = size + 1;
        }
    }
    /*void*/ Clear()
    {
        _items = null;
        _size = 0;
    }
    /*bool*/ Contains(/*T*/ item)
    {
        return _size <= 0 ? false : _items instanceof T, o = _items ? o.Equals(item) : _items instanceof T, items = _items && Array.IndexOf(items, item, 0, _size) !== 1;
    }
    /*void*/ CopyTo(/*T[]*/ array, /*int*/ arrayIndex)
    {
        if (_items instanceof T, items = _items)
        {
            Array.Copy(items, 0, array, arrayIndex, _size);
        }
        else 
        {
            Debug.Assert(_size === 0 || _size === 1);
            if (array || _size > array.Length  - arrayIndex)
            {
                [ BlazorJs.Cast(_items, T) ].CopyTo(array, arrayIndex);
            }
            else if (_size === 1)
            {
                array[arrayIndex] = BlazorJs.Cast(_items, T);
            }
        }
    }
    /*bool*/ Remove(/*T*/ item)
    {
        if (_items instanceof T, o = _items)
        {
            if (o.Equals(item))
            {
                _items = null;
                _size = 0;
                return true;
            }
        }
        else if (_items instanceof T, items = _items)
        {
            /*int*/ let index = Array.IndexOf(items, item, 0, _size);
            if (index !== 1)
            {
                _size--;
                if (index < _size)
                {
                    Array.Copy(items, index + 1, items, index, _size - index);
                }
                items[_size] = null;
                return true;
            }
        }
        return false;
    }
    /*Enumerator*/ GetEnumerator()
    {
        return new Enumerator(this);
    }
    /*IEnumerator<T>*/ GetEnumerator()
    {
        return GetEnumerator();
    }
    /*IEnumerator*/ GetEnumerator()
    {
        return GetEnumerator();
    }
    static System_Net_Http_Headers_ObjectCollection_Enumerator = class extends System_Collections_IEnumerator(System_IDisposable(System_Collections_Generic_IEnumerator(T)(System_ValueType)))
    {
        /*ObjectCollection<T>*/ _list = null;
        /*int*/ _index = null;
        /*T*/ _current = null;
        constructor(/*ObjectCollection<T>*/ list)
        {
            super();
            _list = list;
            _index = 0;
            _current = BlazorJs.getDefault();
        }
        /*void*/ Dispose()
        {
        }
        /*bool*/ MoveNext()
        {
            /*ObjectCollection<T>*/ let list = _list;
            if (BlazorJs.Cast(_index, uint) < BlazorJs.Cast(list._size, uint))
            {
                _current = list._items  instanceof T ? items[_index] : BlazorJs.Cast(list._items, T);
                _index++;
                return true;
            }
            _index = _list._size  + 1;
            _current = BlazorJs.getDefault();
            return false;
        }
        /*T*/ get Current()
        {
            return _current;
        }
        /*object*/ get Current()
        {
            return _current;
        }
        /*void*/ Reset()
        {
            _index = 0;
            _current = BlazorJs.getDefault();
        }
    }
    static System_Net_Http_Headers_ObjectCollection_DebugView = class extends object
    {
        /*ObjectCollection<T>*/ _collection = null;
        constructor(/*ObjectCollection<T>*/ collection)
        {
            super();
            if (collection === null)
            throw new ArgumentNullException(nameof(collection));
            _collection = collection;
        }
        /*T[]*/ get Items()
        {
            /*T[]*/ let items = new Array(_collection.Count);
            _collection.CopyTo(items, 0);
            return items;
        }
    }
}

class System_Net_Http_Headers_ProductHeaderValue extends H5_IH5Class(System_ICloneable(object))
{
    /*string*/ _name = null;
    /*string*/ _version = null;
    /*string*/ get Name()
    {
        return _name;
    }
    /*string*/ get Version()
    {
        return _version;
    }
    constructor(/*string*/ name)
    {
        super(name, null);
    }
    constructor(/*string*/ name, /*string*/ version)
    {
        super();
        HeaderUtilities.CheckValidToken(name);
        if (string.IsNullOrEmpty(version))
        {
            HeaderUtilities.CheckValidToken(version);
            _version = version;
        }
        _name = name;
    }
    constructor(/*ProductHeaderValue*/ source)
    {
        super();
        Debug.Assert(source !== null);
        _name = source._name;
        _version = source._version;
    }
    /*string*/ ToString()
    {
        if (string.IsNullOrEmpty(_version))
        {
            return _name;
        }
        return _name + "/" + _version;
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        /*ProductHeaderValue*/ let other = BlazorJs.As(obj, ProductHeaderValue);
        if (other === null)
        {
            return false;
        }
        return string.Equals(_name, other._name, StringComparison.OrdinalIgnoreCase) && string.Equals(_version, other._version, StringComparison.OrdinalIgnoreCase);
    }
    /*int*/ GetHashCode()
    {
        /*int*/ let result = StringComparer.OrdinalIgnoreCase.GetHashCode(_name);
        if (string.IsNullOrEmpty(_version))
        {
            result ^= StringComparer.OrdinalIgnoreCase.GetHashCode(_version);
        }
        return result;
    }
    /*ProductHeaderValue*/ static Parse(/*string*/ input)
    {
        let $ref0 = { set value(v){ index = v } };
        /*int*/ let index = 0;
        return BlazorJs.Cast(GenericHeaderParser.SingleValueProductParser.ParseValue(input, null, $ref0), ProductHeaderValue);
    }
    /*bool*/ static TryParse(/*string*/ input, /*out ProductHeaderValue*/ parsedValue)
    {
        let $ref0 = { set value(v){ index = v } };
        let output = null;
        let $ref2 = { set value(v){ output = v } };
        /*int*/ let index = 0;
        parsedValue = null;
        if (GenericHeaderParser.SingleValueProductParser.TryParseValue(input, null, $ref0, $ref2))
        {
            parsedValue = BlazorJs.Cast(output, ProductHeaderValue);
            return true;
        }
        return false;
    }
    /*int*/ static GetProductLength(/*string*/ input, /*int*/ startIndex, /*out ProductHeaderValue*/ parsedValue)
    {
        Debug.Assert(startIndex >= 0);
        parsedValue = null;
        if (string.IsNullOrEmpty(input) || (startIndex >= input.Length))
        {
            return 0;
        }
        /*// Parse the name string: <name> in '<name>/<version>'.
            int*/ let nameLength = HttpRuleParser.GetTokenLength(input, startIndex);
        if (nameLength === 0)
        {
            return 0;
        }
        /*string*/ let name = input.Substring(startIndex, nameLength);
        /*int*/ let current = startIndex + nameLength;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        if ((current === input.Length) || (input[current] !== '/'))
        {
            parsedValue = new ProductHeaderValue(name);
            return current - startIndex;
        }
        current++;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        /*// Parse the name string: <version> in '<name>/<version>'.
            int*/ let versionLength = HttpRuleParser.GetTokenLength(input, current);
        if (versionLength === 0)
        {
            return 0;
        }
        /*string*/ let version = input.Substring(current, versionLength);
        current += versionLength;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        parsedValue = new ProductHeaderValue(name, version);
        return current - startIndex;
    }
    /*object*/ Clone()
    {
        return new ProductHeaderValue(this);
    }
}

class System_Net_Http_Headers_ProductInfoHeaderParser extends System_Net_Http_Headers_HttpHeaderParser
{
    /*string*/ separator = " ";
    /*ProductInfoHeaderParser*/ static SingleValueParser = new ProductInfoHeaderParser(false);
    /*ProductInfoHeaderParser*/ static MultipleValueParser = new ProductInfoHeaderParser(true);
    constructor(/*bool*/ supportsMultipleValues)
    {
        super(supportsMultipleValues, separator);
    }
    /*bool*/ TryParseValue(/*string*/ value, /*object*/ storeValue, /*ref int*/ index, /*out object*/ parsedValue)
    {
        let result = null;
        let $ref1 = { set value(v){ result = v } };
        parsedValue = null;
        if (string.IsNullOrEmpty(value) || (index === value.Length))
        {
            return false;
        }
        /*// Skip leading whitespace
            int*/ let current = index + HttpRuleParser.GetWhitespaceLength(value, index);
        if (current === value.Length)
        {
            return false;
        }
        /*int*/ let length = ProductInfoHeaderValue.GetProductInfoLength(value, current, $ref1);
        if (length === 0)
        {
            return false;
        }
        current += length;
        if (current < value.Length)
        {
            /*// Note that for \r\n to be a valid whitespace, it must be followed by a space/tab. I.e. it's enough if
                // we check whether the char before the next value is space/tab.
                char*/ let lastSeparatorChar = value[current - 1];
            if ((lastSeparatorChar !== ' ') && (lastSeparatorChar !== '\t'))
            {
                return false;
            }
        }
        index = current;
        parsedValue = result;
        return true;
    }
}

class System_Net_Http_Headers_ProductInfoHeaderValue extends H5_IH5Class(System_ICloneable(object))
{
    /*ProductHeaderValue*/ _product = null;
    /*string*/ _comment = null;
    /*ProductHeaderValue*/ get Product()
    {
        return _product;
    }
    /*string*/ get Comment()
    {
        return _comment;
    }
    constructor(/*string*/ productName, /*string*/ productVersion)
    {
        super(new ProductHeaderValue(productName, productVersion));
    }
    constructor(/*ProductHeaderValue*/ product)
    {
        super();
        if (product === null)
        throw new ArgumentNullException(nameof(product));
        _product = product;
    }
    constructor(/*string*/ comment)
    {
        super();
        HeaderUtilities.CheckValidComment(comment);
        _comment = comment;
    }
    constructor(/*ProductInfoHeaderValue*/ source)
    {
        super();
        Debug.Assert(source !== null);
        _product = source._product;
        _comment = source._comment;
    }
    /*string*/ ToString()
    {
        if (_product === null)
        {
            Debug.Assert(_comment !== null);
            return _comment;
        }
        return _product.ToString();
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        /*ProductInfoHeaderValue*/ let other = BlazorJs.As(obj, ProductInfoHeaderValue);
        if (other === null)
        {
            return false;
        }
        if (_product === null)
        {
            return string.Equals(_comment, other._comment, StringComparison.Ordinal);
        }
        return _product.Equals(other._product);
    }
    /*int*/ GetHashCode()
    {
        if (_product === null)
        {
            Debug.Assert(_comment !== null);
            return _comment.GetHashCode();
        }
        return _product.GetHashCode();
    }
    /*ProductInfoHeaderValue*/ static Parse(/*string*/ input)
    {
        let $ref0 = { set value(v){ index = v } };
        /*int*/ let index = 0;
        /*object*/ let result = ProductInfoHeaderParser.SingleValueParser.ParseValue(input, null, $ref0);
        if (index < input.Length)
        {
            throw new FormatException("net_http_headers_invalid_value");
        }
        return BlazorJs.Cast(result, ProductInfoHeaderValue);
    }
    /*bool*/ static TryParse(/*string*/ input, /*out ProductInfoHeaderValue*/ parsedValue)
    {
        let $ref0 = { set value(v){ index = v } };
        let output = null;
        let $ref2 = { set value(v){ output = v } };
        /*int*/ let index = 0;
        parsedValue = null;
        if (ProductInfoHeaderParser.SingleValueParser.TryParseValue(input, null, $ref0, $ref2))
        {
            if (index < input.Length)
            {
                return false;
            }
            parsedValue = BlazorJs.Cast(output, ProductInfoHeaderValue);
            return true;
        }
        return false;
    }
    /*int*/ static GetProductInfoLength(/*string*/ input, /*int*/ startIndex, /*out ProductInfoHeaderValue*/ parsedValue)
    {
        Debug.Assert(startIndex >= 0);
        parsedValue = null;
        if (string.IsNullOrEmpty(input) || (startIndex >= input.Length))
        {
            return 0;
        }
        /*int*/ let current = startIndex;
        /*// Caller must remove leading whitespace.
            string*/ let comment;
        /*ProductHeaderValue*/ let product;
        if (input[current] === '(')
        {
            let $ref0 = { set value(v){ commentLength = v } };
            /*int*/ let commentLength;
            if (HttpRuleParser.GetCommentLength(input, current, $ref0) !== HttpParseResult.Parsed)
            {
                return 0;
            }
            comment = input.Substring(current, commentLength);
            current += commentLength;
            current += HttpRuleParser.GetWhitespaceLength(input, current);
            parsedValue = new ProductInfoHeaderValue(comment);
        }
        else 
        {
            let $ref0 = { set value(v){ product = v } };
            /*// Trailing whitespace is removed by GetProductLength().
                int*/ let productLength = ProductHeaderValue.GetProductLength(input, current, $ref0);
            if (productLength === 0)
            {
                return 0;
            }
            current += productLength;
            parsedValue = new ProductInfoHeaderValue(product);
        }
        return current - startIndex;
    }
    /*object*/ Clone()
    {
        return new ProductInfoHeaderValue(this);
    }
}

static class System_Net_Http_Headers_QPackStaticTable
{
    /*(HeaderDescriptor descriptor, string value)[]*/ _backingField_HeaderLookup = null;
    /*(HeaderDescriptor descriptor, string value)[]*/ static get HeaderLookup()
    {
        return _backingField_HeaderLookup;
    }
}

class System_Net_Http_Headers_RangeConditionHeaderValue extends H5_IH5Class(System_ICloneable(object))
{
    /*DateTimeOffset*/ _date = null;
    /*EntityTagHeaderValue*/ _entityTag = null;
    /*DateTimeOffset?*/ get Date()
    {
        return _entityTag ? _date : BlazorJs.Cast(null, DateTimeOffset);
    }
    /*EntityTagHeaderValue*/ get EntityTag()
    {
        return _entityTag;
    }
    constructor(/*DateTimeOffset*/ date)
    {
        super();
        _date = date;
    }
    constructor(/*EntityTagHeaderValue*/ entityTag)
    {
        super();
        if (entityTag === null)
        throw new ArgumentNullException(nameof(entityTag));
        _entityTag = entityTag;
    }
    constructor(/*string*/ entityTag)
    {
        super(new EntityTagHeaderValue(entityTag));
    }
    constructor(/*RangeConditionHeaderValue*/ source)
    {
        super();
        Debug.Assert(source !== null);
        _entityTag = source._entityTag;
        _date = source._date;
    }
    /*string*/ ToString()
    {
        return _entityTag?.ToString() ?? _date.ToString("r");
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        return obj instanceof RangeConditionHeaderValue, other = obj && (_entityTag ? other._entityTag  : _entityTag.Equals(other._entityTag)) && _date === other._date;
    }
    /*int*/ GetHashCode()
    {
        return _entityTag?.GetHashCode() ?? _date.GetHashCode();
    }
    /*RangeConditionHeaderValue*/ static Parse(/*string*/ input)
    {
        let $ref0 = { set value(v){ index = v } };
        /*int*/ let index = 0;
        return BlazorJs.Cast(GenericHeaderParser.RangeConditionParser.ParseValue(input, null, $ref0), RangeConditionHeaderValue);
    }
    /*bool*/ static TryParse(/*string*/ input, /*out RangeConditionHeaderValue*/ parsedValue)
    {
        let $ref0 = { set value(v){ index = v } };
        let output = null;
        let $ref2 = { set value(v){ output = v } };
        /*int*/ let index = 0;
        parsedValue = null;
        if (GenericHeaderParser.RangeConditionParser.TryParseValue(input, null, $ref0, $ref2))
        {
            parsedValue = BlazorJs.Cast(output, RangeConditionHeaderValue);
            return true;
        }
        return false;
    }
    /*int*/ static GetRangeConditionLength(/*string*/ input, /*int*/ startIndex, /*out object*/ parsedValue)
    {
        Debug.Assert(startIndex >= 0);
        parsedValue = null;
        if (string.IsNullOrEmpty(input) || (startIndex + 1 >= input.Length))
        {
            return 0;
        }
        /*int*/ let current = startIndex;
        /*// Caller must remove leading whitespace.
            DateTimeOffset*/ let date = DateTimeOffset.MinValue;
        /*EntityTagHeaderValue*/ let entityTag = null;
        /*// Entity tags are quoted strings optionally preceded by "W/". By looking at the first two character we
            // can determine whether the string is en entity tag or a date.
            char*/ let firstChar = input[current];
        /*char*/ let secondChar = input[current + 1];
        if ((firstChar === '\"') || (((firstChar === 'w') || (firstChar === 'W')) && (secondChar === '/')))
        {
            let $ref0 = { set value(v){ entityTag = v } };
            /*// trailing whitespace is removed by GetEntityTagLength()
                int*/ let entityTagLength = EntityTagHeaderValue.GetEntityTagLength(input, current, $ref0);
            if (entityTagLength === 0)
            {
                return 0;
            }
            current += entityTagLength;
            if (current !== input.Length)
            {
                return 0;
            }
        }
        else 
        {
            let $ref0 = { set value(v){ date = v } };
            if (DateTimeOffset.TryParse(input.AsSpan(current), $ref0))
            {
                return 0;
            }
            current = input.Length;
        }
        if (entityTag === null)
        {
            parsedValue = new RangeConditionHeaderValue(date);
        }
        else 
        {
            parsedValue = new RangeConditionHeaderValue(entityTag);
        }
        return current - startIndex;
    }
    /*object*/ Clone()
    {
        return new RangeConditionHeaderValue(this);
    }
}

class System_Net_Http_Headers_RangeHeaderValue extends H5_IH5Class(System_ICloneable(object))
{
    /*string*/ _unit = null;
    /*UnvalidatedObjectCollection<RangeItemHeaderValue>*/ _ranges = null;
    /*string*/ get Unit()
    {
        return _unit;
    }
    /*string*/ set Unit(value)
    {
        HeaderUtilities.CheckValidToken(value);
        _unit = value;
    }
    /*ICollection<RangeItemHeaderValue>*/ get Ranges()
    {
        return _ranges = _ranges ?? new UnvalidatedObjectCollection(RangeItemHeaderValue)();
    }
    constructor()
    {
        super();
        _unit = HeaderUtilities.BytesUnit;
    }
    constructor(/*long*/ from, /*long*/ to)
    {
        super();
        _unit = HeaderUtilities.BytesUnit;
        Ranges.Add(new RangeItemHeaderValue(from, to));
    }
    constructor(/*RangeHeaderValue*/ source)
    {
        super();
        Debug.Assert(source !== null);
        _unit = source._unit;
        if (source._ranges  !== null)
        {
            BlazorJs.forEach(source._ranges, function(range, $_i)
            {
                this.Ranges.Add(new RangeItemHeaderValue(range));
            });
        }
    }
    /*string*/ ToString()
    {
        /*var*/ let sb = new StringBuilder(256);
        sb.Append(_unit);
        sb.Append('=');
        if (_ranges !== null)
        {
            /*bool*/ let first = true;
            BlazorJs.forEach(_ranges, function(range, $_i)
            {
                if (first)
                {
                    first = false;
                }
                else 
                {
                    sb.Append(", ");
                }
                if (range.From.HasValue)
                sb.Append(range.From.GetValueOrDefault());
                sb.Append('-');
                if (range.To.HasValue)
                sb.Append(range.To.GetValueOrDefault());
            });
        }
        return sb.ToString();
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        /*RangeHeaderValue*/ let other = BlazorJs.As(obj, RangeHeaderValue);
        if (other === null)
        {
            return false;
        }
        return string.Equals(_unit, other._unit, StringComparison.OrdinalIgnoreCase) && HeaderUtilities.AreEqualCollections(_ranges, other._ranges);
    }
    /*int*/ GetHashCode()
    {
        /*int*/ let result = StringComparer.OrdinalIgnoreCase.GetHashCode(_unit);
        if (_ranges !== null)
        {
            BlazorJs.forEach(_ranges, function(range, $_i)
            {
                result ^= range.GetHashCode();
            });
        }
        return result;
    }
    /*RangeHeaderValue*/ static Parse(/*string*/ input)
    {
        let $ref0 = { set value(v){ index = v } };
        /*int*/ let index = 0;
        return BlazorJs.Cast(GenericHeaderParser.RangeParser.ParseValue(input, null, $ref0), RangeHeaderValue);
    }
    /*bool*/ static TryParse(/*string*/ input, /*out RangeHeaderValue*/ parsedValue)
    {
        let $ref0 = { set value(v){ index = v } };
        let output = null;
        let $ref2 = { set value(v){ output = v } };
        /*int*/ let index = 0;
        parsedValue = null;
        if (GenericHeaderParser.RangeParser.TryParseValue(input, null, $ref0, $ref2))
        {
            parsedValue = BlazorJs.Cast(output, RangeHeaderValue);
            return true;
        }
        return false;
    }
    /*int*/ static GetRangeLength(/*string*/ input, /*int*/ startIndex, /*out object*/ parsedValue)
    {
        Debug.Assert(startIndex >= 0);
        parsedValue = null;
        if (string.IsNullOrEmpty(input) || (startIndex >= input.Length))
        {
            return 0;
        }
        /*// Parse the unit string: <unit> in '<unit>=<from1>-<to1>, <from2>-<to2>'
            int*/ let unitLength = HttpRuleParser.GetTokenLength(input, startIndex);
        if (unitLength === 0)
        {
            return 0;
        }
        /*RangeHeaderValue*/ let result = new RangeHeaderValue();
        result._unit  = input.Substring(startIndex, unitLength);
        /*int*/ let current = startIndex + unitLength;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        if ((current === input.Length) || (input[current] !== '='))
        {
            return 0;
        }
        current++;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        /*int*/ let rangesLength = RangeItemHeaderValue.GetRangeItemListLength(input, current, result.Ranges);
        if (rangesLength === 0)
        {
            return 0;
        }
        current += rangesLength;
        Debug.Assert(current === input.Length, "GetRangeItemListLength() should consume the whole string or fail.");
        parsedValue = result;
        return current - startIndex;
    }
    /*object*/ Clone()
    {
        return new RangeHeaderValue(this);
    }
}

class System_Net_Http_Headers_RangeItemHeaderValue extends H5_IH5Class(System_ICloneable(object))
{
    /*long*/ _from = null;
    /*long*/ _to = null;
    /*long?*/ get From()
    {
        return _from >= 0 ? _from : BlazorJs.Cast(null, long);
    }
    /*long?*/ get To()
    {
        return _to >= 0 ? _to : BlazorJs.Cast(null, long);
    }
    constructor(/*long?*/ from, /*long?*/ to)
    {
        super();
        if (from.HasValue  && to.HasValue)
        {
            throw new ArgumentException("net_http_headers_invalid_range");
        }
        if (from.HasValue)
        {
            throw new ArgumentOutOfRangeException(nameof(from));
        }
        if (to.HasValue)
        {
            throw new ArgumentOutOfRangeException(nameof(to));
        }
        if (from.HasValue  && to.HasValue  && from.Value  > to.Value)
        {
            throw new ArgumentOutOfRangeException(nameof(from));
        }
        _from = from ?? 1;
        _to = to ?? 1;
    }
    constructor(/*RangeItemHeaderValue*/ source)
    {
        super();
        Debug.Assert(source !== null);
        _from = source._from;
        _to = source._to;
    }
    /*string*/ ToString()
    {
        /*Span<char>*/ let stackBuffer = new Span(char)(128);
        if (_from < 0)
        {
            return `-${_to}`;
        }
        if (_to < 0)
        {
            return `${_from}-`;
        }
        return `${_from}-${_to}`;
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        return obj instanceof RangeItemHeaderValue, other = obj && _from === other._from  && _to === other._to;
    }
    /*int*/ GetHashCode()
    {
        return HashCode.Combine(_from, _to);
    }
    /*int*/ static GetRangeItemListLength(/*string*/ input, /*int*/ startIndex, /*ICollection<RangeItemHeaderValue>*/ rangeCollection)
    {
        let $ref0 = { set value(v){ _ = v } };
        Debug.Assert(rangeCollection !== null);
        Debug.Assert(startIndex >= 0);
        if ((string.IsNullOrEmpty(input)) || (startIndex >= input.Length))
        {
            return 0;
        }
        /*// Empty segments are allowed, so skip all delimiter-only segments (e.g. ", ,").
            int*/ let current = HeaderUtilities.GetNextNonEmptyOrWhitespaceIndex(input, startIndex, true, $ref0);
        if (current === input.Length)
        {
            return 0;
        }
        while(true)
        {
            let range = null;
            let $ref1 = { set value(v){ range = v } };
            let separatorFound = null;
            let $ref3 = { set value(v){ separatorFound = v } };
            /*int*/ let rangeLength = GetRangeItemLength(input, current, $ref1);
            if (rangeLength === 0)
            {
                return 0;
            }
            rangeCollection.Add(range);
            current += rangeLength;
            current = HeaderUtilities.GetNextNonEmptyOrWhitespaceIndex(input, current, true, $ref3);
            if ((current < input.Length) && separatorFound)
            {
                return 0;
            }
            if (current === input.Length)
            {
                return current - startIndex;
            }
        }
    }
    /*int*/ static GetRangeItemLength(/*string*/ input, /*int*/ startIndex, /*out RangeItemHeaderValue*/ parsedValue)
    {
        let $ref0 = { set value(v){ from = v } };
        let $ref1 = { set value(v){ to = v } };
        Debug.Assert(startIndex >= 0);
        parsedValue = null;
        if (string.IsNullOrEmpty(input) || (startIndex >= input.Length))
        {
            return 0;
        }
        /*// Caller must remove leading whitespace. If not, we'll return 0.
            int*/ let current = startIndex;
        /*// Try parse the first value of a value pair.
            int*/ let fromStartIndex = current;
        /*int*/ let fromLength = HttpRuleParser.GetNumberLength(input, current, false);
        if (fromLength > HttpRuleParser.MaxInt64Digits)
        {
            return 0;
        }
        current += fromLength;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        if ((current === input.Length) || (input[current] !== '-'))
        {
            return 0;
        }
        current++;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        /*int*/ let toStartIndex = current;
        /*int*/ let toLength = 0;
        if (current < input.Length)
        {
            toLength = HttpRuleParser.GetNumberLength(input, current, false);
            if (toLength > HttpRuleParser.MaxInt64Digits)
            {
                return 0;
            }
            current += toLength;
            current += HttpRuleParser.GetWhitespaceLength(input, current);
        }
        if ((fromLength === 0) && (toLength === 0))
        {
            return 0;
        }
        /*// Try convert first value to int64
            long*/ let from = 0;
        if ((fromLength > 0) && HeaderUtilities.TryParseInt64(input, fromStartIndex, fromLength, $ref0))
        {
            return 0;
        }
        /*// Try convert second value to int64
            long*/ let to = 0;
        if ((toLength > 0) && HeaderUtilities.TryParseInt64(input, toStartIndex, toLength, $ref1))
        {
            return 0;
        }
        if ((fromLength > 0) && (toLength > 0) && (from > to))
        {
            return 0;
        }
        parsedValue = new RangeItemHeaderValue((fromLength === 0 ? BlazorJs.Cast(null, long) : from), (toLength === 0 ? BlazorJs.Cast(null, long) : to));
        return current - startIndex;
    }
    /*object*/ Clone()
    {
        return new RangeItemHeaderValue(this);
    }
}

class System_Net_Http_Headers_RetryConditionHeaderValue extends H5_IH5Class(System_ICloneable(object))
{
    /*long*/ DeltaNotSetTicksSentinel = long.MaxValue;
    /*DateTimeOffset*/ _date = null;
    /*TimeSpan*/ _delta = null;
    /*DateTimeOffset?*/ get Date()
    {
        return _delta.Ticks  === DeltaNotSetTicksSentinel ? _date : BlazorJs.Cast(null, DateTimeOffset);
    }
    /*TimeSpan?*/ get Delta()
    {
        return _delta.Ticks  === DeltaNotSetTicksSentinel ? BlazorJs.Cast(null, TimeSpan) : _delta;
    }
    constructor(/*DateTimeOffset*/ date)
    {
        super();
        _date = date;
        _delta = new TimeSpan(DeltaNotSetTicksSentinel);
    }
    constructor(/*TimeSpan*/ delta)
    {
        super();
        if (delta.TotalSeconds > int.MaxValue)
        throw new ArgumentOutOfRangeException();
        _delta = delta;
    }
    constructor(/*RetryConditionHeaderValue*/ source)
    {
        super();
        Debug.Assert(source !== null);
        _delta = source._delta;
        _date = source._date;
    }
    /*string*/ ToString()
    {
        return _delta.Ticks  !== DeltaNotSetTicksSentinel ? (BlazorJs.Cast(_delta.TotalSeconds, int)).ToString() : _date.ToString("r");
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        return obj instanceof RetryConditionHeaderValue, other = obj && _delta === other._delta  && _date === other._date;
    }
    /*int*/ GetHashCode()
    {
        return HashCode.Combine(_delta, _date);
    }
    /*RetryConditionHeaderValue*/ static Parse(/*string*/ input)
    {
        let $ref0 = { set value(v){ index = v } };
        /*int*/ let index = 0;
        return BlazorJs.Cast(GenericHeaderParser.RetryConditionParser.ParseValue(input, null, $ref0), RetryConditionHeaderValue);
    }
    /*bool*/ static TryParse(/*string*/ input, /*out RetryConditionHeaderValue*/ parsedValue)
    {
        let $ref0 = { set value(v){ index = v } };
        let output = null;
        let $ref2 = { set value(v){ output = v } };
        /*int*/ let index = 0;
        parsedValue = null;
        if (GenericHeaderParser.RetryConditionParser.TryParseValue(input, null, $ref0, $ref2))
        {
            parsedValue = BlazorJs.Cast(output, RetryConditionHeaderValue);
            return true;
        }
        return false;
    }
    /*int*/ static GetRetryConditionLength(/*string*/ input, /*int*/ startIndex, /*out object*/ parsedValue)
    {
        Debug.Assert(startIndex >= 0);
        parsedValue = null;
        if (string.IsNullOrEmpty(input) || (startIndex >= input.Length))
        {
            return 0;
        }
        /*int*/ let current = startIndex;
        /*// Caller must remove leading whitespace.
            DateTimeOffset*/ let date = DateTimeOffset.MinValue;
        /*int*/ let deltaSeconds = 1;
        /*// We either have a timespan or a date/time value. Determine which one we have by looking at the first char.
            // If it is a number, we have a timespan, otherwise we assume we have a date.
            char*/ let firstChar = input[current];
        if (char.IsDigit(firstChar))
        {
            let $ref0 = { set value(v){ deltaSeconds = v } };
            /*int*/ let deltaStartIndex = current;
            /*int*/ let deltaLength = HttpRuleParser.GetNumberLength(input, current, false);
            if ((deltaLength === 0) || (deltaLength > HttpRuleParser.MaxInt32Digits))
            {
                return 0;
            }
            current += deltaLength;
            current += HttpRuleParser.GetWhitespaceLength(input, current);
            if (current !== input.Length)
            {
                return 0;
            }
            if (HeaderUtilities.TryParseInt32(input, deltaStartIndex, deltaLength, $ref0))
            {
                return 0;
            }
        }
        else 
        {
            let $ref0 = { set value(v){ date = v } };
            if (DateTimeOffset.TryParse(input.AsSpan(current), $ref0))
            {
                return 0;
            }
            current = input.Length;
        }
        if (deltaSeconds === 1)
        {
            parsedValue = new RetryConditionHeaderValue(date);
        }
        else 
        {
            parsedValue = new RetryConditionHeaderValue(new TimeSpan(0, 0, deltaSeconds));
        }
        return current - startIndex;
    }
    /*object*/ Clone()
    {
        return new RetryConditionHeaderValue(this);
    }
}

class System_Net_Http_Headers_StringWithQualityHeaderValue extends H5_IH5Class(System_ICloneable(object))
{
    /*double*/ NotSetSentinel = double.PositiveInfinity;
    /*string*/ _value = null;
    /*double*/ _quality = null;
    /*string*/ get Value()
    {
        return _value;
    }
    /*double?*/ get Quality()
    {
        return _quality === NotSetSentinel ? BlazorJs.Cast(null, double) : _quality;
    }
    constructor(/*string*/ value)
    {
        super();
        HeaderUtilities.CheckValidToken(value);
        _value = value;
        _quality = NotSetSentinel;
    }
    constructor(/*string*/ value, /*double*/ quality)
    {
        super();
        HeaderUtilities.CheckValidToken(value);
        if (quality < 0)
        throw new ArgumentOutOfRangeException(nameof(quality));
        if (quality > 1.0)
        throw new ArgumentOutOfRangeException(nameof(quality));
        _value = value;
        _quality = quality;
    }
    constructor(/*StringWithQualityHeaderValue*/ source)
    {
        super();
        Debug.Assert(source !== null);
        _value = source._value;
        _quality = source._quality;
    }
    /*string*/ ToString()
    {
        return _quality === NotSetSentinel ? _value : `${_value}; q=${_quality}`;
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        return obj instanceof StringWithQualityHeaderValue, other = obj && string.Equals(_value, other._value, StringComparison.OrdinalIgnoreCase) && _quality === other._quality;
    }
    /*int*/ GetHashCode()
    {
        return HashCode.Combine(StringComparer.OrdinalIgnoreCase.GetHashCode(_value), _quality);
    }
    /*StringWithQualityHeaderValue*/ static Parse(/*string*/ input)
    {
        let $ref0 = { set value(v){ index = v } };
        /*int*/ let index = 0;
        return BlazorJs.Cast(GenericHeaderParser.SingleValueStringWithQualityParser.ParseValue(input, null, $ref0), StringWithQualityHeaderValue);
    }
    /*bool*/ static TryParse(/*string*/ input, /*out StringWithQualityHeaderValue*/ parsedValue)
    {
        let $ref0 = { set value(v){ index = v } };
        let output = null;
        let $ref2 = { set value(v){ output = v } };
        /*int*/ let index = 0;
        parsedValue = null;
        if (GenericHeaderParser.SingleValueStringWithQualityParser.TryParseValue(input, null, $ref0, $ref2))
        {
            parsedValue = BlazorJs.Cast(output, StringWithQualityHeaderValue);
            return true;
        }
        return false;
    }
    /*int*/ static GetStringWithQualityLength(/*string*/ input, /*int*/ startIndex, /*out object*/ parsedValue)
    {
        let quality = null;
        let $ref1 = { set value(v){ quality = v } };
        let $ref2 = { set value(v){ current = v } };
        Debug.Assert(startIndex >= 0);
        parsedValue = null;
        if (string.IsNullOrEmpty(input) || (startIndex >= input.Length))
        {
            return 0;
        }
        /*// Parse the value string: <value> in '<value>; q=<quality>'
            int*/ let valueLength = HttpRuleParser.GetTokenLength(input, startIndex);
        if (valueLength === 0)
        {
            return 0;
        }
        /*string*/ let value = input.Substring(startIndex, valueLength);
        /*int*/ let current = startIndex + valueLength;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        if ((current === input.Length) || (input[current] !== ';'))
        {
            parsedValue = new StringWithQualityHeaderValue(value);
            return current - startIndex;
        }
        current++;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        if (TryReadQuality(input, $ref1, $ref2))
        {
            return 0;
        }
        parsedValue = new StringWithQualityHeaderValue(value, quality);
        return current - startIndex;
    }
    /*bool*/ static TryReadQuality(/*string*/ input, /*out double*/ quality, /*ref int*/ index)
    {
        let $ref0 = { set value(v){ quality = v } };
        /*int*/ let current = index;
        quality = BlazorJs.getDefault();
        if ((current === input.Length) || ((input[current] !== 'q') && (input[current] !== 'Q')))
        {
            return false;
        }
        current++;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        if ((current === input.Length) || (input[current] !== '='))
        {
            return false;
        }
        current++;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        if (current === input.Length)
        {
            return false;
        }
        /*int*/ let qualityLength = HttpRuleParser.GetNumberLength(input, current, true);
        if (qualityLength === 0)
        {
            return false;
        }
        if (double.TryParse(input.AsSpan(current, qualityLength), $ref0))
        {
            return false;
        }
        if ((quality < 0) || (quality > 1))
        {
            return false;
        }
        current += qualityLength;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        index = current;
        return true;
    }
    /*object*/ Clone()
    {
        return new StringWithQualityHeaderValue(this);
    }
}

class System_Net_Http_Headers_TimeSpanHeaderParser extends System_Net_Http_Headers_BaseHeaderParser
{
    /*TimeSpanHeaderParser*/ static Parser = new TimeSpanHeaderParser();
    constructor()
    {
        super(false);
    }
    /*string*/ ToString(/*object*/ value)
    {
        Debug.Assert(value instanceof TimeSpan);
        return (BlazorJs.Cast((BlazorJs.Cast(value, TimeSpan)).TotalSeconds, int)).ToString();
    }
    /*int*/ GetParsedValueLength(/*string*/ value, /*int*/ startIndex, /*object*/ storeValue, /*out object*/ parsedValue)
    {
        let $ref0 = { set value(v){ result = v } };
        parsedValue = null;
        /*int*/ let numberLength = HttpRuleParser.GetNumberLength(value, startIndex, false);
        if ((numberLength === 0) || (numberLength > HttpRuleParser.MaxInt32Digits))
        {
            return 0;
        }
        /*int*/ let result;
        if (HeaderUtilities.TryParseInt32(value, startIndex, numberLength, $ref0))
        {
            return 0;
        }
        parsedValue = new TimeSpan(0, 0, result);
        return numberLength;
    }
}

class System_Net_Http_Headers_TransferCodingHeaderParser extends System_Net_Http_Headers_BaseHeaderParser
{
    /*Func<TransferCodingHeaderValue>*/ _transferCodingCreator = null;
    /*TransferCodingHeaderParser*/ static SingleValueParser = new TransferCodingHeaderParser(false, CreateTransferCoding);
    /*TransferCodingHeaderParser*/ static MultipleValueParser = new TransferCodingHeaderParser(true, CreateTransferCoding);
    /*TransferCodingHeaderParser*/ static SingleValueWithQualityParser = new TransferCodingHeaderParser(false, CreateTransferCodingWithQuality);
    /*TransferCodingHeaderParser*/ static MultipleValueWithQualityParser = new TransferCodingHeaderParser(true, CreateTransferCodingWithQuality);
    constructor(/*bool*/ supportsMultipleValues, /*Func<TransferCodingHeaderValue>*/ transferCodingCreator)
    {
        super(supportsMultipleValues);
        Debug.Assert(transferCodingCreator !== null);
        _transferCodingCreator = transferCodingCreator;
    }
    /*int*/ GetParsedValueLength(/*string*/ value, /*int*/ startIndex, /*object*/ storeValue, /*out object*/ parsedValue)
    {
        let temp = null;
        let $ref1 = { set value(v){ temp = v } };
        /*int*/ let resultLength = TransferCodingHeaderValue.GetTransferCodingLength(value, startIndex, _transferCodingCreator, $ref1);
        parsedValue = temp;
        return resultLength;
    }
    /*TransferCodingHeaderValue*/ static CreateTransferCoding()
    {
        return new TransferCodingHeaderValue();
    }
    /*TransferCodingWithQualityHeaderValue*/ static CreateTransferCodingWithQuality()
    {
        return new TransferCodingWithQualityHeaderValue();
    }
}

class System_Net_Http_Headers_TransferCodingHeaderValue extends H5_IH5Class(System_ICloneable(object))
{
    /*UnvalidatedObjectCollection<NameValueHeaderValue>*/ _parameters = null;
    /*string*/ _value = null;
    /*string*/ get Value()
    {
        return _value;
    }
    /*ICollection<NameValueHeaderValue>*/ get Parameters()
    {
        return _parameters = _parameters = _parameters ?? new UnvalidatedObjectCollection(NameValueHeaderValue)();
    }
    constructor()
    {
        super();
    }
    constructor(/*TransferCodingHeaderValue*/ source)
    {
        super();
        Debug.Assert(source !== null);
        _value = source._value;
        _parameters = source._parameters.Clone();
    }
    constructor(/*string*/ value)
    {
        super();
        HeaderUtilities.CheckValidToken(value);
        _value = value;
    }
    /*TransferCodingHeaderValue*/ static Parse(/*string*/ input)
    {
        let $ref0 = { set value(v){ index = v } };
        /*int*/ let index = 0;
        return BlazorJs.Cast(TransferCodingHeaderParser.SingleValueParser.ParseValue(input, null, $ref0), TransferCodingHeaderValue);
    }
    /*bool*/ static TryParse(/*string*/ input, /*out TransferCodingHeaderValue*/ parsedValue)
    {
        let $ref0 = { set value(v){ index = v } };
        let output = null;
        let $ref2 = { set value(v){ output = v } };
        /*int*/ let index = 0;
        parsedValue = null;
        if (TransferCodingHeaderParser.SingleValueParser.TryParseValue(input, null, $ref0, $ref2))
        {
            parsedValue = BlazorJs.Cast(output, TransferCodingHeaderValue);
            return true;
        }
        return false;
    }
    /*int*/ static GetTransferCodingLength(/*string*/ input, /*int*/ startIndex, /*Func<TransferCodingHeaderValue>*/ transferCodingCreator, /*out TransferCodingHeaderValue*/ parsedValue)
    {
        Debug.Assert(transferCodingCreator !== null);
        Debug.Assert(startIndex >= 0);
        parsedValue = null;
        if (string.IsNullOrEmpty(input) || (startIndex >= input.Length))
        {
            return 0;
        }
        /*// Caller must remove leading whitespace. If not, we'll return 0.
            int*/ let valueLength = HttpRuleParser.GetTokenLength(input, startIndex);
        if (valueLength === 0)
        {
            return 0;
        }
        /*string*/ let value = input.Substring(startIndex, valueLength);
        /*int*/ let current = startIndex + valueLength;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        /*TransferCodingHeaderValue*/ let transferCodingHeader;
        if ((current < input.Length) && (input[current] === ';'))
        {
            transferCodingHeader = transferCodingCreator();
            transferCodingHeader._value  = value;
            current++;
            /*int*/ let parameterLength = NameValueHeaderValue.GetNameValueListLength(input, current, ';', BlazorJs.Cast(transferCodingHeader.Parameters, UnvalidatedObjectCollection(NameValueHeaderValue)));
            if (parameterLength === 0)
            {
                return 0;
            }
            parsedValue = transferCodingHeader;
            return current + parameterLength - startIndex;
        }
        transferCodingHeader = transferCodingCreator();
        transferCodingHeader._value  = value;
        parsedValue = transferCodingHeader;
        return current - startIndex;
    }
    /*string*/ ToString()
    {
        /*StringBuilder*/ let sb = new StringBuilder();
        sb.Append(_value);
        NameValueHeaderValue.ToString(_parameters, ';', true, sb);
        return sb.ToString();
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        /*TransferCodingHeaderValue*/ let other = BlazorJs.As(obj, TransferCodingHeaderValue);
        if (other === null)
        {
            return false;
        }
        return string.Equals(_value, other._value, StringComparison.OrdinalIgnoreCase) && HeaderUtilities.AreEqualCollections(_parameters, other._parameters);
    }
    /*int*/ GetHashCode()
    {
        return StringComparer.OrdinalIgnoreCase.GetHashCode(_value) ^ NameValueHeaderValue.GetHashCode(_parameters);
    }
    /*// Implement ICloneable explicitly to allow derived types to "override" the implementation.
        object*/ Clone()
    {
        return new TransferCodingHeaderValue(this);
    }
}

class System_Net_Http_Headers_TransferCodingWithQualityHeaderValue extends H5_IH5Class(System_ICloneable(System_Net_Http_Headers_TransferCodingHeaderValue))
{
    /*double?*/ get Quality()
    {
        return HeaderUtilities.GetQuality(BlazorJs.Cast(Parameters, UnvalidatedObjectCollection(NameValueHeaderValue)));
    }
    /*double?*/ set Quality(value)
    {
        HeaderUtilities.SetQuality(BlazorJs.Cast(Parameters, UnvalidatedObjectCollection(NameValueHeaderValue)), value);
    }
    constructor()
    {
        super();
    }
    constructor(/*string*/ value)
    {
        super(value);
    }
    constructor(/*string*/ value, /*double*/ quality)
    {
        super(value);
        Quality = quality;
    }
    constructor(/*TransferCodingWithQualityHeaderValue*/ source)
    {
        super(source);
    }
    /*object*/ Clone()
    {
        return new TransferCodingWithQualityHeaderValue(this);
    }
    /*TransferCodingWithQualityHeaderValue*/ static Parse(/*string*/ input)
    {
        let $ref0 = { set value(v){ index = v } };
        /*int*/ let index = 0;
        return BlazorJs.Cast(TransferCodingHeaderParser.SingleValueWithQualityParser
.ParseValue(input, null, $ref0), TransferCodingWithQualityHeaderValue);
    }
    /*bool*/ static TryParse(/*string*/ input, /*out TransferCodingWithQualityHeaderValue*/ parsedValue)
    {
        let $ref0 = { set value(v){ index = v } };
        let output = null;
        let $ref2 = { set value(v){ output = v } };
        /*int*/ let index = 0;
        parsedValue = null;
        if (TransferCodingHeaderParser.SingleValueWithQualityParser.TryParseValue(input, null, $ref0, $ref2))
        {
            parsedValue = BlazorJs.Cast(output, TransferCodingWithQualityHeaderValue);
            return true;
        }
        return false;
    }
}

class System_Net_Http_Headers_UriHeaderParser extends System_Net_Http_Headers_HttpHeaderParser
{
    /*UriKind*/ _uriKind = null;
    /*UriHeaderParser*/ static RelativeOrAbsoluteUriParser = new UriHeaderParser(UriKind.RelativeOrAbsolute);
    constructor(/*UriKind*/ uriKind)
    {
        super(false);
        _uriKind = uriKind;
    }
    /*bool*/ TryParseValue(/*string*/ value, /*object*/ storeValue, /*ref int*/ index, /*out object*/ parsedValue)
    {
        let uri = null;
        let $ref1 = { set value(v){ uri = v } };
        parsedValue = null;
        if (string.IsNullOrEmpty(value) || (index === value.Length))
        {
            return false;
        }
        /*string*/ let uriString = value;
        if (index > 0)
        {
            uriString = value.Substring(index);
        }
        if (UriExtension.TryCreate(uriString, _uriKind, $ref1))
        {
            let $ref0 = { set value(v){ uri = v } };
            uriString = DecodeUtf8FromString(uriString);
            if (UriExtension.TryCreate(uriString, _uriKind, $ref0))
            {
                return false;
            }
        }
        index = value.Length;
        parsedValue = uri;
        return true;
    }
    /*string*/ static DecodeUtf8FromString(/*string*/ input)
    {
        if (string.IsNullOrWhiteSpace(input))
        {
            /*int*/ let possibleUtf8Pos = input.AsSpan().IndexOfAnyExceptInRange(BlazorJs.Cast(0, char), BlazorJs.Cast(127, char));
            if (possibleUtf8Pos >= 0 && input.AsSpan(possibleUtf8Pos).ContainsAnyExceptInRange(BlazorJs.Cast(0, char), BlazorJs.Cast(255, char)))
            {
                /*Span<byte>*/ let rawBytes = new Array(input.Length);
                for(/*int*/ let i = 0; i < input.Length; i++)
                {
                    rawBytes[i] = BlazorJs.Cast(input[i], byte);
                }
                try
                {
                    /*// We don't want '?' replacement characters, just fail.
                        Encoding*/ let decoder = Encoding.GetEncoding("utf-8");
                    return decoder.GetString(rawBytes.ToArray());
                }
                catch($e)
                {
                }
            }
        }
        return input;
    }
    /*string*/ ToString(/*object*/ value)
    {
        Debug.Assert(value instanceof Uri);
        /*Uri*/ let uri = BlazorJs.Cast(value, Uri);
        if (uri.IsAbsoluteUri())
        {
            return uri.AbsoluteUri;
        }
        else 
        {
            return uri.ToString();
        }
    }
}

class System_Net_Http_Headers_ViaHeaderValue extends H5_IH5Class(System_ICloneable(object))
{
    /*string*/ _protocolName = null;
    /*string*/ _protocolVersion = null;
    /*string*/ _receivedBy = null;
    /*string*/ _comment = null;
    /*string*/ get ProtocolName()
    {
        return _protocolName;
    }
    /*string*/ get ProtocolVersion()
    {
        return _protocolVersion;
    }
    /*string*/ get ReceivedBy()
    {
        return _receivedBy;
    }
    /*string*/ get Comment()
    {
        return _comment;
    }
    constructor(/*string*/ protocolVersion, /*string*/ receivedBy, /*string*/ protocolName, /*string*/ comment, /*bool*/ _)
    {
        super();
        _protocolVersion = protocolVersion;
        _receivedBy = receivedBy;
        _protocolName = protocolName;
        _comment = comment;
    }
    constructor(/*string*/ protocolVersion, /*string*/ receivedBy)
    {
        super(protocolVersion, receivedBy, null, null);
    }
    constructor(/*string*/ protocolVersion, /*string*/ receivedBy, /*string*/ protocolName)
    {
        super(protocolVersion, receivedBy, protocolName, null);
    }
    constructor(/*string*/ protocolVersion, /*string*/ receivedBy, /*string*/ protocolName, /*string*/ comment)
    {
        super();
        HeaderUtilities.CheckValidToken(protocolVersion);
        CheckReceivedBy(receivedBy);
        if (string.IsNullOrEmpty(protocolName))
        {
            HeaderUtilities.CheckValidToken(protocolName);
            _protocolName = protocolName;
        }
        if (string.IsNullOrEmpty(comment))
        {
            HeaderUtilities.CheckValidComment(comment);
            _comment = comment;
        }
        _protocolVersion = protocolVersion;
        _receivedBy = receivedBy;
    }
    constructor(/*ViaHeaderValue*/ source)
    {
        super();
        Debug.Assert(source !== null);
        _protocolName = source._protocolName;
        _protocolVersion = source._protocolVersion;
        _receivedBy = source._receivedBy;
        _comment = source._comment;
    }
    /*string*/ ToString()
    {
        /*var*/ let sb = new StringBuilder((256));
        if (string.IsNullOrEmpty(_protocolName))
        {
            sb.Append(_protocolName);
            sb.Append('/');
        }
        sb.Append(_protocolVersion);
        sb.Append(' ');
        sb.Append(_receivedBy);
        if (string.IsNullOrEmpty(_comment))
        {
            sb.Append(' ');
            sb.Append(_comment);
        }
        return sb.ToString();
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        return obj instanceof ViaHeaderValue, other = obj && // Note that for token and host case-insensitive comparison is used. Comments are compared using case-
            // sensitive comparison.
            string.Equals(_protocolVersion, other._protocolVersion, StringComparison.OrdinalIgnoreCase) && string.Equals(_receivedBy, other._receivedBy, StringComparison.OrdinalIgnoreCase) && string.Equals(_protocolName, other._protocolName, StringComparison.OrdinalIgnoreCase) && string.Equals(_comment, other._comment, StringComparison.Ordinal);
    }
    /*int*/ GetHashCode()
    {
        return HashCode.Combine(StringComparer.OrdinalIgnoreCase.GetHashCode(_protocolVersion), StringComparer.OrdinalIgnoreCase.GetHashCode(_receivedBy), _protocolName ? 0 : StringComparer.OrdinalIgnoreCase.GetHashCode(_protocolName), _comment);
    }
    /*ViaHeaderValue*/ static Parse(/*string*/ input)
    {
        let $ref0 = { set value(v){ index = v } };
        /*int*/ let index = 0;
        return BlazorJs.Cast(GenericHeaderParser.SingleValueViaParser.ParseValue(input, null, $ref0), ViaHeaderValue);
    }
    /*bool*/ static TryParse(/*string*/ input, /*out ViaHeaderValue*/ parsedValue)
    {
        let $ref0 = { set value(v){ index = v } };
        let output = null;
        let $ref2 = { set value(v){ output = v } };
        /*int*/ let index = 0;
        parsedValue = null;
        if (GenericHeaderParser.SingleValueViaParser.TryParseValue(input, null, $ref0, $ref2))
        {
            parsedValue = BlazorJs.Cast(output, ViaHeaderValue);
            return true;
        }
        return false;
    }
    /*int*/ static GetViaLength(/*string*/ input, /*int*/ startIndex, /*out object*/ parsedValue)
    {
        let protocolName = null;
        let $ref1 = { set value(v){ protocolName = v } };
        let protocolVersion = null;
        let $ref3 = { set value(v){ protocolVersion = v } };
        Debug.Assert(startIndex >= 0);
        parsedValue = null;
        if (string.IsNullOrEmpty(input) || (startIndex >= input.Length))
        {
            return 0;
        }
        /*// Read <protocolName> and <protocolVersion> in '[<protocolName>/]<protocolVersion> <receivedBy> [<comment>]'
            int*/ let current = GetProtocolEndIndex(input, startIndex, $ref1, $ref3);
        if ((current === 0) || (current === input.Length))
        {
            return 0;
        }
        Debug.Assert(protocolVersion !== null);
        /*// Read <receivedBy> in '[<protocolName>/]<protocolVersion> <receivedBy> [<comment>]'
            int*/ let receivedByLength = HttpRuleParser.GetHostLength(input, current, true);
        if (receivedByLength === 0)
        {
            return 0;
        }
        /*string*/ let receivedBy = input.Substring(current, receivedByLength);
        current += receivedByLength;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        /*string*/ let comment = null;
        if ((current < input.Length) && (input[current] === '('))
        {
            let commentLength = null;
            let $ref1 = { set value(v){ commentLength = v } };
            if (HttpRuleParser.GetCommentLength(input, current, $ref1) !== HttpParseResult.Parsed)
            {
                return 0;
            }
            comment = input.Substring(current, commentLength);
            current += commentLength;
            current += HttpRuleParser.GetWhitespaceLength(input, current);
        }
        parsedValue = new ViaHeaderValue(protocolVersion, receivedBy, protocolName, comment, false);
        return current - startIndex;
    }
    /*int*/ static GetProtocolEndIndex(/*string*/ input, /*int*/ startIndex, /*out string*/ protocolName, /*out string*/ protocolVersion)
    {
        protocolName = null;
        protocolVersion = null;
        /*int*/ let current = startIndex;
        /*int*/ let protocolVersionOrNameLength = HttpRuleParser.GetTokenLength(input, current);
        if (protocolVersionOrNameLength === 0)
        {
            return 0;
        }
        current = startIndex + protocolVersionOrNameLength;
        /*int*/ let whitespaceLength = HttpRuleParser.GetWhitespaceLength(input, current);
        current += whitespaceLength;
        if (current === input.Length)
        {
            return 0;
        }
        if (input[current] === '/')
        {
            protocolName = input.Substring(startIndex, protocolVersionOrNameLength);
            current++;
            current += HttpRuleParser.GetWhitespaceLength(input, current);
            protocolVersionOrNameLength = HttpRuleParser.GetTokenLength(input, current);
            if (protocolVersionOrNameLength === 0)
            {
                return 0;
            }
            protocolVersion = input.Substring(current, protocolVersionOrNameLength);
            current += protocolVersionOrNameLength;
            whitespaceLength = HttpRuleParser.GetWhitespaceLength(input, current);
            current += whitespaceLength;
        }
        else 
        {
            protocolVersion = input.Substring(startIndex, protocolVersionOrNameLength);
        }
        if (whitespaceLength === 0)
        {
            return 0;
        }
        return current;
    }
    /*object*/ Clone()
    {
        return new ViaHeaderValue(this);
    }
    /*void*/ static CheckReceivedBy(/*string*/ receivedBy)
    {
        if (string.IsNullOrEmpty(receivedBy))
        throw new ArgumentException(nameof(receivedBy));
        if (HttpRuleParser.GetHostLength(receivedBy, 0, true) !== receivedBy.Length)
        {
            throw new FormatException("net_http_headers_invalid_value");
        }
    }
}

class System_Net_Http_Headers_WarningHeaderValue extends H5_IH5Class(System_ICloneable(object))
{
    /*int*/ _code = null;
    /*string*/ _agent = null;
    /*string*/ _text = null;
    /*DateTimeOffset*/ _date = null;
    /*bool*/ _dateHasValue = null;
    /*int*/ get Code()
    {
        return _code;
    }
    /*string*/ get Agent()
    {
        return _agent;
    }
    /*string*/ get Text()
    {
        return _text;
    }
    /*DateTimeOffset?*/ get Date()
    {
        return _dateHasValue ? _date : BlazorJs.Cast(null, DateTimeOffset);
    }
    constructor(/*int*/ code, /*string*/ agent, /*string*/ text, /*DateTimeOffset?*/ date)
    {
        super();
        _code = code;
        _agent = agent;
        _text = text;
        _date = date.GetValueOrDefault();
        _dateHasValue = date.HasValue;
    }
    constructor(/*int*/ code, /*string*/ agent, /*string*/ text)
    {
        super();
        CheckCode(code);
        CheckAgent(agent);
        HeaderUtilities.CheckValidQuotedString(text);
        _code = code;
        _agent = agent;
        _text = text;
    }
    constructor(/*int*/ code, /*string*/ agent, /*string*/ text, /*DateTimeOffset*/ date)
    {
        super();
        CheckCode(code);
        CheckAgent(agent);
        HeaderUtilities.CheckValidQuotedString(text);
        _code = code;
        _agent = agent;
        _text = text;
        _date = date;
        _dateHasValue = true;
    }
    constructor(/*WarningHeaderValue*/ source)
    {
        super();
        Debug.Assert(source !== null);
        _code = source._code;
        _agent = source._agent;
        _text = source._text;
        _date = source._date;
        _dateHasValue = source._dateHasValue;
    }
    /*string*/ ToString()
    {
        /*var*/ let sb = new StringBuilder();
        sb.Append(_code.ToString("000"));
        sb.Append(' ');
        sb.Append(_agent);
        sb.Append(' ');
        sb.Append(_text);
        if (_dateHasValue)
        {
            sb.Append(" \"");
            sb.Append(_date.ToString("r"));
            sb.Append('\"');
        }
        return sb.ToString();
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        return obj instanceof WarningHeaderValue, other = obj && _code === other._code  && // 'agent' is a host/token, i.e. use case-insensitive comparison. Use case-sensitive comparison for 'text'
            // since it is a quoted string.
            string.Equals(_agent, other._agent, StringComparison.OrdinalIgnoreCase) && string.Equals(_text, other._text, StringComparison.Ordinal) && _dateHasValue === other._dateHasValue  && _date === other._date;
    }
    /*int*/ GetHashCode()
    {
        return HashCode.Combine(_code, StringComparer.OrdinalIgnoreCase.GetHashCode(_agent), _text, _dateHasValue, _date);
    }
    /*WarningHeaderValue*/ static Parse(/*string*/ input)
    {
        let $ref0 = { set value(v){ index = v } };
        /*int*/ let index = 0;
        return BlazorJs.Cast(GenericHeaderParser.SingleValueWarningParser.ParseValue(input, null, $ref0), WarningHeaderValue);
    }
    /*bool*/ static TryParse(/*string*/ input, /*out WarningHeaderValue*/ parsedValue)
    {
        let $ref0 = { set value(v){ index = v } };
        let output = null;
        let $ref2 = { set value(v){ output = v } };
        /*int*/ let index = 0;
        parsedValue = null;
        if (GenericHeaderParser.SingleValueWarningParser.TryParseValue(input, null, $ref0, $ref2))
        {
            parsedValue = BlazorJs.Cast(output, WarningHeaderValue);
            return true;
        }
        return false;
    }
    /*int*/ static GetWarningLength(/*string*/ input, /*int*/ startIndex, /*out object*/ parsedValue)
    {
        let $ref0 = { set value(v){ current = v } };
        let code = null;
        let $ref2 = { set value(v){ code = v } };
        let $ref3 = { set value(v){ current = v } };
        let agent = null;
        let $ref5 = { set value(v){ agent = v } };
        let textLength = null;
        let $ref7 = { set value(v){ textLength = v } };
        let $ref8 = { set value(v){ current = v } };
        let date = null;
        let $ref10 = { set value(v){ date = v } };
        Debug.Assert(startIndex >= 0);
        parsedValue = null;
        if (string.IsNullOrEmpty(input) || (startIndex >= input.Length))
        {
            return 0;
        }
        /*// Read <code> in '<code> <agent> <text> ["<date>"]'
            int*/ let current = startIndex;
        if (TryReadCode(input, $ref0, $ref2))
        {
            return 0;
        }
        if (TryReadAgent(input, $ref3, $ref5))
        {
            return 0;
        }
        /*// Read <text> in '<code> <agent> <text> ["<date>"]'
            int*/ let textStartIndex = current;
        if (HttpRuleParser.GetQuotedStringLength(input, current, $ref7) !== HttpParseResult.Parsed)
        {
            return 0;
        }
        /*string*/ let text = input.Substring(textStartIndex, textLength);
        current += textLength;
        if (TryReadDate(input, $ref8, $ref10))
        {
            return 0;
        }
        parsedValue = new WarningHeaderValue(code, agent, text, date);
        return current - startIndex;
    }
    /*bool*/ static TryReadAgent(/*string*/ input, /*ref int*/ current, /*out string*/ agent)
    {
        agent = null;
        /*int*/ let agentLength = HttpRuleParser.GetHostLength(input, current, true);
        if (agentLength === 0)
        {
            return false;
        }
        agent = input.Substring(current, agentLength);
        current += agentLength;
        /*int*/ let whitespaceLength = HttpRuleParser.GetWhitespaceLength(input, current);
        current += whitespaceLength;
        if ((whitespaceLength === 0) || (current === input.Length))
        {
            return false;
        }
        return true;
    }
    /*bool*/ static TryReadCode(/*string*/ input, /*ref int*/ current, /*out int*/ code)
    {
        let $ref0 = { set value(v){ code = v } };
        code = 0;
        /*int*/ let codeLength = HttpRuleParser.GetNumberLength(input, current, false);
        if ((codeLength === 0) || (codeLength > 3))
        {
            return false;
        }
        if (HeaderUtilities.TryParseInt32(input, current, codeLength, $ref0))
        {
            Debug.Fail("Unable to parse value even though it was parsed as <=3 digits string. Input: '" + input + "', Current: " + current + ", CodeLength: " + codeLength);
            return false;
        }
        current += codeLength;
        /*int*/ let whitespaceLength = HttpRuleParser.GetWhitespaceLength(input, current);
        current += whitespaceLength;
        if ((whitespaceLength === 0) || (current === input.Length))
        {
            return false;
        }
        return true;
    }
    /*bool*/ static TryReadDate(/*string*/ input, /*ref int*/ current, /*out DateTimeOffset?*/ date)
    {
        date = null;
        /*// Make sure we have at least one whitespace between <text> and <date> (if we have <date>)
            int*/ let whitespaceLength = HttpRuleParser.GetWhitespaceLength(input, current);
        current += whitespaceLength;
        if ((current < input.Length) && (input[current] === '"'))
        {
            let temp = null;
            let $ref1 = { set value(v){ temp = v } };
            if (whitespaceLength === 0)
            {
                return false;
            }
            current++;
            /*// Find the closing '"'
                int*/ let dateStartIndex = current;
            /*int*/ let quote = input.AsSpan(current).IndexOf('"');
            if (quote <= 0)
            {
                return false;
            }
            current += quote;
            if (DateTimeOffset.TryParse(input.AsSpan(dateStartIndex, current - dateStartIndex), $ref1))
            {
                return false;
            }
            date = temp;
            current++;
            current += HttpRuleParser.GetWhitespaceLength(input, current);
        }
        return true;
    }
    /*object*/ Clone()
    {
        return new WarningHeaderValue(this);
    }
    /*void*/ static CheckCode(/*int*/ code)
    {
        if (code < 0 || code > 999)
        throw new ArgumentOutOfRangeException();
    }
    /*void*/ static CheckAgent(/*string*/ agent)
    {
        if (string.IsNullOrEmpty(agent))
        throw new ArgumentException();
        if (HttpRuleParser.GetHostLength(agent, 0, true) !== agent.Length)
        {
            throw new FormatException("net_http_headers_invalid_value");
        }
    }
}















































