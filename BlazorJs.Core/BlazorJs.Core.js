class BlazorJs_Core_BrowserApplicationBuilder extends object
{
    /*BrowserServiceProvider*/ _backingField_Services = null;
    /*BrowserServiceProvider*/ get Services()
    {
        return _backingField_Services;
    }
    /*DefaultComponentActivator*/ _backingField_ComponentActivator = null;
    /*DefaultComponentActivator*/ get ComponentActivator()
    {
        return _backingField_ComponentActivator;
    }
    /*BrowserNativeRenderer*/ _backingField_Renderer = null;
    /*BrowserNativeRenderer*/ get Renderer()
    {
        return _backingField_Renderer;
    }
    /*BrowserNativeNavigationManager*/ _backingField_NavigationManager = null;
    /*BrowserNativeNavigationManager*/ get NavigationManager()
    {
        return _backingField_NavigationManager;
    }
    /*BrowserNativeErrorBoundaryLogger*/ _backingField_ErrorBoundaryLogger = null;
    /*BrowserNativeErrorBoundaryLogger*/ get ErrorBoundaryLogger()
    {
        return _backingField_ErrorBoundaryLogger;
    }
    /*BrowserJavascriptRuntime*/ _backingField_JavascriptRuntime = null;
    /*BrowserJavascriptRuntime*/ get JavascriptRuntime()
    {
        return _backingField_JavascriptRuntime;
    }
    /*HttpClient*/ _backingField_Http = null;
    /*HttpClient*/ get Http()
    {
        return _backingField_Http;
    }
    constructor()
    {
        super();
        Services = new BrowserServiceProvider();
        NavigationManager = new BrowserNativeNavigationManager();
        Http = new HttpClient();
        ErrorBoundaryLogger = new BrowserNativeErrorBoundaryLogger();
        JavascriptRuntime = new BrowserJavascriptRuntime();
        Services.AddSingleton(IServiceProvider, Services);
        Services.AddSingleton(NavigationManager).AddSingleton(NavigationManager, NavigationManager).AddSingleton(INavigationInterception, NavigationManager);
        Services.AddSingleton(IErrorBoundaryLogger, ErrorBoundaryLogger);
        Services.AddSingleton(IJSRuntime, JavascriptRuntime);
        Services.AddSingleton(Http);
        ComponentActivator = new DefaultComponentActivator(Services);
        Renderer = new BrowserNativeRenderer(Services, ComponentActivator);
    }
    /*BrowserApplicationBuilder*/ Create({ /*Action<BrowserApplicationBuilder>*/ build = null})
    {
        /*var*/ let app = new BrowserApplicationBuilder();
        buildInvoke(app);
        return app;
    }
    /*BrowserApplicationBuilder*/ Create(TRootComponent, { /*Action<BrowserApplicationBuilder>*/ build = null, /*Action<TRootComponent>*/ buildComponent = null})
    {
        /*var*/ let app = new BrowserApplicationBuilder();
        app.Renderer.Add(TRootComponent, buildComponent);
        buildInvoke(app);
        return app;
    }
}

class BlazorJs_Core_BrowserJavascriptRuntime extends Microsoft_JSInterop_JSRuntime
{
    constructor()
    {
        super();
    }
    /*void*/ BeginInvokeJS(/*long*/ taskId, /*string*/ identifier, /*string*/ argsJson, /*JSCallResultType*/ resultType, /*long*/ targetInstanceId)
    {
        throw new NotImplementedException();
    }
    /*void*/ BeginInvokeJS(/*JSInvocationInfo*/ invocationInfo)
    {
        throw new NotImplementedException();
    }
    /*void*/ EndInvokeDotNet(/*DotNetInvocationInfo*/ invocationInfo, /*DotNetInvocationResult*/ invocationResult)
    {
        throw new NotImplementedException();
    }
}

class BlazorJs_Core_BrowserNativeDispatcher extends Microsoft_AspNetCore_Components_Dispatcher
{
    constructor()
    {
        super();
    }
    /*bool*/ CheckAccess()
    {
        return true;
    }
    /*Task*/ InvokeAsync(/*Action*/ workItem)
    {
        workItem();
        return Task.CompletedTask;
    }
    /*Task*/ InvokeAsync(/*Func<Task>*/ workItem)
    {
        return workItem();
    }
    /*Task<TResult>*/ InvokeAsync(TResult, /*Func<TResult>*/ workItem)
    {
        /*var*/ let t = workItem();
        return Task.FromResult(t);
    }
    /*Task<TResult>*/ InvokeAsync(TResult, /*Func<Task<TResult>>*/ workItem)
    {
        return workItem();
    }
}

class BlazorJs_Core_BrowserNativeErrorBoundaryLogger extends Microsoft_AspNetCore_Components_Web_IErrorBoundaryLogger(object)
{
    constructor()
    {
        super();
    }
    /*Task*/ LogErrorAsync(/*Exception*/ exception)
    {
        Console.Write(exception.Message);
        return Task.CompletedTask;
    }
}

class BlazorJs_Core_BrowserNativeNavigationManager extends Microsoft_AspNetCore_Components_Routing_INavigationInterception(Microsoft_AspNetCore_Components_NavigationManager)
{
    constructor()
    {
        super();
        Initialize("", window.location.pathname  + window.location.search  + window.location.hash);
        //we are on the client, always enable navigation interception
            EnableNavigationInterceptionAsync().FireAndForget();
    }
    /*void*/ LinkClicked(/*Event*/ _event)
    {
        /*var*/ let href = HTMLElement_event.currentTarget.getAttribute("href");
        _event.preventDefault();
        /*var*/ let currentHRef = window.location.href  + window.location.search;
        if (currentHRef.Equals(href, StringComparison.InvariantCultureIgnoreCase))
        {
            NavigateToCore(href, new NavigationOptions(), { isIntercepted : true }).FireAndForget();
        }
    }
    /*void*/ LinkMutationCallback(/*MutationRecord[]*/ mutations, /*MutationObserver*/ observer)
    {
        for(/*int*/ let i = 0; i < mutations.Length; i++)
        {
            BlazorJs.forEach(mutationsi.addedNodes, function(item, $_i)
            {
                if (item.nodeName.Equals("A", StringComparison.InvariantCultureIgnoreCase))
                item.addEventListener("click", LinkClicked);
            });
        });
    }
    /*bool*/ enabledNavigationInterception = null;
    /*Task*/ EnableNavigationInterceptionAsync()
    {
        if (enabledNavigationInterception)
        {
            enabledNavigationInterception = true;
            /*var*/ let observer = new MutationObserver(LinkMutationCallback);
            observer.observe(document.body, new MutationObserverInit()childList = trueattributeFilter = [ "href" ]subtree = true);
            /*var*/ let links = document.querySelectorAll("*[href]");
            links.FirstOrDefault(function(/**/ link)
            {
                link.addEventListener("click", LinkClicked);
                return false;
            });
            window.addEventListener("popstate", function(/*Event*/ _event)
            {
                /*var*/ let popEvent = PopStateEvent_event;
                NavigateToCore(window.location.pathname  + window.location.search  + window.location.hash, new NavigationOptions()HistoryEntryState = popEvent.state , { isIntercepted : false }).FireAndForget();
            });
        }
        return Task.CompletedTask;
    }
    /*void*/ NavigateToCore(/*string*/ uri, /*NavigationOptions*/ options)
    {
        NavigateToCore(uri, options, { isIntercepted : false }).FireAndForget();
    }
    /*Task*/ async NavigateToCore(/*string*/ uri, /*NavigationOptions*/ options, /*bool*/ isIntercepted)
    {
        /*var*/ let _continue = await NotifyLocationChangingAsync(uri, options.HistoryEntryState, isIntercepted);
        if (_continue)
        {
            if (options.ForceLoad)
            {
                window.location.href  = uri;
            }
            else 
            {
                if (options.ReplaceHistoryEntry)
                {
                    window.history.replaceState(null, "", uri);
                }
                else 
                {
                    window.history.pushState(null, "", uri);
                }
            }
            Uri = uri;
            NotifyLocationChanged(isIntercepted);
        }
    }
    /*bool*/ navigationLocked = null;
    /*void*/ SetNavigationLockState(/*bool*/ value)
    {
        navigationLocked = value;
    }
}

class BlazorJs_Core_BrowserNativeRenderer extends BlazorJs_Core_IRenderer(Microsoft_AspNetCore_Components_RenderTree_Renderer)
{
    /*//class RegistryEntry
        //{
        //    public Node.Interface element;
        //    public int id;
        //}
        UIFrame*/ rootFragment = null;
    /*object*/ registries = new ();
    /*Dispatcher*/ _dispatcher = null;
    constructor(/*IServiceProvider*/ services, /*IComponentActivator*/ componentActivator)
    {
        super();
        Services = services;
        rootFragment = new UIFrame();
        rootFragment.Elements  = document.body ;
        ComponentActivator = componentActivator;
    }
    /*IServiceProvider*/ _backingField_Services = null;
    /*IServiceProvider*/ get Services()
    {
        return _backingField_Services;
    }
    /*IComponentActivator*/ _backingField_ComponentActivator = null;
    /*IComponentActivator*/ get ComponentActivator()
    {
        return _backingField_ComponentActivator;
    }
    /*Dispatcher*/ get Dispatcher()
    {
        if (_dispatcher == null)
        _dispatcher = Dispatcher.CreateDefault();
        return _dispatcher;
    }
    /*void*/ Add(/*RenderFragment*/ fragment)
    {
        fragment(rootFragment);
    }
    /*void*/ Add(T, { /*Action<T>*/ attributeBuilder = null})
    {
        rootFragment.Component(T, attributeBuilder, { sequenceNumber : .MaxValue });
    }
    /*int*/ GetUID(/*IUIContent*/ content)
    {
        if (content == null)
        return 0;
        if (content.State.Key  == null)
        {
            return content.State.Id;
        }
        return content.State.Id  + 86438565 * content.State.Key.GetHashCode();
    }
    /*//Node Text(string txt, int id)
        //{
        //    var e = document.createTextNode(txt);
        //    return e;
        //}
        //HTMLElement Element(string tag, int id)
        //{
        //    var e = document.createElement(tag);
        //    return e;
        //}
        //ShadowRoot Component(string tag, int id, int parentId)
        //{
        //    //if (!definedComponents.includes(tag))
        //    //{
        //    //customElements.define(tag, Component, { extends: "div" });
        //    //}
        //    var parent = GetRegistry(parentId);
        //    ShadowRoot shadow;
        //    if (parent.element is ShadowRoot eshadow)
        //    {
        //        eshadow.
        //    }
        //    else
        //    {
        //        var shadow = ((HTMLElement)parent.element).attachShadow(new ShadowRootInit { mode = Literals.Options.mode.open });
        //    }
        //    //var e = document.createElement(tag);
        //    AddRegistry(id, new RegistryEntry { id = id, element = shadow });
        //    return shadow;
        //    //return e;
        //}
        //HTMLElement Region(int id)
        //{
        //    var e = document.createElement("region");
        //    AddRegistry(id, new RegistryEntry { id = id, element = e });
        //    return e;
        //}
        //void Update(IUIContent frame, string txt)
        //{
        //    //var registry = GetRegistry(id);
        //    //if (registry.element is HTMLElement element)
        //    //{
        //    frame.State.Element.textContent = txt;
        //    //}
        //}
        Node.Interface*/ GetParentElement(/*IUIContent*/ element)
    {
        /*var*/ let parentElement = element.State.ParentFrame;
        while(parentElement.State.Elements  == null)
        {
            parentElement = parentElement.State.ParentFrame;
            if (parentElement == null)
            {
                return rootFragment.Elements0;
            }
        }
        return parentElement.State.Elements0;
    }
    /*Node.Interface*/ GetFirstElementAfter(/*IUIContent*/ element)
    {
        /*var*/ let after = element.GetAfter();
        while(after != null)
        {
            if (after.State.Elements  != null)
            {
                return after.State.Elements0;
            }
            if (after instanceof UIFrame, frame = after && frame.Children  != null)
            {
                BlazorJs.forEach(frame.Children, function(c, $_i)
                {
                    /*var*/ let first = GetFirstElementAfter(c);
                    if (first != null)
                    return first;
                });
            }
            if (after.State.Component  != null && after.State.Children  != null)
            {
                BlazorJs.forEach(after.State.Children, function(c, $_i)
                {
                    /*var*/ let first = GetFirstElementAfter(c);
                    if (first != null)
                    return first;
                });
            }
            after = after.GetAfter();
        }
        return null;
    }
    /*void*/ Insert(/*IUIContent*/ frame, /*IUIContent*/ parent, /*IUIContent*/ before)
    {
        /*var*/ let useElement = parent.State.Elements0;
        /*var*/ let reference = beforeState.ElementsLength > 0beforeState.Elements0null;
        if (parent.State.Elements  == null)
        {
            useElement = GetParentElement(parent);
            if (reference == null)
            {
                reference = GetFirstElementAfter(parent);
            }
        }
        if (reference != null)
        {
            frame.State.Elements.ForEach(function(/**/ el)
            {
                {
                    useElement.insertBefore(el, Nodereference);
                }
            });
        }
        else 
        {
            frame.State.Elements.ForEach(function(/**/ el)
            {
                {
                    useElement.appendChild(el);
                }
            });
        }
    }
    /*void*/ CreateElement(/*UIElement*/ element)
    {
        /*var*/ let insertBefore = element.GetAfter();
        /*var*/ let melement = document.createElement(element.Tag);
        element.Elements  = melement;
        Insert(element, element.State.ParentFrame, insertBefore);
    }
    /*void*/ CreateRegion(/*UIFrame*/ frame)
    {
    }
    /*void*/ RemoveRegion(/*UIFrame*/ frame)
    {
    }
    /*void*/ CreateComponent(/*IComponent*/ component)
    {
    }
    /*void*/ RemoveComponent(/*IComponent*/ component)
    {
    }
    /*void*/ CreateText(/*UIText*/ text)
    {
        /*var*/ let insertBefore = text.GetAfter();
        /*var*/ let element = document.createTextNode(text.TextToString());
        text.Elements  = element;
        Insert(text, text.State.ParentFrame, insertBefore);
    }
    /*void*/ UpdateText(/*UIText*/ text)
    {
        text.State.Elements0.textContent  = text.TextToString();
    }
    /*void*/ RemoveElement(/*UIElement*/ element)
    {
        /*var*/ let parent = GetParentElement(element);
        parent.removeChild(element.State.Elements0);
    }
    /*void*/ RemoveText(/*UIText*/ text)
    {
        /*var*/ let parent = GetParentElement(text);
        parent.removeChild(text.State.Elements0);
    }
    /*void*/ SetElementAttribute(/*UIElement*/ element, /*string*/ key, /*object*/ value)
    {
        if (key.StartsWith("@on") && value instanceof IEventCallback, evc = value)
        {
            /*var*/ let eventName = key.Substring(3).Split(':')0;
            /*var*/ let existingEvent = element.State.Elements0"__" + eventName + "__";
            element.State.Elements0.removeEventListener(eventName, EventListenerexistingEvent);
            /*EventListener*/ let evl = function(/**/ ev)
            {
                evc.InvokeAsync(ev).ContinueWith(function(/**/ t)
                {
                    {
                        if (t.Exception  != null)
                        {
                            System.Console.WriteLine(t.Exception);
                        }
                    }
                }).FireAndForget();
                if (evc.Flags.HasFlag(EventCallbackFlags.StopPropagation))
                ev.stopPropagation();
                if (evc.Flags.HasFlag(EventCallbackFlags.PreventDefault))
                ev.preventDefault();
            };
            element.State.Elements0.addEventListener(eventName, evl);
            element.State.Elements0"__" + eventName + "__" = evl;
        }
        else 
        {
            /*bool*/ let isInput = H5.Script.InstanceOf(element.Elements0, HTMLInputElement);
            if (isInput && key == "value")
            {
                HTMLInputElementelement.Elements0.value  = valueToString();
            }
            else if (isInput && key == "readonly")
            {
                HTMLInputElementelement.Elements0.readOnly  = value.As(bool);
            }
            else if (value)
            {
                if (element.State.Elements0 instanceof HTMLElement)
                {
                    if (melement.attributes.getNamedItem(key) != null)
                    melement.attributes.removeNamedItem(key);
                }
            }
            else 
            {
                /*var*/ let atr = document.createAttribute(key);
                atr.value  = value.ToString();
                if (element.State.Elements0 instanceof HTMLElement)
                {
                    melement.attributes.setNamedItem(atr);
                }
            }
        }
    }
    /*void*/ CreateMarkup(/*UIMarkup*/ markup)
    {
        /*var*/ let insertBefore = markup.GetAfter();
        /*var*/ let template = HTMLTemplateElementdocument.createElement("template");
        template.innerHTML  = markup.Markup;
        /*//make sure to clone the NodeList as insert into parent will remove it from the list
            var*/ let nodes = template.content.childNodes.As(Node.Interface[]);
        /*var*/ let elements = new Array(nodes.Length);
        /*int*/ let i = 0;
        nodes.ForEach(function(/**/ n)
        {
            return elementsi++ = n;
        });
        markup.Elements  = elements;
        Insert(markup, markup.State.ParentFrame, insertBefore);
    }
    /*void*/ UpdateMarkup(/*UIMarkup*/ markup)
    {
        RemoveMarkup(markup);
        CreateMarkup(markup);
    }
    /*void*/ RemoveMarkup(/*UIMarkup*/ markup)
    {
        /*var*/ let parent = GetParentElement(markup);
        markup.Elements.ForEach(function(/**/ el)
        {
            {
                parent.removeChild(el);
            }
        });
    }
    /*void*/ Flush()
    {
    }
    /*void*/ Register(/*int*/ frameId, /*UIFrameState*/ state)
    {
        registries.SetValue(frameId, state);
    }
    /*void*/ Remove(/*int*/ frameId)
    {
        registries.Remove(frameId);
    }
    /*UIFrameState*/ GetState(/*int*/ frameId)
    {
        let state = null;
        let $v = { value: set(value){ state = value; } };
        if (registries.TryGetValue(frameId, $v))
        {
            /*var*/ let mstate = UIFrameStatestate;
            return mstate;
        }
        return null;
    }
    /*UIFrameState*/ GetRequiredState(/*int*/ frameId)
    {
        return GetState(frameId) ??         throw new InvalidOperationException(frameId);
;
    }
    /*void*/ AddToRenderQueue(/*int*/ componentId, /*RenderFragment*/ renderFragment)
    {
        /*var*/ let mstate = GetRequiredState(componentId);
        mstate.TrackContents(function()
        {
            renderFragment(mstate);
        });
        /*var*/ let scope = renderFragment"$scope";
        if (scope instanceof IHandleAfterRender, haf = scope)
        {
            haf.OnAfterRenderAsync().FireAndForget();
        }
    }
    /*void*/ HandleComponentException(/*Exception*/ exception, /*int*/ componentId)
    {
        HandleExceptionViaErrorBoundary(exception, GetRequiredState(componentId));
    }
    /*void*/ HandleExceptionViaErrorBoundary(/*Exception*/ error, /*UIFrameState*/ errorSourceOrNull)
    {
        // We only get here in specific situations. Currently, all of them are when we're
            // already on the sync context (and if not, we have a bug we want to know about).
            Dispatcher.AssertAccess();
        if (error is NavigationException)
        {
            HandleException(error);
            return ;
        }
        /*// Find the closest error boundary, if any
            var*/ let candidate = errorSourceOrNull;
        while(candidate != null)
        {
            if (candidate.Component  instanceof IErrorBoundary)
            {
                // Don't just trust the error boundary to dispose its subtree - force it to do so by
                    // making it render an empty fragment. Ensures that failed components don't continue to
                    // operate, which would be a whole new kind of edge case to support forever.
                    AddToRenderQueue(candidate.Id, function(/**/ _, /**/ __)
                {
                });
                {
                    errorBoundary.HandleException(error);
                }
Exception                {
                    // If *notifying* about an exception fails, it's OK for that to be fatal
                        HandleException(errorBoundaryException);
                }
                return ;
            }
            candidate = candidate.ParentFrame.State;
        }
        // It's unhandled, so treat as fatal
            HandleException(error);
    }
}

class BlazorJs_Core_DisposableDelegate extends System_IDisposable(object)
{
    /*Action*/ dispose = null;
    constructor(/*Action*/ dispose)
    {
        super();
        .dispose  = dispose;
    }
    /*void*/ Dispose()
    {
        disposeInvoke();
    }
}


const BlazorJs_Core_IRenderer = (Base) => class extends Base
{
    /*IServiceProvider*/ _backingField_Services = null;
    /*IServiceProvider*/ get Services()
    {
        return _backingField_Services;
    }
    /*IComponentActivator*/ _backingField_ComponentActivator = null;
    /*IComponentActivator*/ get ComponentActivator()
    {
        return _backingField_ComponentActivator;
    }
}

const BlazorJs_Core_IUIContent = (Base) => class extends Base
{
    /*UIFrameState*/ _backingField_State = null;
    /*UIFrameState*/ get State()
    {
        return _backingField_State;
    }
}


const BlazorJs_Core_IUIFrame = (Base) => class extends Base
{
}

class BlazorJs_Core_IUIFrameExtension extends object
{
    constructor()
    {
        super();
    }
    /*IUIContent*/ GetBefore(/*IUIContent*/ reference)
    {
        /*var*/ let siblings = reference.State.ParentFrameState.Children;
        if (siblings == null)
        return null;
        if (siblings.Any(function(/**/ s)
        {
s != null && s.State.Id  < reference.State.Id        }))
        return null;
        /*var*/ let before = siblings.Where(function(/**/ s)
        {
s != null && s.State.Id  < reference.State.Id        }).MaxBy(function(/**/ s)
        {
s.State.Id        });
        return before;
    }
    /*IUIContent*/ GetAfter(/*IUIContent*/ reference)
    {
        /*var*/ let siblings = reference.State.ParentFrameState.Children;
        if (siblings == null)
        return null;
        if (siblings.Any(function(/**/ s)
        {
s != null && s.State.Id  > reference.State.Id        }))
        return null;
        /*var*/ let after = siblings.Where(function(/**/ s)
        {
s != null && s.State.Id  > reference.State.Id        }).MinBy(function(/**/ s)
        {
s.State.Id        });
        return after;
    }
    /*HTMLElement*/ Element(/*IUIFrame*/ frame, /*string*/ tag, { /*ElementAttributeBuilder*/ attributeBuilder = null, /*RenderFragment*/ contentBuilder = null, /*object*/ key = null, /*int*/ sequenceNumber = 0})
    {
        do        {
            /*var*/ let uiElement = frame.State.GetOrCreate(sequenceNumber, function(/**/ id)
            {
                /*var*/ let muiElement = new UIElement(frame.State.Renderer, frame, id, tag, key);
                return muiElement;
            }, key);
            if (uiElement.Tag  != tag)
            {
                uiElement.Dispose();
            }
            uiElement.AttributeBuilder  = attributeBuilder;
            uiElement.ContentBuilder  = contentBuilder;
            //uiElement.TearDown = tearDown;
                uiElement.Build(key);
            return uiElement.Elements0.As(HTMLElement);
        } while(true);
    }
    /*Node*/ Text(/*IUIFrame*/ frame, /*object*/ text, { /*object*/ key = null, /*int*/ sequenceNumber = 0})
    {
        /*var*/ let uiText = frame.State.GetOrCreate(sequenceNumber, function(/**/ id)
        {
            /*var*/ let muiText = new UIText(frame.State.Renderer, frame, id, key);
            return muiText;
        }, key);
        uiText.Text  = text;
        uiText.Build(key);
        return uiText.Elements0.As(Node);
    }
    /*Node*/ Text(/*IUIFrame*/ frame, /*Func<object>*/ text, { /*object*/ key = null, /*int*/ sequenceNumber = 0})
    {
        /*var*/ let uiText = frame.State.GetOrCreate(sequenceNumber, function(/**/ id)
        {
            /*var*/ let muiText = new UIText(frame.State.Renderer, frame, id, key);
            return muiText;
        }, key);
        uiText.Text  = text;
        uiText.Build(key);
        return uiText.Elements0.As(Node);
    }
    /*void*/ Fragment(/*IUIFrame*/ frame, /*RenderFragment*/ view)
    {
        viewInvoke(frame);
    }
    /*void*/ Frame(/*IUIFrame*/ frame, /*RenderFragment*/ view, { /*object*/ key = null, /*int*/ sequenceNumber = 0})
    {
        /*var*/ let uiFrame = frame.State.GetOrCreate(sequenceNumber, function(/**/ id)
        {
            /*var*/ let muiFrame = new UIFrame(frame, view, key, id);
            return muiFrame;
        }, key);
        uiFrame.ContentBuilder  = view;
        uiFrame.Build(key);
    }
    /*Node[]*/ Markup(/*IUIFrame*/ frame, /*MarkupString*/ view, { /*object*/ key = null, /*int*/ sequenceNumber = 0})
    {
        /*var*/ let uiMarkup = frame.State.GetOrCreate(sequenceNumber, function(/**/ id)
        {
            /*var*/ let muiMarkup = new UIMarkup(frame.State.Renderer, frame, id, view.Html, key);
            return muiMarkup;
        }, key);
        uiMarkup.Markup  = view.Html;
        uiMarkup.Build(key);
        return uiMarkup.Elements.As(Node[]);
    }
    /*void*/ Content(T, /*IUIFrame*/ frame, /*T*/ content, { /*object*/ key = null, /*int*/ sequenceNumber = 0})
    {
        if (T == RenderFragment)
        {
            //if (key == null)
                //{
                //    Fragment(frame, (RenderFragment)(object)content);
                //    return null;
                //}
                //else
                //{
                Frame(frame, RenderFragmentcontent, { key : key, sequenceNumber : sequenceNumber });
        }
        else if (T == MarkupString)
        {
            Markup(frame, MarkupStringcontent, { key : key, sequenceNumber : sequenceNumber });
        }
        else 
        {
            Text(frame, content, { key : key, sequenceNumber : sequenceNumber });
        }
    }
    /*IComponent*/ Component(/*IUIFrame*/ frame, /*Type*/ componentType, /*Action<IComponent>*/ attributeBuilder, { /*object*/ key = null, /*int*/ sequenceNumber = 0})
    {
        do        {
            /*var*/ let state = frame.State.GetOrCreate(sequenceNumber, function(/**/ id)
            {
                /*var*/ let renderer = BrowserNativeRendererframe.State.Renderer;
                /*var*/ let mcomponent = renderer.ComponentActivator.CreateInstance(componentType);
                /*var*/ let mstate = new UIFrameState(renderer, frame, id, key);
                mstate.Component  = mcomponent;
                mstate.ComponentType  = componentType;
                mcomponent.Attach(new RenderHandle(renderer, id));
                renderer.Register(id, mstate);
                if (mcomponent instanceof ComponentBase, mcb = mcomponent)
                {
                    mcb.WithErrorHandling(function(/**/ icomponent)
                    {
                        icomponent.InjectServices(renderer.Services);
                        icomponent.CascadeParameters();
                    }, ComponentLifeCycle.OnInjectingService);
                }
                renderer.CreateComponent(mcomponent);
                return mstate;
            }, key);
            if (state.ComponentType  != componentType)
            {
                state.Dispose();
            }
            attributeBuilderInvoke(state.Component);
            /*Task*/ let task = state.Component.SetParametersAsync(default);
            return state.Component;
        } while(true);
    }
    /*T*/ Component(T, /*IUIFrame*/ frame, /*Action<T>*/ attributeBuilder, { /*object*/ key = null, /*int*/ sequenceNumber = 0})
    {
        return Tframe.Component(T, attributeBuilder != nullfunction(/**/ ab)
        {
attributeBuilder(Tab)        }Action_$1null, key, sequenceNumber);
    }
    /*T*/ InferType(TComponent, T, /*IUIFrame*/ context, /*T*/ property, /*T*/ value, /*string*/ expression)
    {
        return value;
    }
}

class BlazorJs_Core_ThrowHelperExtension extends object
{
    constructor()
    {
        super();
    }
    /*void*/ ThrowIfNull(/*object*/ argument, { /*string*/ paramName = null})
    {
        if (argument == null)
        {
            Throw(paramName);
        }
    }
    /*void*/ Throw(/*string*/ paramName)
    {
        throw new ArgumentNullException(paramName);
    }
    /*string*/ IfNullOrWhitespace(/*string*/ argument, { /*string*/ paramName = ""})
    {
        if (.IsNullOrWhiteSpace(argument))
        {
            if (argument == null)
            {
                throw new ArgumentNullException(paramName);
            }
            throw new ArgumentException(paramName, "Argument is whitespace");
        }
        return argument;
    }
}

UIElementAttributeclass BlazorJs_Core_UIElement extends System_IDisposable(BlazorJs_Core_IUIContent(BlazorJs_Core_IUIFrame(BlazorJs_Core_UIFrameState)))
{
    /*string*/ Tag = null;
    /*ElementAttributeBuilder*/ _backingField_AttributeBuilder = null;
    /*ElementAttributeBuilder*/ get AttributeBuilder()
    {
        return _backingField_AttributeBuilder;
    }
    /*ElementAttributeBuilder*/ set AttributeBuilder(value)
    {
        _backingField_AttributeBuilder = value;
    }
    /*RenderFragment*/ _backingField_ContentBuilder = null;
    /*RenderFragment*/ get ContentBuilder()
    {
        return _backingField_ContentBuilder;
    }
    /*RenderFragment*/ set ContentBuilder(value)
    {
        _backingField_ContentBuilder = value;
    }
    constructor(/*IRenderer*/ platformRenderer, /*IUIFrame*/ parent, /*int*/ id, /*string*/ tag, /*object*/ key)
    {
        super(platformRenderer, parent, id, key);
        Tag = tag;
        platformRenderer.CreateElement();
    }
    /*void*/ Build(/*object*/ key)
    {
        if (AttributeBuilder != null)
        {
            /*var*/ let attributes = new UIElementAttribute();
            let $v = { value: set(value){ attributes = value; } };
            AttributeBuilder.Invoke($v);
        }
        if (ContentBuilder != null)
        {
            TrackContents(function()
            {
                ContentBuilder.Invoke(, key);
            });
        }
    }
    /*void*/ Dispose()
    {
        super.Dispose();
        //TearDown?.Invoke();
            Renderer.RemoveElement();
    }
    /*string*/ ToString()
    {
        return Tag.Join("", Children.Select(function(/**/ v)
        {
v.ToString() ?? ""        }) ?? Enumerable.Empty(string))Tag;
    }
}

class BlazorJs_Core_UIElementAttribute extends System_ValueType
{
    /*UIElement*/ element = null;
    constructor(/*UIElement*/ _element)
    {
        super();
        .element  = _element;
    }
    {
        element.State.Renderer.SetElementAttribute(element, key, value);
    }
    /*void*/ Set(/*string*/ key, /*object*/ value)
    {
        if (key == "@attributes")
        {
            if (value instanceof IReadOnlyDictionary_$2, dic = value)
            {
                BlazorJs.forEach(dic, function(kv, $_i)
                {
                    element.State.Renderer.SetElementAttribute(element, kv.Key, kv.Value);
                });
            }
            else 
            {
                BlazorJs.forEach(.GetOwnPropertyNames(value), function(mkey, $_i)
                {
                    if (mkey.Length  > 0 && .IsLower(mkey0))
                    {
                        /*var*/ let val = valuemkey;
                        element.State.Renderer.SetElementAttribute(element, mkey, val);
                    }
                });
            }
        }
        else 
        {
            element.State.Renderer.SetElementAttribute(element, key, value);
        }
    }
    /*void*/ Set(T, /*string*/ key, /*Func<T>*/ value)
    {
        element.State.Renderer.SetElementAttribute(element, key, value());
    }
}

class BlazorJs_Core_UIFrame extends System_IDisposable(BlazorJs_Core_IUIContent(BlazorJs_Core_IUIFrame(BlazorJs_Core_UIFrameState)))
{
    /*RenderFragment*/ _backingField_ContentBuilder = null;
    /*RenderFragment*/ get ContentBuilder()
    {
        return _backingField_ContentBuilder;
    }
    /*RenderFragment*/ set ContentBuilder(value)
    {
        _backingField_ContentBuilder = value;
    }
    constructor(/*IRenderer*/ renderer)
    {
        super(renderer, null, 0, null);
        ContentBuilder = null;
    }
    constructor(/*IUIFrame*/ parent, /*RenderFragment*/ contentBuilder, /*object*/ key, /*int*/ id)
    {
        super(parent.State.Renderer, parent, id, key);
        ContentBuilder = contentBuilder;
        if (parent is UIElement && key == null)
        {
        }
        else 
        {
            Renderer.CreateRegion();
        }
    }
    /*void*/ Build(/*object*/ key)
    {
        if (ContentBuilder != null)
        {
            TrackContents(function()
            {
                ContentBuilder.Invoke(, key);
            });
        }
    }
    /*void*/ Dispose()
    {
        super.Dispose();
    }
    /*string*/ ToString()
    {
        return .Join("", Children.Select(function(/**/ v)
        {
v.ToString() ?? ""        }) ?? Enumerable.Empty(string));
    }
}

class BlazorJs_Core_UIKeyedGroup extends object
{
    constructor()
    {
        super();
    }
    /*Dictionary<object, IUIContent>*/ _backingField_Members = null;
    /*Dictionary<object, IUIContent>*/ get Members()
    {
        return _backingField_Members;
    }
}
class BlazorJs_Core_UIFrameState extends BlazorJs_Core_IUIContent(BlazorJs_Core_IUIFrame(System_IDisposable(object)))
{
    /*//Dictionary<string, object> contents;
        object*/ contents = null;
    /*IRenderer*/ _backingField_Renderer = null;
    /*IRenderer*/ get Renderer()
    {
        return _backingField_Renderer;
    }
    /*IUIFrame*/ parentFrame = null;
    /*int*/ id = null;
    /*object*/ key = null;
    /*Type*/ _backingField_ComponentType = null;
    /*Type*/ get ComponentType()
    {
        return _backingField_ComponentType;
    }
    /*Type*/ set ComponentType(value)
    {
        _backingField_ComponentType = value;
    }
    /*IComponent*/ _backingField_Component = null;
    /*IComponent*/ get Component()
    {
        return _backingField_Component;
    }
    /*IComponent*/ set Component(value)
    {
        _backingField_Component = value;
    }
    /*Node.Interface[]*/ _backingField_Elements = null;
    /*Node.Interface[]*/ get Elements()
    {
        return _backingField_Elements;
    }
    /*Node.Interface[]*/ set Elements(value)
    {
        _backingField_Elements = value;
    }
    /*int*/ _backingField_TrackedId = null;
    /*int*/ get TrackedId()
    {
        return _backingField_TrackedId;
    }
    /*int*/ set TrackedId(value)
    {
        _backingField_TrackedId = value;
    }
    constructor(/*IRenderer*/ renderer, /*IUIFrame*/ parent, /*int*/ id, /*object*/ key)
    {
        super();
        Renderer = renderer;
        .parentFrame  = parent;
        .id  = id;
        .key  = key;
    }
    /*int*/ get Id()
    {
        return id;
    }
    /*object*/ get Key()
    {
        return key;
    }
    /*IUIFrame*/ get ParentFrame()
    {
        return parentFrame;
    }
    /*IEnumerable<IUIContent>*/ get Children()
    {
        return contents == nullnull.GetOwnPropertyNames(contents).SelectMany(string, IUIContent, function(/**/ pn)
        {
            {
                /*var*/ let o = contentspn;
                if (o instanceof UIKeyedGroup, g = o)
                {
                    return g.Members.Values;
                }
                return IUIContento;
            }
        }).OrderBy(function(/**/ o)
        {
o.Stateid ?? 0        }) ?? Enumerable.Empty(IUIContent);
    }
    /*UIFrameState*/ get State()
    {
        return ;
    }
    /*int*/ trackingChildrenId = 1;
    /*T*/ SetContentTracked(T, /*T*/ content)
    {
        if (trackingChildrenId > 0 && content != null)
        {
            content.State.TrackedId  = trackingChildrenId;
        }
        return content;
    }
    /*T*/ GetOrCreate(T, /*int*/ sequenceNumber, /*Func<int, T>*/ create, { /*object*/ key = null})
    {
        if (sequenceNumber == 0)
        throw new InvalidOperationException("Sequence number cannot be zero. Must be a unique number in a frame.");
        /*var*/ let sid = sequenceNumber.ToString();
        if (contents == null)
        contents = new ();
        let t = null;
        let $v = { value: set(value){ t = value; } };
        if (contents.TryGetValue(sid, $v))
        {
            if (key != null)
            {
                /*var*/ let group = UIKeyedGroupt;
                let member = null;
                let $v = { value: set(value){ member = value; } };
                if (group.Members.TryGetValue(key, $v))
                {
                    member = create(sequenceNumber);
                    group.Memberskey = member;
                }
                return SetContentTracked(Tmember);
            }
            else 
            {
                return SetContentTracked(Tt);
            }
        }
        /*var*/ let tt = create(sequenceNumber);
        if (key != null)
        {
            /*var*/ let group = new UIKeyedGroup();
            group.Memberskey = tt;
            contentssid = group;
        }
        else 
        {
            contentssid = tt;
        }
        return SetContentTracked(Ttt);
    }
    /*void*/ Remove(/*IUIContent*/ child)
    {
        let group = null;
        let $v = { value: set(value){ group = value; } };
        if (child.State.Key  != null && contents.TryGetValue(child.State.id, $v) && group instanceof UIKeyedGroup, kgroup = group)
        {
            kgroup.Members.Remove(child.State.Key);
        }
        else 
        {
            contents.Remove(child.State.id);
        }
    }
    /*void*/ TrackContents(/*Action*/ action)
    {
        trackingChildrenId++;
        {
            action();
        }
        {
            if (Children != null)
            {
                /*var*/ let disposedChildren = Children.Where(function(/**/ c)
                {
c.State.TrackedId  != trackingChildrenId                });
                BlazorJs.forEach(disposedChildren, function(child, $_i)
                {
                    if (child != null)
                    {
                        child.Dispose();
                        contents.Remove(child.State.id);
                    }
                });
            }
        }
    }
    /*string*/ ToString()
    {
        return .Join("", ChildrenSelect(function(/**/ v)
        {
v.ToString() ?? ""        }) ?? Enumerable.Empty(string));
    }
    /*string*/ CascadingValueKey = "__CascadingValueKey__";
    class BlazorJs_Core_CascadingValueData extends object
    {
        constructor()
        {
            super();
        }
        /*object*/ _backingField_Value = null;
        /*object*/ get Value()
        {
            return _backingField_Value;
        }
        /*object*/ set Value(value)
        {
            _backingField_Value = value;
        }
        /*bool*/ _backingField_IsFixed = null;
        /*bool*/ get IsFixed()
        {
            return _backingField_IsFixed;
        }
        /*bool*/ set IsFixed(value)
        {
            _backingField_IsFixed = value;
        }
        /*string*/ _backingField_Name = null;
        /*string*/ get Name()
        {
            return _backingField_Name;
        }
        /*string*/ set Name(value)
        {
            _backingField_Name = value;
        }
        /*EventHandler<object>*/ _backingField_Handlers = null;
        /*EventHandler<object>*/ get Handlers()
        {
            return _backingField_Handlers;
        }
        /*EventHandler<object>*/ set Handlers(value)
        {
            _backingField_Handlers = value;
        }
    }
    /*void*/ SetCascadingValue(T, /*T*/ value, /*bool*/ isFixed, /*string*/ name)
    {
        /*var*/ let valueKey = CascadingValueKey + name != null"." + name"";
        /*var*/ let cascadeValue = valueKey.As(CascadingValueData) ?? new CascadingValueData()Name = nameValue = valueIsFixed = isFixed;
        valueKey = cascadeValue;
        if (isFixed)
        {
            if (cascadeValue.Handlers  != null && Utility.Equal(cascadeValue, value))
            {
                cascadeValue.Handlers.Invoke(, cascadeValue.Value);
            }
        }
    }
    /*bool*/ GetCascadingValueImpl(T, /*string*/ valueKey, /*CascadingValueData*/ value)
    {
        /*var*/ let val = valueKey.As(CascadingValueData);
        if (val != null && val.Value  instanceof T)
        {
            value = val;
            return true;
        }
        if (parentFrame != null)
        {
            let $v = { value: set(value){ value = value; } };
            return parentFrame.State.GetCascadingValueImpl(T, valueKey, $v);
        }
        value = default;
        return false;
    }
    /*IDisposable*/ SubscribeCascadingValue(T, /*EventHandler<T>*/ callback, { /*string*/ name = null})
    {
        /*var*/ let valueKey = CascadingValueKey + name != null"." + name"";
        let value = null;
        let $v = { value: set(value){ value = value; } };
        /*bool*/ let gotCurrentValue = GetCascadingValueImpl_$1(T, valueKey, $v);
        /*IDisposable*/ let dispose = null;
        if (gotCurrentValue)
        {
            if (value.IsFixed)
            {
                /*EventHandler<object>*/ let call = function(/**/ s, /**/ e)
                {
                    return callback(s, Te);
                };
                value.Handlers  += call;
                dispose = new DisposableDelegate(function()
                {
                    return value.Handlers  -= call;
                });
            }
            callback.Invoke(, Tvalue.Value);
        }
        return dispose;
    }
    /*void*/ Dispose()
    {
        if (Component instanceof IDisposable, disposable = Component)
        {
            disposable.Dispose();
        }
        if (Children != null)
        {
            BlazorJs.forEach(Children, function(child, $_i)
            {
                child.Dispose();
            });
        }
        contents = null;
        ParentFrame.State.Remove();
        BrowserNativeRendererRenderer.Remove(id);
    }
}

class BlazorJs_Core_UIMarkup extends System_IDisposable(BlazorJs_Core_IUIContent(BlazorJs_Core_IUIFrame(BlazorJs_Core_UIFrameState)))
{
    /*string*/ markup = null;
    /*string*/ oldMarkup = null;
    /*string*/ get Markup()
    {
        return markup;
    }
    /*string*/ set Markup(value)
    {
        if (value != oldMarkup)
        {
            oldMarkup = markup;
            markup = value;
        }
    }
    constructor(/*IRenderer*/ platformRenderer, /*IUIFrame*/ parent, /*int*/ id, /*string*/ markup, /*object*/ key)
    {
        super(platformRenderer, parent, id, key);
        Markup = markup;
        platformRenderer.CreateMarkup();
    }
    /*void*/ Build(/*object*/ key)
    {
        if (markup != oldMarkup)
        {
            Renderer.UpdateMarkup();
            oldMarkup = markup;
        }
    }
    /*void*/ Dispose()
    {
        super.Dispose();
        Renderer.RemoveMarkup();
    }
    /*string*/ ToString()
    {
        return Markup;
    }
}

class BlazorJs_Core_UIText extends System_IDisposable(BlazorJs_Core_IUIContent(BlazorJs_Core_UIFrameState))
{
    /*object*/ oldText = null;
    /*object*/ text = null;
    /*object*/ get Text()
    {
        return text;
    }
    /*object*/ set Text(value)
    {
        if (value == null && oldText == null)
        return ;
        if (Utility.Equal(value, oldText))
        {
            oldText = text;
            text = value;
        }
    }
    constructor(/*IRenderer*/ platformRenderer, /*IUIFrame*/ parent, /*int*/ id, /*object*/ key)
    {
        super(platformRenderer, parent, id, key);
        platformRenderer.CreateText();
    }
    /*void*/ Build(/*object*/ key)
    {
        if (Utility.Equal(text, oldText))
        {
            Renderer.UpdateText();
            oldText = text;
        }
    }
    /*void*/ Dispose()
    {
        super.Dispose();
        Renderer.RemoveText();
    }
    /*string*/ ToString()
    {
        return Text;
    }
}

class BlazorJs_Core_Utility extends object
{
    constructor()
    {
        super();
    }
    /*int*/ LiteRouter_Layout_SequenceNumber = 1;
    /*int*/ LiteRouter_Page_SequenceNumber = 2;
    /*int*/ DynamicComponent_SequenceNumber = 3;
    /*int*/ CascadingValue_SequenceNumber = 4;
    /*int*/ Router_View_SequenceNumber = 5;
    /*int*/ AuthorizeRouteView_LayoutView_SequenceNumber = 5;
    /*int*/ AuthorizeRouteView_AuthorizeRouteViewCore_SequenceNumber = 6;
    /*int*/ AuthorizeViewCore_Authorizing_SequenceNumber = 7;
    /*int*/ AuthorizeViewCore_Authorized_SequenceNumber = 8;
    /*int*/ AuthorizeViewCore_NotAuthorized_SequenceNumber = 9;
    /*int*/ LayoutView_Layout_SequenceNumber = 10;
    /*int*/ LayoutView_Fragment_SequenceNumber = 11;
    /*int*/ RouteView_LayoutView_SequenceNumber = 12;
    /*int*/ RouteView_Page_SequenceNumber = 13;
    /*int*/ Virtualize_DefaultPlaceholder_SequenceNumber = 14;
    /*int*/ Virtualize_SpacerElementBefore_SequenceNumber = 15;
    /*int*/ Virtualize_PlaceholderBefore_SequenceNumber = 16;
    /*int*/ Virtualize_EmptyContent_SequenceNumber = 17;
    /*int*/ Virtualize_Item_SequenceNumber = 18;
    /*int*/ Virtualize_PlaceholderAfter_SequenceNumber = 19;
    /*int*/ Virtualize_SpacerElementAfter_SequenceNumber = 20;
    /*int*/ ErrorBoundary_ChildContent_SequenceNumber = 21;
    /*int*/ ErrorBoundary_ErrorContent_SequenceNumber = 22;
    /*int*/ ErrorBoundary_DefaultContent_SequenceNumber = 23;
    /*void*/ FireAndForget(/*Task*/ task)
    {
        task.ContinueWith(function(/**/ t)
        {
            {
                if (t.Exception  != null)
                {
                    Console.WriteLine(t.Exception);
                }
            }
        });
    }
    /*bool*/ Equal(/*object*/ t1, /*object*/ t2)
    {
        if (t1 == null && t2 == null)
        return true;
        if (t1 == null && t2 != null || t1 != null && t2 == null || t1.Equals(t2))
        {
            return false;
        }
        return true;
    }
    /*bool*/ ContainsKey(/*object*/ container, /*string*/ propertyName)
    {
        return container.HasOwnProperty(propertyName.As(object));
    }
    /*bool*/ TryGetValue(/*object*/ container, /*string*/ propertyName, /*object*/ obj)
    {
        if (container.HasOwnProperty(propertyName.As(object)))
        {
            obj = containerpropertyName.As(string);
            return true;
        }
        obj = null;
        return false;
    }
    /*bool*/ TryGetValue(/*object*/ container, /*int*/ propertyName, /*object*/ obj)
    {
        if (container.HasOwnProperty(propertyName.As(object)))
        {
            obj = containerpropertyName.As(string);
            return true;
        }
        obj = null;
        return false;
    }
    /*void*/ SetValue(/*object*/ container, /*string*/ propertyName, /*object*/ obj)
    {
        containerpropertyName = obj;
    }
    /*void*/ SetValue(/*object*/ container, /*int*/ propertyName, /*object*/ obj)
    {
        containerpropertyName.As(string) = obj;
    }
    /*void*/ Remove(/*object*/ container, /*int*/ propertyName)
    {
        H5.Script.Delete(container, propertyName.As(string));
    }
}

class BlazorJs_Core_ValueConverter extends object
{
    constructor()
    {
        super();
    }
    /*object*/ converters = new ();
    /*int*/ Convert(/*object*/ value, /*int*/ inferType)
    {
        return .Parse(value.ToString());
    }
    /*int?*/ Convert(/*object*/ value, /*int?*/ inferType)
    {
        if (value == null || value.ToString() == "")
        return null;
        return .Parse(value.ToString());
    }
    /*double*/ Convert(/*object*/ value, /*double*/ inferType)
    {
        return .Parse(value.ToString());
    }
    /*double?*/ Convert(/*object*/ value, /*double?*/ inferType)
    {
        if (value == null || value.ToString() == "")
        return null;
        return .Parse(value.ToString());
    }
    /*string*/ Convert(/*object*/ value, /*string*/ inferType)
    {
        return value.ToString();
    }
    /*object*/ Convert(/*object*/ value, /*Type*/ type)
    {
        let converter = null;
        let $v = { value: set(value){ converter = value; } };
        if (converters.TryGetValue(type.FullName, $v))
        {
            return Delegateconverter.Call(null, value);
        }
        if (type.IsEnum)
        {
            if (value != null)
            {
                /*var*/ let i = .Parse(value.ToString());
                return i;
            }
            return default;
        }
        if (value instanceof , str = value)
        {
            if (type == )
            return value;
            /*MethodInfo*/ let method = type.GetMethod("Parse", );
            if (method != null)
            {
                return method.Invoke(null, value);
            }
        }
        throw new InvalidOperationException(type.FullName);
    }
    /*T*/ Convert(T, /*object*/ value, /*T*/ inferType)
    {
        return TConvert(value, T);
    }
    /*void*/ Register(T, /*Func<object, T>*/ converter)
    {
        convertersT.FullName = converter;
    }
}

class Microsoft_AspNetCore_Authorization_AssertionRequirement extends Microsoft_AspNetCore_Authorization_IAuthorizationRequirement(Microsoft_AspNetCore_Authorization_IAuthorizationHandler(object))
{
    /*Func<AuthorizationHandlerContext, Task<bool>>*/ _backingField_Handler = null;
    /*Func<AuthorizationHandlerContext, Task<bool>>*/ get Handler()
    {
        return _backingField_Handler;
    }
    constructor(/*Func<AuthorizationHandlerContext, bool>*/ handler)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(handler);
        Handler = function(/**/ context)
        {
Task.FromResult(handler(context))        };
    }
    constructor(/*Func<AuthorizationHandlerContext, Task<bool>>*/ handler)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(handler);
        Handler = handler;
    }
    /*Task*/ async HandleAsync(/*AuthorizationHandlerContext*/ context)
    {
        if (await Handler(context))
        {
            context.Succeed();
        }
    }
    /*string*/ ToString()
    {
        return nameof(Handler);
    }
}

class Microsoft_AspNetCore_Authorization_AuthorizationFailure extends object
{
    /*AuthorizationFailure*/ _explicitFailure = new AuthorizationFailure()FailCalled = true;
    constructor()
    {
        super();
    }
    /*bool*/ _backingField_FailCalled = null;
    /*bool*/ get FailCalled()
    {
        return _backingField_FailCalled;
    }
    /*bool*/ set FailCalled(value)
    {
        _backingField_FailCalled = value;
    }
    /*IEnumerable<IAuthorizationRequirement>*/ _backingField_FailedRequirements = null;
    /*IEnumerable<IAuthorizationRequirement>*/ get FailedRequirements()
    {
        return _backingField_FailedRequirements;
    }
    /*IEnumerable<IAuthorizationRequirement>*/ set FailedRequirements(value)
    {
        _backingField_FailedRequirements = value;
    }
    /*IEnumerable<AuthorizationFailureReason>*/ _backingField_FailureReasons = null;
    /*IEnumerable<AuthorizationFailureReason>*/ get FailureReasons()
    {
        return _backingField_FailureReasons;
    }
    /*IEnumerable<AuthorizationFailureReason>*/ set FailureReasons(value)
    {
        _backingField_FailureReasons = value;
    }
    /*AuthorizationFailure*/ ExplicitFail()
    {
        _explicitFailure;
    }
    /*AuthorizationFailure*/ Failed(/*IEnumerable<AuthorizationFailureReason>*/ reasons)
    {
        new AuthorizationFailure()FailCalled = trueFailureReasons = reasons;
    }
    /*AuthorizationFailure*/ Failed(/*IEnumerable<IAuthorizationRequirement>*/ failed)
    {
        new AuthorizationFailure()FailedRequirements = failed;
    }
}

class Microsoft_AspNetCore_Authorization_AuthorizationFailureReason extends object
{
    constructor(/*IAuthorizationHandler*/ handler, /*string*/ message)
    {
        super();
        Handler = handler;
        Message = message;
    }
    /*string*/ _backingField_Message = null;
    /*string*/ get Message()
    {
        return _backingField_Message;
    }
    /*IAuthorizationHandler*/ _backingField_Handler = null;
    /*IAuthorizationHandler*/ get Handler()
    {
        return _backingField_Handler;
    }
}

const Microsoft_AspNetCore_Authorization_AuthorizationHandler$_1 = (TRequirement) => class extends Microsoft_AspNetCore_Authorization_IAuthorizationHandler(object)
{
    constructor()
    {
        super();
        TRequirement = $_TRequirement;
    }
TRequirement    /*Task*/ async HandleAsync(/*AuthorizationHandlerContext*/ context)
    {
        BlazorJs.forEach(context.Requirements.OfType(TRequirement), function(req, $_i)
        {
            await HandleRequirementAsync(context, req);
        });
    }
}

const Microsoft_AspNetCore_Authorization_AuthorizationHandler$_2 = (TRequirement, TResource) => class extends Microsoft_AspNetCore_Authorization_IAuthorizationHandler(object)
{
    constructor()
    {
        super();
        TRequirement = $_TRequirement;
        TResource = $_TResource;
    }
TRequirement    /*Task*/ async HandleAsync(/*AuthorizationHandlerContext*/ context)
    {
        if (context.Resource  instanceof TResource)
        {
            BlazorJs.forEach(context.Requirements.OfType(TRequirement), function(req, $_i)
            {
                await HandleRequirementAsync(context, req, resource);
            });
        }
    }
}

class Microsoft_AspNetCore_Authorization_AuthorizationHandlerContext extends object
{
    /*HashSet<IAuthorizationRequirement>*/ _pendingRequirements = null;
    /*List<AuthorizationFailureReason>*/ _failedReasons = null;
    /*bool*/ _failCalled = null;
    /*bool*/ _succeedCalled = null;
    constructor(/*IEnumerable<IAuthorizationRequirement>*/ requirements, /*ClaimsPrincipal*/ user, /*object*/ resource)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(requirements);
        Requirements = requirements;
        User = user;
        Resource = resource;
        _pendingRequirements = new HashSet_$1(IAuthorizationRequirement, requirements);
    }
    /*IEnumerable<IAuthorizationRequirement>*/ _backingField_Requirements = null;
    /*IEnumerable<IAuthorizationRequirement>*/ get Requirements()
    {
        return _backingField_Requirements;
    }
    /*ClaimsPrincipal*/ _backingField_User = null;
    /*ClaimsPrincipal*/ get User()
    {
        return _backingField_User;
    }
    /*object*/ _backingField_Resource = null;
    /*object*/ get Resource()
    {
        return _backingField_Resource;
    }
    /*IEnumerable<IAuthorizationRequirement>*/ get PendingRequirements()
    {
        return _pendingRequirements;
    }
    /*IEnumerable<AuthorizationFailureReason>*/ get FailureReasons()
    {
        return IEnumerable_$1_failedReasons ?? Array.Empty(AuthorizationFailureReason);
    }
    /*bool*/ get HasFailed()
    {
        return _failCalled;
    }
    /*bool*/ get HasSucceeded()
    {
        return _failCalled && _succeedCalled && PendingRequirements.Any();
    }
    /*void*/ Fail()
    {
        _failCalled = true;
    }
    /*void*/ Fail(/*AuthorizationFailureReason*/ reason)
    {
        Fail();
        if (reason != null)
        {
            if (_failedReasons == null)
            {
                _failedReasons = new List_$1(AuthorizationFailureReason);
            }
            _failedReasons.Add(reason);
        }
    }
    /*void*/ Succeed(/*IAuthorizationRequirement*/ requirement)
    {
        _succeedCalled = true;
        _pendingRequirements.Remove(requirement);
    }
}

class Microsoft_AspNetCore_Authorization_AuthorizationPolicy extends object
{
    constructor(/*IEnumerable<IAuthorizationRequirement>*/ requirements, /*IEnumerable<string>*/ authenticationSchemes)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(requirements);
        ArgumentNullExceptionExtension.ThrowIfNull(authenticationSchemes);
        if (requirements.Any())
        {
            throw new InvalidOperationException("AuthorizationPolicyEmpty");
        }
        Requirements = new List_$1(IAuthorizationRequirement, requirements).AsReadOnly();
        AuthenticationSchemes = new List_$1(string, authenticationSchemes).AsReadOnly();
    }
    /*IReadOnlyList<IAuthorizationRequirement>*/ _backingField_Requirements = null;
    /*IReadOnlyList<IAuthorizationRequirement>*/ get Requirements()
    {
        return _backingField_Requirements;
    }
    /*IReadOnlyList<string>*/ _backingField_AuthenticationSchemes = null;
    /*IReadOnlyList<string>*/ get AuthenticationSchemes()
    {
        return _backingField_AuthenticationSchemes;
    }
    /*AuthorizationPolicy*/ Combine(/*AuthorizationPolicy[]*/ policies)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(policies);
        return Combine(IEnumerable_$1policies);
    }
    /*AuthorizationPolicy*/ Combine(/*IEnumerable<AuthorizationPolicy>*/ policies)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(policies);
        /*var*/ let builder = new AuthorizationPolicyBuilder();
        BlazorJs.forEach(policies, function(policy, $_i)
        {
            builder.Combine(policy);
        });
        return builder.Build();
    }
    /*Task<AuthorizationPolicy>*/ CombineAsync(/*IAuthorizationPolicyProvider*/ policyProvider, /*IEnumerable<IAuthorizeData>*/ authorizeData)
    {
        CombineAsync(policyProvider, authorizeData, Enumerable.Empty(AuthorizationPolicy));
    }
    /*Task<AuthorizationPolicy>*/ async CombineAsync(/*IAuthorizationPolicyProvider*/ policyProvider, /*IEnumerable<IAuthorizeData>*/ authorizeData, /*IEnumerable<AuthorizationPolicy>*/ policies)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(policyProvider);
        ArgumentNullExceptionExtension.ThrowIfNull(authorizeData);
        /*var*/ let anyPolicies = policies.Any();
        /*// Avoid allocating enumerator if the data is known to be empty
            var*/ let skipEnumeratingData = false;
        if (authorizeData instanceof IList_$1, dataList = authorizeData)
        {
            skipEnumeratingData = dataList.Count  == 0;
        }
        /*AuthorizationPolicyBuilder*/ let policyBuilder = null;
        if (skipEnumeratingData)
        {
            BlazorJs.forEach(authorizeData, function(authorizeDatum, $_i)
            {
                if (policyBuilder == null)
                {
                    policyBuilder = new AuthorizationPolicyBuilder();
                }
                /*var*/ let useDefaultPolicy = anyPolicies;
                if (.IsNullOrWhiteSpace(authorizeDatum.Policy))
                {
                    /*var*/ let policy = await policyProvider.GetPolicyAsync(authorizeDatum.Policy);
                    if (policy == null)
                    {
                        throw new InvalidOperationException(authorizeDatum.Policy);
                    }
                    policyBuilder.Combine(policy);
                    useDefaultPolicy = false;
                }
                /*var*/ let rolesSplit = authorizeDatum.RolesSplit(',');
                if (rolesSplitLength > 0)
                {
                    /*var*/ let trimmedRolesSplit = rolesSplit.Where(function(/**/ r)
                    {
.IsNullOrWhiteSpace(r)                    }).Select(function(/**/ r)
                    {
r.Trim()                    });
                    policyBuilder.RequireRole(trimmedRolesSplit);
                    useDefaultPolicy = false;
                }
                /*var*/ let authTypesSplit = authorizeDatum.AuthenticationSchemesSplit(',');
                if (authTypesSplitLength > 0)
                {
                    BlazorJs.forEach(authTypesSplit, function(authType, $_i)
                    {
                        if (.IsNullOrWhiteSpace(authType))
                        {
                            policyBuilder.AuthenticationSchemes.Add(authType.Trim());
                        }
                    });
                }
                if (useDefaultPolicy)
                {
                    policyBuilder.Combine(await policyProvider.GetDefaultPolicyAsync());
                }
            });
        }
        if (anyPolicies)
        {
            policyBuilder = policyBuilder ?? new AuthorizationPolicyBuilder();
            BlazorJs.forEach(policies, function(policy, $_i)
            {
                policyBuilder.Combine(policy);
            });
        }
        if (policyBuilder == null)
        {
            /*var*/ let fallbackPolicy = await policyProvider.GetFallbackPolicyAsync();
            if (fallbackPolicy != null)
            {
                return fallbackPolicy;
            }
        }
        return policyBuilderBuild();
    }
}

class Microsoft_AspNetCore_Authorization_AuthorizationPolicyBuilder extends object
{
    /*DenyAnonymousAuthorizationRequirement*/ _denyAnonymousAuthorizationRequirement = new DenyAnonymousAuthorizationRequirement();
    constructor(/*string[]*/ authenticationSchemes)
    {
        super();
        AddAuthenticationSchemes(authenticationSchemes);
    }
    constructor(/*AuthorizationPolicy*/ policy)
    {
        super();
        Combine(policy);
    }
    /*IList<IAuthorizationRequirement>*/ _backingField_Requirements = null;
    /*IList<IAuthorizationRequirement>*/ get Requirements()
    {
        return _backingField_Requirements;
    }
    /*IList<IAuthorizationRequirement>*/ set Requirements(value)
    {
        _backingField_Requirements = value;
    }
    /*IList<string>*/ _backingField_AuthenticationSchemes = null;
    /*IList<string>*/ get AuthenticationSchemes()
    {
        return _backingField_AuthenticationSchemes;
    }
    /*IList<string>*/ set AuthenticationSchemes(value)
    {
        _backingField_AuthenticationSchemes = value;
    }
    /*AuthorizationPolicyBuilder*/ AddAuthenticationSchemes(/*string[]*/ schemes)
    {
        AddAuthenticationSchemesCore(schemes);
    }
    /*AuthorizationPolicyBuilder*/ AddAuthenticationSchemesCore(/*IEnumerable<string>*/ schemes)
    {
        BlazorJs.forEach(schemes, function(authType, $_i)
        {
            AuthenticationSchemes.Add(authType);
        });
        return ;
    }
    /*AuthorizationPolicyBuilder*/ AddRequirements(/*IAuthorizationRequirement[]*/ requirements)
    {
        AddRequirementsCore(requirements);
    }
    /*AuthorizationPolicyBuilder*/ AddRequirementsCore(/*IEnumerable<IAuthorizationRequirement>*/ requirements)
    {
        BlazorJs.forEach(requirements, function(req, $_i)
        {
            Requirements.Add(req);
        });
        return ;
    }
    /*AuthorizationPolicyBuilder*/ Combine(/*AuthorizationPolicy*/ policy)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(policy);
        AddAuthenticationSchemesCore(policy.AuthenticationSchemes);
        AddRequirementsCore(policy.Requirements);
        return ;
    }
    /*AuthorizationPolicyBuilder*/ RequireClaim(/*string*/ claimType, /*string[]*/ allowedValues)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(claimType);
        return RequireClaim(claimType, IEnumerable_$1allowedValues);
    }
    /*AuthorizationPolicyBuilder*/ RequireClaim(/*string*/ claimType, /*IEnumerable<string>*/ allowedValues)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(claimType);
        Requirements.Add(new ClaimsAuthorizationRequirement(claimType, allowedValues));
        return ;
    }
    /*AuthorizationPolicyBuilder*/ RequireClaim(/*string*/ claimType)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(claimType);
        Requirements.Add(new ClaimsAuthorizationRequirement(claimType, { allowedValues : null }));
        return ;
    }
    /*AuthorizationPolicyBuilder*/ RequireRole(/*string[]*/ roles)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(roles);
        return RequireRole(IEnumerable_$1roles);
    }
    /*AuthorizationPolicyBuilder*/ RequireRole(/*IEnumerable<string>*/ roles)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(roles);
        Requirements.Add(new RolesAuthorizationRequirement(roles));
        return ;
    }
    /*AuthorizationPolicyBuilder*/ RequireUserName(/*string*/ userName)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(userName);
        Requirements.Add(new NameAuthorizationRequirement(userName));
        return ;
    }
    /*AuthorizationPolicyBuilder*/ RequireAuthenticatedUser()
    {
        Requirements.Add(_denyAnonymousAuthorizationRequirement);
        return ;
    }
    /*AuthorizationPolicyBuilder*/ RequireAssertion(/*Func<AuthorizationHandlerContext, bool>*/ handler)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(handler);
        Requirements.Add(new AssertionRequirement(handler));
        return ;
    }
    /*AuthorizationPolicyBuilder*/ RequireAssertion(/*Func<AuthorizationHandlerContext, Task<bool>>*/ handler)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(handler);
        Requirements.Add(new AssertionRequirement(handler));
        return ;
    }
    /*AuthorizationPolicy*/ Build()
    {
        return new AuthorizationPolicy(Requirements, AuthenticationSchemes.Distinct());
    }
}

class Microsoft_AspNetCore_Authorization_AuthorizationResult extends object
{
    /*AuthorizationResult*/ _succeededResult = new AuthorizationResult()Succeeded = true;
    /*AuthorizationResult*/ _failedResult = new AuthorizationResult()Failure = AuthorizationFailure.ExplicitFail();
    constructor()
    {
        super();
    }
    /*bool*/ _backingField_Succeeded = null;
    /*bool*/ get Succeeded()
    {
        return _backingField_Succeeded;
    }
    /*bool*/ set Succeeded(value)
    {
        _backingField_Succeeded = value;
    }
    /*AuthorizationFailure*/ _backingField_Failure = null;
    /*AuthorizationFailure*/ get Failure()
    {
        return _backingField_Failure;
    }
    /*AuthorizationFailure*/ set Failure(value)
    {
        _backingField_Failure = value;
    }
    /*AuthorizationResult*/ Success()
    {
        _succeededResult;
    }
    /*AuthorizationResult*/ Failed(/*AuthorizationFailure*/ failure)
    {
        new AuthorizationResult()Failure = failure;
    }
    /*AuthorizationResult*/ Failed()
    {
        _failedResult;
    }
}

class Microsoft_AspNetCore_Authorization_AuthorizeAttribute extends Microsoft_AspNetCore_Authorization_IAuthorizeData(System_Attribute)
{
    /*string*/ _backingField_Policy = null;
    /*string*/ get Policy()
    {
        return _backingField_Policy;
    }
    /*string*/ set Policy(value)
    {
        _backingField_Policy = value;
    }
    /*string*/ _backingField_Roles = null;
    /*string*/ get Roles()
    {
        return _backingField_Roles;
    }
    /*string*/ set Roles(value)
    {
        _backingField_Roles = value;
    }
    /*string*/ _backingField_AuthenticationSchemes = null;
    /*string*/ get AuthenticationSchemes()
    {
        return _backingField_AuthenticationSchemes;
    }
    /*string*/ set AuthenticationSchemes(value)
    {
        _backingField_AuthenticationSchemes = value;
    }
    constructor(/*string*/ policy)
    {
        super();
        Policy = policy;
    }
    constructor()
    {
        super();
    }
}

class Microsoft_AspNetCore_Authorization_ClaimsAuthorizationRequirement extends Microsoft_AspNetCore_Authorization_IAuthorizationRequirement(Microsoft_AspNetCore_Authorization_AuthorizationHandler)
{
    /*bool*/ _emptyAllowedValues = null;
    constructor(/*string*/ claimType, /*IEnumerable<string>*/ allowedValues)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(claimType);
        ClaimType = claimType;
        AllowedValues = allowedValues;
        _emptyAllowedValues = AllowedValues == null || AllowedValues.Any();
    }
    /*string*/ _backingField_ClaimType = null;
    /*string*/ get ClaimType()
    {
        return _backingField_ClaimType;
    }
    /*IEnumerable<string>*/ _backingField_AllowedValues = null;
    /*IEnumerable<string>*/ get AllowedValues()
    {
        return _backingField_AllowedValues;
    }
    /*Task*/ HandleRequirementAsync(/*AuthorizationHandlerContext*/ context, /*ClaimsAuthorizationRequirement*/ requirement)
    {
        if (context.User  != null)
        {
            /*var*/ let found = false;
            if (requirement._emptyAllowedValues)
            {
                BlazorJs.forEach(context.User.Claims, function(claim, $_i)
                {
                    if (.Equals(claim.Type, requirement.ClaimType, StringComparison.OrdinalIgnoreCase))
                    {
                        found = true;
                        break;
                    }
                });
            }
            else 
            {
                BlazorJs.forEach(context.User.Claims, function(claim, $_i)
                {
                    if (.Equals(claim.Type, requirement.ClaimType, StringComparison.OrdinalIgnoreCase) && requirement.AllowedValues.Contains(claim.Value, StringComparer.Ordinal))
                    {
                        found = true;
                        break;
                    }
                });
            }
            if (found)
            {
                context.Succeed(requirement);
            }
        }
        return Task.CompletedTask;
    }
    /*string*/ ToString()
    {
        /*var*/ let value = _emptyAllowedValues.Empty
.Join("|", AllowedValues);
        return nameof(ClaimsAuthorizationRequirement)ClaimTypevalue;
    }
}

class Microsoft_AspNetCore_Authorization_DenyAnonymousAuthorizationRequirement extends Microsoft_AspNetCore_Authorization_IAuthorizationRequirement(Microsoft_AspNetCore_Authorization_AuthorizationHandler)
{
    constructor()
    {
        super();
    }
    /*Task*/ HandleRequirementAsync(/*AuthorizationHandlerContext*/ context, /*DenyAnonymousAuthorizationRequirement*/ requirement)
    {
        /*var*/ let user = context.User;
        /*var*/ let userIsAnonymous = userIdentity == null || user.Identities.Any(function(/**/ i)
        {
i.IsAuthenticated        });
        if (userIsAnonymous)
        {
            context.Succeed(requirement);
        }
        return Task.CompletedTask;
    }
    /*string*/ ToString()
    {
        return nameof(DenyAnonymousAuthorizationRequirement);
    }
}

const Microsoft_AspNetCore_Authorization_IAllowAnonymous = (Base) => class extends Base
{
}

const Microsoft_AspNetCore_Authorization_IAuthorizationHandler = (Base) => class extends Base
{
}

const Microsoft_AspNetCore_Authorization_IAuthorizationPolicyProvider = (Base) => class extends Base
{
}

const Microsoft_AspNetCore_Authorization_IAuthorizationRequirement = (Base) => class extends Base
{
}

const Microsoft_AspNetCore_Authorization_IAuthorizationService = (Base) => class extends Base
{
}

const Microsoft_AspNetCore_Authorization_IAuthorizeData = (Base) => class extends Base
{
    /*//
        // Summary:
        //     Gets or sets the policy name that determines access to the resource.
        string*/ _backingField_Policy = null;
    /*//
        // Summary:
        //     Gets or sets the policy name that determines access to the resource.
        string*/ get Policy()
    {
        return _backingField_Policy;
    }
    /*//
        // Summary:
        //     Gets or sets the policy name that determines access to the resource.
        string*/ set Policy(value)
    {
        _backingField_Policy = value;
    }
    /*//
        // Summary:
        //     Gets or sets a comma delimited list of roles that are allowed to access the resource.
        string*/ _backingField_Roles = null;
    /*//
        // Summary:
        //     Gets or sets a comma delimited list of roles that are allowed to access the resource.
        string*/ get Roles()
    {
        return _backingField_Roles;
    }
    /*//
        // Summary:
        //     Gets or sets a comma delimited list of roles that are allowed to access the resource.
        string*/ set Roles(value)
    {
        _backingField_Roles = value;
    }
    /*//
        // Summary:
        //     Gets or sets a comma delimited list of schemes from which user information is
        //     constructed.
        string*/ _backingField_AuthenticationSchemes = null;
    /*//
        // Summary:
        //     Gets or sets a comma delimited list of schemes from which user information is
        //     constructed.
        string*/ get AuthenticationSchemes()
    {
        return _backingField_AuthenticationSchemes;
    }
    /*//
        // Summary:
        //     Gets or sets a comma delimited list of schemes from which user information is
        //     constructed.
        string*/ set AuthenticationSchemes(value)
    {
        _backingField_AuthenticationSchemes = value;
    }
}

class Microsoft_AspNetCore_Authorization_NameAuthorizationRequirement extends Microsoft_AspNetCore_Authorization_IAuthorizationRequirement(Microsoft_AspNetCore_Authorization_AuthorizationHandler)
{
    constructor(/*string*/ requiredName)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(requiredName);
        RequiredName = requiredName;
    }
    /*string*/ _backingField_RequiredName = null;
    /*string*/ get RequiredName()
    {
        return _backingField_RequiredName;
    }
    /*Task*/ HandleRequirementAsync(/*AuthorizationHandlerContext*/ context, /*NameAuthorizationRequirement*/ requirement)
    {
        if (context.User  != null)
        {
            /*var*/ let succeed = false;
            BlazorJs.forEach(context.User.Identities, function(identity, $_i)
            {
                if (.Equals(identity.Name, requirement.RequiredName, StringComparison.Ordinal))
                {
                    succeed = true;
                    break;
                }
            });
            if (succeed)
            {
                context.Succeed(requirement);
            }
        }
        return Task.CompletedTask;
    }
    /*string*/ ToString()
    {
        return nameof(NameAuthorizationRequirement)RequiredName;
    }
}

class Microsoft_AspNetCore_Authorization_RolesAuthorizationRequirement extends Microsoft_AspNetCore_Authorization_IAuthorizationRequirement(Microsoft_AspNetCore_Authorization_AuthorizationHandler)
{
    constructor(/*IEnumerable<string>*/ allowedRoles)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(allowedRoles);
        if (allowedRoles.Any())
        {
            throw new InvalidOperationException("RoleRequirementEmpty");
        }
        AllowedRoles = allowedRoles;
    }
    /*IEnumerable<string>*/ _backingField_AllowedRoles = null;
    /*IEnumerable<string>*/ get AllowedRoles()
    {
        return _backingField_AllowedRoles;
    }
    /*Task*/ HandleRequirementAsync(/*AuthorizationHandlerContext*/ context, /*RolesAuthorizationRequirement*/ requirement)
    {
        if (context.User  != null)
        {
            /*var*/ let found = false;
            BlazorJs.forEach(requirement.AllowedRoles, function(role, $_i)
            {
                if (context.User.IsInRole(role))
                {
                    found = true;
                    break;
                }
            });
            if (found)
            {
                context.Succeed(requirement);
            }
        }
        return Task.CompletedTask;
    }
    /*string*/ ToString()
    {
        /*var*/ let roles = .Join("|", AllowedRoles);
        return nameof(RolesAuthorizationRequirement)roles;
    }
}

class Microsoft_AspNetCore_Components_BindConverter extends object
{
    constructor()
    {
        super();
    }
    /*object*/ BoxedTrue = true;
    /*object*/ BoxedFalse = false;
TCultureInfoCultureInfoTCultureInfoT    /*string*/ FormatValue(/*string*/ value, { /*CultureInfo*/ culture = null})
    {
        FormatStringValueCore(value, culture);
    }
    /*string*/ FormatStringValueCore(/*string*/ value, /*CultureInfo*/ _)
    {
        return value;
    }
    /*bool*/ FormatValue(/*bool*/ value, { /*CultureInfo*/ culture = null})
    {
        return value;
    }
    /*object*/ FormatBoolValueCore(/*bool*/ value, /*CultureInfo*/ _)
    {
        return valueBoxedTrueBoxedFalse;
    }
    /*bool?*/ FormatValue(/*bool?*/ value, { /*CultureInfo*/ culture = null})
    {
        return value == nullnullvalue.Value;
    }
    /*object*/ FormatNullableBoolValueCore(/*bool?*/ value, /*CultureInfo*/ _)
    {
        return value == nullnullvalue.Value BoxedTrueBoxedFalse;
    }
    /*string*/ FormatValue(/*int*/ value, { /*CultureInfo*/ culture = null})
    {
        FormatIntValueCore(value, culture);
    }
    /*string*/ FormatIntValueCore(/*int*/ value, /*CultureInfo*/ culture)
    {
        return value.ToString();
    }
    /*string*/ FormatValue(/*int?*/ value, { /*CultureInfo*/ culture = null})
    {
        FormatNullableIntValueCore(value, culture);
    }
    /*string*/ FormatNullableIntValueCore(/*int?*/ value, /*CultureInfo*/ culture)
    {
        if (value == null)
        {
            return null;
        }
        return value.Value.ToString();
    }
    /*string*/ FormatValue(/*long*/ value, { /*CultureInfo*/ culture = null})
    {
        FormatLongValueCore(value, culture);
    }
    /*string*/ FormatLongValueCore(/*long*/ value, /*CultureInfo*/ culture)
    {
        return value.ToString();
    }
    /*string*/ FormatValue(/*long?*/ value, { /*CultureInfo*/ culture = null})
    {
        FormatNullableLongValueCore(value, culture);
    }
    /*string*/ FormatNullableLongValueCore(/*long?*/ value, /*CultureInfo*/ culture)
    {
        if (value == null)
        {
            return null;
        }
        return value.Value.ToString();
    }
    /*string*/ FormatValue(/*short*/ value, { /*CultureInfo*/ culture = null})
    {
        FormatShortValueCore(value, culture);
    }
    /*string*/ FormatShortValueCore(/*short*/ value, /*CultureInfo*/ culture)
    {
        return value.ToString();
    }
    /*string*/ FormatValue(/*short?*/ value, { /*CultureInfo*/ culture = null})
    {
        FormatNullableShortValueCore(value, culture);
    }
    /*string*/ FormatNullableShortValueCore(/*short?*/ value, /*CultureInfo*/ culture)
    {
        if (value == null)
        {
            return null;
        }
        return value.Value.ToString();
    }
    /*string*/ FormatValue(/*float*/ value, { /*CultureInfo*/ culture = null})
    {
        FormatFloatValueCore(value, culture);
    }
    /*string*/ FormatFloatValueCore(/*float*/ value, /*CultureInfo*/ culture)
    {
        return value.ToString();
    }
    /*string*/ FormatValue(/*float?*/ value, { /*CultureInfo*/ culture = null})
    {
        FormatNullableFloatValueCore(value, culture);
    }
    /*string*/ FormatNullableFloatValueCore(/*float?*/ value, /*CultureInfo*/ culture)
    {
        if (value == null)
        {
            return null;
        }
        return value.Value.ToString();
    }
    /*string*/ FormatValue(/*double*/ value, { /*CultureInfo*/ culture = null})
    {
        FormatDoubleValueCore(value, culture);
    }
    /*string*/ FormatDoubleValueCore(/*double*/ value, /*CultureInfo*/ culture)
    {
        return value.ToString();
    }
    /*string*/ FormatValue(/*double?*/ value, { /*CultureInfo*/ culture = null})
    {
        FormatNullableDoubleValueCore(value, culture);
    }
    /*string*/ FormatNullableDoubleValueCore(/*double?*/ value, /*CultureInfo*/ culture)
    {
        if (value == null)
        {
            return null;
        }
        return value.Value.ToString();
    }
    /*string*/ FormatValue(/*decimal*/ value, { /*CultureInfo*/ culture = null})
    {
        FormatDecimalValueCore(value, culture);
    }
    /*string*/ FormatDecimalValueCore(/*decimal*/ value, /*CultureInfo*/ culture)
    {
        return value.ToString();
    }
    /*string*/ FormatValue(/*decimal?*/ value, { /*CultureInfo*/ culture = null})
    {
        FormatNullableDecimalValueCore(value, culture);
    }
    /*string*/ FormatNullableDecimalValueCore(/*decimal?*/ value, /*CultureInfo*/ culture)
    {
        if (value == null)
        {
            return null;
        }
        return value.Value.ToString();
    }
    /*string*/ FormatValue(/*DateTime*/ value, { /*CultureInfo*/ culture = null})
    {
        FormatDateTimeValueCore(value, null, culture);
    }
    /*string*/ FormatValue(/*DateTime*/ value, /*string*/ format, { /*CultureInfo*/ culture = null})
    {
        FormatDateTimeValueCore(value, format, culture);
    }
    /*string*/ FormatDateTimeValueCore(/*DateTime*/ value, /*string*/ format, /*CultureInfo*/ culture)
    {
        if (format != null)
        {
            return value.ToString(format/*, culture ?? CultureInfo.CurrentCulture*/);
        }
        return value.ToString();
    }
    /*string*/ FormatDateTimeValueCore(/*DateTime*/ value, /*CultureInfo*/ culture)
    {
        return value.ToString();
    }
    /*string*/ FormatValue(/*DateTime?*/ value, { /*CultureInfo*/ culture = null})
    {
        FormatNullableDateTimeValueCore(value, null, culture);
    }
    /*string*/ FormatValue(/*DateTime?*/ value, /*string*/ format, { /*CultureInfo*/ culture = null})
    {
        FormatNullableDateTimeValueCore(value, format, culture);
    }
    /*string*/ FormatNullableDateTimeValueCore(/*DateTime?*/ value, /*string*/ format, /*CultureInfo*/ culture)
    {
        if (value == null)
        {
            return null;
        }
        if (format != null)
        {
            return value.Value.ToString(format/*, culture ?? CultureInfo.CurrentCulture*/);
        }
        return value.Value.ToString();
    }
    /*string*/ FormatNullableDateTimeValueCore(/*DateTime?*/ value, /*CultureInfo*/ culture)
    {
        if (value == null)
        {
            return null;
        }
        return value.Value.ToString();
    }
    /*string*/ FormatValue(/*DateTimeOffset*/ value, { /*CultureInfo*/ culture = null})
    {
        FormatDateTimeOffsetValueCore(value, null, culture);
    }
    /*string*/ FormatValue(/*DateTimeOffset*/ value, /*string*/ format, { /*CultureInfo*/ culture = null})
    {
        FormatDateTimeOffsetValueCore(value, format, culture);
    }
    /*string*/ FormatDateTimeOffsetValueCore(/*DateTimeOffset*/ value, /*string*/ format, /*CultureInfo*/ culture)
    {
        if (format != null)
        {
            return value.ToString(format/*, culture ?? CultureInfo.CurrentCulture*/);
        }
        return value.ToString();
    }
    /*string*/ FormatDateTimeOffsetValueCore(/*DateTimeOffset*/ value, /*CultureInfo*/ culture)
    {
        return value.ToString();
    }
    /*string*/ FormatValue(/*DateTimeOffset?*/ value, { /*CultureInfo*/ culture = null})
    {
        FormatNullableDateTimeOffsetValueCore(value, null, culture);
    }
    /*string*/ FormatValue(/*DateTimeOffset?*/ value, /*string*/ format, { /*CultureInfo*/ culture = null})
    {
        FormatNullableDateTimeOffsetValueCore(value, format, culture);
    }
    /*string*/ FormatNullableDateTimeOffsetValueCore(/*DateTimeOffset?*/ value, /*string*/ format, /*CultureInfo*/ culture)
    {
        if (value == null)
        {
            return null;
        }
        if (format != null)
        {
            return value.Value.ToString(format/*, culture ?? CultureInfo.CurrentCulture*/);
        }
        return value.Value.ToString();
    }
    /*string*/ FormatNullableDateTimeOffsetValueCore(/*DateTimeOffset?*/ value, /*CultureInfo*/ culture)
    {
        if (value == null)
        {
            return null;
        }
        return value.Value.ToString();
    }
    /*string*/ FormatEnumValueCore(T, /*T*/ value, /*CultureInfo*/ _)
    {
        if (value == null)
        {
            return null;
        }
        return value.ToString();
    }
    /*object*/ FormatValue(T, /*T*/ value, { /*CultureInfo*/ culture = null})
    {
        /*var*/ let formatter = FormatterDelegateCache.Get(T);
        return formatter(value, culture);
    }
    /*bool*/ TryConvertToString(/*object*/ obj, /*CultureInfo*/ culture, /*string*/ value)
    {
        let $v = { value: set(value){ value = value; } };
        return ConvertToStringCore(obj, culture, $v);
    }
    /*BindParser<string>*/ ConvertToString = ConvertToStringCore;
    /*bool*/ ConvertToStringCore(/*object*/ obj, /*CultureInfo*/ culture, /*string*/ value)
    {
        // We expect the input to already be a string.
            value = obj;
        return true;
    }
    /*bool*/ TryConvertToBool(/*object*/ obj, /*CultureInfo*/ culture, /*bool*/ value)
    {
        let $v = { value: set(value){ value = value; } };
        return ConvertToBoolCore(obj, culture, $v);
    }
    /*bool*/ TryConvertToNullableBool(/*object*/ obj, /*CultureInfo*/ culture, /*bool?*/ value)
    {
        let $v = { value: set(value){ value = value; } };
        return ConvertToNullableBoolCore(obj, culture, $v);
    }
    /*BindParser<bool>*/ ConvertToBool = ConvertToBoolCore;
    /*BindParser<bool?>*/ ConvertToNullableBool = ConvertToNullableBoolCore;
    /*bool*/ ConvertToBoolCore(/*object*/ obj, /*CultureInfo*/ culture, /*bool*/ value)
    {
        // We expect the input to already be a bool.
            value = obj;
        return true;
    }
    /*bool*/ ConvertToNullableBoolCore(/*object*/ obj, /*CultureInfo*/ culture, /*bool?*/ value)
    {
        // We expect the input to already be a bool.
            value = obj;
        return true;
    }
    /*bool*/ TryConvertToInt(/*object*/ obj, /*CultureInfo*/ culture, /*int*/ value)
    {
        let $v = { value: set(value){ value = value; } };
        return ConvertToIntCore(obj, culture, $v);
    }
    /*bool*/ TryConvertToNullableInt(/*object*/ obj, /*CultureInfo*/ culture, /*int?*/ value)
    {
        let $v = { value: set(value){ value = value; } };
        return ConvertToNullableIntCore(obj, culture, $v);
    }
    /*BindParser<int>*/ ConvertToInt = ConvertToIntCore;
    /*BindParser<int?>*/ ConvertToNullableInt = ConvertToNullableIntCore;
    /*bool*/ ConvertToIntCore(/*object*/ obj, /*CultureInfo*/ culture, /*int*/ value)
    {
        /*var*/ let text = obj;
        if (.IsNullOrEmpty(text))
        {
            value = default;
            return false;
        }
        let converted = null;
        let $v = { value: set(value){ converted = value; } };
        if (.TryParse(text/*, NumberStyles.Number, culture ?? CultureInfo.CurrentCulture*/, $v))
        {
            value = default;
            return false;
        }
        value = converted;
        return true;
    }
    /*bool*/ ConvertToNullableIntCore(/*object*/ obj, /*CultureInfo*/ culture, /*int?*/ value)
    {
        /*var*/ let text = obj;
        if (.IsNullOrEmpty(text))
        {
            value = default;
            return true;
        }
        let converted = null;
        let $v = { value: set(value){ converted = value; } };
        if (.TryParse(text/*, NumberStyles.Number, culture ?? CultureInfo.CurrentCulture*/, $v))
        {
            value = default;
            return false;
        }
        value = converted;
        return true;
    }
    /*bool*/ TryConvertToLong(/*object*/ obj, /*CultureInfo*/ culture, /*long*/ value)
    {
        let $v = { value: set(value){ value = value; } };
        return ConvertToLongCore(obj, culture, $v);
    }
    /*bool*/ TryConvertToNullableLong(/*object*/ obj, /*CultureInfo*/ culture, /*long?*/ value)
    {
        let $v = { value: set(value){ value = value; } };
        return ConvertToNullableLongCore(obj, culture, $v);
    }
    /*BindParser<long>*/ ConvertToLong = ConvertToLongCore;
    /*BindParser<long?>*/ ConvertToNullableLong = ConvertToNullableLongCore;
    /*bool*/ ConvertToLongCore(/*object*/ obj, /*CultureInfo*/ culture, /*long*/ value)
    {
        /*var*/ let text = obj;
        if (.IsNullOrEmpty(text))
        {
            value = default;
            return false;
        }
        let converted = null;
        let $v = { value: set(value){ converted = value; } };
        if (.TryParse(text/*, NumberStyles.Number, culture ?? CultureInfo.CurrentCulture*/, $v))
        {
            value = default;
            return false;
        }
        value = converted;
        return true;
    }
    /*bool*/ ConvertToNullableLongCore(/*object*/ obj, /*CultureInfo*/ culture, /*long?*/ value)
    {
        /*var*/ let text = obj;
        if (.IsNullOrEmpty(text))
        {
            value = default;
            return true;
        }
        let converted = null;
        let $v = { value: set(value){ converted = value; } };
        if (.TryParse(text/*, NumberStyles.Number, culture ?? CultureInfo.CurrentCulture*/, $v))
        {
            value = default;
            return false;
        }
        value = converted;
        return true;
    }
    /*bool*/ TryConvertToShort(/*object*/ obj, /*CultureInfo*/ culture, /*short*/ value)
    {
        let $v = { value: set(value){ value = value; } };
        return ConvertToShortCore(obj, culture, $v);
    }
    /*bool*/ TryConvertToNullableShort(/*object*/ obj, /*CultureInfo*/ culture, /*short?*/ value)
    {
        let $v = { value: set(value){ value = value; } };
        return ConvertToNullableShort(obj, culture, $v);
    }
    /*BindParser<short>*/ ConvertToShort = ConvertToShortCore;
    /*BindParser<short?>*/ ConvertToNullableShort = ConvertToNullableShortCore;
    /*bool*/ ConvertToShortCore(/*object*/ obj, /*CultureInfo*/ culture, /*short*/ value)
    {
        /*var*/ let text = obj;
        if (.IsNullOrEmpty(text))
        {
            value = default;
            return false;
        }
        let converted = null;
        let $v = { value: set(value){ converted = value; } };
        if (.TryParse(text/*, NumberStyles.Number, culture ?? CultureInfo.CurrentCulture*/, $v))
        {
            value = default;
            return false;
        }
        value = converted;
        return true;
    }
    /*bool*/ ConvertToNullableShortCore(/*object*/ obj, /*CultureInfo*/ culture, /*short?*/ value)
    {
        /*var*/ let text = obj;
        if (.IsNullOrEmpty(text))
        {
            value = default;
            return true;
        }
        let converted = null;
        let $v = { value: set(value){ converted = value; } };
        if (.TryParse(text/*, NumberStyles.Number, culture ?? CultureInfo.CurrentCulture*/, $v))
        {
            value = default;
            return false;
        }
        value = converted;
        return true;
    }
    /*bool*/ TryConvertToFloat(/*object*/ obj, /*CultureInfo*/ culture, /*float*/ value)
    {
        let $v = { value: set(value){ value = value; } };
        return ConvertToFloatCore(obj, culture, $v);
    }
    /*bool*/ TryConvertToNullableFloat(/*object*/ obj, /*CultureInfo*/ culture, /*float?*/ value)
    {
        let $v = { value: set(value){ value = value; } };
        return ConvertToNullableFloatCore(obj, culture, $v);
    }
    /*BindParser<float>*/ ConvertToFloat = ConvertToFloatCore;
    /*BindParser<float?>*/ ConvertToNullableFloat = ConvertToNullableFloatCore;
    /*bool*/ ConvertToFloatCore(/*object*/ obj, /*CultureInfo*/ culture, /*float*/ value)
    {
        /*var*/ let text = obj;
        if (.IsNullOrEmpty(text))
        {
            value = default;
            return false;
        }
        let converted = null;
        let $v = { value: set(value){ converted = value; } };
        if (.TryParse(text/*, NumberStyles.Number, culture ?? CultureInfo.CurrentCulture*/, $v))
        {
            value = default;
            return false;
        }
        if (.IsInfinity(converted) || .IsNaN(converted))
        {
            value = default;
            return false;
        }
        value = converted;
        return true;
    }
    /*bool*/ ConvertToNullableFloatCore(/*object*/ obj, /*CultureInfo*/ culture, /*float?*/ value)
    {
        /*var*/ let text = obj;
        if (.IsNullOrEmpty(text))
        {
            value = default;
            return true;
        }
        let converted = null;
        let $v = { value: set(value){ converted = value; } };
        if (.TryParse(text/*, NumberStyles.Number, culture ?? CultureInfo.CurrentCulture*/, $v))
        {
            value = default;
            return false;
        }
        if (.IsInfinity(converted) || .IsNaN(converted))
        {
            value = default;
            return false;
        }
        value = converted;
        return true;
    }
    /*bool*/ TryConvertToDouble(/*object*/ obj, /*CultureInfo*/ culture, /*double*/ value)
    {
        let $v = { value: set(value){ value = value; } };
        return ConvertToDoubleCore(obj, culture, $v);
    }
    /*bool*/ TryConvertToNullableDouble(/*object*/ obj, /*CultureInfo*/ culture, /*double?*/ value)
    {
        let $v = { value: set(value){ value = value; } };
        return ConvertToNullableDoubleCore(obj, culture, $v);
    }
    /*BindParser<double>*/ ConvertToDoubleDelegate = ConvertToDoubleCore;
    /*BindParser<double?>*/ ConvertToNullableDoubleDelegate = ConvertToNullableDoubleCore;
    /*bool*/ ConvertToDoubleCore(/*object*/ obj, /*CultureInfo*/ culture, /*double*/ value)
    {
        /*var*/ let text = obj;
        if (.IsNullOrEmpty(text))
        {
            value = default;
            return false;
        }
        let converted = null;
        let $v = { value: set(value){ converted = value; } };
        if (.TryParse(text/*, NumberStyles.Number, culture ?? CultureInfo.CurrentCulture*/, $v))
        {
            value = default;
            return false;
        }
        if (.IsInfinity(converted) || .IsNaN(converted))
        {
            value = default;
            return false;
        }
        value = converted;
        return true;
    }
    /*bool*/ ConvertToNullableDoubleCore(/*object*/ obj, /*CultureInfo*/ culture, /*double?*/ value)
    {
        /*var*/ let text = obj;
        if (.IsNullOrEmpty(text))
        {
            value = default;
            return true;
        }
        let converted = null;
        let $v = { value: set(value){ converted = value; } };
        if (.TryParse(text/*, NumberStyles.Number, culture ?? CultureInfo.CurrentCulture*/, $v))
        {
            value = default;
            return false;
        }
        if (.IsInfinity(converted) || .IsNaN(converted))
        {
            value = default;
            return false;
        }
        value = converted;
        return true;
    }
    /*bool*/ TryConvertToDecimal(/*object*/ obj, /*CultureInfo*/ culture, /*decimal*/ value)
    {
        let $v = { value: set(value){ value = value; } };
        return ConvertToDecimalCore(obj, culture, $v);
    }
    /*bool*/ TryConvertToNullableDecimal(/*object*/ obj, /*CultureInfo*/ culture, /*decimal?*/ value)
    {
        let $v = { value: set(value){ value = value; } };
        return ConvertToNullableDecimalCore(obj, culture, $v);
    }
    /*BindParser<decimal>*/ ConvertToDecimal = ConvertToDecimalCore;
    /*BindParser<decimal?>*/ ConvertToNullableDecimal = ConvertToNullableDecimalCore;
    /*bool*/ ConvertToDecimalCore(/*object*/ obj, /*CultureInfo*/ culture, /*decimal*/ value)
    {
        /*var*/ let text = obj;
        if (.IsNullOrEmpty(text))
        {
            value = default;
            return false;
        }
        let converted = null;
        let $v = { value: set(value){ converted = value; } };
        if (.TryParse(text/*, NumberStyles.Number, culture ?? CultureInfo.CurrentCulture*/, $v))
        {
            value = default;
            return false;
        }
        value = converted;
        return true;
    }
    /*bool*/ ConvertToNullableDecimalCore(/*object*/ obj, /*CultureInfo*/ culture, /*decimal?*/ value)
    {
        /*var*/ let text = obj;
        if (.IsNullOrEmpty(text))
        {
            value = default;
            return true;
        }
        let converted = null;
        let $v = { value: set(value){ converted = value; } };
        if (.TryParse(text/*, NumberStyles.Number, culture ?? CultureInfo.CurrentCulture*/, $v))
        {
            value = default;
            return false;
        }
        value = converted;
        return true;
    }
    /*bool*/ TryConvertToDateTime(/*object*/ obj, /*CultureInfo*/ culture, /*DateTime*/ value)
    {
        let $v = { value: set(value){ value = value; } };
        return ConvertToDateTimeCore(obj, culture, $v);
    }
    /*bool*/ TryConvertToDateTime(/*object*/ obj, /*CultureInfo*/ culture, /*string*/ format, /*DateTime*/ value)
    {
        let $v = { value: set(value){ value = value; } };
        return ConvertToDateTimeCore(obj, culture, format, $v);
    }
    /*bool*/ TryConvertToNullableDateTime(/*object*/ obj, /*CultureInfo*/ culture, /*DateTime?*/ value)
    {
        let $v = { value: set(value){ value = value; } };
        return ConvertToNullableDateTimeCore(obj, culture, $v);
    }
    /*bool*/ TryConvertToNullableDateTime(/*object*/ obj, /*CultureInfo*/ culture, /*string*/ format, /*DateTime?*/ value)
    {
        let $v = { value: set(value){ value = value; } };
        return ConvertToNullableDateTimeCore(obj, culture, format, $v);
    }
    /*BindParser<DateTime>*/ ConvertToDateTime = ConvertToDateTimeCore;
    /*BindParserWithFormat<DateTime>*/ ConvertToDateTimeWithFormat = ConvertToDateTimeCore;
    /*BindParser<DateTime?>*/ ConvertToNullableDateTime = ConvertToNullableDateTimeCore;
    /*BindParserWithFormat<DateTime?>*/ ConvertToNullableDateTimeWithFormat = ConvertToNullableDateTimeCore;
    /*bool*/ ConvertToDateTimeCore(/*object*/ obj, /*CultureInfo*/ culture, /*DateTime*/ value)
    {
        let $v = { value: set(value){ value = value; } };
        return ConvertToDateTimeCore(obj, culture, null, $v);
    }
    /*bool*/ ConvertToDateTimeCore(/*object*/ obj, /*CultureInfo*/ culture, /*string*/ format, /*DateTime*/ value)
    {
        /*var*/ let text = obj;
        if (.IsNullOrEmpty(text))
        {
            value = default;
            return false;
        }
        let converted = null;
        let $v = { value: set(value){ converted = value; } };
        if (format != null && DateTime.TryParseExact(text, format/*, culture ?? CultureInfo.CurrentCulture*//*, DateTimeStyles.None*/, null, $v))
        {
            value = converted;
            return true;
        }
        let $v = { value: set(value){ converted = value; } };
        else if (format == null && DateTime.TryParse(text/*, culture ?? CultureInfo.CurrentCulture*//*, DateTimeStyles.None*/, $v))
        {
            value = converted;
            return true;
        }
        value = default;
        return false;
    }
    /*bool*/ ConvertToNullableDateTimeCore(/*object*/ obj, /*CultureInfo*/ culture, /*DateTime?*/ value)
    {
        let $v = { value: set(value){ value = value; } };
        return ConvertToNullableDateTimeCore(obj, culture, null, $v);
    }
    /*bool*/ ConvertToNullableDateTimeCore(/*object*/ obj, /*CultureInfo*/ culture, /*string*/ format, /*DateTime?*/ value)
    {
        /*var*/ let text = obj;
        if (.IsNullOrEmpty(text))
        {
            value = default;
            return true;
        }
        let converted = null;
        let $v = { value: set(value){ converted = value; } };
        if (format != null && DateTime.TryParseExact(text, format/*, culture ?? CultureInfo.CurrentCulture*//*, DateTimeStyles.None*/, null, $v))
        {
            value = converted;
            return true;
        }
        let $v = { value: set(value){ converted = value; } };
        else if (format == null && DateTime.TryParse(text/*, culture ?? CultureInfo.CurrentCulture*//*, DateTimeStyles.None*/, $v))
        {
            value = converted;
            return true;
        }
        value = default;
        return false;
    }
    /*bool*/ TryConvertToDateTimeOffset(/*object*/ obj, /*CultureInfo*/ culture, /*DateTimeOffset*/ value)
    {
        let $v = { value: set(value){ value = value; } };
        return ConvertToDateTimeOffsetCore(obj, culture, $v);
    }
    /*bool*/ TryConvertToDateTimeOffset(/*object*/ obj, /*CultureInfo*/ culture, /*string*/ format, /*DateTimeOffset*/ value)
    {
        let $v = { value: set(value){ value = value; } };
        return ConvertToDateTimeOffsetCore(obj, culture, format, $v);
    }
    /*bool*/ TryConvertToNullableDateTimeOffset(/*object*/ obj, /*CultureInfo*/ culture, /*DateTimeOffset?*/ value)
    {
        let $v = { value: set(value){ value = value; } };
        return ConvertToNullableDateTimeOffsetCore(obj, culture, $v);
    }
    /*bool*/ TryConvertToNullableDateTimeOffset(/*object*/ obj, /*CultureInfo*/ culture, /*string*/ format, /*DateTimeOffset?*/ value)
    {
        let $v = { value: set(value){ value = value; } };
        return ConvertToNullableDateTimeOffsetCore(obj, culture, format, $v);
    }
    /*BindParser<DateTimeOffset>*/ ConvertToDateTimeOffset = ConvertToDateTimeOffsetCore;
    /*BindParserWithFormat<DateTimeOffset>*/ ConvertToDateTimeOffsetWithFormat = ConvertToDateTimeOffsetCore;
    /*BindParser<DateTimeOffset?>*/ ConvertToNullableDateTimeOffset = ConvertToNullableDateTimeOffsetCore;
    /*BindParserWithFormat<DateTimeOffset?>*/ ConvertToNullableDateTimeOffsetWithFormat = ConvertToNullableDateTimeOffsetCore;
    /*bool*/ ConvertToDateTimeOffsetCore(/*object*/ obj, /*CultureInfo*/ culture, /*DateTimeOffset*/ value)
    {
        let $v = { value: set(value){ value = value; } };
        return ConvertToDateTimeOffsetCore(obj, culture, null, $v);
    }
    /*bool*/ ConvertToDateTimeOffsetCore(/*object*/ obj, /*CultureInfo*/ culture, /*string*/ format, /*DateTimeOffset*/ value)
    {
        /*var*/ let text = obj;
        if (.IsNullOrEmpty(text))
        {
            value = default;
            return false;
        }
        let converted = null;
        let $v = { value: set(value){ converted = value; } };
        if (format == null && DateTimeOffset.TryParse(text/*, culture ?? CultureInfo.CurrentCulture*//*, DateTimeStyles.None*/, $v))
        {
            value = converted;
            return true;
        }
        value = default;
        return false;
    }
    /*bool*/ ConvertToNullableDateTimeOffsetCore(/*object*/ obj, /*CultureInfo*/ culture, /*DateTimeOffset?*/ value)
    {
        let $v = { value: set(value){ value = value; } };
        return ConvertToNullableDateTimeOffsetCore(obj, culture, null, $v);
    }
    /*bool*/ ConvertToNullableDateTimeOffsetCore(/*object*/ obj, /*CultureInfo*/ culture, /*string*/ format, /*DateTimeOffset?*/ value)
    {
        /*var*/ let text = obj;
        if (.IsNullOrEmpty(text))
        {
            value = default;
            return true;
        }
        let converted = null;
        let $v = { value: set(value){ converted = value; } };
        if (format == null && DateTimeOffset.TryParse(text/*, culture ?? CultureInfo.CurrentCulture*//*, DateTimeStyles.None*/, $v))
        {
            value = converted;
            return true;
        }
        value = default;
        return false;
    }
    /*BindParser<Guid>*/ ConvertToGuid = ConvertToGuidCore;
    /*BindParser<Guid?>*/ ConvertToNullableGuid = ConvertToNullableGuidCore;
    /*bool*/ ConvertToGuidCore(/*object*/ obj, /*CultureInfo*/ culture, /*Guid*/ value)
    {
        let converted = null;
        let $v = { value: set(value){ converted = value; } };
        ConvertToNullableGuidCore(obj, culture, $v);
        value = converted.GetValueOrDefault();
        return converted.HasValue;
    }
    /*bool*/ ConvertToNullableGuidCore(/*object*/ obj, /*CultureInfo*/ culture, /*Guid?*/ value)
    {
        /*var*/ let text = obj;
        if (.IsNullOrEmpty(text))
        {
            value = default;
            return true;
        }
        let converted = null;
        let $v = { value: set(value){ converted = value; } };
        if (Guid.TryParse(text, $v))
        {
            value = default;
            return false;
        }
        value = converted;
        return true;
    }
    /*bool*/ ConvertToEnum(T, /*object*/ obj, /*CultureInfo*/ _, /*T*/ value)
    {
        /*var*/ let text = obj;
        if (.IsNullOrEmpty(text))
        {
            value = default;
            return true;
        }
        let converted = null;
        let $v = { value: set(value){ converted = value; } };
        if (Enum.TryParse(T, text, $v))
        {
            value = default;
            return false;
        }
        if (Enum.IsDefined(T, converted))
        {
            value = default;
            return false;
        }
        value = converted;
        return true;
    }
    /*bool*/ ConvertToNullableEnum(T, /*object*/ obj, /*CultureInfo*/ _, /*T?*/ value)
    {
        /*var*/ let text = obj;
        if (.IsNullOrEmpty(text))
        {
            value = default;
            return true;
        }
        let converted = null;
        let $v = { value: set(value){ converted = value; } };
        if (Enum.TryParse(T, text, $v))
        {
            value = default;
            return false;
        }
        if (Enum.IsDefined(T, converted))
        {
            value = default;
            return false;
        }
        value = converted;
        return true;
    }
    /*bool*/ TryConvertTo(T, /*object*/ obj, /*CultureInfo*/ culture, /*T*/ value)
    {
        /*var*/ let converter = ParserDelegateCache.Get(T);
        let $v = { value: set(value){ value = value; } };
        return converter(obj, culture, $v);
    }
    class Microsoft_AspNetCore_Components_FormatterDelegateCache extends object
    {
        constructor()
        {
            super();
        }
        /*Dictionary<Type, Delegate>*/ _cache = new Dictionary_$2(Type, Delegate);
        /*MethodInfo*/ _makeArrayFormatter = null;
        /*BindFormatter<T>*/ Get(T)
        {
            let formatter = null;
            let $v = { value: set(value){ formatter = value; } };
            if (_cache.TryGetValue(T, $v))
            {
                if (T == )
                {
                    formatter = BindFormatter_$1FormatStringValueCore;
                }
                else if (T == )
                {
                    formatter = BindFormatter_$1FormatBoolValueCore;
                }
                else if (T == )
                {
                    formatter = BindFormatter_$1FormatNullableBoolValueCore;
                }
                else if (T == )
                {
                    formatter = BindFormatter_$1FormatIntValueCore;
                }
                else if (T == )
                {
                    formatter = BindFormatter_$1FormatNullableIntValueCore;
                }
                else if (T == )
                {
                    formatter = BindFormatter_$1FormatLongValueCore;
                }
                else if (T == )
                {
                    formatter = BindFormatter_$1FormatNullableLongValueCore;
                }
                else if (T == )
                {
                    formatter = BindFormatter_$1FormatShortValueCore;
                }
                else if (T == )
                {
                    formatter = BindFormatter_$1FormatNullableShortValueCore;
                }
                else if (T == )
                {
                    formatter = BindFormatter_$1FormatFloatValueCore;
                }
                else if (T == )
                {
                    formatter = BindFormatter_$1FormatNullableFloatValueCore;
                }
                else if (T == )
                {
                    formatter = BindFormatter_$1FormatDoubleValueCore;
                }
                else if (T == )
                {
                    formatter = BindFormatter_$1FormatNullableDoubleValueCore;
                }
                else if (T == )
                {
                    formatter = BindFormatter_$1FormatDecimalValueCore;
                }
                else if (T == )
                {
                    formatter = BindFormatter_$1FormatNullableDecimalValueCore;
                }
                else if (T == DateTime)
                {
                    formatter = BindFormatter_$1FormatDateTimeValueCore;
                }
                else if (T == DateTime)
                {
                    formatter = BindFormatter_$1FormatNullableDateTimeValueCore;
                }
                else if (T == DateTimeOffset)
                {
                    formatter = BindFormatter_$1FormatDateTimeOffsetValueCore;
                }
                else if (T == DateTimeOffset)
                {
                    formatter = BindFormatter_$1FormatNullableDateTimeOffsetValueCore;
                }
                else if (T.IsEnum  || Nullable.GetUnderlyingType(T) instanceof Type && innerType.IsEnum)
                {
                    formatter = BindFormatter_$1FormatEnumValueCore_$1;
                }
                else if (T.IsArray)
                {
                    /*var*/ let method = _makeArrayFormatter = _makeArrayFormatter ?? FormatterDelegateCache.GetMethod(nameof(MakeArrayFormatter), BindingFlags.NonPublic  | BindingFlags.Static);
                    /*var*/ let elementType = T.GetElementType();
                    formatter = Delegatemethod.MakeGenericMethod(elementType).Invoke(null, null);
                }
                else 
                {
                    formatter = MakeTypeConverterFormatter_$1(T);
                }
                _cache.TryAdd(T, formatter);
            }
            return BindFormatter_$1formatter;
        }
        /*string*/ FormatArrayValue(T, /*T[]*/ value, /*CultureInfo*/ culture)
        {
            /*var*/ let elementFormatter = Get_$1(T);
            if (value.Length  == 0)
            {
                return "[]";
            }
            /*var*/ let builder = new StringBuilder("[\"");
            builder.Append(elementFormatter(value0, culture)ToString() ?? .Empty);
            builder.Append('\"');
            for(/*var*/ let i = 1; i < value.Length; i++)
            {
                builder.Append(", \"");
                builder.Append(elementFormatter(valuei, culture)ToString() ?? .Empty);
                builder.Append('\"');
            });
            builder.Append(']');
            return builder.ToString();
        }
        /*BindFormatter<T[]>*/ MakeArrayFormatter(T)
        {
            /*var*/ let elementFormatter = Get_$1(T);
            return FormatArrayValue_$1;
        }
        /*BindFormatter<T>*/ MakeTypeConverterFormatter(T)
        {
            {
                throw new InvalidOperationException(T.FullName);
            }
        }
    }
    class Microsoft_AspNetCore_Components_ParserDelegateCache extends object
    {
        constructor()
        {
            super();
        }
        /*Dictionary<Type, Delegate>*/ _cache = new Dictionary_$2(Type, Delegate);
        /*MethodInfo*/ _convertToEnum = null;
        /*MethodInfo*/ _convertToNullableEnum = null;
        /*MethodInfo*/ _makeArrayTypeConverter = null;
        /*BindParser<T>*/ Get(T)
        {
            let parser = null;
            let $v = { value: set(value){ parser = value; } };
            if (_cache.TryGetValue(T, $v))
            {
                if (T == )
                {
                    parser = ConvertToString;
                }
                else if (T == )
                {
                    parser = ConvertToBool;
                }
                else if (T == )
                {
                    parser = ConvertToNullableBool;
                }
                else if (T == )
                {
                    parser = ConvertToInt;
                }
                else if (T == )
                {
                    parser = ConvertToNullableInt;
                }
                else if (T == )
                {
                    parser = ConvertToLong;
                }
                else if (T == )
                {
                    parser = ConvertToNullableLong;
                }
                else if (T == )
                {
                    parser = ConvertToShort;
                }
                else if (T == )
                {
                    parser = ConvertToNullableShort;
                }
                else if (T == )
                {
                    parser = ConvertToFloat;
                }
                else if (T == )
                {
                    parser = ConvertToNullableFloat;
                }
                else if (T == )
                {
                    parser = ConvertToDoubleDelegate;
                }
                else if (T == )
                {
                    parser = ConvertToNullableDoubleDelegate;
                }
                else if (T == )
                {
                    parser = ConvertToDecimal;
                }
                else if (T == )
                {
                    parser = ConvertToNullableDecimal;
                }
                else if (T == DateTime)
                {
                    parser = ConvertToDateTime;
                }
                else if (T == DateTime)
                {
                    parser = ConvertToNullableDateTime;
                }
                else if (T == DateTimeOffset)
                {
                    parser = ConvertToDateTimeOffset;
                }
                else if (T == DateTimeOffset)
                {
                    parser = ConvertToNullableDateTimeOffset;
                }
                else if (T == Guid)
                {
                    parser = ConvertToGuid;
                }
                else if (T == Guid)
                {
                    parser = ConvertToNullableGuid;
                }
                else if (T.IsEnum)
                {
                    /*// We have to deal invoke this dynamically to work around the type constraint on Enum.TryParse.
                        var*/ let method = _convertToEnum = _convertToEnum ?? BindConverter.GetMethod(nameof(ConvertToEnum), BindingFlags.NonPublic  | BindingFlags.Static);
                    parser = method.MakeGenericMethod(T).CreateDelegate(BindParser_$1, { target : null });
                }
                else if (Nullable.GetUnderlyingType(T) instanceof Type && innerType.IsEnum)
                {
                    /*// We have to deal invoke this dynamically to work around the type constraint on Enum.TryParse.
                        var*/ let method = _convertToNullableEnum = _convertToNullableEnum ?? BindConverter.GetMethod(nameof(ConvertToNullableEnum), BindingFlags.NonPublic  | BindingFlags.Static);
                    parser = method.MakeGenericMethod(innerType).CreateDelegate(BindParser_$1, { target : null });
                }
                else if (T.IsArray)
                {
                    /*var*/ let method = _makeArrayTypeConverter = _makeArrayTypeConverter ?? ParserDelegateCache.GetMethod(nameof(MakeArrayTypeConverter), BindingFlags.NonPublic  | BindingFlags.Static);
                    /*var*/ let elementType = T.GetElementType();
                    parser = Delegatemethod.MakeGenericMethod(elementType).Invoke(null, null);
                }
                else 
                {
                    parser = MakeTypeConverterConverter_$1(T);
                }
                _cache.TryAdd(T, parser);
            }
            return BindParser_$1parser;
        }
        /*BindParser<T[]>*/ MakeArrayTypeConverter(T)
        {
            /*var*/ let elementParser = Get_$1(T);
            return ConvertToArray;
CultureInfoT            {
                if (obj instanceof Array, initialArray = obj)
                {
                    value = default;
                    return false;
                }
                /*var*/ let convertedArray = new Array(initialArray.Length);
                for(/*var*/ let i = 0; i < initialArray.Length; i++)
                {
                    let $v = { value: set(value){ convertedArray[i] = value; } };
                    if (elementParser(initialArray.GetValue(i), culture, $v))
                    {
                        value = default;
                        return false;
                    }
                });
                value = convertedArray;
                return true;
            }
        }
        /*BindParser<T>*/ MakeTypeConverterConverter(T)
        {
            throw new InvalidOperationException(T.FullName);
        }
    }
}

class Microsoft_AspNetCore_Components_CascadingParameterAttribute extends System_Attribute
{
    constructor()
    {
        super();
    }
    constructor(/*string*/ name)
    {
        super();
        Name = name;
    }
    /*string*/ _backingField_Name = null;
    /*string*/ get Name()
    {
        return _backingField_Name;
    }
    /*string*/ set Name(value)
    {
        _backingField_Name = value;
    }
}

const Microsoft_AspNetCore_Components_CascadingValue$_1 = (TValue) => class extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
        TValue = $_TValue;
    }
    /*string*/ _backingField_Name = null;
    /*string*/ get Name()
    {
        return _backingField_Name;
    }
    /*string*/ set Name(value)
    {
        _backingField_Name = value;
    }
    /*TValue*/ _backingField_Value = null;
    /*TValue*/ get Value()
    {
        return _backingField_Value;
    }
    /*TValue*/ set Value(value)
    {
        _backingField_Value = value;
    }
    /*bool*/ _backingField_IsFixed = null;
    /*bool*/ get IsFixed()
    {
        return _backingField_IsFixed;
    }
    /*bool*/ set IsFixed(value)
    {
        _backingField_IsFixed = value;
    }
    /*RenderFragment*/ _backingField_ChildContent = null;
    /*RenderFragment*/ get ChildContent()
    {
        return _backingField_ChildContent;
    }
    /*RenderFragment*/ set ChildContent(value)
    {
        _backingField_ChildContent = value;
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ frame, { /*object*/ key = null})
    {
        frame.State.SetCascadingValue(Value, IsFixed, Name);
        frame.Content(ChildContent, { sequenceNumber : Utility.CascadingValue_SequenceNumber });
    }
}

const Microsoft_AspNetCore_Components_CascadingValue$_1 = (TValue) => class extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
        TValue = $_TValue;
    }
}

class Microsoft_AspNetCore_Components_EventTarget extends object
{
    constructor()
    {
        super();
    }
    /*object*/ _backingField_Value = null;
    /*object*/ get Value()
    {
        return _backingField_Value;
    }
    /*object*/ set Value(value)
    {
        _backingField_Value = value;
    }
}
class Microsoft_AspNetCore_Components_ChangeEventArgs extends System_EventArgs
{
    constructor()
    {
        super();
    }
    /*EventTarget*/ _backingField_Target = null;
    /*EventTarget*/ get Target()
    {
        return _backingField_Target;
    }
    /*EventTarget*/ set Target(value)
    {
        _backingField_Target = value;
    }
}

class Microsoft_AspNetCore_Components_ComponentBase extends System_IDisposable(Microsoft_AspNetCore_Components_IHandleAfterRender(Microsoft_AspNetCore_Components_IHandleEvent(Microsoft_AspNetCore_Components_IComponent(object))))
{
    /*string*/ get ShadowName()
    {
        return GetType().Name;
    }
    /*RenderFragment*/ _renderFragment = null;
    /*RenderHandle*/ _renderHandle = null;
    /*bool*/ _initialized = null;
    /*bool*/ _hasNeverRendered = true;
    /*bool*/ _hasPendingQueuedRender = null;
    /*bool*/ _hasCalledOnAfterRender = null;
    constructor()
    {
        super();
        _renderFragment = function(/*IUIFrame*/ builder, /*object*/ key)
        {
            _hasPendingQueuedRender = false;
            _hasNeverRendered = false;
            BuildRenderTree(builder);
        };
    }
    /*Task*/ InvokeAsync(/*Action*/ workItem)
    {
        return _renderHandle.Dispatcher.InvokeAsync(workItem);
    }
    /*Task*/ InvokeAsync(/*Func<Task>*/ workItem)
    {
        return _renderHandle.Dispatcher.InvokeAsync(workItem);
    }
    /*void*/ BuildRenderTree(/*RenderTreeBuilder*/ builder)
    {
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ frame, { /*object*/ key = null})
    {
    }
    /*void*/ InjectServices(/*IServiceProvider*/ provider)
    {
    }
    /*void*/ CascadeParameters()
    {
    }
    /*void*/ OnInitialized()
    {
    }
    /*Task*/ OnInitializedAsync()
    {
        return Task.CompletedTask;
    }
    /*void*/ OnParametersSet()
    {
    }
    /*Task*/ OnParametersSetAsync()
    {
        return Task.CompletedTask;
    }
    /*void*/ OnAfterRender(/*bool*/ firstRender)
    {
    }
    /*Task*/ OnAfterRenderAsync(/*bool*/ firstRender)
    {
        return Task.CompletedTask;
    }
    /*bool*/ HandleError(/*Exception*/ exception, /*ComponentLifeCycle*/ lifeCycle)
    {
        return false;
    }
    /*void*/ WithErrorHandling(/*Action<ComponentBase>*/ action, /*ComponentLifeCycle*/ lifeCycle)
    {
        if (isDisposed)
        return ;
        {
            action();
        }
Exception        {
            /*var*/ let handled = HandleError(e, lifeCycle);
            if (handled)
            throw ;
        }
    }
    /*void*/ RequestCascadingParameter(T, /*Action<T>*/ action, { /*string*/ cascadingParameterName = null})
    {
        /*var*/ let renderer = BrowserNativeRenderer_renderHandle._renderer;
        /*var*/ let state = renderer.GetRequiredState(_renderHandle._componentId);
        DisposeOnDispose(state.SubscribeCascadingValue(T, function(/**/ o, /**/ e)
        {
            return action(e);
        }, cascadingParameterName));
    }
    /*void*/ Set(/*string*/ key, /*object*/ value)
    {
        if (key == "@attributes")
        {
            if (value instanceof IReadOnlyDictionary_$2, dic = value)
            {
                BlazorJs.forEach(dic, function(kv, $_i)
                {
                    .SetValue(kv.Key, kv.Value);
                });
            }
            else 
            {
                BlazorJs.forEach(.GetOwnPropertyNames(value), function(mkey, $_i)
                {
                    if (mkey.Length  > 0 && .IsLower(mkey0))
                    {
                        /*var*/ let val = valuemkey;
                        .SetValue(mkey, val);
                    }
                });
            }
        }
        else 
        {
            if (key.Length  > 0 && .IsLower(key0))
            {
                .SetValue(key, value);
            }
        }
    }
/*EventHandler*/ let OnDisposed    /*void*/ DisposeOnDispose(/*IDisposable*/ disposable)
    {
        if (disposable != null)
        OnDisposed += function(/**/ s, /**/ e)
        {
            return disposable.Dispose();
        };
    }
    /*bool*/ isDisposed = null;
    /*void*/ Dispose()
    {
        if (isDisposed)
        return ;
        //var renderer = (BrowserNativeRenderer)_renderHandle._renderer;
            //var state = renderer.GetState(_renderHandle._componentId);
            //state?.Dispose();
            OnDisposedInvoke(, EventArgs.Empty);
        isDisposed = true;
    }
    /*bool*/ ShouldRender()
    {
        return true;
    }
    /*void*/ StateHasChanged()
    {
        if (isDisposed)
        return ;
        if (_hasPendingQueuedRender || _hasNeverRendered && ShouldRender() && _renderHandle.IsRenderingOnMetadataUpdate)
        {
            return ;
        }
        _hasPendingQueuedRender = true;
        {
            _renderHandle.Render(_renderFragment);
        }
        {
            _hasPendingQueuedRender = false;
            throw ;
        }
    }
    /*Task*/ DispatchExceptionAsync(/*Exception*/ exception)
    {
        return _renderHandle.DispatchExceptionAsync(exception);
    }
    /*void*/ Attach(/*RenderHandle*/ renderHandle)
    {
        if (_renderHandle.IsInitialized)
        {
            throw new InvalidOperationException("The render handle is already set. Cannot initialize a ComponentBase more than once.");
        }
        _renderHandle = renderHandle;
    }
    /*Task*/ SetParametersAsync(/*ParameterView*/ parameters)
    {
        parameters.SetParameterProperties();
        if (_initialized)
        {
            _initialized = true;
            return RunInitAndSetParametersAsync();
        }
        return CallOnParametersSetAsync();
    }
    /*Task*/ async RunInitAndSetParametersAsync()
    {
        WithErrorHandling(function(/**/ icomponent)
        {
            OnInitialized();
        }, ComponentLifeCycle.OnInitializing);
        /*Task*/ let task = Task.CompletedTask;
        WithErrorHandling(function(/**/ icomponent)
        {
            task = OnInitializedAsync();
        }, ComponentLifeCycle.OnInitializingAsync);
        if (task.Status  != TaskStatus.RanToCompletion  && task.Status  != TaskStatus.Canceled)
        {
            StateHasChanged();
            {
                await task;
            }
            {
                if (task.IsCanceled)
                {
                    throw ;
                }
            }
        }
        await CallOnParametersSetAsync();
    }
    /*Task*/ CallOnParametersSetAsync()
    {
        WithErrorHandling(function(/**/ icomponent)
        {
            OnParametersSet();
        }, ComponentLifeCycle.OnParametersSetting);
        /*Task*/ let task = Task.CompletedTask;
        WithErrorHandling(function(/**/ icomponent)
        {
            task = OnParametersSetAsync();
        }, ComponentLifeCycle.OnParametersSettingAsnc);
        /*bool*/ let num = task.Status  != TaskStatus.RanToCompletion  && task.Status  != TaskStatus.Canceled;
        StateHasChanged();
        if (num)
        {
            return Task.CompletedTask;
        }
        return CallStateHasChangedOnAsyncCompletion(task);
    }
    /*Task*/ async CallStateHasChangedOnAsyncCompletion(/*Task*/ task)
    {
        {
            await task;
        }
        {
            if (task.IsCanceled)
            {
                return ;
            }
            throw ;
        }
        StateHasChanged();
    }
    /*Task*/ HandleEventAsync(/*EventCallbackWorkItem*/ callback, /*object*/ arg)
    {
        /*Task*/ let task = callback.InvokeAsync(arg);
        /*bool*/ let num = task.Status  != TaskStatus.RanToCompletion  && task.Status  != TaskStatus.Canceled;
        StateHasChanged();
        if (num)
        {
            return Task.CompletedTask;
        }
        return CallStateHasChangedOnAsyncCompletion(task);
    }
    /*Task*/ OnAfterRenderAsync()
    {
        /*bool*/ let firstRender = _hasCalledOnAfterRender;
        _hasCalledOnAfterRender = true;
        WithErrorHandling(function(/**/ icomponent)
        {
            icomponent.OnAfterRender(firstRender);
        }, ComponentLifeCycle.OnAfterRender);
        /*Task*/ let task = Task.CompletedTask;
        WithErrorHandling(function(/**/ icomponent)
        {
            task = OnAfterRenderAsync(firstRender);
        }, ComponentLifeCycle.OnAfterRenderAsnyc);
        return task;
    }
    /*string*/ ToString()
    {
        /*var*/ let renderer = BrowserNativeRenderer_renderHandle._renderer;
        /*var*/ let state = renderer.GetState(_renderHandle._componentId);
        return stateToString() ?? super.ToString();
    }
}


class Microsoft_AspNetCore_Components_DefaultComponentActivator extends Microsoft_AspNetCore_Components_IComponentActivator(object)
{
    /*IServiceProvider*/ serviceProvider = null;
    constructor(/*IServiceProvider*/ serviceProvider)
    {
        super();
        .serviceProvider  = serviceProvider;
    }
    /*IComponent*/ CreateInstance(/*Type*/ componentType)
    {
        if (IComponent.IsAssignableFrom(componentType))
        {
            throw new ArgumentException(componentType.FullNamenameof(IComponent), nameof(componentType));
        }
        return IComponentserviceProvider.GetService(componentType) ?? Activator.CreateInstance(componentType);
    }
}

class Microsoft_AspNetCore_Components_Dispatcher extends object
{
    constructor()
    {
        super();
    }
    /*SectionRegistry*/ _sectionRegistry = null;
    /*Dispatcher*/ CreateDefault()
    {
        new BrowserNativeDispatcher();
    }
/*UnhandledExceptionEventHandler*/ let UnhandledException    /*SectionRegistry*/ get SectionRegistry()
    {
        if (_sectionRegistry == null)
        _sectionRegistry = new SectionRegistry();
        return _sectionRegistry;
    }
    /*void*/ AssertAccess()
    {
        if (CheckAccess())
        {
            throw new InvalidOperationException("The current thread is not associated with the Dispatcher. " + "Use InvokeAsync() to switch execution to the Dispatcher when " + "triggering rendering or component state.");
        }
    }
    /*void*/ OnUnhandledException(/*UnhandledExceptionEventArgs*/ e)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(e);
        UnhandledExceptionInvoke(, e);
    }
}

class Microsoft_AspNetCore_Components_DynamicComponent extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
    }
    /*Type*/ _backingField_Type = null;
    /*Type*/ get Type()
    {
        return _backingField_Type;
    }
    /*Type*/ set Type(value)
    {
        _backingField_Type = value;
    }
    /*Dictionary<string, object>*/ _backingField_Properties = null;
    /*Dictionary<string, object>*/ get Properties()
    {
        return _backingField_Properties;
    }
    /*Dictionary<string, object>*/ set Properties(value)
    {
        _backingField_Properties = value;
    }
    /*Action<IComponent>*/ _backingField_ParameterSetter = null;
    /*Action<IComponent>*/ get ParameterSetter()
    {
        return _backingField_ParameterSetter;
    }
    /*Action<IComponent>*/ set ParameterSetter(value)
    {
        _backingField_ParameterSetter = value;
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ frame, { /*object*/ key = null})
    {
        if (Type != null)
        {
            frame.Component(Type, function(/**/ component)
            {
                if (Properties != null)
                {
                    BlazorJs.forEach(Properties, function(kv, $_i)
                    {
                        componentkv.Key = kv.Value;
                    });
                }
                ParameterSetterInvoke(component);
            }, { sequenceNumber : Utility.DynamicComponent_SequenceNumber  + Type.GetHashCode() });
        }
    }
}
const Microsoft_AspNetCore_Components_DynamicComponentT$_1 = (TComponent) => class extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
        TComponent = $_TComponent;
    }
TComponent    /*Dictionary<string, object>*/ _backingField_Properties = null;
    /*Dictionary<string, object>*/ get Properties()
    {
        return _backingField_Properties;
    }
    /*Dictionary<string, object>*/ set Properties(value)
    {
        _backingField_Properties = value;
    }
    /*Action<TComponent>*/ _backingField_ParameterSetter = null;
    /*Action<TComponent>*/ get ParameterSetter()
    {
        return _backingField_ParameterSetter;
    }
    /*Action<TComponent>*/ set ParameterSetter(value)
    {
        _backingField_ParameterSetter = value;
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ frame, { /*object*/ key = null})
    {
        frame.Component(TComponent, function(/**/ component)
        {
            if (Properties != null)
            {
                BlazorJs.forEach(Properties, function(kv, $_i)
                {
                    componentkv.Key = kv.Value;
                });
            }
            ParameterSetterInvoke(component);
        }, { sequenceNumber : Utility.DynamicComponent_SequenceNumber  + TComponent.GetHashCode() });
    }
}

class Microsoft_AspNetCore_Components_EditorRequiredAttribute extends System_Attribute
{
    constructor()
    {
        super();
    }
}

class Microsoft_AspNetCore_Components_ElementReference extends System_ValueType
{
    constructor()
    {
        super();
    }
    /*HTMLElement*/ _backingField_Element = null;
    /*HTMLElement*/ get Element()
    {
        return _backingField_Element;
    }
    /*HTMLElement*/ set Element(value)
    {
        _backingField_Element = value;
    }
ElementReferenceHTMLElement    new ElementReference()Element = element;
}

class Microsoft_AspNetCore_Components_ErrorBoundaryBase extends Microsoft_AspNetCore_Components_IErrorBoundary(Microsoft_AspNetCore_Components_ComponentBase)
{
    constructor()
    {
        super();
    }
    /*int*/ _errorCount = null;
    /*RenderFragment*/ _backingField_ChildContent = null;
    /*RenderFragment*/ get ChildContent()
    {
        return _backingField_ChildContent;
    }
    /*RenderFragment*/ set ChildContent(value)
    {
        _backingField_ChildContent = value;
    }
    /*RenderFragment<Exception>*/ _backingField_ErrorContent = null;
    /*RenderFragment<Exception>*/ get ErrorContent()
    {
        return _backingField_ErrorContent;
    }
    /*RenderFragment<Exception>*/ set ErrorContent(value)
    {
        _backingField_ErrorContent = value;
    }
    /*int*/ _backingField_MaximumErrorCount = null;
    /*int*/ get MaximumErrorCount()
    {
        return _backingField_MaximumErrorCount;
    }
    /*int*/ set MaximumErrorCount(value)
    {
        _backingField_MaximumErrorCount = value;
    }
    /*Exception*/ _backingField_CurrentException = null;
    /*Exception*/ get CurrentException()
    {
        return _backingField_CurrentException;
    }
    /*Exception*/ set CurrentException(value)
    {
        _backingField_CurrentException = value;
    }
    /*void*/ Recover()
    {
        if (CurrentException != null)
        {
            _errorCount = 0;
            CurrentException = null;
            StateHasChanged();
        }
    }
    /*void*/ HandleException(/*Exception*/ exception)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(exception);
        if (_errorCount > MaximumErrorCount)
        {
            throw exception;
        }
        /*// Notify the subclass so it can begin any async operation even before we render, because (for example)
            // we want logs to be written before rendering in case the rendering throws. But there's no reason to
            // wait for the async operation to complete before we render.
            var*/ let onErrorTask = OnErrorAsync(exception);
        if (onErrorTask.IsCanceled  || onErrorTask.IsFaulted)
        {
            _ = HandleOnErrorExceptions(onErrorTask);
        }
        CurrentException = exception;
        StateHasChanged();
    }
    /*Task*/ async HandleOnErrorExceptions(/*Task*/ onExceptionTask)
    {
        if (onExceptionTask.IsFaulted)
        {
            throw onExceptionTask.Exception;
        }
        else 
        {
            {
                await onExceptionTask;
            }
Exception            {
                CurrentException = exception;
                ChildContent = function(/**/ _, /**/ __)
                {
                    throw exception;
                };
                ErrorContent = function(/**/ _)
                {
function(/**/ __, /**/ ___)
                    {
                        throw exception;
                    }                };
                StateHasChanged();
            }
        }
    }
}

const Microsoft_AspNetCore_Components_IEventCallback = (Base) => class extends Base
{
    /*EventCallbackFlags*/ _backingField_Flags = null;
    /*EventCallbackFlags*/ get Flags()
    {
        return _backingField_Flags;
    }
}
class Microsoft_AspNetCore_Components_EventCallback extends Microsoft_AspNetCore_Components_IEventCallback(System_ValueType)
{
    /*EventCallbackFactory*/ Factory = new EventCallbackFactory();
    /*EventCallback<object>*/ internalCallback = null;
    constructor(/*EventCallback<object>*/ internalCallback)
    {
        super();
        .internalCallback  = internalCallback;
    }
    /*Task*/ InvokeAsync()
    {
        return internalCallback.InvokeAsync(null);
    }
    /*Task*/ InvokeAsync(/*Event*/ eventData)
    {
        return internalCallback.InvokeAsync(eventData);
    }
    /*object*/ get Receiver()
    {
        return internalCallback.Receiver;
    }
    /*Delegate*/ get Delegate()
    {
        return internalCallback.Delegate;
    }
    /*bool*/ get HasDelegate()
    {
        return internalCallback.HasDelegate;
    }
    /*EventCallbackFlags*/ get Flags()
    {
        return internalCallback.Flags;
    }
}
const Microsoft_AspNetCore_Components_EventCallback$_1 = (T) => class extends Microsoft_AspNetCore_Components_IEventCallback(System_ValueType)
{
    /*object*/ _backingField_Receiver = null;
    /*object*/ get Receiver()
    {
        return _backingField_Receiver;
    }
    /*MulticastDelegate*/ _backingField_Delegate = null;
    /*MulticastDelegate*/ get Delegate()
    {
        return _backingField_Delegate;
    }
    /*EventCallbackDelegateType*/ type = null;
    /*EventCallbackFlags*/ _backingField_Flags = null;
    /*EventCallbackFlags*/ get Flags()
    {
        return _backingField_Flags;
    }
    constructor(/*object*/ receiver, /*MulticastDelegate*/ target, /*EventCallbackDelegateType*/ type, /*EventCallbackFlags*/ eventFlags)
    {
        super();
        Receiver = receiver;
        Delegate = target;
        .type  = type;
        Flags = eventFlags;
    }
    constructor(/*object*/ receiver, /*Action<T>*/ target, /*EventCallbackFlags*/ eventFlags)
    {
        super(receiver, target, EventCallbackDelegateType.ActionT, eventFlags);
    }
    constructor(/*object*/ receiver, /*Func<T, Task>*/ target, /*EventCallbackFlags*/ eventFlags)
    {
        super(receiver, target, EventCallbackDelegateType.FuncTTask, eventFlags);
    }
    /*Task*/ Callback(/*object*/ _eventData)
    {
        /*Task*/ let task = Task.CompletedTask;
        switch(type)
        {
            case EventCallbackDelegateType.Action:
            {
                Delegate.Call();
                break;
            }
            case EventCallbackDelegateType.FuncTask:
            {
                task = TaskDelegate.Call();
                break;
            }
            case EventCallbackDelegateType.ActionT:
            {
                Delegate.Call(null, _eventData);
                break;
            }
            case EventCallbackDelegateType.FuncTTask:
            {
                task = TaskDelegate.Call(null, _eventData);
                break;
            }
        }
        return task;
    }
    /*Task*/ InvokeAsync(/*Event*/ eventData)
    {
        return InvokeAsync(eventData);
    }
    /*Task*/ async InvokeAsync(/*object*/ eventData)
    {
        if (Delegate != null)
        {
            /*var*/ let scope = Receiver ?? Delegate"$scope";
            if (scope instanceof IHandleEvent, he = scope)
            {
                await he.HandleEventAsync(new EventCallbackWorkItem(Delegate), eventData);
            }
            else 
            {
                await Callback(eventData);
            }
        }
    }
    /*Task*/ InvokeAsync(/*T*/ eventData)
    {
        return InvokeAsync(eventData);
    }
    /*bool*/ get HasDelegate()
    {
        return Delegate != null;
    }
}


class Microsoft_AspNetCore_Components_EventCallbackFactory extends object
{
    constructor()
    {
        super();
    }
    /*EventCallback*/ Create(/*object*/ receiver, /*EventCallback*/ callback)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(receiver);
        return callback;
    }
    /*EventCallback*/ Create(/*object*/ receiver, /*Action*/ callback)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(receiver);
        return CreateCore(receiver, callback);
    }
    /*EventCallback*/ Create(/*object*/ receiver, /*Action<object>*/ callback)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(receiver);
        return CreateCore(receiver, callback);
    }
    /*EventCallback*/ Create(/*object*/ receiver, /*Func<Task>*/ callback)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(receiver);
        return CreateCore(receiver, callback);
    }
    /*EventCallback*/ Create(/*object*/ receiver, /*Func<object, Task>*/ callback)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(receiver);
        return CreateCore(receiver, callback);
    }
    /*EventCallback<TValue>*/ Create(TValue, /*object*/ receiver, /*EventCallback*/ callback)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(receiver);
        throw new NotImplementedException();
    }
    /*EventCallback<TValue>*/ Create(TValue, /*object*/ receiver, /*EventCallback<TValue>*/ callback)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(receiver);
        return callback;
    }
    /*EventCallback<TValue>*/ Create(TValue, /*object*/ receiver, /*Action*/ callback)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(receiver);
        return CreateCore_$1(TValue, receiver, callback);
    }
    /*EventCallback<TValue>*/ Create(TValue, /*object*/ receiver, /*Action<TValue>*/ callback)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(receiver);
        return CreateCore_$1(TValue, receiver, callback);
    }
    /*EventCallback<TValue>*/ Create(TValue, /*object*/ receiver, /*Func<Task>*/ callback)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(receiver);
        return CreateCore_$1(TValue, receiver, callback);
    }
    /*EventCallback<TValue>*/ Create(TValue, /*object*/ receiver, /*Func<TValue, Task>*/ callback)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(receiver);
        return CreateCore_$1(TValue, receiver, callback);
    }
    /*EventCallback<TValue>*/ CreateInferred(TValue, /*object*/ receiver, /*Action<TValue>*/ callback, /*TValue*/ value)
    {
        return Create(receiver, callback);
    }
    /*EventCallback<TValue>*/ CreateInferred(TValue, /*object*/ receiver, /*Func<TValue, Task>*/ callback, /*TValue*/ value)
    {
        return Create(receiver, callback);
    }
    /*EventCallback*/ CreateCore(/*object*/ receiver, /*Action*/ callback)
    {
        return new EventCallback(new EventCallback_$1(object, receiver, callback, EventCallbackDelegateType.Action, EventCallbackFlags.None));
    }
    /*EventCallback*/ CreateCore(/*object*/ receiver, /*Action<object>*/ callback)
    {
        return new EventCallback(new EventCallback_$1(object, receiver, callback, EventCallbackDelegateType.ActionT, EventCallbackFlags.None));
    }
    /*EventCallback*/ CreateCore(/*object*/ receiver, /*Func<Task>*/ callback)
    {
        return new EventCallback(new EventCallback_$1(object, receiver, callback, EventCallbackDelegateType.FuncTask, EventCallbackFlags.None));
    }
    /*EventCallback*/ CreateCore(/*object*/ receiver, /*Func<object, Task>*/ callback)
    {
        return new EventCallback(new EventCallback_$1(object, receiver, callback, EventCallbackDelegateType.FuncTTask, EventCallbackFlags.None));
    }
    /*EventCallback<TValue>*/ CreateCore(TValue, /*object*/ receiver, /*Action*/ callback)
    {
        return new EventCallback_$1(TValue, receiver, callback, EventCallbackDelegateType.Action, EventCallbackFlags.None);
    }
    /*EventCallback<TValue>*/ CreateCore(TValue, /*object*/ receiver, /*Func<Task>*/ callback)
    {
        return new EventCallback_$1(TValue, receiver, callback, EventCallbackDelegateType.FuncTask, EventCallbackFlags.None);
    }
    /*EventCallback<TValue>*/ CreateCore(TValue, /*object*/ receiver, /*Action<TValue>*/ callback)
    {
        return new EventCallback_$1(TValue, receiver, callback, EventCallbackDelegateType.ActionT, EventCallbackFlags.None);
    }
    /*EventCallback<TValue>*/ CreateCore(TValue, /*object*/ receiver, /*Func<TValue, Task>*/ callback)
    {
        return new EventCallback_$1(TValue, receiver, callback, EventCallbackDelegateType.FuncTTask, EventCallbackFlags.None);
    }
    /*EventCallback*/ Create(/*object*/ receiver, /*Action*/ action, { /*EventCallbackFlags*/ eventFlags = EventCallbackFlags.None})
    {
        return new EventCallback(new EventCallback_$1(object, receiver, action, EventCallbackDelegateType.Action, eventFlags));
    }
    /*EventCallback*/ Create(/*object*/ receiver, /*Func<Task>*/ action, { /*EventCallbackFlags*/ eventFlags = EventCallbackFlags.None})
    {
        return new EventCallback(new EventCallback_$1(object, receiver, action, EventCallbackDelegateType.FuncTask, eventFlags));
    }
    /*EventCallback<T>*/ Create(T, /*object*/ receiver, /*Action<T>*/ action, { /*EventCallbackFlags*/ eventFlags = EventCallbackFlags.None})
    {
        return new EventCallback_$1(T, receiver, action, eventFlags);
    }
    /*EventCallback<T>*/ Create(T, /*object*/ receiver, /*Func<T, Task>*/ action, { /*EventCallbackFlags*/ eventFlags = EventCallbackFlags.None})
    {
        return new EventCallback_$1(T, receiver, action, eventFlags);
    }
}

class Microsoft_AspNetCore_Components_EventCallbackFactoryBinderExtensions extends object
{
    constructor()
    {
        super();
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<string>*/ setter, /*string*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore_$1(string, factory, receiver, setter, culture, ConvertToString);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<string, Task>*/ setter, /*string*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync_$1(string, factory, receiver, setter, culture, ConvertToString);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<bool>*/ setter, /*bool*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore_$1(bool, factory, receiver, setter, culture, ConvertToBool);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<bool, Task>*/ setter, /*bool*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync_$1(bool, factory, receiver, setter, culture, ConvertToBool);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<bool?>*/ setter, /*bool*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore_$1(bool?, factory, receiver, setter, culture, ConvertToNullableBool);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<bool?, Task>*/ setter, /*bool?*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync_$1(bool?, factory, receiver, setter, culture, ConvertToNullableBool);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<int>*/ setter, /*int*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore_$1(int, factory, receiver, setter, culture, ConvertToInt);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<int, Task>*/ setter, /*int*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync_$1(int, factory, receiver, setter, culture, ConvertToInt);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<int?>*/ setter, /*int?*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore_$1(int?, factory, receiver, setter, culture, ConvertToNullableInt);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<int?, Task>*/ setter, /*int?*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync_$1(int?, factory, receiver, setter, culture, ConvertToNullableInt);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<long>*/ setter, /*long*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore_$1(long, factory, receiver, setter, culture, ConvertToLong);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<long, Task>*/ setter, /*long*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync_$1(long, factory, receiver, setter, culture, ConvertToLong);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<short>*/ setter, /*short*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore_$1(short, factory, receiver, setter, culture, ConvertToShort);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<short, Task>*/ setter, /*short*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync_$1(short, factory, receiver, setter, culture, ConvertToShort);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<long?>*/ setter, /*long?*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore_$1(long?, factory, receiver, setter, culture, ConvertToNullableLong);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<long?, Task>*/ setter, /*long?*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync_$1(long?, factory, receiver, setter, culture, ConvertToNullableLong);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<short?>*/ setter, /*short?*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore_$1(short?, factory, receiver, setter, culture, ConvertToNullableShort);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<short?, Task>*/ setter, /*short?*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync_$1(short?, factory, receiver, setter, culture, ConvertToNullableShort);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<float>*/ setter, /*float*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore_$1(float, factory, receiver, setter, culture, ConvertToFloat);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<float, Task>*/ setter, /*float*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync_$1(float, factory, receiver, setter, culture, ConvertToFloat);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<float?>*/ setter, /*float?*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore_$1(float?, factory, receiver, setter, culture, ConvertToNullableFloat);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<float?, Task>*/ setter, /*float?*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync_$1(float?, factory, receiver, setter, culture, ConvertToNullableFloat);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<double>*/ setter, /*double*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore_$1(double, factory, receiver, setter, culture, ConvertToDoubleDelegate);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<double, Task>*/ setter, /*double*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync_$1(double, factory, receiver, setter, culture, ConvertToDoubleDelegate);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<double?>*/ setter, /*double?*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore_$1(double?, factory, receiver, setter, culture, ConvertToNullableDoubleDelegate);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<double?, Task>*/ setter, /*double?*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync_$1(double?, factory, receiver, setter, culture, ConvertToNullableDoubleDelegate);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<decimal>*/ setter, /*decimal*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore_$1(decimal, factory, receiver, setter, culture, ConvertToDecimal);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<decimal, Task>*/ setter, /*decimal*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync_$1(decimal, factory, receiver, setter, culture, ConvertToDecimal);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<decimal?>*/ setter, /*decimal?*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore_$1(decimal?, factory, receiver, setter, culture, ConvertToNullableDecimal);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<decimal?, Task>*/ setter, /*decimal?*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync_$1(decimal?, factory, receiver, setter, culture, ConvertToNullableDecimal);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<DateTime>*/ setter, /*DateTime*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore_$1(DateTime, factory, receiver, setter, culture, ConvertToDateTime);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<DateTime, Task>*/ setter, /*DateTime*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync_$1(DateTime, factory, receiver, setter, culture, ConvertToDateTime);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<DateTime>*/ setter, /*DateTime*/ existingValue, /*string*/ format, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore_$1(DateTime, factory, receiver, setter, culture, format, ConvertToDateTimeWithFormat);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<DateTime, Task>*/ setter, /*DateTime*/ existingValue, /*string*/ format, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync_$1(DateTime, factory, receiver, setter, culture, format, ConvertToDateTimeWithFormat);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<DateTime?>*/ setter, /*DateTime?*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore_$1(DateTime?, factory, receiver, setter, culture, ConvertToNullableDateTime);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<DateTime?, Task>*/ setter, /*DateTime?*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync_$1(DateTime?, factory, receiver, setter, culture, ConvertToNullableDateTime);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<DateTime?>*/ setter, /*DateTime?*/ existingValue, /*string*/ format, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore_$1(DateTime?, factory, receiver, setter, culture, format, ConvertToNullableDateTimeWithFormat);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<DateTime?, Task>*/ setter, /*DateTime?*/ existingValue, /*string*/ format, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync_$1(DateTime?, factory, receiver, setter, culture, format, ConvertToNullableDateTimeWithFormat);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<DateTimeOffset>*/ setter, /*DateTimeOffset*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore_$1(DateTimeOffset, factory, receiver, setter, culture, ConvertToDateTimeOffset);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<DateTimeOffset, Task>*/ setter, /*DateTimeOffset*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync_$1(DateTimeOffset, factory, receiver, setter, culture, ConvertToDateTimeOffset);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<DateTimeOffset>*/ setter, /*DateTimeOffset*/ existingValue, /*string*/ format, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore_$1(DateTimeOffset, factory, receiver, setter, culture, format, ConvertToDateTimeOffsetWithFormat);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<DateTimeOffset, Task>*/ setter, /*DateTimeOffset*/ existingValue, /*string*/ format, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync_$1(DateTimeOffset, factory, receiver, setter, culture, format, ConvertToDateTimeOffsetWithFormat);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<DateTimeOffset?>*/ setter, /*DateTimeOffset?*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore_$1(DateTimeOffset?, factory, receiver, setter, culture, ConvertToNullableDateTimeOffset);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<DateTimeOffset?, Task>*/ setter, /*DateTimeOffset?*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync_$1(DateTimeOffset?, factory, receiver, setter, culture, ConvertToNullableDateTimeOffset);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<DateTimeOffset?>*/ setter, /*DateTimeOffset?*/ existingValue, /*string*/ format, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore_$1(DateTimeOffset?, factory, receiver, setter, culture, format, ConvertToNullableDateTimeOffsetWithFormat);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<DateTimeOffset?, Task>*/ setter, /*DateTimeOffset?*/ existingValue, /*string*/ format, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync_$1(DateTimeOffset?, factory, receiver, setter, culture, format, ConvertToNullableDateTimeOffsetWithFormat);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(T, /*EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<T>*/ setter, /*T*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCore_$1(T, factory, receiver, setter, culture, ParserDelegateCache.Get(T));
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinder(T, /*EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<T, Task>*/ setter, /*T*/ existingValue, { /*CultureInfo*/ culture = null})
    {
        return CreateBinderCoreAsync_$1(T, factory, receiver, setter, culture, ParserDelegateCache.Get(T));
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinderCore(T, /*EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<T>*/ setter, /*CultureInfo*/ culture, /*BindConverter.BindParser<T>*/ converter)
    {
        /*Action<ChangeEventArgs>*/ let callback = function(/**/ e)
        {
            {
                /*T*/ let value = default;
                /*var*/ let converted = false;
                {
                    let $v = { value: set(value){ value = value; } };
                    converted = converter(e.Target.Value, culture, $v);
                }
                {
                }
                if (converted)
                {
                    setter(value);
                }
                else if (.Empty.Equals(e.Target.Value))
                {
                    setter(default);
                }
            }
        };
        return factory.Create(ChangeEventArgs, receiver, callback);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinderCoreAsync(T, /*EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<T, Task>*/ setter, /*CultureInfo*/ culture, /*BindConverter.BindParser<T>*/ converter)
    {
        /*Func<ChangeEventArgs, Task>*/ let callback = function(/**/ e)
        {
            {
                /*T*/ let value = default;
                /*var*/ let converted = false;
                {
                    let $v = { value: set(value){ value = value; } };
                    converted = converter(e.Target.Value, culture, $v);
                }
                {
                }
                if (converted)
                {
                    await setter(value);
                }
                else if (.Empty.Equals(e.Target.Value))
                {
                    await setter(default);
                }
            }
        };
        return factory.Create(ChangeEventArgs, receiver, callback);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinderCore(T, /*EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<T>*/ setter, /*CultureInfo*/ culture, /*string*/ format, /*BindConverter.BindParserWithFormat<T>*/ converter)
    {
        /*Action<ChangeEventArgs>*/ let callback = function(/**/ e)
        {
            {
                /*T*/ let value = default;
                /*var*/ let converted = false;
                {
                    let $v = { value: set(value){ value = value; } };
                    converted = converter(e.Target.Value, culture, format, $v);
                }
                {
                }
                if (converted)
                {
                    setter(value);
                }
                else if (.Empty.Equals(e.Target.Value))
                {
                    setter(default);
                }
            }
        };
        return factory.Create(ChangeEventArgs, receiver, callback);
    }
    /*EventCallback<ChangeEventArgs>*/ CreateBinderCoreAsync(T, /*EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<T, Task>*/ setter, /*CultureInfo*/ culture, /*string*/ format, /*BindConverter.BindParserWithFormat<T>*/ converter)
    {
        /*Func<ChangeEventArgs, Task>*/ let callback = function(/**/ e)
        {
            {
                /*T*/ let value = default;
                /*var*/ let converted = false;
                {
                    let $v = { value: set(value){ value = value; } };
                    converted = converter(e.Target.Value, culture, format, $v);
                }
                {
                }
                if (converted)
                {
                    await setter(value);
                }
                else if (.Empty.Equals(e.Target.Value))
                {
                    await setter(default);
                }
            }
        };
        return factory.Create(ChangeEventArgs, receiver, callback);
    }
}

class Microsoft_AspNetCore_Components_EventCallbackFactoryEventArgsExtensions extends object
{
    constructor()
    {
        super();
    }
    /*EventCallback<EventArgs>*/ Create(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<EventArgs>*/ callback)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(factory);
        return factory.Create(EventArgs, receiver, callback);
    }
    /*EventCallback<EventArgs>*/ Create(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<EventArgs, Task>*/ callback)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(factory);
        return factory.Create(EventArgs, receiver, callback);
    }
    /*EventCallback<ChangeEventArgs>*/ Create(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Action<ChangeEventArgs>*/ callback)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(factory);
        return factory.Create(ChangeEventArgs, receiver, callback);
    }
    /*EventCallback<ChangeEventArgs>*/ Create(/*EventCallbackFactory*/ factory, /*object*/ receiver, /*Func<ChangeEventArgs, Task>*/ callback)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(factory);
        return factory.Create(ChangeEventArgs, receiver, callback);
    }
}

 = 1 << 0 = 1 << 1
class Microsoft_AspNetCore_Components_EventCallbackWorkItem extends System_ValueType
{
    /*EventCallbackWorkItem*/ Empty = new EventCallbackWorkItem(null);
    /*MulticastDelegate*/ _delegate = null;
    constructor(/*MulticastDelegate*/ @delegate)
    {
        super();
        _delegate = @delegate;
    }
    /*Task*/ InvokeAsync(/*object*/ arg)
    {
        return InvokeAsync_$1(object, _delegate, arg);
    }
    /*Task*/ InvokeAsync(T, /*MulticastDelegate*/ @delegate, /*T*/ arg)
    {
        switch(@delegate)
        {
            case null:
            {
                return Task.CompletedTask;
            }
Func_$2            {
                return funcEventArgs.Invoke(arg) ?? Task.CompletedTask;
            }
Func_$1            {
                return func.Invoke() ?? Task.CompletedTask;
            }
Action_$1            {
                actionEventArgs.Invoke(arg);
                return Task.CompletedTask;
            }
Action            {
                action.Invoke();
                return Task.CompletedTask;
            }
            default:            {
                {
                    {
                        return @delegate.Call(arg) as Task ?? Task.CompletedTask;
                    }
TargetInvocationException                    {
                        throw e.InnerException;
                    }
                }
            }
        }
    }
}


const Microsoft_AspNetCore_Components_IComponent = (Base) => class extends Base
{
}

const Microsoft_AspNetCore_Components_IComponentActivator = (Base) => class extends Base
{
}

const Microsoft_AspNetCore_Components_IComponentRenderMode = (Base) => class extends Base
{
}

const Microsoft_AspNetCore_Components_IErrorBoundary = (Base) => class extends Base
{
}

const Microsoft_AspNetCore_Components_IHandleAfterRender = (Base) => class extends Base
{
}

const Microsoft_AspNetCore_Components_IHandleEvent = (Base) => class extends Base
{
}

const Microsoft_AspNetCore_Components_ILayoutComponent = (Base) => class extends Base
{
    /*RenderFragment*/ _backingField_Body = null;
    /*RenderFragment*/ get Body()
    {
        return _backingField_Body;
    }
    /*RenderFragment*/ set Body(value)
    {
        _backingField_Body = value;
    }
}

class Microsoft_AspNetCore_Components_InjectAttribute extends System_Attribute
{
    constructor(/*bool*/ required)
    {
        super();
    }
}

class Microsoft_AspNetCore_Components_LayoutAttribute extends System_Attribute
{
    constructor(/*Type*/ layoutType)
    {
        super();
        LayoutType = layoutType ??         throw new ArgumentNullException(nameof(layoutType));
;
        if (IComponent.IsAssignableFrom(layoutType))
        {
            throw new ArgumentException(layoutType.FullName + IComponent.FullName);
        }
    }
    /*Type*/ _backingField_LayoutType = null;
    /*Type*/ get LayoutType()
    {
        return _backingField_LayoutType;
    }
    /*Type*/ set LayoutType(value)
    {
        _backingField_LayoutType = value;
    }
}

class Microsoft_AspNetCore_Components_LayoutComponentBase extends Microsoft_AspNetCore_Components_IComponent(Microsoft_AspNetCore_Components_ILayoutComponent(Microsoft_AspNetCore_Components_ComponentBase))
{
    constructor()
    {
        super();
    }
    /*RenderFragment*/ _backingField_Body = null;
    /*RenderFragment*/ get Body()
    {
        return _backingField_Body;
    }
    /*RenderFragment*/ set Body(value)
    {
        _backingField_Body = value;
    }
}

class Microsoft_AspNetCore_Components_LayoutView extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
    }
    /*RenderFragment*/ EmptyRenderFragment = function(/**/ builder, /**/ key)
    {
    };
    /*RenderFragment*/ _backingField_ChildContent = null;
    /*RenderFragment*/ get ChildContent()
    {
        return _backingField_ChildContent;
    }
    /*RenderFragment*/ set ChildContent(value)
    {
        _backingField_ChildContent = value;
    }
    /*Type*/ _backingField_Layout = null;
    /*Type*/ get Layout()
    {
        return _backingField_Layout;
    }
    /*Type*/ set Layout(value)
    {
        _backingField_Layout = value;
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ frame, { /*object*/ key = null})
    {
        /*// In the middle goes the supplied content
            var*/ let fragment = ChildContent ?? EmptyRenderFragment;
        /*// Then repeatedly wrap that in each layer of nested layout until we get
            // to a layout that has no parent
            var*/ let layoutType = Layout;
        while(layoutType != null)
        {
            fragment = WrapInLayout(layoutType, fragment);
            layoutType = GetParentLayoutType(layoutType);
        }
        frame.Content(fragment, { sequenceNumber : Utility.LayoutView_Fragment_SequenceNumber });
    }
    /*RenderFragment*/ WrapInLayout(/*Type*/ layoutType, /*RenderFragment*/ bodyParam)
    {
IUIFrame = null        {
            builder.Component(layoutType, function(/**/ component)
            {
                {
                    LayoutComponentBasecomponent.Body  = bodyParam;
                }
            }, { key : key, sequenceNumber : Utility.LayoutView_Layout_SequenceNumber });
        }
        return Render;
    }
    /*Type*/ GetParentLayoutType(/*Type*/ type)
    {
        type.GetCustomAttributes(LayoutAttribute, true).FirstOrDefault().As(LayoutAttribute)LayoutType;
    }
}

class Microsoft_AspNetCore_Components_LayoutView extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
    }
}

class Microsoft_AspNetCore_Components_LocationChangeException extends System_Exception
{
    constructor(/*string*/ message, /*Exception*/ innerException)
    {
        super(message, innerException);
    }
}

class Microsoft_AspNetCore_Components_MarkupString extends System_ValueType
{
    constructor(/*string*/ html)
    {
        super();
        Html = html;
    }
    /*string*/ _backingField_Html = null;
    /*string*/ get Html()
    {
        return _backingField_Html;
    }
    /*string*/ set Html(value)
    {
        _backingField_Html = value;
    }
MarkupString    new MarkupString(str);
}

class Microsoft_AspNetCore_Components_NavigationException extends System_Exception
{
    constructor(/*string*/ uri)
    {
        super();
        Location = uri;
    }
    /*string*/ _backingField_Location = null;
    /*string*/ get Location()
    {
        return _backingField_Location;
    }
}

class Microsoft_AspNetCore_Components_NavigationManager extends object
{
    constructor()
    {
        super();
    }
EventHandler_$1    {
        AssertInitialized();
        _locationChanged += value;
    }
    {
        AssertInitialized();
        _locationChanged -= value;
    }
    /*EventHandler<LocationChangedEventArgs>*/ _locationChanged = null;
    /*List<Func<LocationChangingContext, Task>>*/ _locationChangingHandlers = new List_$1(Func<LocationChangingContext, Task>);
    /*CancellationTokenSource*/ _locationChangingCts = null;
    /*Uri*/ _baseUri = null;
    /*string*/ _uri = null;
    /*bool*/ _isInitialized = null;
    /*string*/ get BaseUri()
    {
        AssertInitialized();
        return _baseUri.OriginalString();
    }
    /*string*/ set BaseUri(value)
    {
        if (value != null)
        {
            value = NormalizeBaseUri(value);
        }
        _baseUri = new Uri(value/*, UriKind.Absolute*/);
    }
    /*string*/ get Uri()
    {
        AssertInitialized();
        return _uri;
    }
    /*string*/ set Uri(value)
    {
        Validate(_baseUri, value);
        _uri = value;
    }
    /*string*/ _backingField_HistoryEntryState = null;
    /*string*/ get HistoryEntryState()
    {
        return _backingField_HistoryEntryState;
    }
    /*string*/ set HistoryEntryState(value)
    {
        _backingField_HistoryEntryState = value;
    }
    /*void*/ NavigateTo(/*string*/ uri, /*bool*/ forceLoad)
    {
        NavigateTo(uri, forceLoad, { replace : false });
    }
    /*void*/ NavigateTo(/*string*/ uri, { /*bool*/ forceLoad = false, /*bool*/ replace = false})
    {
        AssertInitialized();
        if (replace)
        {
            NavigateToCore(uri, new NavigationOptions()ForceLoad = forceLoadReplaceHistoryEntry = replace);
        }
        else 
        {
            // For back-compatibility, we must call the (string, bool) overload of NavigateToCore from here,
                // because that's the only overload guaranteed to be implemented in subclasses.
                NavigateToCore(uri, forceLoad);
        }
    }
    /*void*/ NavigateTo(/*string*/ uri, /*NavigationOptions*/ options)
    {
        AssertInitialized();
        NavigateToCore(uri, options);
    }
    /*void*/ NavigateToCore(/*string*/ uri, /*bool*/ forceLoad)
    {
        NavigateToCore(uri, new NavigationOptions()ForceLoad = forceLoad);
    }
    /*void*/ NavigateToCore(/*string*/ uri, /*NavigationOptions*/ options)
    {
                throw new NotImplementedException(GetType().FullNamenameof(NavigationOptions)nameof(NavigateToCore)nameof(NavigationOptions));
;
    }
    /*void*/ Refresh({ /*bool*/ forceReload = false})
    {
        NavigateTo(Uri, { forceLoad : true, replace : true });
    }
    /*void*/ Initialize(/*string*/ baseUri, /*string*/ uri)
    {
        // Make sure it's possible/safe to call this method from constructors of derived classes.
            ArgumentNullExceptionExtension.ThrowIfNull(uri);
        ArgumentNullExceptionExtension.ThrowIfNull(baseUri);
        if (_isInitialized)
        {
            throw new InvalidOperationException(GetType().Name);
        }
        _isInitialized = true;
        // Setting BaseUri before Uri so they get validated.
            BaseUri = baseUri;
        Uri = uri;
    }
    /*void*/ EnsureInitialized()
    {
    }
    /*Uri*/ ToAbsoluteUri(/*string*/ relativeUri)
    {
        AssertInitialized();
        return new Uri(_baseUri + relativeUri);
    }
    /*string*/ ToBaseRelativePath(/*string*/ uri)
    {
        if (uri == null)
        return null;
        if (uri.StartsWith(_baseUri.OriginalString(), StringComparison.Ordinal))
        {
            return uri.Substring(_baseUri.OriginalString().Length);
        }
        /*var*/ let pathEndIndex = uri.AsSpan().IndexOfAny('#', '?');
        /*var*/ let uriPathOnly = pathEndIndex < 0uriuri.AsSpan(0, pathEndIndex);
        if (_baseUri.OriginalString().EndsWith("/") && uriPathOnly.Equals(_baseUri.OriginalString().AsSpan(0, _baseUri.OriginalString().Length  - 1), StringComparison.Ordinal))
        {
            return uri.Substring(_baseUri.OriginalString().Length  - 1);
        }
        /*var*/ let message = uri_baseUri;
        throw new ArgumentException(message);
    }
    /*ReadOnlySpan<char>*/ ToBaseRelativePath(/*ReadOnlySpan<char>*/ uri)
    {
        if (uri.StartsWith(_baseUri.OriginalString().AsSpan(), StringComparison.Ordinal))
        {
            return urinew SystemRange(_baseUri.OriginalString().Length, 1);
        }
        /*var*/ let pathEndIndex = uri.IndexOfAny('#', '?');
        /*var*/ let uriPathOnly = pathEndIndex < 0uriurinew SystemRange(0, pathEndIndex);
        if (_baseUri.OriginalString().EndsWith("/") && uriPathOnly.IsEqual(_baseUri.OriginalString().AsSpan(0, _baseUri.OriginalString().Length  - 1), StringComparison.Ordinal))
        {
            return urinew SystemRange(_baseUri.OriginalString().Length  - 1, 1);
        }
        /*var*/ let message = uri_baseUri;
        throw new ArgumentException(message);
    }
    /*string*/ NormalizeBaseUri(/*string*/ baseUri)
    {
        /*var*/ let lastSlashIndex = baseUri.LastIndexOf('/');
        if (lastSlashIndex >= 0)
        {
            baseUri = baseUri.Substring(0, lastSlashIndex + 1);
        }
        return baseUri;
    }
    /*void*/ NotifyLocationChanged(/*bool*/ isInterceptedLink)
    {
        {
            _locationChangedInvoke(, new LocationChangedEventArgs(_uri, isInterceptedLink)HistoryEntryState = HistoryEntryState);
        }
Exception        {
            throw new LocationChangeException("An exception occurred while dispatching a location changed event.", ex);
        }
    }
    /*Task<bool>*/ async NotifyLocationChangingAsync(/*string*/ uri, /*object*/ state, /*bool*/ isNavigationIntercepted)
    {
        _locationChangingCtsCancel();
        _locationChangingCts = null;
        /*var*/ let handlerCount = _locationChangingHandlers.Count;
        if (handlerCount == 0)
        {
            return true;
        }
        /*var*/ let cts = new CancellationTokenSource();
        _locationChangingCts = cts;
        /*var*/ let cancellationToken = cts.Token;
        /*var*/ let context = new LocationChangingContext()TargetLocation = uriHistoryEntryState = stateIsNavigationIntercepted = isNavigationInterceptedCancellationToken = cancellationToken;
        {
            if (handlerCount == 1)
            {
                /*var*/ let handlerTask = InvokeLocationChangingHandlerAsync(_locationChangingHandlers0, context);
                if (handlerTask.IsFaulted)
                {
                    await handlerTask;
                    return false;
                }
                if (context.DidPreventNavigation)
                {
                    return false;
                }
                if (handlerTask.IsFaulted/* !handlerTask.IsCompletedSuccessfully*/)
                {
                    await handlerTask;
                }
            }
            else 
            {
                /*var*/ let locationChangingHandlersCopy = ArrayPool_$1.Shared.Rent(handlerCount);
                {
                    _locationChangingHandlers.CopyTo(locationChangingHandlersCopy);
                    /*var*/ let locationChangingTasks = new HashSet_$1(Task);
                    for(/*var*/ let i = 0; i < handlerCount; i++)
                    {
                        /*var*/ let handlerTask = InvokeLocationChangingHandlerAsync(locationChangingHandlersCopyi, context);
                        if (handlerTask.IsFaulted)
                        {
                            await handlerTask;
                            return false;
                        }
                        if (context.DidPreventNavigation)
                        {
                            return false;
                        }
                        locationChangingTasks.Add(handlerTask/*.AsTask()*/);
                    });
                    while(locationChangingTasks.Count  != 0)
                    {
                        /*var*/ let completedHandlerTask = await Task.WhenAny(locationChangingTasks);
                        if (completedHandlerTask.IsFaulted)
                        {
                            await completedHandlerTask;
                            return false;
                        }
                        if (context.DidPreventNavigation)
                        {
                            return false;
                        }
                        locationChangingTasks.Remove(completedHandlerTask);
                    }
                }
                {
                    ArrayPool_$1.Shared.Return(locationChangingHandlersCopy);
                }
            }
            return context.DidPreventNavigation;
        }
TaskCanceledException        {
            if (ex.CancellationToken.Equals(cancellationToken))
            {
                return false;
            }
            throw ;
        }
        {
            cts.Cancel();
            cts.Dispose();
            if (_locationChangingCts == cts)
            {
                _locationChangingCts = null;
            }
        }
    }
    /*Task*/ async InvokeLocationChangingHandlerAsync(/*Func<LocationChangingContext, Task>*/ handler, /*LocationChangingContext*/ context)
    {
        {
            await handler(context);
        }
OperationCanceledException        {
        }
Exception        {
            HandleLocationChangingHandlerException(ex, context);
        }
    }
    /*void*/ HandleLocationChangingHandlerException(/*Exception*/ ex, /*LocationChangingContext*/ context)
    {
                throw new InvalidOperationException(GetType().Namenameof(HandleLocationChangingHandlerException));
;
    }
    /*void*/ SetNavigationLockState(/*bool*/ value)
    {
                throw new NotSupportedException(GetType().Namenameof(SetNavigationLockState));
;
    }
    /*IDisposable*/ RegisterLocationChangingHandler(/*Func<LocationChangingContext, Task>*/ locationChangingHandler)
    {
        AssertInitialized();
        /*var*/ let isFirstHandler = _locationChangingHandlers.Count  == 0;
        _locationChangingHandlers.Add(locationChangingHandler);
        if (isFirstHandler)
        {
            SetNavigationLockState(true);
        }
        return new LocationChangingRegistration(locationChangingHandler, );
    }
    /*void*/ RemoveLocationChangingHandler(/*Func<LocationChangingContext, Task>*/ locationChangingHandler)
    {
        AssertInitialized();
        if (_locationChangingHandlers.Remove(locationChangingHandler) && _locationChangingHandlers.Count  == 0)
        {
            SetNavigationLockState(false);
        }
    }
    /*void*/ AssertInitialized()
    {
        if (_isInitialized)
        {
            EnsureInitialized();
        }
        if (_isInitialized)
        {
            throw new InvalidOperationException(GetType().Name);
        }
    }
    /*bool*/ TryGetLengthOfBaseUriPrefix(/*Uri*/ baseUri, /*string*/ uri, /*int*/ length)
    {
        if (uri.StartsWith(baseUri.OriginalString(), StringComparison.Ordinal))
        {
            // The absolute URI must be of the form "{baseUri}something" (where
                // baseUri ends with a slash), and from that we return "something"
                length = baseUri.OriginalString().Length;
            return true;
        }
        /*var*/ let pathEndIndex = uri.AsSpan().IndexOfAny('#', '?');
        /*var*/ let uriPathOnly = pathEndIndex < 0uriuri.AsSpan(0, pathEndIndex);
        if (baseUri.OriginalString().EndsWith("/") && uriPathOnly.Equals(baseUri.OriginalString().AsSpan(0, baseUri.OriginalString().Length  - 1), StringComparison.Ordinal))
        {
            // Special case: for the base URI "/something/", if you're at
                // "/something" then treat it as if you were at "/something/" (i.e.,
                // with the trailing slash). It's a bit ambiguous because we don't know
                // whether the server would return the same page whether or not the
                // slash is present, but ASP.NET Core at least does by default when
                // using PathBase.
                length = baseUri.OriginalString().Length  - 1;
            return true;
        }
        length = 0;
        return false;
    }
    /*void*/ Validate(/*Uri*/ baseUri, /*string*/ uri)
    {
        if (baseUri == null || uri == null)
        {
            return ;
        }
        let $v = { value: set(value){ _ = value; } };
        if (TryGetLengthOfBaseUriPrefix(baseUri, uri, $v))
        {
            /*var*/ let message = uribaseUri;
            throw new ArgumentException(message);
        }
    }
    class Microsoft_AspNetCore_Components_LocationChangingRegistration extends System_IDisposable(object)
    {
        /*Func<LocationChangingContext, Task>*/ _handler = null;
        /*NavigationManager*/ _navigationManager = null;
        constructor(/*Func<LocationChangingContext, Task>*/ handler, /*NavigationManager*/ navigationManager)
        {
            super();
            _handler = handler;
            _navigationManager = navigationManager;
        }
        /*void*/ Dispose()
        {
            _navigationManager.RemoveLocationChangingHandler(_handler);
        }
    }
}

class Microsoft_AspNetCore_Components_NavigationOptions extends System_ValueType
{
    constructor()
    {
        super();
    }
    /*bool*/ _backingField_ForceLoad = null;
    /*bool*/ get ForceLoad()
    {
        return _backingField_ForceLoad;
    }
    /*bool*/ set ForceLoad(value)
    {
        _backingField_ForceLoad = value;
    }
    /*bool*/ _backingField_ReplaceHistoryEntry = null;
    /*bool*/ get ReplaceHistoryEntry()
    {
        return _backingField_ReplaceHistoryEntry;
    }
    /*bool*/ set ReplaceHistoryEntry(value)
    {
        _backingField_ReplaceHistoryEntry = value;
    }
    /*object*/ _backingField_HistoryEntryState = null;
    /*object*/ get HistoryEntryState()
    {
        return _backingField_HistoryEntryState;
    }
    /*object*/ set HistoryEntryState(value)
    {
        _backingField_HistoryEntryState = value;
    }
}

class Microsoft_AspNetCore_Components_PageTitle extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
    }
    /*HTMLElement*/ titleWrapper = null;
    /*RenderFragment*/ _backingField_ChildContent = null;
    /*RenderFragment*/ get ChildContent()
    {
        return _backingField_ChildContent;
    }
    /*RenderFragment*/ set ChildContent(value)
    {
        _backingField_ChildContent = value;
    }
    /*void*/ OnAfterRender(/*bool*/ firstRender)
    {
        document.title  = titleWrapper.innerText;
        super.OnAfterRender(firstRender);
    }
}

class Microsoft_AspNetCore_Components_ParameterAttribute extends System_Attribute
{
    constructor()
    {
        super();
    }
}

class Microsoft_AspNetCore_Components_ParameterView extends System_ValueType
{
    constructor()
    {
        super();
    }
    class Microsoft_AspNetCore_Components_ParameterViewValue extends System_ValueType
    {
        constructor()
        {
            super();
        }
        /*string*/ get Name()
        {
            return default;
        }
        /*object*/ get Value()
        {
            return default;
        }
    }
    class Microsoft_AspNetCore_Components_ParameterViewEnumerator extends System_ValueType
    {
        constructor()
        {
            super();
        }
        /*bool*/ MoveNext()
        {
            false;
        }
        /*ParameterViewValue*/ get Current()
        {
            return default;
        }
    }
    /*ParameterViewEnumerator*/ GetEnumerator()
    {
        return default;
    }
    /*void*/ SetParameterProperties(/*IComponent*/ component)
    {
    }
}

class Microsoft_AspNetCore_Components_RendererInfo extends object
{
    /*string*/ _backingField_Name = null;
    /*string*/ get Name()
    {
        return _backingField_Name;
    }
    /*bool*/ _backingField_IsInteractive = null;
    /*bool*/ get IsInteractive()
    {
        return _backingField_IsInteractive;
    }
    constructor(/*string*/ rendererName, /*bool*/ isInteractive)
    {
        super();
        Name = rendererName;
        IsInteractive = isInteractive;
    }
}

IUIFrame = nullRenderFragmentT
class Microsoft_AspNetCore_Components_RenderHandle extends System_ValueType
{
    /*Renderer*/ _renderer = null;
    /*int*/ _componentId = null;
    constructor(/*Renderer*/ renderer, /*int*/ componentId)
    {
        super();
        _renderer = renderer ??         throw new ArgumentNullException(nameof(renderer));
;
        _componentId = componentId;
    }
    /*Dispatcher*/ get Dispatcher()
    {
        if (_renderer == null)
        {
            ThrowNotInitialized();
        }
        return _renderer.Dispatcher;
    }
    /*bool*/ get IsRenderingOnMetadataUpdate()
    {
        return false;
    }
    /*bool*/ get IsInitialized()
    {
        return _renderer != null;
    }
    /*bool*/ get IsRendererDisposed()
    {
        return _rendererDisposed ??         throw new InvalidOperationException("No renderer has been initialized.");
;
    }
    /*RendererInfo*/ get RendererInfo()
    {
        return _rendererRendererInfo ??         throw new InvalidOperationException("No renderer has been initialized.");
;
    }
    /*IComponentRenderMode*/ get RenderMode()
    {
        if (_renderer == null)
        {
            throw new InvalidOperationException("No renderer has been initialized.");
        }
        return _renderer.GetComponentRenderMode(_componentId);
    }
    /*ResourceAssetCollection*/ get Assets()
    {
        return _rendererAssets ??         throw new InvalidOperationException("No renderer has been initialized.");
;
    }
    /*void*/ Render(/*RenderFragment*/ renderFragment)
    {
        if (_renderer == null)
        {
            ThrowNotInitialized();
        }
        _renderer.AddToRenderQueue(_componentId, renderFragment);
    }
    /*Task*/ DispatchExceptionAsync(/*Exception*/ exception)
    {
        /*var*/ let renderer = _renderer;
        /*var*/ let componentId = _componentId;
        return Dispatcher.InvokeAsync(function()
        {
            return renderer.HandleComponentException(exception, componentId);
        });
    }
    /*void*/ ThrowNotInitialized()
    {
        throw new InvalidOperationException("The render handle is not yet assigned.");
    }
}

class Microsoft_AspNetCore_Components_RenderModeServerAttribute extends System_Attribute
{
    constructor()
    {
        super();
    }
}

const Microsoft_AspNetCore_Components_Rendering_RenderTreeBuilder = (Base) => class extends Base
{
}
class Microsoft_AspNetCore_Components_Rendering_RenderTreeBuilderExtension extends object
{
    constructor()
    {
        super();
    }
    /*void*/ AddAttribute(/*IUIFrame*/ builder, /*int*/ sequenceNumber, /*string*/ name, /*object*/ value)
    {
    }
    /*void*/ AddContent(/*IUIFrame*/ builder, /*int*/ sequenceNumber, /*RenderFragment*/ content)
    {
    }
    /*void*/ AddContent(/*IUIFrame*/ builder, /*int*/ sequenceNumber, /*string*/ content)
    {
    }
    /*void*/ AddMultipleAttributes(/*IUIFrame*/ builder, /*int*/ sequenceNumber, /*IReadOnlyDictionary<string, object>*/ content)
    {
    }
    /*void*/ SetKey(/*IUIFrame*/ builder, /*int*/ sequenceNumber, /*string*/ key)
    {
    }
}

class Microsoft_AspNetCore_Components_ResourceAsset extends object
{
    constructor()
    {
        super();
    }
    /*string*/ _backingField_Url = null;
    /*string*/ get Url()
    {
        return _backingField_Url;
    }
    /*IReadOnlyList<ResourceAssetProperty>*/ _backingField_Properties = null;
    /*IReadOnlyList<ResourceAssetProperty>*/ get Properties()
    {
        return _backingField_Properties;
    }
}

class Microsoft_AspNetCore_Components_ResourceAssetCollection extends H5_IH5Class(System_Collections_IEnumerable(System_Collections_Generic_IEnumerable<Microsoft_AspNetCore_Components_ResourceAsset>(System_Collections_Generic_IReadOnlyCollection<Microsoft_AspNetCore_Components_ResourceAsset>(System_Collections_Generic_IReadOnlyList<Microsoft_AspNetCore_Components_ResourceAsset>(object)))))
{
    constructor()
    {
        super();
    }
    /*ResourceAssetCollection*/ Empty = new ResourceAssetCollection();
    null;
    /*bool*/ IsContentSpecificUrl(/*string*/ path)
    {
        false;
    }
// IReadOnlyList<ResourceAsset> implementation
        ResourceAssetIReadOnlyList_$1    null;
    /*int*/ get Count()
    {
        return 0;
    }
    /*IEnumerator<ResourceAsset>*/ GetEnumerator()
    {
        Enumerable.Empty(ResourceAsset).GetEnumerator();
    }
    /*IEnumerator*/ GetEnumerator()
    {
        Enumerable.Empty(ResourceAsset).GetEnumerator();
    }
}

class Microsoft_AspNetCore_Components_ResourceAssetProperty extends object
{
    constructor()
    {
        super();
    }
    /*string*/ _backingField_Name = null;
    /*string*/ get Name()
    {
        return _backingField_Name;
    }
    /*string*/ _backingField_Value = null;
    /*string*/ get Value()
    {
        return _backingField_Value;
    }
}

class Microsoft_AspNetCore_Components_RouteAttribute extends System_Attribute
{
    constructor(/*string*/ template)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(template);
        Template = template;
    }
    /*string*/ _backingField_Template = null;
    /*string*/ get Template()
    {
        return _backingField_Template;
    }
}

class Microsoft_AspNetCore_Components_RouteData extends object
{
    constructor(/*Type*/ pageType, /*IReadOnlyDictionary<string, object>*/ routeValues)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(pageType);
        if (IComponent.IsAssignableFrom(pageType))
        {
            throw new ArgumentException(nameof(IComponent), nameof(pageType));
        }
        PageType = pageType;
        RouteValues = routeValues ??         throw new ArgumentNullException(nameof(routeValues));
;
    }
    /*Type*/ _backingField_PageType = null;
    /*Type*/ get PageType()
    {
        return _backingField_PageType;
    }
    /*IReadOnlyDictionary<string, object>*/ _backingField_RouteValues = null;
    /*IReadOnlyDictionary<string, object>*/ get RouteValues()
    {
        return _backingField_RouteValues;
    }
    /*string*/ _backingField_Template = null;
    /*string*/ get Template()
    {
        return _backingField_Template;
    }
    /*string*/ set Template(value)
    {
        _backingField_Template = value;
    }
}

class Microsoft_AspNetCore_Components_RouteView extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
    }
    /*Dictionary<Type, Type>*/ _layoutAttributeCache = new Dictionary_$2(Type, Type);
    /*NavigationManager*/ _backingField_NavigationManager = null;
    /*NavigationManager*/ get NavigationManager()
    {
        return _backingField_NavigationManager;
    }
    /*NavigationManager*/ set NavigationManager(value)
    {
        _backingField_NavigationManager = value;
    }
    /*RouteData*/ _backingField_RouteData = null;
    /*RouteData*/ get RouteData()
    {
        return _backingField_RouteData;
    }
    /*RouteData*/ set RouteData(value)
    {
        _backingField_RouteData = value;
    }
    /*Type*/ _backingField_DefaultLayout = null;
    /*Type*/ get DefaultLayout()
    {
        return _backingField_DefaultLayout;
    }
    /*Type*/ set DefaultLayout(value)
    {
        _backingField_DefaultLayout = value;
    }
    /*void*/ OnParametersSet()
    {
        if (RouteData == null)
        {
            throw new InvalidOperationException(nameof(RouteView)nameof(RouteData));
        }
        super.OnParametersSet();
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ frame, { /*object*/ key = null})
    {
        let pageLayoutType = null;
        let $v = { value: set(value){ pageLayoutType = value; } };
        if (_layoutAttributeCache.TryGetValue(RouteData.PageType, $v))
        {
            pageLayoutType = RouteData.PageType.GetCustomAttributes(LayoutAttribute, true)FirstOrDefault().As(LayoutAttribute)LayoutType;
            _layoutAttributeCacheRouteData.PageType = pageLayoutType;
        }
        pageLayoutType = pageLayoutType ?? DefaultLayout;
        frame.Component(LayoutView, function(/**/ component)
        {
            {
                component.Layout  = pageLayoutType;
                component.ChildContent  = RenderFragmentRenderPageWithParameters;
            }
        }, { sequenceNumber : Utility.RouteView_LayoutView_SequenceNumber  + pageLayoutType.GetHashCode() });
    }
    /*void*/ RenderPageWithParameters(/*IUIFrame*/ frame, { /*object*/ key = null})
    {
        frame.Component(RouteData.PageType, function(/**/ component)
        {
            {
                BlazorJs.forEach(RouteData.RouteValues, function(kvp, $_i)
                {
                    componentkvp.Key = kvp.Value;
                });
            }
        }, { key : key, sequenceNumber : Utility.RouteView_Page_SequenceNumber });
    }
}

class Microsoft_AspNetCore_Components_StreamRenderingAttribute extends System_Attribute
{
    constructor(/*bool*/ v)
    {
        super();
    }
}

class Microsoft_AspNetCore_Components_SupplyParameterFromQueryAttribute extends System_Attribute
{
    constructor()
    {
        super();
    }
}

class Microsoft_AspNetCore_Components_Authorization_AttributeAuthorizeDataCache extends object
{
    constructor()
    {
        super();
    }
    /*Dictionary<Type, IAuthorizeData[]>*/ _cache = new Dictionary_$2(Type, IAuthorizeData[]);
    /*IAuthorizeData[]*/ GetAuthorizeDataForType(/*Type*/ type)
    {
        let result = null;
        let $v = { value: set(value){ result = value; } };
        if (_cache.TryGetValue(type, $v))
        {
            result = ComputeAuthorizeDataForType(type);
            _cachetype = result;
        }
        return result;
    }
    /*IAuthorizeData[]*/ ComputeAuthorizeDataForType(/*Type*/ type)
    {
        /*// Allow Anonymous skips all authorization
            var*/ let allAttributes = type.GetCustomAttributes({ inherit : true });
        /*List<IAuthorizeData>*/ let authorizeDatas = null;
        for(/*var*/ let i = 0; i < allAttributes.Length; i++)
        {
            if (allAttributesi is IAllowAnonymous)
            {
                return null;
            }
            if (allAttributesi instanceof IAuthorizeData)
            {
                authorizeDatas = authorizeDatas ?? new List_$1(IAuthorizeData);
                authorizeDatas.Add(authorizeData);
            }
        });
        return authorizeDatasToArray();
    }
}

class Microsoft_AspNetCore_Components_Authorization_AuthenticationState extends object
{
    constructor(/*ClaimsPrincipal*/ user)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(user);
        User = user;
    }
    /*ClaimsPrincipal*/ _backingField_User = null;
    /*ClaimsPrincipal*/ get User()
    {
        return _backingField_User;
    }
}

class Microsoft_AspNetCore_Components_Authorization_AuthenticationStateData extends object
{
    constructor()
    {
        super();
    }
    /*IList<ClaimData>*/ _backingField_Claims = null;
    /*IList<ClaimData>*/ get Claims()
    {
        return _backingField_Claims;
    }
    /*IList<ClaimData>*/ set Claims(value)
    {
        _backingField_Claims = value;
    }
    /*string*/ _backingField_NameClaimType = null;
    /*string*/ get NameClaimType()
    {
        return _backingField_NameClaimType;
    }
    /*string*/ set NameClaimType(value)
    {
        _backingField_NameClaimType = value;
    }
    /*string*/ _backingField_RoleClaimType = null;
    /*string*/ get RoleClaimType()
    {
        return _backingField_RoleClaimType;
    }
    /*string*/ set RoleClaimType(value)
    {
        _backingField_RoleClaimType = value;
    }
}

class Microsoft_AspNetCore_Components_Authorization_AuthenticationStateProvider extends object
{
    constructor()
    {
        super();
    }
/*AuthenticationStateChangedHandler*/ let AuthenticationStateChanged    /*void*/ NotifyAuthenticationStateChanged(/*Task<AuthenticationState>*/ task)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(task);
        AuthenticationStateChangedInvoke(task);
    }
}
Task_$1
class Microsoft_AspNetCore_Components_Authorization_AuthorizeDataAdapter extends Microsoft_AspNetCore_Authorization_IAuthorizeData(object)
{
    /*AuthorizeView*/ _component = null;
    constructor(/*AuthorizeView*/ component)
    {
        super();
        _component = component ??         throw new ArgumentNullException(nameof(component));
;
    }
    /*string*/ get Policy()
    {
        return _component.Policy;
    }
    /*string*/ set Policy(value)
    {
                throw new NotSupportedException();
;
    }
    /*string*/ get Roles()
    {
        return _component.Roles;
    }
    /*string*/ set Roles(value)
    {
                throw new NotSupportedException();
;
    }
    /*string*/ get AuthenticationSchemes()
    {
        return null;
    }
    /*string*/ set AuthenticationSchemes(value)
    {
                throw new NotSupportedException();
;
    }
}

class Microsoft_AspNetCore_Components_Authorization_AuthorizeRouteView extends Microsoft_AspNetCore_Components_RouteView
{
    /*RenderFragment<AuthenticationState>*/ _defaultNotAuthorizedContent = function(/**/ state)
    {
function(/**/ builder, /**/ key)
        {
            return builder.AddContent(0, "Not authorized");
        }    };
    /*RenderFragment*/ _defaultAuthorizingContent = function(/**/ builder, /**/ key)
    {
        return builder.AddContent(0, "Authorizing...");
    };
    /*RenderFragment*/ _renderAuthorizeRouteViewCoreDelegate = null;
    /*RenderFragment<AuthenticationState>*/ _renderAuthorizedDelegate = null;
    /*RenderFragment<AuthenticationState>*/ _renderNotAuthorizedDelegate = null;
    /*RenderFragment*/ _renderAuthorizingDelegate = null;
    constructor()
    {
        super();
        /*// Cache the rendering delegates so that we only construct new closure instances
            // when they are actually used (e.g., we never prepare a RenderFragment bound to
            // the NotAuthorized content except when you are displaying that particular state)
            RenderFragment*/ let renderBaseRouteViewDelegate = super.BuildRenderTree;
        _renderAuthorizedDelegate = function(/**/ authenticateState)
        {
renderBaseRouteViewDelegate        };
        _renderNotAuthorizedDelegate = function(/**/ authenticationState)
        {
function(/**/ builder, /**/ key)
            {
                return RenderNotAuthorizedInDefaultLayout(builder, key, authenticationState);
            }        };
        _renderAuthorizingDelegate = RenderAuthorizingInDefaultLayout;
        _renderAuthorizeRouteViewCoreDelegate = RenderAuthorizeRouteViewCore;
    }
    /*RenderFragment<AuthenticationState>*/ _backingField_NotAuthorized = null;
    /*RenderFragment<AuthenticationState>*/ get NotAuthorized()
    {
        return _backingField_NotAuthorized;
    }
    /*RenderFragment<AuthenticationState>*/ set NotAuthorized(value)
    {
        _backingField_NotAuthorized = value;
    }
    /*RenderFragment*/ _backingField_Authorizing = null;
    /*RenderFragment*/ get Authorizing()
    {
        return _backingField_Authorizing;
    }
    /*RenderFragment*/ set Authorizing(value)
    {
        _backingField_Authorizing = value;
    }
    /*object*/ _backingField_Resource = null;
    /*object*/ get Resource()
    {
        return _backingField_Resource;
    }
    /*object*/ set Resource(value)
    {
        _backingField_Resource = value;
    }
    /*Task<AuthenticationState>*/ _backingField_ExistingCascadedAuthenticationState = null;
    /*Task<AuthenticationState>*/ get ExistingCascadedAuthenticationState()
    {
        return _backingField_ExistingCascadedAuthenticationState;
    }
    /*Task<AuthenticationState>*/ set ExistingCascadedAuthenticationState(value)
    {
        _backingField_ExistingCascadedAuthenticationState = value;
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ frame, { /*object*/ key = null})
    {
        if (ExistingCascadedAuthenticationState != null)
        {
            // If this component is already wrapped in a <CascadingAuthenticationState> (or another
                // compatible provider), then don't interfere with the cascaded authentication state.
                _renderAuthorizeRouteViewCoreDelegate(frame, key);
        }
        else 
        {
            frame.Component(CascadingAuthenticationState, function(/**/ component)
            {
                {
                    component.ChildContent  = _renderAuthorizeRouteViewCoreDelegate;
                }
            }, { sequenceNumber : 1 });
        }
    }
    /*void*/ RenderAuthorizeRouteViewCore(/*IUIFrame*/ frame, { /*object*/ key = null})
    {
        frame.Component(AuthorizeRouteViewCore, function(/**/ component)
        {
            {
                component.RouteData  = RouteData;
                component.Authorized  = _renderAuthorizedDelegate;
                component.Authorizing  = _renderAuthorizingDelegate;
                component.NotAuthorized  = _renderNotAuthorizedDelegate;
                component.Resource  = Resource;
            }
        }, { sequenceNumber : Utility.AuthorizeRouteView_AuthorizeRouteViewCore_SequenceNumber });
    }
    /*void*/ RenderContentInDefaultLayout(/*IUIFrame*/ frame, /*object*/ key, /*RenderFragment*/ content)
    {
        frame.Component(LayoutView, function(/**/ component)
        {
            {
                component.Layout  = DefaultLayout;
                component.ChildContent  = content;
            }
        }, { sequenceNumber : Utility.AuthorizeRouteView_LayoutView_SequenceNumber });
    }
    /*void*/ RenderNotAuthorizedInDefaultLayout(/*IUIFrame*/ builder, /*object*/ key, /*AuthenticationState*/ authenticationState)
    {
        /*var*/ let content = NotAuthorized ?? _defaultNotAuthorizedContent;
        RenderContentInDefaultLayout(builder, key, content(authenticationState));
    }
    /*void*/ RenderAuthorizingInDefaultLayout(/*IUIFrame*/ builder, { /*object*/ key = null})
    {
        /*var*/ let content = Authorizing ?? _defaultAuthorizingContent;
        RenderContentInDefaultLayout(builder, key, content);
    }
    class Microsoft_AspNetCore_Components_Authorization_AuthorizeRouteViewCore extends Microsoft_AspNetCore_Components_Authorization_AuthorizeViewCore
    {
        constructor()
        {
            super();
        }
        /*RouteData*/ _backingField_RouteData = null;
        /*RouteData*/ get RouteData()
        {
            return _backingField_RouteData;
        }
        /*RouteData*/ set RouteData(value)
        {
            _backingField_RouteData = value;
        }
        /*IAuthorizeData[]*/ GetAuthorizeData()
        {
            AttributeAuthorizeDataCache.GetAuthorizeDataForType(RouteData.PageType);
        }
    }
}

class Microsoft_AspNetCore_Components_Authorization_AuthorizeView extends Microsoft_AspNetCore_Components_Authorization_AuthorizeViewCore
{
    /*IAuthorizeData[]*/ selfAsAuthorizeData = null;
    constructor()
    {
        super();
        selfAsAuthorizeData = new AuthorizeDataAdapter();
    }
    /*string*/ _backingField_Policy = null;
    /*string*/ get Policy()
    {
        return _backingField_Policy;
    }
    /*string*/ set Policy(value)
    {
        _backingField_Policy = value;
    }
    /*string*/ _backingField_Roles = null;
    /*string*/ get Roles()
    {
        return _backingField_Roles;
    }
    /*string*/ set Roles(value)
    {
        _backingField_Roles = value;
    }
    /*IAuthorizeData[]*/ GetAuthorizeData()
    {
        selfAsAuthorizeData;
    }
}

class Microsoft_AspNetCore_Components_Authorization_AuthorizeView extends Microsoft_AspNetCore_Components_Authorization_AuthorizeViewCore
{
    constructor()
    {
        super();
    }
}

class Microsoft_AspNetCore_Components_Authorization_AuthorizeViewCore extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
    }
    /*AuthenticationState*/ currentAuthenticationState = null;
    /*bool?*/ isAuthorized = null;
    /*RenderFragment<AuthenticationState>*/ _backingField_ChildContent = null;
    /*RenderFragment<AuthenticationState>*/ get ChildContent()
    {
        return _backingField_ChildContent;
    }
    /*RenderFragment<AuthenticationState>*/ set ChildContent(value)
    {
        _backingField_ChildContent = value;
    }
    /*RenderFragment<AuthenticationState>*/ _backingField_NotAuthorized = null;
    /*RenderFragment<AuthenticationState>*/ get NotAuthorized()
    {
        return _backingField_NotAuthorized;
    }
    /*RenderFragment<AuthenticationState>*/ set NotAuthorized(value)
    {
        _backingField_NotAuthorized = value;
    }
    /*RenderFragment<AuthenticationState>*/ _backingField_Authorized = null;
    /*RenderFragment<AuthenticationState>*/ get Authorized()
    {
        return _backingField_Authorized;
    }
    /*RenderFragment<AuthenticationState>*/ set Authorized(value)
    {
        _backingField_Authorized = value;
    }
    /*RenderFragment*/ _backingField_Authorizing = null;
    /*RenderFragment*/ get Authorizing()
    {
        return _backingField_Authorizing;
    }
    /*RenderFragment*/ set Authorizing(value)
    {
        _backingField_Authorizing = value;
    }
    /*object*/ _backingField_Resource = null;
    /*object*/ get Resource()
    {
        return _backingField_Resource;
    }
    /*object*/ set Resource(value)
    {
        _backingField_Resource = value;
    }
    /*Task<AuthenticationState>*/ _backingField_AuthenticationState = null;
    /*Task<AuthenticationState>*/ get AuthenticationState()
    {
        return _backingField_AuthenticationState;
    }
    /*Task<AuthenticationState>*/ set AuthenticationState(value)
    {
        _backingField_AuthenticationState = value;
    }
    /*IAuthorizationPolicyProvider*/ _backingField_AuthorizationPolicyProvider = null;
    /*IAuthorizationPolicyProvider*/ get AuthorizationPolicyProvider()
    {
        return _backingField_AuthorizationPolicyProvider;
    }
    /*IAuthorizationPolicyProvider*/ set AuthorizationPolicyProvider(value)
    {
        _backingField_AuthorizationPolicyProvider = value;
    }
    /*IAuthorizationService*/ _backingField_AuthorizationService = null;
    /*IAuthorizationService*/ get AuthorizationService()
    {
        return _backingField_AuthorizationService;
    }
    /*IAuthorizationService*/ set AuthorizationService(value)
    {
        _backingField_AuthorizationService = value;
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ frame, { /*object*/ key = null})
    {
        if (isAuthorized == null)
        {
            frame.Content(Authorizing, { sequenceNumber : Utility.AuthorizeViewCore_Authorizing_SequenceNumber });
        }
        else if (isAuthorized == true)
        {
            /*var*/ let authorized = Authorized ?? ChildContent;
            frame.Content(authorizedInvoke(currentAuthenticationState), { sequenceNumber : Utility.AuthorizeViewCore_Authorized_SequenceNumber });
        }
        else 
        {
            frame.Content(NotAuthorizedInvoke(currentAuthenticationState), { sequenceNumber : Utility.AuthorizeViewCore_NotAuthorized_SequenceNumber });
        }
    }
    /*Task*/ async OnParametersSetAsync()
    {
        if (ChildContent != null && Authorized != null)
        {
            throw new InvalidOperationException(nameof(Authorized)nameof(ChildContent));
        }
        if (AuthenticationState == null)
        {
            throw new InvalidOperationException(nameof(AuthenticationState)CascadingAuthenticationState.Name);
        }
        // Clear the previous result of authorization
            // This will cause the Authorizing state to be displayed until the authorization has been completed
            isAuthorized = null;
        currentAuthenticationState = await AuthenticationState;
        isAuthorized = await IsAuthorizedAsync(currentAuthenticationState.User);
    }
    /*Task<bool>*/ async IsAuthorizedAsync(/*ClaimsPrincipal*/ user)
    {
        /*var*/ let authorizeData = GetAuthorizeData();
        if (authorizeData == null)
        {
            return true;
        }
        EnsureNoAuthenticationSchemeSpecified(authorizeData);
        /*var*/ let policy = await AuthorizationPolicy.CombineAsync(AuthorizationPolicyProvider, authorizeData);
        /*var*/ let result = await AuthorizationService.AuthorizeAsync(user, Resource, policy.Requirements);
        return result.Succeeded;
    }
    /*void*/ EnsureNoAuthenticationSchemeSpecified(/*IAuthorizeData[]*/ authorizeData)
    {
        for(/*var*/ let i = 0; i < authorizeData.Length; i++)
        {
            /*var*/ let entry = authorizeDatai;
            if (.IsNullOrEmpty(entry.AuthenticationSchemes))
            {
                throw new NotSupportedException(entry.AuthenticationSchemes);
            }
        });
    }
}

class Microsoft_AspNetCore_Components_Authorization_CascadingAuthenticationState extends System_IDisposable(Microsoft_AspNetCore_Components_ComponentBase)
{
    constructor()
    {
        super();
    }
    /*Task<AuthenticationState>*/ _currentAuthenticationStateTask = null;
    /*RenderFragment*/ _backingField_ChildContent = null;
    /*RenderFragment*/ get ChildContent()
    {
        return _backingField_ChildContent;
    }
    /*RenderFragment*/ set ChildContent(value)
    {
        _backingField_ChildContent = value;
    }
    /*AuthenticationStateProvider*/ _backingField_AuthenticationStateProvider = null;
    /*AuthenticationStateProvider*/ get AuthenticationStateProvider()
    {
        return _backingField_AuthenticationStateProvider;
    }
    /*AuthenticationStateProvider*/ set AuthenticationStateProvider(value)
    {
        _backingField_AuthenticationStateProvider = value;
    }
    /*void*/ OnInitialized()
    {
        AuthenticationStateProvider.AuthenticationStateChanged  += OnAuthenticationStateChanged;
        _currentAuthenticationStateTask = AuthenticationStateProvider.GetAuthenticationStateAsync();
    }
    /*void*/ OnAuthenticationStateChanged(/*Task<AuthenticationState>*/ newAuthStateTask)
    {
        InvokeAsync(function()
        {
            _currentAuthenticationStateTask = newAuthStateTask;
            StateHasChanged();
        }).FireAndForget();
    }
    /*void*/ Dispose()
    {
        AuthenticationStateProvider.AuthenticationStateChanged  -= OnAuthenticationStateChanged;
    }
}


class Microsoft_AspNetCore_Components_Authorization_ClaimData extends System_ValueType
{
    constructor(/*string*/ type, /*string*/ value)
    {
        super();
        Type = type;
        Value = value;
    }
    constructor(/*Claim*/ claim)
    {
        super(claim.Type, claim.Value);
    }
    /*string*/ _backingField_Type = null;
    /*string*/ get Type()
    {
        return _backingField_Type;
    }
    /*string*/ _backingField_Value = null;
    /*string*/ get Value()
    {
        return _backingField_Value;
    }
}


class Microsoft_AspNetCore_Components_Forms_AttributeUtilities extends object
{
    constructor()
    {
        super();
    }
    /*string*/ CombineClassNames(/*object*/ additionalAttributes, /*string*/ classNames)
    {
        let mclass = null;
        let $v = { value: set(value){ mclass = value; } };
        if (additionalAttributes || additionalAttributes.TryGetValue("class", $v))
        {
            return classNames;
        }
        /*var*/ let classAttributeValue = Convert.ToString(mclass);
        if (.IsNullOrEmpty(classAttributeValue))
        {
            return classNames;
        }
        if (.IsNullOrEmpty(classNames))
        {
            return classAttributeValue;
        }
        return classAttributeValueclassNames;
    }
}

class Microsoft_AspNetCore_Components_Forms_DataAnnotationsValidator extends System_IDisposable(Microsoft_AspNetCore_Components_ComponentBase)
{
    constructor()
    {
        super();
    }
    /*IDisposable*/ _subscriptions = null;
    /*EditContext*/ _originalEditContext = null;
    /*EditContext*/ _backingField_CurrentEditContext = null;
    /*EditContext*/ get CurrentEditContext()
    {
        return _backingField_CurrentEditContext;
    }
    /*EditContext*/ set CurrentEditContext(value)
    {
        _backingField_CurrentEditContext = value;
    }
    /*IServiceProvider*/ _backingField_ServiceProvider = null;
    /*IServiceProvider*/ get ServiceProvider()
    {
        return _backingField_ServiceProvider;
    }
    /*IServiceProvider*/ set ServiceProvider(value)
    {
        _backingField_ServiceProvider = value;
    }
    /*void*/ OnInitialized()
    {
        if (CurrentEditContext == null)
        {
            throw new InvalidOperationException(nameof(DataAnnotationsValidator) + nameof(EditContext)nameof(DataAnnotationsValidator) + );
        }
        _subscriptions = CurrentEditContext.EnableDataAnnotationsValidation(ServiceProvider);
        _originalEditContext = CurrentEditContext;
    }
    /*void*/ OnParametersSet()
    {
        if (CurrentEditContext != _originalEditContext)
        {
            throw new InvalidOperationException(GetType() + nameof(EditContext));
        }
    }
    /*void*/ Dispose(/*bool*/ disposing)
    {
    }
    /*void*/ Dispose()
    {
        super.Dispose();
        _subscriptionsDispose();
        _subscriptions = null;
        Dispose({ disposing : true });
    }
}

class Microsoft_AspNetCore_Components_Forms_EditContext extends object
{
    /*Dictionary<FieldIdentifier, FieldState>*/ _fieldStates = new Dictionary_$2(FieldIdentifier, FieldState);
    constructor(/*object*/ model)
    {
        super();
        // The only reason we disallow null is because you'd almost always want one, and if you
            // really don't, you can pass an empty object then ignore it. Ensuring it's nonnull
            // simplifies things for all consumers of EditContext.
            Model = model ??         throw new ArgumentNullException(nameof(model));
;
        Properties = new EditContextProperties();
    }
/*EventHandler<FieldChangedEventArgs>*/ let OnFieldChanged/*EventHandler<ValidationRequestedEventArgs>*/ let OnValidationRequested/*EventHandler<ValidationStateChangedEventArgs>*/ let OnValidationStateChanged    /*FieldIdentifier*/ Field(/*string*/ fieldName)
    {
        new FieldIdentifier(Model, fieldName);
    }
    /*object*/ _backingField_Model = null;
    /*object*/ get Model()
    {
        return _backingField_Model;
    }
    /*EditContextProperties*/ _backingField_Properties = null;
    /*EditContextProperties*/ get Properties()
    {
        return _backingField_Properties;
    }
    /*bool*/ _backingField_ShouldUseFieldIdentifiers = null;
    /*bool*/ get ShouldUseFieldIdentifiers()
    {
        return _backingField_ShouldUseFieldIdentifiers;
    }
    /*bool*/ set ShouldUseFieldIdentifiers(value)
    {
        _backingField_ShouldUseFieldIdentifiers = value;
    }
    /*void*/ NotifyFieldChanged(/*FieldIdentifier*/ fieldIdentifier)
    {
        GetOrAddFieldState(fieldIdentifier).IsModified  = true;
        OnFieldChangedInvoke(, new FieldChangedEventArgs(fieldIdentifier));
    }
    /*void*/ NotifyValidationStateChanged()
    {
        OnValidationStateChangedInvoke(, ValidationStateChangedEventArgs.Empty);
    }
    /*void*/ MarkAsUnmodified(/*FieldIdentifier*/ fieldIdentifier)
    {
        let state = null;
        let $v = { value: set(value){ state = value; } };
        if (_fieldStates.TryGetValue(fieldIdentifier, $v))
        {
            state.IsModified  = false;
        }
    }
    /*void*/ MarkAsUnmodified()
    {
        BlazorJs.forEach(_fieldStates, function(state, $_i)
        {
            state.Value.IsModified  = false;
        });
    }
    /*bool*/ IsModified()
    {
        BlazorJs.forEach(_fieldStates, function(state, $_i)
        {
            if (state.Value.IsModified)
            {
                return true;
            }
        });
        return false;
    }
    /*IEnumerable<string>*/ GetValidationMessages()
    {
        BlazorJs.forEach(_fieldStates, function(state, $_i)
        {
            BlazorJs.forEach(state.Value.GetValidationMessages(), function(message, $_i)
            {
message            });
        });
    }
    /*IEnumerable<string>*/ GetValidationMessages(/*FieldIdentifier*/ fieldIdentifier)
    {
        let state = null;
        let $v = { value: set(value){ state = value; } };
        if (_fieldStates.TryGetValue(fieldIdentifier, $v))
        {
            BlazorJs.forEach(state.GetValidationMessages(), function(message, $_i)
            {
message            });
        }
    }
    /*IEnumerable<string>*/ GetValidationMessages(/*Expression<Func<object>>*/ accessor)
    {
        GetValidationMessages(FieldIdentifier.Create(accessor));
    }
    /*bool*/ IsModified(/*FieldIdentifier*/ fieldIdentifier)
    {
        let state = null;
        let $v = { value: set(value){ state = value; } };
        _fieldStates.TryGetValue(fieldIdentifier, $v)state.IsModified
false;
    }
    /*bool*/ IsModified(/*Expression<Func<object>>*/ accessor)
    {
        IsModified(FieldIdentifier.Create(accessor));
    }
    /*bool*/ IsValid(/*FieldIdentifier*/ fieldIdentifier)
    {
        GetValidationMessages(fieldIdentifier).Any();
    }
    /*bool*/ IsValid(/*Expression<Func<object>>*/ accessor)
    {
        IsValid(FieldIdentifier.Create(accessor));
    }
    /*bool*/ Validate()
    {
        OnValidationRequestedInvoke(, ValidationRequestedEventArgs.Empty);
        return GetValidationMessages().Any();
    }
    /*FieldState*/ GetFieldState(/*FieldIdentifier*/ fieldIdentifier)
    {
        let state = null;
        let $v = { value: set(value){ state = value; } };
        _fieldStates.TryGetValue(fieldIdentifier, $v);
        return state;
    }
    /*FieldState*/ GetOrAddFieldState(/*FieldIdentifier*/ fieldIdentifier)
    {
        let state = null;
        let $v = { value: set(value){ state = value; } };
        if (_fieldStates.TryGetValue(fieldIdentifier, $v))
        {
            state = new FieldState(fieldIdentifier);
            _fieldStates.Add(fieldIdentifier, state);
        }
        return state;
    }
}

class Microsoft_AspNetCore_Components_Forms_EditContextDataAnnotationsExtensions extends object
{
    constructor()
    {
        super();
    }
    /*IDisposable*/ EnableDataAnnotationsValidation(/*EditContext*/ editContext, /*IServiceProvider*/ serviceProvider)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(serviceProvider);
        return new DataAnnotationsEventSubscriptions(editContext, serviceProvider);
    }
/*Action*/ let OnClearCache    /*void*/ ClearCache(/*Type[]*/ _)
    {
        OnClearCacheInvoke();
    }
    class Microsoft_AspNetCore_Components_Forms_DataAnnotationsEventSubscriptions extends System_IDisposable(object)
    {
        /*Dictionary<(Type ModelType, string FieldName), PropertyInfo>*/ _propertyInfoCache = new Dictionary_$2((Type ModelType, string FieldName), PropertyInfo);
        /*EditContext*/ _editContext = null;
        /*IServiceProvider*/ _serviceProvider = null;
        /*ValidationMessageStore*/ _messages = null;
        constructor(/*EditContext*/ editContext, /*IServiceProvider*/ serviceProvider)
        {
            super();
            _editContext = editContext ??             throw new ArgumentNullException(nameof(editContext));
;
            _serviceProvider = serviceProvider;
            _messages = new ValidationMessageStore(_editContext);
            _editContext.OnFieldChanged  += OnFieldChanged;
            _editContext.OnValidationRequested  += OnValidationRequested;
        }
        /*void*/ OnFieldChanged(/*object*/ sender, /*FieldChangedEventArgs*/ eventArgs)
        {
            /*var*/ let fieldIdentifier = eventArgs.FieldIdentifier;
            let propertyInfo = null;
            let $v = { value: set(value){ propertyInfo = value; } };
            if (TryGetValidatableProperty(fieldIdentifier, $v))
            {
                /*var*/ let propertyValue = propertyInfo.GetValue(fieldIdentifier.Model);
                /*var*/ let validationContext = new ValidationContext(fieldIdentifier.Model, _serviceProvider, { items : null })MemberName = propertyInfo.Name
;
                /*var*/ let results = new List_$1(ValidationResult);
                Validator.TryValidateProperty(propertyValue, validationContext, results);
                _messages.Clear(fieldIdentifier);
                BlazorJs.forEach(results, function(result, $_i)
                {
                    _messages.Add(fieldIdentifier, result.ErrorMessage);
                });
                // We have to notify even if there were no messages before and are still no messages now,
                    // because the "state" that changed might be the completion of some async validation task
                    _editContext.NotifyValidationStateChanged();
            }
        }
        /*void*/ OnValidationRequested(/*object*/ sender, /*ValidationRequestedEventArgs*/ e)
        {
            /*var*/ let validationContext = new ValidationContext(_editContext.Model, _serviceProvider, { items : null });
            /*var*/ let validationResults = new List_$1(ValidationResult);
            Validator.TryValidateObject(_editContext.Model, validationContext, validationResults, true);
            // Transfer results to the ValidationMessageStore
                _messages.Clear();
            BlazorJs.forEach(validationResults, function(validationResult, $_i)
            {
                if (validationResult == null)
                {
                }
                /*var*/ let hasMemberNames = false;
                BlazorJs.forEach(validationResult.MemberNames, function(memberName, $_i)
                {
                    hasMemberNames = true;
                    _messages.Add(_editContext.Field(memberName), validationResult.ErrorMessage);
                });
                if (hasMemberNames)
                {
                    _messages.Add(new FieldIdentifier(_editContext.Model, { fieldName : .Empty }), validationResult.ErrorMessage);
                }
            });
            _editContext.NotifyValidationStateChanged();
        }
        /*void*/ Dispose()
        {
            _messages.Clear();
            _editContext.OnFieldChanged  -= OnFieldChanged;
            _editContext.OnValidationRequested  -= OnValidationRequested;
            _editContext.NotifyValidationStateChanged();
        }
        /*bool*/ TryGetValidatableProperty(/*FieldIdentifier*/ fieldIdentifier, /*PropertyInfo*/ propertyInfo)
        {
            /*var*/ let cacheKey = ModelType : fieldIdentifier.Model.GetType()fieldIdentifier.FieldName;
            let $v = { value: set(value){ propertyInfo = value; } };
            if (_propertyInfoCache.TryGetValue(cacheKey, $v))
            {
                // DataAnnotations only validates public properties, so that's all we'll look for
                    // If we can't find it, cache 'null' so we don't have to try again next time
                    propertyInfo = cacheKey.ModelType.GetProperty(cacheKey.FieldName);
                // No need to lock, because it doesn't matter if we write the same value twice
                    _propertyInfoCachecacheKey = propertyInfo;
            }
            return propertyInfo != null;
        }
        /*void*/ ClearCache()
        {
            _propertyInfoCache.Clear();
        }
    }
}

class Microsoft_AspNetCore_Components_Forms_EditContextProperties extends object
{
    constructor()
    {
        super();
    }
    /*Dictionary<object, object>*/ _contents = null;
    _contents    throw new KeyNotFoundException();
_contentskey;
    {
        _contents = _contents ?? new Dictionary_$2(object, object);
        _contentskey = value;
    }
    /*bool*/ TryGetValue(/*object*/ key, /*object*/ value)
    {
        if (_contents)
        {
            value = default;
            return false;
        }
        else 
        {
            let $v = { value: set(value){ value = value; } };
            return _contents.TryGetValue(key, $v);
        }
    }
    /*bool*/ Remove(/*object*/ key)
    {
        return _contentsRemove(key) ?? false;
    }
}

class Microsoft_AspNetCore_Components_Forms_ExpressionFormatter extends object
{
    constructor()
    {
        super();
    }
    /*int*/ StackAllocBufferSize = 128;
ReverseStringBuilder    /*Dictionary<MemberInfo, CapturedValueFormatter>*/ s_capturedValueFormatterCache = new Dictionary_$2(MemberInfo, CapturedValueFormatter);
    /*Dictionary<MethodInfo, MethodInfoData>*/ s_methodInfoDataCache = new Dictionary_$2(MethodInfo, MethodInfoData);
    /*void*/ ClearCache()
    {
        s_capturedValueFormatterCache.Clear();
        s_methodInfoDataCache.Clear();
    }
    /*string*/ FormatLambda(/*LambdaExpression*/ expression)
    {
        return FormatLambda(expression, { prefix : null });
    }
    /*string*/ FormatLambda(/*LambdaExpression*/ expression, { /*string*/ prefix = null})
    {
        /*var*/ let builder = new ReverseStringBuilder(new Array(StackAllocBufferSize));
        /*var*/ let node = expression.Body;
        /*var*/ let wasLastExpressionMemberAccess = false;
        /*var*/ let wasLastExpressionIndexer = false;
        while(node)
        {
            switch(node.NodeType)
            {
                case ExpressionType.Constant:
                {
                    /*var*/ let constantExpression = ConstantExpressionnode;
                    node = null;
                    break;
                }
                case ExpressionType.Call:
                {
                    /*var*/ let methodCallExpression = MethodCallExpressionnode;
                    if (IsSingleArgumentIndexer(methodCallExpression))
                    {
                        throw new InvalidOperationException("Method calls cannot be formatted.");
                    }
                    node = methodCallExpression.Object;
                    if (prefix != null && node is ConstantExpression)
                    {
                        break;
                    }
                    if (wasLastExpressionMemberAccess)
                    {
                        wasLastExpressionMemberAccess = false;
                        builder.InsertFront(".");
                    }
                    wasLastExpressionIndexer = true;
                    builder.InsertFront("]");
                    let $v = { value: set(value){ builder = value; } };
                    FormatIndexArgument(methodCallExpression.Arguments0, $v);
                    builder.InsertFront("[");
                    break;
                }
                case ExpressionType.ArrayIndex:
                {
                    /*var*/ let binaryExpression = BinaryExpressionnode;
                    node = binaryExpression.Left;
                    if (prefix != null && node is ConstantExpression)
                    {
                        break;
                    }
                    if (wasLastExpressionMemberAccess)
                    {
                        wasLastExpressionMemberAccess = false;
                        builder.InsertFront(".");
                    }
                    builder.InsertFront("]");
                    let $v = { value: set(value){ builder = value; } };
                    FormatIndexArgument(binaryExpression.Right, $v);
                    builder.InsertFront("[");
                    wasLastExpressionIndexer = true;
                    break;
                }
                case ExpressionType.MemberAccess:
                {
                    /*var*/ let memberExpression = MemberExpressionnode;
                    node = memberExpression.Expression;
                    if (prefix != null && node is ConstantExpression)
                    {
                        break;
                    }
                    if (wasLastExpressionMemberAccess)
                    {
                        builder.InsertFront(".");
                    }
                    wasLastExpressionMemberAccess = true;
                    wasLastExpressionIndexer = false;
                    /*var*/ let name = memberExpression.Member.GetCustomAttribute(DataMemberAttribute)Name ?? memberExpression.Member.Name;
                    builder.InsertFront(name);
                    break;
                }
                default:                {
                    // Unsupported expression type.
                        node = null;
                    break;
                }
            }
        }
        if (prefix != null)
        {
            if (builder.Empty  && wasLastExpressionIndexer)
            {
                builder.InsertFront(".");
            }
            builder.InsertFront(prefix);
        }
        /*var*/ let result = builder.ToString();
        builder.Dispose();
        return result;
    }
    /*bool*/ IsSingleArgumentIndexer(/*Expression*/ expression)
    {
        if (expression instanceof MethodCallExpression, methodExpression = expression || methodExpression.Arguments.Count  != 1)
        {
            return false;
        }
        /*var*/ let methodInfoData = GetOrCreateMethodInfoData(methodExpression.Method);
        return methodInfoData.IsSingleArgumentIndexer;
    }
    /*MethodInfoData*/ GetOrCreateMethodInfoData(/*MethodInfo*/ methodInfo)
    {
        let methodInfoData = null;
        let $v = { value: set(value){ methodInfoData = value; } };
        if (s_methodInfoDataCache.TryGetValue(methodInfo, $v))
        {
            methodInfoData = GetMethodInfoData(methodInfo);
            s_methodInfoDataCachemethodInfo = methodInfoData;
        }
        return methodInfoData;
MethodInfoDataMethodInfo        {
            /*var*/ let declaringType = iMethodInfo.DeclaringType;
            if (declaringType)
            {
                return new MethodInfoData({ isSingleArgumentIndexer : false });
            }
            return new MethodInfoData({ isSingleArgumentIndexer : false });
        }
    }
    /*void*/ FormatIndexArgument(/*Expression*/ indexExpression, /*ReverseStringBuilder*/ builder)
    {
        switch(indexExpression)
        {
MemberExpressionmemberExpression.Expression  instanceof ConstantExpression            {
                let $v = { value: set(value){ builder = value; } };
                FormatCapturedValue(memberExpression, constantExpression, $v);
                break;
            }
ConstantExpression            {
                let $v = { value: set(value){ builder = value; } };
                FormatConstantValue(constantExpression2, $v);
                break;
            }
            default:            {
                throw new InvalidOperationException(indexExpression.GetType().Name);
            }
        }
    }
    /*string*/ FormatIndexArgument(/*Expression*/ indexExpression)
    {
        /*var*/ let builder = new ReverseStringBuilder(new Array(StackAllocBufferSize));
        {
            let $v = { value: set(value){ builder = value; } };
            FormatIndexArgument(indexExpression, $v);
            /*var*/ let result = builder.ToString();
            return result;
        }
        {
            builder.Dispose();
        }
    }
    /*void*/ FormatCapturedValue(/*MemberExpression*/ memberExpression, /*ConstantExpression*/ constantExpression, /*ReverseStringBuilder*/ builder)
    {
        /*var*/ let member = memberExpression.Member;
        let format = null;
        let $v = { value: set(value){ format = value; } };
        if (s_capturedValueFormatterCache.TryGetValue(member, $v))
        {
            format = CreateCapturedValueFormatter(memberExpression);
            s_capturedValueFormatterCachemember = format;
        }
        let $v = { value: set(value){ builder = value; } };
        format(constantExpression.Value, $v);
    }
    /*Func<object, TResult>*/ CompileMemberEvaluator(TResult, /*MemberExpression*/ imemberExpression)
    {
        /*var*/ let parameterExpression = Expression.Parameter();
        /*var*/ let convertExpression = Expression.Convert(parameterExpression, imemberExpression.Member.DeclaringType);
        /*var*/ let replacedMemberExpression = imemberExpression.Update(convertExpression);
        /*var*/ let replacedExpression = Expression.Lambda(Func<object, TResult>, replacedMemberExpression, parameterExpression);
        return replacedExpression.Compile();
    }
    /*CapturedValueFormatter*/ CreateCapturedValueFormatter(/*MemberExpression*/ memberExpression)
    {
        /*var*/ let memberType = memberExpression.Type;
        if (memberType == )
        {
            /*var*/ let func = CompileMemberEvaluator_$1(int, memberExpression);
            return function(/*object*/ closure, /*ReverseStringBuilder*/ builder)
            {
                return builder.InsertFront(func.Invoke(closure));
            };
        }
        else if (memberType == )
        {
            /*var*/ let func = CompileMemberEvaluator_$1(string, memberExpression);
            return function(/*object*/ closure, /*ReverseStringBuilder*/ builder)
            {
                return builder.InsertFront(func.Invoke(closure));
            };
        }
        else if (IFormattable.IsAssignableFrom(memberType))
        {
            /*var*/ let func = CompileMemberEvaluator_$1(IFormattable, memberExpression);
            return function(/*object*/ closure, /*ReverseStringBuilder*/ builder)
            {
                return builder.InsertFront(func.Invoke(closure));
            };
        }
        else 
        {
            throw new InvalidOperationException(memberType);
        }
    }
    /*void*/ FormatConstantValue(/*ConstantExpression*/ constantExpression, /*ReverseStringBuilder*/ builder)
    {
        switch(constantExpression.Value)
        {
            {
                builder.InsertFront(s);
                break;
            }
IFormattable            {
                builder.InsertFront(formattable);
                break;
            }
            case null:
            {
                builder.InsertFront("null");
                break;
            }
        }
    }
    class Microsoft_AspNetCore_Components_Forms_MethodInfoData extends System_ValueType
    {
        /*bool*/ _backingField_IsSingleArgumentIndexer = null;
        /*bool*/ get IsSingleArgumentIndexer()
        {
            return _backingField_IsSingleArgumentIndexer;
        }
        constructor(/*bool*/ isSingleArgumentIndexer)
        {
            super();
            IsSingleArgumentIndexer = isSingleArgumentIndexer;
        }
    }
}

class Microsoft_AspNetCore_Components_Forms_FieldChangedEventArgs extends System_EventArgs
{
    constructor(/*FieldIdentifier*/ fieldIdentifier)
    {
        super();
        FieldIdentifier = fieldIdentifier;
    }
    /*FieldIdentifier*/ _backingField_FieldIdentifier = null;
    /*FieldIdentifier*/ get FieldIdentifier()
    {
        return _backingField_FieldIdentifier;
    }
}

class Microsoft_AspNetCore_Components_Forms_FieldIdentifier extends H5_IH5Class(System_IEquatable<Microsoft_AspNetCore_Components_Forms_FieldIdentifier>(System_ValueType))
{
    /*Dictionary<(Type ModelType, MemberInfo Member), Func<object, object>>*/ _fieldAccessors = new Dictionary_$2((Type ModelType, MemberInfo Member), Func<object, object>);
    constructor()
    {
        super();
    }
    /*FieldIdentifier*/ Create(TField, /*Expression<Func<TField>>*/ accessor)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(accessor);
        let model = null;
        let $v = { value: set(value){ model = value; } };
        let fieldName = null;
        let $v = { value: set(value){ fieldName = value; } };
        ParseAccessor(accessor, $v, $v);
        return new FieldIdentifier(model, fieldName);
    }
    constructor(/*object*/ model, /*string*/ fieldName)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(model);
        if (model.GetType().IsValueType)
        {
            throw new ArgumentException("The model must be a reference-typed object.", nameof(model));
        }
        Model = model;
        // Note that we do allow an empty string. This is used by some validation systems
            // as a place to store object-level (not per-property) messages.
            FieldName = fieldName ??         throw new ArgumentNullException(nameof(fieldName));
;
    }
    /*object*/ _backingField_Model = null;
    /*object*/ get Model()
    {
        return _backingField_Model;
    }
    /*string*/ _backingField_FieldName = null;
    /*string*/ get FieldName()
    {
        return _backingField_FieldName;
    }
    /*int*/ GetHashCode()
    {
        /*// We want to compare Model instances by reference. RuntimeHelpers.GetHashCode returns identical hashes for equal object references (ignoring any `Equals`/`GetHashCode` overrides) which is what we want.
            var*/ let modelHash = RuntimeHelpers.GetHashCode(Model);
        /*var*/ let fieldHash = StringComparer.Ordinal.GetHashCode(FieldName);
        return modelHashfieldHash.GetHashCode();
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        obj instanceof FieldIdentifier, otherIdentifier = obj && Equals(otherIdentifier);
    }
    /*bool*/ Equals(/*FieldIdentifier*/ otherIdentifier)
    {
        return ReferenceEquals(otherIdentifier.Model, Model) && .Equals(otherIdentifier.FieldName, FieldName, StringComparison.Ordinal);
    }
    /*void*/ ParseAccessor(T, /*Expression<Func<T>>*/ accessor, /*object*/ model, /*string*/ fieldName)
    {
        /*var*/ let accessorBody = accessor.Body;
        if (accessorBody instanceof UnaryExpression, unaryExpression = accessorBody && unaryExpression.NodeType  == ExpressionType.Convert
 && unaryExpression.Type  == )
        {
            accessorBody = unaryExpression.Operand;
        }
        switch(accessorBody)
        {
MemberExpression            {
                // Identify the field name. We don't mind whether it's a property or field, or even something else.
                    fieldName = memberExpression.Member.Name;
                switch(memberExpression.Expression)
                {
ConstantExpressionconstant.Value  == null                    {
                        throw new ArgumentException("The provided expression must evaluate to a non-null value.");
                    }
ConstantExpressionconstant.Value  != null                    {
                        model = constant.Value;
                        break;
                    }
MemberExpressionmember.Expression  is ConstantExpression                    {
                        model = GetModelFromMemberAccess(member);
                        break;
                    }
                    default:                    {
                        if (memberExpression.Expression  != null)
                        {
                            /*// It would be great to cache this somehow, but it's unclear there's a reasonable way to do
                                // so, given that it embeds captured values such as "this". We could consider special-casing
                                // for "() => something.Member" and building a cache keyed by "something.GetType()" with values
                                // of type Func<object, object> so we can cheaply map from "something" to "something.Member".
                                var*/ let modelLambda = Expression.Lambda(memberExpression.Expression);
                            /*var*/ let modelLambdaCompiled = Func_$1modelLambda.Compile();
                            /*var*/ let result = modelLambdaCompiled() ??                             throw new ArgumentException("The provided expression must evaluate to a non-null value.");
;
                            model = result;
                            break;
                        }
                        else 
                        throw new ArgumentException(accessorBody.GetType().Namenameof(FieldIdentifier));
                    }
                }
                break;
            }
MethodCallExpressionExpressionFormatter.IsSingleArgumentIndexer(accessorBody)            {
                fieldName = ExpressionFormatter.FormatIndexArgument(methodCallExpression.Arguments0);
                model = GetModelFromIndexer(methodCallExpression.Object);
                break;
            }
BinaryExpressionbinaryExpression.NodeType  == ExpressionType.ArrayIndex            {
                fieldName = ExpressionFormatter.FormatIndexArgument(binaryExpression.Right);
                model = GetModelFromIndexer(binaryExpression.Left);
                break;
            }
            default:            {
                throw new ArgumentException(accessorBody.GetType().Namenameof(FieldIdentifier));
            }
        }
    }
    /*object*/ GetModelFromMemberAccess(/*MemberExpression*/ member, { /*Dictionary<(Type ModelType, MemberInfo Member), Func<object, object>>*/ cache = null})
    {
        cache = cache ?? _fieldAccessors;
        /*Func<object, object>*/ let accessor = null;
        /*object*/ let value = null;
        switch(member.Expression)
        {
ConstantExpression            {
                value = model.Value  ??                 throw new ArgumentException("The provided expression must evaluate to a non-null value.");
;
                accessor = cache.GetOrAdd(value.GetType()member.Member, CreateAccessor);
                break;
            }
            default:            {
                break;
            }
        }
        if (accessor == null)
        {
            throw new InvalidOperationException(member);
        }
        if (value == null)
        {
            throw new ArgumentException("The provided expression must evaluate to a non-null value.");
        }
        /*var*/ let result = accessor(value);
        return result;
Func_$2TypeMemberInfo        {
            /*var*/ let parameter = Expression.Parameter(, "value");
            /*Expression*/ let expression = Expression.Convert(parameter, arg.model);
            expression = Expression.MakeMemberAccess(expression, arg.member);
            expression = Expression.Convert(expression, );
            /*var*/ let lambda = Expression.Lambda(Func<object, object>, expression, parameter);
            /*var*/ let func = lambda.Compile();
            return func;
        }
    }
    /*object*/ GetModelFromIndexer(/*Expression*/ methodCallExpression)
    {
        /*object*/ let model;
        /*var*/ let methodCallObjectLambda = Expression.Lambda(methodCallExpression);
        /*var*/ let methodCallObjectLambdaCompiled = Func_$1methodCallObjectLambda.Compile();
        /*var*/ let result = methodCallObjectLambdaCompiled();
        if (result)
        {
            throw new ArgumentException("The provided expression must evaluate to a non-null value.");
        }
        model = result;
        return model;
    }
    /*void*/ ClearCache()
    {
        _fieldAccessors.Clear();
    }
}

class Microsoft_AspNetCore_Components_Forms_FieldState extends object
{
    /*FieldIdentifier*/ _fieldIdentifier = null;
    /*HashSet<ValidationMessageStore>*/ _validationMessageStores = null;
    constructor(/*FieldIdentifier*/ fieldIdentifier)
    {
        super();
        _fieldIdentifier = fieldIdentifier;
    }
    /*bool*/ _backingField_IsModified = null;
    /*bool*/ get IsModified()
    {
        return _backingField_IsModified;
    }
    /*bool*/ set IsModified(value)
    {
        _backingField_IsModified = value;
    }
    /*IEnumerable<string>*/ GetValidationMessages()
    {
        if (_validationMessageStores != null)
        {
            BlazorJs.forEach(_validationMessageStores, function(store, $_i)
            {
                BlazorJs.forEach(store_fieldIdentifier, function(message, $_i)
                {
message                });
            });
        }
    }
    /*void*/ AssociateWithValidationMessageStore(/*ValidationMessageStore*/ validationMessageStore)
    {
        if (_validationMessageStores == null)
        {
            _validationMessageStores = new HashSet_$1(ValidationMessageStore);
        }
        _validationMessageStores.Add(validationMessageStore);
    }
    /*void*/ DissociateFromValidationMessageStore(/*ValidationMessageStore*/ validationMessageStore)
    {
        _validationMessageStoresRemove(validationMessageStore);
    }
}

class Microsoft_AspNetCore_Components_Forms_ReverseStringBuilder extends System_ValueType
{
    /*int*/ MinimumRentedArraySize = 1024;
    /*ArrayPool<char>*/ s_arrayPool = ArrayPool_$1.Shared;
    /*int*/ _nextEndIndex = null;
    /*Span<char>*/ _currentBuffer = null;
    constructor(/*int*/ conservativeEstimatedStringLength)
    {
        super();
        /*var*/ let array = s_arrayPool.Rent(conservativeEstimatedStringLength);
        //_fallbackSequenceSegment = new SequenceSegment(array);
            _currentBuffer = array;
        _nextEndIndex = _currentBuffer.Length;
    }
    constructor(/*Span<char>*/ initialBuffer)
    {
        super();
        _currentBuffer = initialBuffer;
        _nextEndIndex = _currentBuffer.Length;
    }
    /*bool*/ get Empty()
    {
        return _nextEndIndex == _currentBuffer.Length;
    }
    /*void*/ InsertFront(/*ReadOnlySpan<char>*/ span)
    {
        /*var*/ let startIndex = _nextEndIndex - span.Length;
        if (startIndex >= 0)
        {
            // The common case. There is enough space in the current buffer to copy the given span.
                // No additional work needs to be done here after the copy.
                span.CopyTo(_currentBuffernew SystemRange(startIndex, 1));
            _nextEndIndex = startIndex;
            return ;
        }
        throw new InvalidOperationException("Not enough space");
    }
    /*void*/ InsertFront(T, /*T*/ value)
    {
        /*// This is large enough for any integer value (10 digits plus the possible sign).
            // We won't try to optimize for anything larger.
            Span<char>*/ let result = new Span_$1(char, 11);
        //if (value.TryFormat(result, out var charsWritten, format: default, CultureInfo.InvariantCulture))
            //{
            //    InsertFront(result[new System.Range(0, charsWritten)]);
            //}
            //else
            //{
                InsertFront(IFormattablevalue);
    }
    /*void*/ InsertFront(/*IFormattable*/ formattable)
    {
        InsertFront(formattable.ToString(null, CultureInfo.InvariantCulture).AsSpan());
    }
    /*string*/ ToString()
    {
        //_fallbackSequenceSegment is null ?
                 _currentBuffernew SystemRange(_nextEndIndex, 1).AsString();
    }
    /*void*/ Dispose()
    {
    }
}

class Microsoft_AspNetCore_Components_Forms_ValidationMessageStore extends object
{
    /*EditContext*/ _editContext = null;
    /*Dictionary<FieldIdentifier, List<string>>*/ _messages = new Dictionary_$2(FieldIdentifier, List<string>);
    constructor(/*EditContext*/ editContext)
    {
        super();
        _editContext = editContext ??         throw new ArgumentNullException(nameof(editContext));
;
    }
    /*void*/ Add(/*FieldIdentifier*/ fieldIdentifier, /*string*/ message)
    {
        GetOrCreateMessagesListForField(fieldIdentifier).Add(message);
    }
    /*void*/ Add(/*Expression<Func<object>>*/ accessor, /*string*/ message)
    {
        Add(FieldIdentifier.Create(accessor), message);
    }
    /*void*/ Add(/*FieldIdentifier*/ fieldIdentifier, /*IEnumerable<string>*/ messages)
    {
        GetOrCreateMessagesListForField(fieldIdentifier).AddRange(messages);
    }
    /*void*/ Add(/*Expression<Func<object>>*/ accessor, /*IEnumerable<string>*/ messages)
    {
        Add(FieldIdentifier.Create(accessor), messages);
    }
    let messages = null;
    let $v = { value: set(value){ messages = value; } };
IEnumerable_$1FieldIdentifier    _messages.TryGetValue(fieldIdentifier, $v)IEnumerable_$1messagesArray.Empty(string);
IEnumerable_$1Expression_$1    FieldIdentifier.Create(accessor);
    /*void*/ Clear()
    {
        BlazorJs.forEach(_messages.Keys, function(fieldIdentifier, $_i)
        {
            DissociateFromField(fieldIdentifier);
        });
        _messages.Clear();
    }
    /*void*/ Clear(/*Expression<Func<object>>*/ accessor)
    {
        Clear(FieldIdentifier.Create(accessor));
    }
    /*void*/ Clear(/*FieldIdentifier*/ fieldIdentifier)
    {
        DissociateFromField(fieldIdentifier);
        _messages.Remove(fieldIdentifier);
    }
    /*List<string>*/ GetOrCreateMessagesListForField(/*FieldIdentifier*/ fieldIdentifier)
    {
        let messagesForField = null;
        let $v = { value: set(value){ messagesForField = value; } };
        if (_messages.TryGetValue(fieldIdentifier, $v))
        {
            messagesForField = new List_$1(string);
            _messages.Add(fieldIdentifier, messagesForField);
            AssociateWithField(fieldIdentifier);
        }
        return messagesForField;
    }
    /*void*/ AssociateWithField(/*FieldIdentifier*/ fieldIdentifier)
    {
        _editContext.GetOrAddFieldState(fieldIdentifier).AssociateWithValidationMessageStore();
    }
    /*void*/ DissociateFromField(/*FieldIdentifier*/ fieldIdentifier)
    {
        _editContext.GetFieldState(fieldIdentifier)DissociateFromValidationMessageStore();
    }
}

class Microsoft_AspNetCore_Components_Forms_ValidationRequestedEventArgs extends System_EventArgs
{
    /*ValidationRequestedEventArgs*/ Empty = new ValidationRequestedEventArgs();
    constructor()
    {
        super();
    }
}

class Microsoft_AspNetCore_Components_Forms_ValidationStateChangedEventArgs extends System_EventArgs
{
    /*ValidationStateChangedEventArgs*/ Empty = new ValidationStateChangedEventArgs();
    constructor()
    {
        super();
    }
}

class Microsoft_AspNetCore_Components_ExcludeFromInteractiveRoutingAttribute extends System_Attribute
{
    constructor()
    {
        super();
    }
}

class Microsoft_AspNetCore_Components_Routing_FocusOnNavigate extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
    }
    /*string*/ CustomElementName = "blazor-focus-on-navigate";
    /*Type*/ _lastNavigatedPageType = NonMatchingType;
    /*bool*/ _focusAfterRender = null;
    /*RouteData*/ _backingField_RouteData = null;
    /*RouteData*/ get RouteData()
    {
        return _backingField_RouteData;
    }
    /*RouteData*/ set RouteData(value)
    {
        _backingField_RouteData = value;
    }
    /*string*/ _backingField_Selector = null;
    /*string*/ get Selector()
    {
        return _backingField_Selector;
    }
    /*string*/ set Selector(value)
    {
        _backingField_Selector = value;
    }
    /*void*/ OnParametersSet()
    {
        if (RouteData)
        {
            throw new InvalidOperationException(nameof(FocusOnNavigate)nameof(RouteData));
        }
        if (.IsNullOrWhiteSpace(Selector))
        {
            throw new InvalidOperationException(nameof(FocusOnNavigate)nameof(Selector));
        }
        if (RouteData.PageType  != _lastNavigatedPageType)
        {
            _lastNavigatedPageType = RouteData.PageType;
            _focusAfterRender = true;
        }
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ frame, { /*object*/ key = null})
    {
    }
    /*void*/ OnAfterRender(/*bool*/ firstRender)
    {
        if (_focusAfterRender)
        {
            _focusAfterRender = false;
            /*var*/ let element = document.querySelector(HTMLElement, Selector).As(HTMLElement);
            if (element != null)
            element.scrollIntoView();
        }
        super.OnAfterRender(firstRender);
    }
    class Microsoft_AspNetCore_Components_Routing_NonMatchingType extends object
    {
        constructor()
        {
            super();
        }
    }
}


const Microsoft_AspNetCore_Components_Routing_INavigationInterception = (Base) => class extends Base
{
}



const Microsoft_AspNetCore_Components_Routing_IRoutingStateProvider = (Base) => class extends Base
{
    /*/// <summary>
        /// Gets RouteData
        /// </summary>
        RouteData*/ _backingField_RouteData = null;
    /*/// <summary>
        /// Gets RouteData
        /// </summary>
        RouteData*/ get RouteData()
    {
        return _backingField_RouteData;
    }
}

const Microsoft_AspNetCore_Components_Routing_IScrollToLocationHash = (Base) => class extends Base
{
}

class Microsoft_AspNetCore_Components_Routing_LocationChangedEventArgs extends System_EventArgs
{
    constructor(/*string*/ location, /*bool*/ isNavigationIntercepted)
    {
        super();
        Location = location;
        IsNavigationIntercepted = isNavigationIntercepted;
    }
    /*string*/ _backingField_Location = null;
    /*string*/ get Location()
    {
        return _backingField_Location;
    }
    /*bool*/ _backingField_IsNavigationIntercepted = null;
    /*bool*/ get IsNavigationIntercepted()
    {
        return _backingField_IsNavigationIntercepted;
    }
    /*object*/ _backingField_HistoryEntryState = null;
    /*object*/ get HistoryEntryState()
    {
        return _backingField_HistoryEntryState;
    }
    /*object*/ set HistoryEntryState(value)
    {
        _backingField_HistoryEntryState = value;
    }
}

class Microsoft_AspNetCore_Components_Routing_LocationChangingContext extends object
{
    constructor()
    {
        super();
    }
    /*bool*/ _backingField_DidPreventNavigation = null;
    /*bool*/ get DidPreventNavigation()
    {
        return _backingField_DidPreventNavigation;
    }
    /*bool*/ set DidPreventNavigation(value)
    {
        _backingField_DidPreventNavigation = value;
    }
    /*string*/ _backingField_TargetLocation = null;
    /*string*/ get TargetLocation()
    {
        return _backingField_TargetLocation;
    }
    /*string*/ set TargetLocation(value)
    {
        _backingField_TargetLocation = value;
    }
    /*object*/ _backingField_HistoryEntryState = null;
    /*object*/ get HistoryEntryState()
    {
        return _backingField_HistoryEntryState;
    }
    /*object*/ set HistoryEntryState(value)
    {
        _backingField_HistoryEntryState = value;
    }
    /*bool*/ _backingField_IsNavigationIntercepted = null;
    /*bool*/ get IsNavigationIntercepted()
    {
        return _backingField_IsNavigationIntercepted;
    }
    /*bool*/ set IsNavigationIntercepted(value)
    {
        _backingField_IsNavigationIntercepted = value;
    }
    /*CancellationToken*/ _backingField_CancellationToken = null;
    /*CancellationToken*/ get CancellationToken()
    {
        return _backingField_CancellationToken;
    }
    /*CancellationToken*/ set CancellationToken(value)
    {
        _backingField_CancellationToken = value;
    }
    /*void*/ PreventNavigation()
    {
        DidPreventNavigation = true;
    }
}

class Microsoft_AspNetCore_Components_Routing_NavigationContext extends object
{
    constructor(/*string*/ path, /*CancellationToken*/ cancellationToken)
    {
        super();
        Path = path;
        CancellationToken = cancellationToken;
    }
    /*string*/ _backingField_Path = null;
    /*string*/ get Path()
    {
        return _backingField_Path;
    }
    /*CancellationToken*/ _backingField_CancellationToken = null;
    /*CancellationToken*/ get CancellationToken()
    {
        return _backingField_CancellationToken;
    }
}

class Microsoft_AspNetCore_Components_Routing_NavigationLock extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
    }
    /*string*/ _id = Guid.NewGuid().ToString("D");
    /*IDisposable*/ _locationChangingRegistration = null;
    /*bool*/ _hasLocationChangingHandler = null;
    /*bool*/ _confirmExternalNavigation = null;
    /*bool*/ get HasLocationChangingHandler()
    {
        return OnBeforeInternalNavigation.HasDelegate;
    }
    /*NavigationManager*/ _backingField_NavigationManager = null;
    /*NavigationManager*/ get NavigationManager()
    {
        return _backingField_NavigationManager;
    }
    /*NavigationManager*/ set NavigationManager(value)
    {
        _backingField_NavigationManager = value;
    }
    /*EventCallback<LocationChangingContext>*/ _backingField_OnBeforeInternalNavigation = null;
    /*EventCallback<LocationChangingContext>*/ get OnBeforeInternalNavigation()
    {
        return _backingField_OnBeforeInternalNavigation;
    }
    /*EventCallback<LocationChangingContext>*/ set OnBeforeInternalNavigation(value)
    {
        _backingField_OnBeforeInternalNavigation = value;
    }
    /*bool*/ _backingField_ConfirmExternalNavigation = null;
    /*bool*/ get ConfirmExternalNavigation()
    {
        return _backingField_ConfirmExternalNavigation;
    }
    /*bool*/ set ConfirmExternalNavigation(value)
    {
        _backingField_ConfirmExternalNavigation = value;
    }
    /*void*/ OnParametersSet()
    {
        if (_hasLocationChangingHandler != HasLocationChangingHandler || _confirmExternalNavigation != ConfirmExternalNavigation)
        {
        }
        super.OnParametersSet();
    }
    /*int*/ onBeforeUnloadSubscribed = null;
    /*void*/ OnBeforeUnload(/*Event*/ e)
    {
        e.preventDefault();
        e.returnValue  = true;
    }
    /*void*/ DisableNavigationPrompt()
    {
        onBeforeUnloadSubscribed--;
        if (onBeforeUnloadSubscribed == 0)
        {
            window.removeEventListener("beforeunload", OnBeforeUnload);
        }
    }
    /*void*/ EnableNavigationPrompt()
    {
        if (onBeforeUnloadSubscribed == 0)
        {
            window.addEventListener("beforeunload", OnBeforeUnload);
        }
        onBeforeUnloadSubscribed++;
    }
    /*Task*/ OnAfterRenderAsync(/*bool*/ firstRender)
    {
        if (_hasLocationChangingHandler != HasLocationChangingHandler)
        {
            _hasLocationChangingHandler = HasLocationChangingHandler;
            _locationChangingRegistrationDispose();
            _locationChangingRegistration = _hasLocationChangingHandlerNavigationManager.RegisterLocationChangingHandler(OnLocationChanging)null;
        }
        if (_confirmExternalNavigation != ConfirmExternalNavigation)
        {
            _confirmExternalNavigation = ConfirmExternalNavigation;
            if (_confirmExternalNavigation)
            {
                EnableNavigationPrompt();
            }
            else 
            {
                DisableNavigationPrompt();
            }
        }
        return super.OnAfterRenderAsync(firstRender);
    }
    /*Task*/ async OnLocationChanging(/*LocationChangingContext*/ context)
    {
        await OnBeforeInternalNavigation.InvokeAsync(context);
    }
    /*void*/ Dispose()
    {
        _locationChangingRegistrationDispose();
        if (_confirmExternalNavigation)
        {
            DisableNavigationPrompt();
        }
        super.Dispose();
    }
}

class Microsoft_AspNetCore_Components_Routing_NavLink extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
    }
    /*string*/ DefaultActiveClass = "active";
    /*bool*/ _isActive = null;
    /*string*/ _hrefAbsolute = null;
    /*string*/ _class = null;
    /*string*/ _backingField_ActiveClass = null;
    /*string*/ get ActiveClass()
    {
        return _backingField_ActiveClass;
    }
    /*string*/ set ActiveClass(value)
    {
        _backingField_ActiveClass = value;
    }
    /*string*/ _backingField_CssClass = null;
    /*string*/ get CssClass()
    {
        return _backingField_CssClass;
    }
    /*string*/ set CssClass(value)
    {
        _backingField_CssClass = value;
    }
    /*RenderFragment*/ _backingField_ChildContent = null;
    /*RenderFragment*/ get ChildContent()
    {
        return _backingField_ChildContent;
    }
    /*RenderFragment*/ set ChildContent(value)
    {
        _backingField_ChildContent = value;
    }
    /*NavLinkMatch*/ _backingField_Match = null;
    /*NavLinkMatch*/ get Match()
    {
        return _backingField_Match;
    }
    /*NavLinkMatch*/ set Match(value)
    {
        _backingField_Match = value;
    }
    /*NavigationManager*/ _backingField_NavigationManager = null;
    /*NavigationManager*/ get NavigationManager()
    {
        return _backingField_NavigationManager;
    }
    /*NavigationManager*/ set NavigationManager(value)
    {
        _backingField_NavigationManager = value;
    }
    /*void*/ OnInitialized()
    {
        // We'll consider re-rendering on each location change
            NavigationManager.LocationChanged  += OnLocationChanged;
    }
    /*void*/ OnParametersSet()
    {
        /*// Update computed state
            var*/ let href = null;
        let obj = null;
        let $v = { value: set(value){ obj = value; } };
        if (.TryGetValue("href", $v))
        {
            href = Convert.ToString(obj);
        }
        _hrefAbsolute = href == nullnullNavigationManager.ToAbsoluteUri(href).AbsoluteUri;
        _isActive = ShouldMatch(NavigationManager.Uri);
        _class = null;
        let $v = { value: set(value){ obj = value; } };
        if (.TryGetValue("class", $v))
        {
            _class = Convert.ToString(obj);
        }
        UpdateCssClass();
    }
    /*void*/ Dispose()
    {
        // To avoid leaking memory, it's important to detach any event handlers in Dispose()
            NavigationManager.LocationChanged  -= OnLocationChanged;
    }
    /*void*/ UpdateCssClass()
    {
        CssClass = _isActiveCombineWithSpace(_class, ActiveClass ?? DefaultActiveClass)_class;
    }
    /*void*/ OnLocationChanged(/*object*/ sender, /*LocationChangedEventArgs*/ args)
    {
        /*// We could just re-render always, but for this component we know the
            // only relevant state change is to the _isActive property.
            var*/ let shouldBeActiveNow = ShouldMatch(args.Location);
        if (shouldBeActiveNow != _isActive)
        {
            _isActive = shouldBeActiveNow;
            UpdateCssClass();
            StateHasChanged();
        }
    }
    /*bool*/ ShouldMatch(/*string*/ currentUriAbsolute)
    {
        if (_hrefAbsolute == null)
        {
            return false;
        }
        if (EqualsHrefExactlyOrIfTrailingSlashAdded(currentUriAbsolute))
        {
            return true;
        }
        if (Match == NavLinkMatch.Prefix
 && IsStrictlyPrefixWithSeparator(currentUriAbsolute, _hrefAbsolute))
        {
            return true;
        }
        return false;
    }
    /*bool*/ EqualsHrefExactlyOrIfTrailingSlashAdded(/*string*/ currentUriAbsolute)
    {
        Debug.Assert(_hrefAbsolute != null);
        if (.Equals(currentUriAbsolute, _hrefAbsolute, StringComparison.OrdinalIgnoreCase))
        {
            return true;
        }
        if (currentUriAbsolute.Length  == _hrefAbsolute.Length  - 1)
        {
            if (_hrefAbsolute_hrefAbsolute.Length  - 1 == '/' && _hrefAbsolute.StartsWith(currentUriAbsolute, StringComparison.OrdinalIgnoreCase))
            {
                return true;
            }
        }
        return false;
    }
    /*string*/ CombineWithSpace(/*string*/ str1, /*string*/ str2)
    {
        str1 == nullstr2str1str2;
    }
    /*bool*/ IsStrictlyPrefixWithSeparator(/*string*/ value, /*string*/ prefix)
    {
        /*var*/ let prefixLength = prefix.Length;
        if (value.Length  > prefixLength)
        {
            return value.StartsWith(prefix, StringComparison.OrdinalIgnoreCase) && // Only match when there's a separator character either at the end of the
                        // prefix or right after it.
                        // Example: "/abc" is treated as a prefix of "/abc/def" but not "/abcdef"
                        // Example: "/abc/" is treated as a prefix of "/abc/def" but not "/abcdef"
                        prefixLength == 0 || IsUnreservedCharacter(prefixprefixLength - 1) || IsUnreservedCharacter(valueprefixLength);
        }
        else 
        {
            return false;
        }
    }
    /*bool*/ IsUnreservedCharacter(/*char*/ c)
    {
        return .IsLetterOrDigit(c) || c == '-' || c == '.' || c == '_' || c == '~';
    }
}








class Microsoft_AspNetCore_Components_Routing_RouteKey extends H5_IH5Class(System_IEquatable<Microsoft_AspNetCore_Components_Routing_RouteKey>(System_ValueType))
{
    /*Assembly*/ AppAssembly = null;
    /*HashSet<Assembly>*/ AdditionalAssemblies = null;
    constructor(/*Assembly*/ appAssembly, /*IEnumerable<Assembly>*/ additionalAssemblies)
    {
        super();
        AppAssembly = appAssembly;
        AdditionalAssemblies = additionalAssembliesnullnew HashSet_$1(Assembly, additionalAssemblies);
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        return obj instanceof RouteKey, other = obj && Equals(other);
    }
    /*bool*/ Equals(/*RouteKey*/ other)
    {
        if (Equals(AppAssembly, other.AppAssembly))
        {
            return false;
        }
        if (AdditionalAssemblies && other.AdditionalAssemblies )
        {
            return true;
        }
        if (AdditionalAssemblies || other.AdditionalAssemblies )
        {
            return false;
        }
        return AdditionalAssemblies.Count  == other.AdditionalAssemblies.Count  && AdditionalAssemblies.SetEquals(other.AdditionalAssemblies);
    }
    /*int*/ GetHashCode()
    {
        if (AppAssembly)
        {
            return 0;
        }
        if (AdditionalAssemblies)
        {
            return AppAssembly.GetHashCode();
        }
        return HashCode.Combine(AppAssembly, AdditionalAssemblies.Count);
    }
}

class Microsoft_AspNetCore_Components_Routing_Router extends System_IDisposable(Microsoft_AspNetCore_Components_ComponentBase)
{
    constructor()
    {
        super();
    }
    /*//// Dictionary is intentionally used instead of ReadOnlyDictionary to reduce Blazor size
        //static readonly IReadOnlyDictionary<string, object> _emptyParametersDictionary
        //    = new Dictionary<string, object>();

        string*/ _baseUri = null;
    /*string*/ _locationAbsolute = null;
    /*bool*/ _navigationInterceptionEnabled = null;
    /*string*/ _updateScrollPositionForHashLastLocation = null;
    /*bool*/ _updateScrollPositionForHash = null;
    /*CancellationTokenSource*/ _onNavigateCts = null;
    /*Task*/ _previousOnNavigateTask = Task.CompletedTask;
    /*RouteKey*/ _routeTableLastBuiltForRouteKey = null;
    /*bool*/ _onNavigateCalled = null;
    /*NavigationManager*/ _backingField_NavigationManager = null;
    /*NavigationManager*/ get NavigationManager()
    {
        return _backingField_NavigationManager;
    }
    /*NavigationManager*/ set NavigationManager(value)
    {
        _backingField_NavigationManager = value;
    }
    /*INavigationInterception*/ _backingField_NavigationInterception = null;
    /*INavigationInterception*/ get NavigationInterception()
    {
        return _backingField_NavigationInterception;
    }
    /*INavigationInterception*/ set NavigationInterception(value)
    {
        _backingField_NavigationInterception = value;
    }
    /*IScrollToLocationHash*/ _backingField_ScrollToLocationHash = null;
    /*IScrollToLocationHash*/ get ScrollToLocationHash()
    {
        return _backingField_ScrollToLocationHash;
    }
    /*IScrollToLocationHash*/ set ScrollToLocationHash(value)
    {
        _backingField_ScrollToLocationHash = value;
    }
    /*IServiceProvider*/ _backingField_ServiceProvider = null;
    /*IServiceProvider*/ get ServiceProvider()
    {
        return _backingField_ServiceProvider;
    }
    /*IServiceProvider*/ set ServiceProvider(value)
    {
        _backingField_ServiceProvider = value;
    }
    /*IRoutingStateProvider*/ _backingField_RoutingStateProvider = null;
    /*IRoutingStateProvider*/ get RoutingStateProvider()
    {
        return _backingField_RoutingStateProvider;
    }
    /*IRoutingStateProvider*/ set RoutingStateProvider(value)
    {
        _backingField_RoutingStateProvider = value;
    }
    /*Assembly*/ _backingField_AppAssembly = null;
    /*Assembly*/ get AppAssembly()
    {
        return _backingField_AppAssembly;
    }
    /*Assembly*/ set AppAssembly(value)
    {
        _backingField_AppAssembly = value;
    }
    /*IEnumerable<Assembly>*/ _backingField_AdditionalAssemblies = null;
    /*IEnumerable<Assembly>*/ get AdditionalAssemblies()
    {
        return _backingField_AdditionalAssemblies;
    }
    /*IEnumerable<Assembly>*/ set AdditionalAssemblies(value)
    {
        _backingField_AdditionalAssemblies = value;
    }
    /*RenderFragment*/ _backingField_NotFound = null;
    /*RenderFragment*/ get NotFound()
    {
        return _backingField_NotFound;
    }
    /*RenderFragment*/ set NotFound(value)
    {
        _backingField_NotFound = value;
    }
    /*RenderFragment<RouteData>*/ _backingField_Found = null;
    /*RenderFragment<RouteData>*/ get Found()
    {
        return _backingField_Found;
    }
    /*RenderFragment<RouteData>*/ set Found(value)
    {
        _backingField_Found = value;
    }
    /*RenderFragment*/ _backingField_Navigating = null;
    /*RenderFragment*/ get Navigating()
    {
        return _backingField_Navigating;
    }
    /*RenderFragment*/ set Navigating(value)
    {
        _backingField_Navigating = value;
    }
    /*EventCallback<NavigationContext>*/ _backingField_OnNavigateAsync = null;
    /*EventCallback<NavigationContext>*/ get OnNavigateAsync()
    {
        return _backingField_OnNavigateAsync;
    }
    /*EventCallback<NavigationContext>*/ set OnNavigateAsync(value)
    {
        _backingField_OnNavigateAsync = value;
    }
    /*RouteTable*/ _backingField_Routes = null;
    /*RouteTable*/ get Routes()
    {
        return _backingField_Routes;
    }
    /*RouteTable*/ set Routes(value)
    {
        _backingField_Routes = value;
    }
    /*void*/ OnInitialized()
    {
        super.OnInitialized();
        //_logger = LoggerFactory.CreateLogger<Router>();
            //_renderHandle = renderHandle;
            _baseUri = NavigationManager.BaseUri;
        _locationAbsolute = NavigationManager.Uri;
        NavigationManager.LocationChanged  += OnLocationChanged;
        RoutingStateProvider = ServiceProvider.GetService(IRoutingStateProvider);
    }
    /*Task*/ async OnParametersSetAsync()
    {
        await super.OnParametersSetAsync();
        if (AppAssembly == null)
        {
            throw new InvalidOperationException(nameof(Router)nameof(AppAssembly));
        }
        if (Found == null)
        {
            throw new InvalidOperationException(nameof(Router)nameof(Found));
        }
        if (_onNavigateCalled)
        {
            _onNavigateCalled = true;
            await RunOnNavigateAsync(NavigationManager.ToBaseRelativePath(_locationAbsolute), { isNavigationIntercepted : false });
        }
        else 
        {
            Refresh({ isNavigationIntercepted : false });
        }
    }
    /*void*/ Dispose()
    {
        super.Dispose();
        NavigationManager.LocationChanged  -= OnLocationChanged;
    }
    /*ReadOnlySpan<char>*/ TrimQueryOrHash(/*ReadOnlySpan<char>*/ str)
    {
        /*var*/ let firstIndex = str.IndexOfAny('?', '#');
        return firstIndex < 0strstrnew Range(0, firstIndex);
    }
    /*void*/ RefreshRouteTable()
    {
        /*var*/ let routeKey = new RouteKey(AppAssembly, AdditionalAssemblies);
        if (routeKey.Equals(_routeTableLastBuiltForRouteKey))
        {
            Routes = RouteTableFactory.Instance.Create(routeKey, ServiceProvider);
            _routeTableLastBuiltForRouteKey = routeKey;
        }
    }
    /*void*/ ClearRouteCaches()
    {
        RouteTableFactory.Instance.ClearCaches();
        _routeTableLastBuiltForRouteKey = default;
    }
    /*RenderFragment*/ _viewFragment = null;
    /*void*/ BuildRenderTree(/*IUIFrame*/ frame, { /*object*/ key = null})
    {
        frame.Content(_viewFragment, { sequenceNumber : Utility.Router_View_SequenceNumber });
    }
    /*void*/ Render(/*RenderFragment*/ fragment)
    {
        _viewFragment = fragment;
        StateHasChanged();
    }
    /*void*/ Refresh(/*bool*/ isNavigationIntercepted)
    {
        if (_previousOnNavigateTask.Status  != TaskStatus.RanToCompletion)
        {
            if (Navigating != null)
            {
                Render(Navigating);
            }
            return ;
        }
        /*var*/ let relativePath = NavigationManager.ToBaseRelativePath(_locationAbsolute);
        /*var*/ let locationPathSpan = TrimQueryOrHash(relativePath.AsSpan());
        /*var*/ let locationPath = locationPathSpan;
        // In order to avoid routing twice we check for RouteData
            //if (RoutingStateProvider?.RouteData is { } endpointRouteData)
            //{
            //    // Other routers shouldn't provide RouteData, this is specific to our router component
            //    // and must abide by our syntax and behaviors.
            //    // Other routers must create their own abstractions to flow data from their SSR routing
            //    // scheme to their interactive router.
            //    //Log.NavigatingToComponent(_logger, endpointRouteData.PageType, locationPath, _baseUri);
            //    // Post process the entry to add Blazor specific behaviors:
            //    // - Add 'null' for unused route parameters.
            //    // - Convert constrained parameters with (int, double, etc) to the target type.
            //    endpointRouteData = RouteTable.ProcessParameters(endpointRouteData);
            //    Render(Found(endpointRouteData));
            //    return;
            //}

            RefreshRouteTable();
        /*//var context = new RouteContext(locationPath);
            var*/ let routeData = Routes.Route(locationPath);
        if (routeDataPageType != null)
        {
            if (IComponent.IsAssignableFrom(routeData.PageType))
            {
                throw new InvalidOperationException(routeData.PageType.FullName + IComponent.FullName);
            }
            //Log.NavigatingToComponent(_logger, context.Handler, locationPath, _baseUri);

                //var routeData = new RouteData(
                //    context.Handler,
                //    context.Parameters ?? _emptyParametersDictionary);

                Render(Found(routeData));
            if (relativePath != _updateScrollPositionForHashLastLocation)
            {
                _updateScrollPositionForHashLastLocation = relativePath.ToString();
                _updateScrollPositionForHash = true;
            }
        }
        else 
        {
            if (isNavigationIntercepted)
            {
                //Log.DisplayingNotFound(_logger, locationPath, _baseUri);

                    // We did not find a Component that matches the route.
                    // Only show the NotFound content if the application developer programatically got us here i.e we did not
                    // intercept the navigation. In all other cases, force a browser navigation since this could be non-Blazor content.
                    Render(NotFound ?? DefaultNotFoundContent);
            }
            else 
            {
                //Log.NavigatingToExternalUri(_logger, _locationAbsolute, locationPath, _baseUri);
                    NavigationManager.NavigateTo(_locationAbsolute, { forceLoad : true });
            }
        }
    }
    /*void*/ DefaultNotFoundContent(/*IUIFrame*/ builder, { /*object*/ key = null})
    {
        // This output can't use any layout (none is specified), and it can't use any web-specific concepts
            // such as <p role="alert">, and we can't localize the output. However none of that matters because
            // in all cases we expect either:
            // 1. The app to be hosted with MapRazorPages, and then it will never use any NotFound content
            // 2. Or, the app to supply its own NotFound content
            // ... so this is just a fallback for badly-set-up apps.
            builder.AddContent(0, "Not found");
    }
    /*Task*/ async RunOnNavigateAsync(/*string*/ path, /*bool*/ isNavigationIntercepted)
    {
        // Cancel the CTS instead of disposing it, since disposing does not
            // actually cancel and can cause unintended Object Disposed Exceptions.
            // This effectively cancels the previously running task and completes it.
            _onNavigateCtsCancel();
        await _previousOnNavigateTask;
        /*var*/ let tcs = new TaskCompletionSource_$1(object);
        _previousOnNavigateTask = tcs.Task;
        if (OnNavigateAsync.HasDelegate)
        {
            Refresh(isNavigationIntercepted);
        }
        _onNavigateCts = new CancellationTokenSource();
        /*var*/ let navigateContext = new NavigationContext(path, _onNavigateCts.Token);
        /*var*/ let cancellationTcs = new TaskCompletionSource_$1(object);
        navigateContext.CancellationToken.Register(function(/**/ state)
        {
TaskCompletionSource_$1state.SetResult(null)        }, cancellationTcs);
        /*//try
            //{
            // Task.WhenAny returns a Task<Task> so we need to await twice to unwrap the exception
            var*/ let task = await Task.WhenAny(OnNavigateAsync.InvokeAsync(navigateContext), cancellationTcs.Task);
        await task;
        tcs.SetResult(null);
        Refresh(isNavigationIntercepted);
    }
    /*void*/ OnLocationChanged(/*object*/ sender, /*LocationChangedEventArgs*/ args)
    {
        _locationAbsolute = args.Location;
        if (Routes != null)
        {
            RunOnNavigateAsync(NavigationManager.ToBaseRelativePath(_locationAbsolute), args.IsNavigationIntercepted).FireAndForget();
        }
    }
    /*Task*/ async OnAfterRenderAsync(/*bool*/ firstRender)
    {
        await super.OnAfterRenderAsync(firstRender);
        if (_navigationInterceptionEnabled)
        {
            _navigationInterceptionEnabled = true;
            await NavigationInterception.EnableNavigationInterceptionAsync();
        }
        if (_updateScrollPositionForHash)
        {
            _updateScrollPositionForHash = false;
            if (ScrollToLocationHash != null)
            await ScrollToLocationHash.RefreshScrollPositionForHash(_locationAbsolute);
        }
    }
}

class Microsoft_AspNetCore_Components_Routing_RouteRegistration extends Microsoft_AspNetCore_Components_RouteData
{
    /*IReadOnlyDictionary<string, object>*/ _emptyParametersDictionary = new Dictionary_$2(string, object);
    constructor(/*Type*/ pageType)
    {
        super(pageType, _emptyParametersDictionary);
    }
    /*Type*/ _backingField_Layout = null;
    /*Type*/ get Layout()
    {
        return _backingField_Layout;
    }
    /*Type*/ set Layout(value)
    {
        _backingField_Layout = value;
    }
    /*Action<object, string, string>*/ _backingField_ParameterSetter = null;
    /*Action<object, string, string>*/ get ParameterSetter()
    {
        return _backingField_ParameterSetter;
    }
    /*Action<object, string, string>*/ set ParameterSetter(value)
    {
        _backingField_ParameterSetter = value;
    }
}

class Microsoft_AspNetCore_Components_Routing_RouteTable extends object
{
    /*//private readonly TreeRouter _router = treeRouter;
        //private static readonly Dictionary<(Type, string), InboundRouteEntry> _routeEntryCache = new Dictionary<(Type, string), InboundRouteEntry>();
        //public TreeRouter? TreeRouter => _router;
        Dictionary<Type, string[]>*/ _templatesByHandler = null;
    constructor(/*Dictionary<Type, string[]>*/ templatesByHandler)
    {
        super();
        _templatesByHandler = templatesByHandler;
    }
    /*RouteData*/ Route(/*string*/ locationPath)
    {
        let $v = { value: set(value){ _ = value; } };
        let parameter = null;
        let $v = { value: set(value){ parameter = value; } };
        /*var*/ let registeredRoute = RouteTableFactory.Match(locationPath, $v, $v);
        if (registeredRoute != null)
        {
            return new RouteData(registeredRoute.PageType, parameter != null.GetOwnPropertyNames(parameter).ToDictionary(function(/**/ name)
            {
name            }, function(/**/ name)
            {
parametername            })new Dictionary_$2(string, object));
        }
        /*var*/ let found = _templatesByHandler.SelectMany(function(/**/ t)
        {
t.Value.Select(function(/**/ pattern)
            {
                {
                    /*object*/ let iparameter = new ();
                    /*var*/ let weight = RouteTableFactory.MatchPath(pattern, locationPath, iparameter);
                    return t.Keypatternweightiparameter;
                }
            })        }).MaxBy(function(/**/ t)
        {
t.weight        });
        if (found.Key  != null)
        {
            return new RouteData(found.Key, found.iparameter  != null.GetOwnPropertyNames(found.iparameter).ToDictionary(function(/**/ name)
            {
name            }, function(/**/ name)
            {
found.iparametername            })new Dictionary_$2(string, object));
        }
        return null;
    }
}

class Microsoft_AspNetCore_Components_RouteTableFactory extends object
{
    constructor()
    {
        super();
    }
    /*RouteTableFactory*/ Instance = new RouteTableFactory();
    /*Dictionary<string, RouteRegistration>*/ routeRegistrations = new Dictionary_$2(string, RouteRegistration);
    /*void*/ Register(T, /*string*/ route, { /*Type*/ layout = null, /*Action<T, string, string>*/ routeParameterSetter = null})
    {
        routeRegistrationsroute = new RouteRegistration(T)Layout = layoutParameterSetter = routeParameterSetter != nullfunction(/**/ o, /**/ n, /**/ v)
        {
            return routeParameterSetter(To, n, v);
        }Action_$3null;
    }
    /*int*/ MatchPath(/*string*/ pathPattern, /*string*/ path, /*object*/ routeParameter)
    {
        /*var*/ let splitPattern = pathPattern.Trim('/').Split('/');
        /*var*/ let splitPath = path.Trim('/').Split('/');
        /*int*/ let weight = 0;
        for(/*int*/ let i = 0; i < splitPattern.Length; i++)
        {
            /*var*/ let t1 = splitPatterni;
            /*var*/ let t2 = i < splitPath.Length splitPathinull;
            if (t1.StartsWith("*"))
            weight += 10;
            else if (t1.Equals(t2, StringComparison.InvariantCultureIgnoreCase))
            weight += 1000;
            else if (t1.StartsWith("{") && t1.EndsWith("}") && t2 != null)
            {
                weight += 100;
                routeParametert1.Substring(1, t1.Length  - 2) = t2;
            }
        });
        return weight;
    }
    /*RouteRegistration*/ Match(/*string*/ uri, /*int*/ routeIndexSequenceNumber, /*object*/ routeParameter)
    {
        /*var*/ let split = uri.Split('?');
        /*var*/ let path = split0.Trim('/');
        /*var*/ let query = split.Length  > 1split1null;
        /*RouteRegistration*/ let registration = null;
        /*int*/ let maxWeight = 0;
        /*int*/ let index = 0;
        routeIndexSequenceNumber = 0;
        routeParameter = null;
        BlazorJs.forEach(routeRegistrations, function(route, $_i)
        {
            /*object*/ let dic = new ();
            /*var*/ let w = MatchPath(route.Key, path, dic);
            if (w > 0 && w > maxWeight)
            {
                registration = route.Value;
                routeParameter = dic;
                routeIndexSequenceNumber = index;
                maxWeight = w;
            }
            index++;
        });
        if (registration != null && query != null)
        {
            if (routeParameter == null)
            routeParameter = new ();
            /*var*/ let querySplit = query.Split('&');
            BlazorJs.forEach(querySplit, function(kv, $_i)
            {
                /*var*/ let split2 = kv.Split('=');
                routeParametersplit20 = H5.Script.DecodeURI(split21);
            });
        }
        return registration;
    }
    /*Dictionary<RouteKey, RouteTable>*/ _cache = new Dictionary_$2(RouteKey, RouteTable);
    /*RouteTable*/ Create(/*RouteKey*/ routeKey, /*IServiceProvider*/ serviceProvider)
    {
        let resolvedComponents = null;
        let $v = { value: set(value){ resolvedComponents = value; } };
        if (_cache.TryGetValue(routeKey, $v))
        {
            return resolvedComponents;
        }
        /*var*/ let componentTypes = GetRouteableComponents(routeKey);
        /*var*/ let routeTable = Create(componentTypes, serviceProvider);
        _cache.TryAdd(routeKey, routeTable);
        return routeTable;
    }
    /*void*/ ClearCaches()
    {
        _cache.Clear();
    }
    /*List<Type>*/ GetRouteableComponents(/*RouteKey*/ routeKey)
    {
        /*var*/ let routeableComponents = new List_$1(Type);
        if (routeKey.AppAssembly )
        {
            GetRouteableComponents(routeableComponents, routeKey.AppAssembly);
        }
        if (routeKey.AdditionalAssemblies )
        {
            BlazorJs.forEach(routeKey.AdditionalAssemblies, function(assembly, $_i)
            {
                if (assembly != routeKey.AppAssembly)
                {
                    GetRouteableComponents(routeableComponents, assembly);
                }
            });
        }
        return routeableComponents;
List_$1Assembly        {
            BlazorJs.forEach(assembly.GetTypes(), function(type, $_i)
            {
                if (IComponent.IsAssignableFrom(type) && type.IsDefined(RouteAttribute) && type.IsDefined(ExcludeFromInteractiveRoutingAttribute))
                {
                    routeableComponents1.Add(type);
                }
            });
        }
    }
    /*RouteTable*/ Create(/*List<Type>*/ componentTypes, /*IServiceProvider*/ serviceProvider)
    {
        /*var*/ let templatesByHandler = new Dictionary_$2(Type, string[]);
        BlazorJs.forEach(componentTypes, function(componentType, $_i)
        {
            /*// We're deliberately using inherit = false here.
                //
                // RouteAttribute is defined as non-inherited, because inheriting a route attribute always causes an
                // ambiguity. You end up with two components (base class and derived class) with the same route.
                var*/ let templates = GetTemplates(componentType);
            templatesByHandler.Add(componentType, templates);
        });
        return Create(templatesByHandler, serviceProvider);
    }
    /*string[]*/ GetTemplates(/*Type*/ componentType)
    {
        /*var*/ let routeAttributes = componentType.GetCustomAttributes(RouteAttribute, { inherit : false });
        /*var*/ let templates = new Array(routeAttributes.Length);
        for(/*var*/ let i = 0; i < routeAttributes.Length; i++)
        {
            /*var*/ let attribute = RouteAttributerouteAttributesi;
            templatesi = attribute.Template;
        });
        return templates;
    }
    /*RouteTable*/ Create(/*Dictionary<Type, string[]>*/ templatesByHandler, /*IServiceProvider*/ serviceProvider)
    {
        return new RouteTable(templatesByHandler);
    }
}




class Microsoft_AspNetCore_Components_Web_ErrorBoundary extends Microsoft_AspNetCore_Components_ErrorBoundaryBase
{
    constructor()
    {
        super();
    }
    /*IErrorBoundaryLogger*/ _backingField_ErrorBoundaryLogger = null;
    /*IErrorBoundaryLogger*/ get ErrorBoundaryLogger()
    {
        return _backingField_ErrorBoundaryLogger;
    }
    /*IErrorBoundaryLogger*/ set ErrorBoundaryLogger(value)
    {
        _backingField_ErrorBoundaryLogger = value;
    }
    /*Task*/ async OnErrorAsync(/*Exception*/ exception)
    {
        await ErrorBoundaryLogger.LogErrorAsync(exception);
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ frame, { /*object*/ key = null})
    {
        if (CurrentException == null)
        {
            frame.Content(ChildContent, { sequenceNumber : Utility.ErrorBoundary_ChildContent_SequenceNumber });
        }
        else if (ErrorContent != null)
        {
            frame.Content(ErrorContent(CurrentException), { sequenceNumber : Utility.ErrorBoundary_ErrorContent_SequenceNumber });
        }
        else 
        {
            // The default error UI doesn't include any content, because:
                // [1] We don't know whether or not you'd be happy to show the stack trace. It depends both on
                //     whether DetailedErrors is enabled and whether you're in production, because even on WebAssembly
                //     you likely don't want to put technical data like that in the UI for end users. A reasonable way
                //     to toggle this is via something like "#if DEBUG" but that can only be done in user code.
                // [2] We can't have any other human-readable content by default, because it would need to be valid
                //     for all languages.
                // Instead, the default project template provides locale-specific default content via CSS. This provides
                // a quick form of customization even without having to subclass this component.
                frame.Element("div", { attributeBuilder : function(/*UIElementAttribute*/ attribute)
            {
                attribute.Set("class", "blazor-error-boundary");
            }, sequenceNumber : Utility.ErrorBoundary_DefaultContent_SequenceNumber });
        }
    }
}

const Microsoft_AspNetCore_Components_Web_IErrorBoundaryLogger = (Base) => class extends Base
{
}

class Microsoft_AspNetCore_Components_Forms_AntiforgeryRequestToken extends object
{
    constructor(/*string*/ value, /*string*/ formFieldName)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(value);
        ArgumentNullExceptionExtension.ThrowIfNull(formFieldName);
        Value = value;
        FormFieldName = formFieldName;
    }
    /*string*/ _backingField_Value = null;
    /*string*/ get Value()
    {
        return _backingField_Value;
    }
    /*string*/ _backingField_FormFieldName = null;
    /*string*/ get FormFieldName()
    {
        return _backingField_FormFieldName;
    }
}

class Microsoft_AspNetCore_Components_Forms_AntiforgeryStateProvider extends object
{
    constructor()
    {
        super();
    }
}

class Microsoft_AspNetCore_Components_Forms_AntiforgeryToken extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
    }
    /*bool*/ _hasRendered = null;
    /*AntiforgeryRequestToken*/ _requestToken = null;
    /*IServiceProvider*/ _backingField_Services = null;
    /*IServiceProvider*/ get Services()
    {
        return _backingField_Services;
    }
    /*IServiceProvider*/ set Services(value)
    {
        _backingField_Services = value;
    }
    /*void*/ OnInitialized()
    {
        _requestToken = Services.GetService(AntiforgeryStateProvider)GetAntiforgeryToken();
        super.OnInitialized();
    }
}

class Microsoft_AspNetCore_Components_Forms_EditContextFieldClassExtensions extends object
{
    constructor()
    {
        super();
    }
    /*object*/ FieldCssClassProviderKey = new ();
    /*string*/ FieldCssClass(TField, /*EditContext*/ editContext, /*Expression<Func<TField>>*/ accessor)
    {
        FieldCssClass(editContext, FieldIdentifier.Create(accessor));
    }
    /*string*/ FieldCssClass(/*EditContext*/ editContext, /*FieldIdentifier*/ fieldIdentifier)
    {
        let customProvider = null;
        let $v = { value: set(value){ customProvider = value; } };
        /*var*/ let provider = editContext.Properties.TryGetValue(FieldCssClassProviderKey, $v)FieldCssClassProvidercustomProviderFieldCssClassProvider.Instance;
        return provider.GetFieldCssClass(editContext, fieldIdentifier);
    }
    /*void*/ SetFieldCssClassProvider(/*EditContext*/ editContext, /*FieldCssClassProvider*/ fieldCssClassProvider)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(fieldCssClassProvider);
        editContext.PropertiesFieldCssClassProviderKey = fieldCssClassProvider;
    }
}

class Microsoft_AspNetCore_Components_Forms_EditForm extends Microsoft_AspNetCore_Components_ComponentBase
{
    /*Func<Task>*/ _handleSubmitDelegate = null;
    /*EditContext*/ _editContext = null;
    /*bool*/ _hasSetEditContextExplicitly = null;
    constructor()
    {
        super();
        _handleSubmitDelegate = HandleSubmitAsync;
    }
    /*EditContext*/ get EditContext()
    {
        return _editContext;
    }
    /*EditContext*/ set EditContext(value)
    {
        _editContext = value;
        _hasSetEditContextExplicitly = value != null;
    }
    /*bool*/ _backingField_Enhance = null;
    /*bool*/ get Enhance()
    {
        return _backingField_Enhance;
    }
    /*bool*/ set Enhance(value)
    {
        _backingField_Enhance = value;
    }
    /*object*/ _backingField_Model = null;
    /*object*/ get Model()
    {
        return _backingField_Model;
    }
    /*object*/ set Model(value)
    {
        _backingField_Model = value;
    }
    /*RenderFragment<EditContext>*/ _backingField_ChildContent = null;
    /*RenderFragment<EditContext>*/ get ChildContent()
    {
        return _backingField_ChildContent;
    }
    /*RenderFragment<EditContext>*/ set ChildContent(value)
    {
        _backingField_ChildContent = value;
    }
    /*EventCallback<EditContext>*/ _backingField_OnSubmit = null;
    /*EventCallback<EditContext>*/ get OnSubmit()
    {
        return _backingField_OnSubmit;
    }
    /*EventCallback<EditContext>*/ set OnSubmit(value)
    {
        _backingField_OnSubmit = value;
    }
    /*EventCallback<EditContext>*/ _backingField_OnValidSubmit = null;
    /*EventCallback<EditContext>*/ get OnValidSubmit()
    {
        return _backingField_OnValidSubmit;
    }
    /*EventCallback<EditContext>*/ set OnValidSubmit(value)
    {
        _backingField_OnValidSubmit = value;
    }
    /*EventCallback<EditContext>*/ _backingField_OnInvalidSubmit = null;
    /*EventCallback<EditContext>*/ get OnInvalidSubmit()
    {
        return _backingField_OnInvalidSubmit;
    }
    /*EventCallback<EditContext>*/ set OnInvalidSubmit(value)
    {
        _backingField_OnInvalidSubmit = value;
    }
    /*FormMappingContext*/ _backingField_MappingContext = null;
    /*FormMappingContext*/ get MappingContext()
    {
        return _backingField_MappingContext;
    }
    /*FormMappingContext*/ set MappingContext(value)
    {
        _backingField_MappingContext = value;
    }
    /*string*/ _backingField_FormName = null;
    /*string*/ get FormName()
    {
        return _backingField_FormName;
    }
    /*string*/ set FormName(value)
    {
        _backingField_FormName = value;
    }
    /*void*/ OnParametersSet()
    {
        if (_hasSetEditContextExplicitly && Model != null)
        {
            throw new InvalidOperationException(nameof(EditForm)nameof(Model) + nameof(EditContext));
        }
        else if (_hasSetEditContextExplicitly && Model == null)
        {
            throw new InvalidOperationException(nameof(EditForm)nameof(Model) + nameof(EditContext));
        }
        if (OnSubmit.HasDelegate  && OnValidSubmit.HasDelegate  || OnInvalidSubmit.HasDelegate)
        {
            throw new InvalidOperationException(nameof(OnSubmit) + nameof(EditForm)nameof(OnValidSubmit)nameof(OnInvalidSubmit));
        }
        if (Model != null && Model != _editContextModel)
        {
            _editContext = new EditContext(Model);
        }
    }
    /*Task*/ async HandleSubmitAsync()
    {
        Debug.Assert(_editContext != null);
        if (OnSubmit.HasDelegate)
        {
            await OnSubmit.InvokeAsync(_editContext);
        }
        else 
        {
            /*// Otherwise, the system implicitly runs validation on form submission
                var*/ let isValid = _editContext.Validate();
            if (isValid && OnValidSubmit.HasDelegate)
            {
                await OnValidSubmit.InvokeAsync(_editContext);
            }
            if (isValid && OnInvalidSubmit.HasDelegate)
            {
                await OnInvalidSubmit.InvokeAsync(_editContext);
            }
        }
    }
}


class Microsoft_AspNetCore_Components_Forms_FieldCssClassProvider extends object
{
    constructor()
    {
        super();
    }
    /*FieldCssClassProvider*/ Instance = new FieldCssClassProvider();
    /*string*/ GetFieldCssClass(/*EditContext*/ editContext, /*FieldIdentifier*/ fieldIdentifier)
    {
        /*var*/ let isValid = editContext.GetValidationMessages(fieldIdentifier).Any();
        if (editContext.IsModified(fieldIdentifier))
        {
            return isValid"modified valid""modified invalid";
        }
        else 
        {
            return isValid"valid""invalid";
        }
    }
}

class Microsoft_AspNetCore_Components_Forms_HtmlFieldPrefix extends object
{
    /*LambdaExpression*/ initial = null;
    constructor(/*LambdaExpression*/ initial)
    {
        super();
        .initial = initial;
    }
    /*LambdaExpression[]*/ _rest = Array.Empty(LambdaExpression);
    constructor(/*LambdaExpression*/ expression, /*LambdaExpression[]*/ rest)
    {
        super(expression);
        _rest = rest;
    }
    /*HtmlFieldPrefix*/ Combine(/*LambdaExpression*/ other)
    {
        /*var*/ let restLength = _restLength ?? 0;
        /*var*/ let length = restLength + 1;
        /*var*/ let expressions = new Array(length);
        for(/*var*/ let i = 0; i < restLength - 1; i++)
        {
            expressionsi = _resti;
        });
        expressionslength - 1 = other;
        return new HtmlFieldPrefix(initial, expressions);
    }
    /*string*/ GetFieldName(/*LambdaExpression*/ expression)
    {
        /*var*/ let prefix = ExpressionFormatter.FormatLambda(initial);
        /*var*/ let restLength = _restLength ?? 0;
        for(/*var*/ let i = 0; i < restLength; i++)
        {
            prefix = ExpressionFormatter.FormatLambda(_resti, prefix);
        });
        return ExpressionFormatter.FormatLambda(expression, prefix);
    }
}

const Microsoft_AspNetCore_Components_IInputRadioValueProvider = (Base) => class extends Base
{
    /*object*/ _backingField_CurrentValue = null;
    /*object*/ get CurrentValue()
    {
        return _backingField_CurrentValue;
    }
}

const Microsoft_AspNetCore_Components_Forms_InputBase$_1 = (TValue) => class extends Microsoft_AspNetCore_Components_ComponentBase
{
    /*EventHandler<ValidationStateChangedEventArgs>*/ _validationStateChangedHandler = null;
    /*bool*/ _hasInitializedParameters = null;
    /*bool*/ _parsingFailed = null;
    /*string*/ _incomingValueBeforeParsing = null;
    /*string*/ _formattedValueExpression = null;
    /*bool*/ _previousParsingAttemptFailed = null;
    /*ValidationMessageStore*/ _parsingValidationMessages = null;
    /*Type*/ _nullableUnderlyingType = null;
    /*bool*/ _shouldGenerateFieldNames = null;
    /*EditContext*/ _backingField_CascadedEditContext = null;
    /*EditContext*/ get CascadedEditContext()
    {
        return _backingField_CascadedEditContext;
    }
    /*EditContext*/ set CascadedEditContext(value)
    {
        _backingField_CascadedEditContext = value;
    }
    /*HtmlFieldPrefix*/ _backingField_FieldPrefix = null;
    /*HtmlFieldPrefix*/ get FieldPrefix()
    {
        return _backingField_FieldPrefix;
    }
    /*HtmlFieldPrefix*/ set FieldPrefix(value)
    {
        _backingField_FieldPrefix = value;
    }
    /*TValue*/ _backingField_Value = null;
    /*TValue*/ get Value()
    {
        return _backingField_Value;
    }
    /*TValue*/ set Value(value)
    {
        _backingField_Value = value;
    }
    /*EventCallback<TValue>*/ _backingField_ValueChanged = null;
    /*EventCallback<TValue>*/ get ValueChanged()
    {
        return _backingField_ValueChanged;
    }
    /*EventCallback<TValue>*/ set ValueChanged(value)
    {
        _backingField_ValueChanged = value;
    }
    /*Expression<Func<TValue>>*/ _backingField_ValueExpression = null;
    /*Expression<Func<TValue>>*/ get ValueExpression()
    {
        return _backingField_ValueExpression;
    }
    /*Expression<Func<TValue>>*/ set ValueExpression(value)
    {
        _backingField_ValueExpression = value;
    }
    /*string*/ _backingField_DisplayName = null;
    /*string*/ get DisplayName()
    {
        return _backingField_DisplayName;
    }
    /*string*/ set DisplayName(value)
    {
        _backingField_DisplayName = value;
    }
    /*EditContext*/ _backingField_EditContext = null;
    /*EditContext*/ get EditContext()
    {
        return _backingField_EditContext;
    }
    /*EditContext*/ set EditContext(value)
    {
        _backingField_EditContext = value;
    }
    /*FieldIdentifier*/ _backingField_FieldIdentifier = null;
    /*FieldIdentifier*/ get FieldIdentifier()
    {
        return _backingField_FieldIdentifier;
    }
    /*FieldIdentifier*/ set FieldIdentifier(value)
    {
        _backingField_FieldIdentifier = value;
    }
    /*TValue*/ get CurrentValue()
    {
        return Value;
    }
    /*TValue*/ set CurrentValue(value)
    {
        /*var*/ let hasChanged = EqualityComparer_$1.Default.Equals(value, Value);
        if (hasChanged)
        {
            _parsingFailed = false;
            // If we don't do this, then when the user edits from A to B, we'd:
                    // - Do a render that changes back to A
                    // - Then send the updated value to the parent, which sends the B back to this component
                    // - Do another render that changes it to B again
                    // The unnecessary reversion from B to A can cause selection to be lost while typing
                    // A better solution would be somehow forcing the parent component's render to occur first,
                    // but that would involve a complex change in the renderer to keep the render queue sorted
                    // by component depth or similar.
                    Value = value;
            ValueChanged.InvokeAsync(Value).FireAndForget();
            EditContextNotifyFieldChanged(FieldIdentifier);
        }
    }
    /*string*/ get CurrentValueAsString()
    {
        return _parsingFailed_incomingValueBeforeParsingFormatValueAsString(CurrentValue);
    }
    /*string*/ set CurrentValueAsString(value)
    {
        _incomingValueBeforeParsing = value;
        _parsingValidationMessagesClear();
        if (_nullableUnderlyingType != null && .IsNullOrEmpty(value))
        {
            // Assume if it's a nullable type, null/empty inputs should correspond to default(T)
                    // Then all subclasses get nullable support almost automatically (they just have to
                    // not reject Nullable<T> based on the type itself).
                    _parsingFailed = false;
            CurrentValue = default;
        }
        let parsedValue = null;
        let $v = { value: set(value){ parsedValue = value; } };
        let validationErrorMessage = null;
        let $v = { value: set(value){ validationErrorMessage = value; } };
        else if (TryParseValueFromString(value, $v, $v))
        {
            _parsingFailed = false;
            CurrentValue = parsedValue;
        }
        else 
        {
            _parsingFailed = true;
            if (EditContext)
            {
                _parsingValidationMessages = _parsingValidationMessages ?? new ValidationMessageStore(EditContext);
                _parsingValidationMessages.Add(FieldIdentifier, validationErrorMessage);
                // Since we're not writing to CurrentValue, we'll need to notify about modification from here
                        EditContext.NotifyFieldChanged(FieldIdentifier);
            }
        }
        if (_parsingFailed || _previousParsingAttemptFailed)
        {
            EditContextNotifyValidationStateChanged();
            _previousParsingAttemptFailed = _parsingFailed;
        }
    }
    constructor()
    {
        super();
        _validationStateChangedHandler = OnValidateStateChanged;
    }
    /*string*/ FormatValueAsString(/*TValue*/ value)
    {
        valueToString();
    }
    /*string*/ get CssClass()
    {
        /*var*/ let fieldClass = EditContextFieldCssClass(FieldIdentifier);
        return AttributeUtilities.CombineClassNames(, fieldClass) ?? .Empty;
    }
    /*string*/ get NameAttributeValue()
    {
        let nameAttributeValue = null;
        let $v = { value: set(value){ nameAttributeValue = value; } };
        if (.TryGetValue("name", $v))
        {
            return Convert.ToString(nameAttributeValue) ?? .Empty;
        }
        if (_shouldGenerateFieldNames)
        {
            if (_formattedValueExpression && ValueExpression)
            {
                _formattedValueExpression = FieldPrefix != nullFieldPrefix.GetFieldName(ValueExpression)ExpressionFormatter.FormatLambda(ValueExpression);
            }
            return _formattedValueExpression ?? .Empty;
        }
        return .Empty;
    }
    /*void*/ OnParametersSet()
    {
        super.OnParametersSet();
        if (_hasInitializedParameters)
        {
            if (ValueExpression == null)
            {
                throw new InvalidOperationException(GetType() + );
            }
            FieldIdentifier = FieldIdentifier.Create(ValueExpression);
            if (CascadedEditContext != null)
            {
                EditContext = CascadedEditContext;
                EditContext.OnValidationStateChanged  += _validationStateChangedHandler;
                _shouldGenerateFieldNames = EditContext.ShouldUseFieldIdentifiers;
            }
            else 
            {
                // Ideally we'd know if we were in an SSR context but we don't
                    _shouldGenerateFieldNames = false;
            }
            _nullableUnderlyingType = Nullable.GetUnderlyingType(TValue);
            _hasInitializedParameters = true;
        }
        else if (CascadedEditContext != EditContext)
        {
            throw new InvalidOperationException(GetType() + nameof(Forms.EditContext));
        }
        UpdateAdditionalValidationAttributes();
    }
    /*void*/ OnValidateStateChanged(/*object*/ sender, /*ValidationStateChangedEventArgs*/ eventArgs)
    {
        UpdateAdditionalValidationAttributes();
        StateHasChanged();
    }
    /*void*/ UpdateAdditionalValidationAttributes()
    {
        if (EditContext)
        {
            return ;
        }
        /*var*/ let hasAriaInvalidAttribute = .ContainsKey("aria-invalid");
        if (EditContext.GetValidationMessages(FieldIdentifier).Any())
        {
            /*// If this input is associated with an incoming value from an HTTP form post (via model binding),
                // retain the attempted value even if it's unparseable
                var*/ let attemptedValue = EditContext.GetAttemptedValue(NameAttributeValue);
            if (attemptedValue != null)
            {
                _parsingFailed = true;
                _incomingValueBeforeParsing = attemptedValue;
            }
            if (hasAriaInvalidAttribute)
            {
                return ;
            }
            "aria-invalid" = "true";
        }
        else if (hasAriaInvalidAttribute)
        {
        }
    }
    /*bool*/ ConvertToDictionary(/*IReadOnlyDictionary<string, object>*/ source, /*Dictionary<string, object>*/ result)
    {
        /*var*/ let newDictionaryCreated = true;
        if (source == null)
        {
            result = new Dictionary_$2(string, object);
        }
        else if (source instanceof Dictionary_$2, currentDictionary = source)
        {
            result = currentDictionary;
            newDictionaryCreated = false;
        }
        else 
        {
            result = new Dictionary_$2(string, object);
            BlazorJs.forEach(source, function(item, $_i)
            {
                result.Add(item.Key, item.Value);
            });
        }
        return newDictionaryCreated;
    }
    /*void*/ Dispose(/*bool*/ disposing)
    {
    }
    /*void*/ Dispose()
    {
        super.Dispose();
        if (EditContext)
        {
            EditContext.OnValidationStateChanged  -= _validationStateChangedHandler;
        }
        if (_parsingValidationMessages != null)
        {
            _parsingValidationMessages.Clear();
            EditContext.NotifyValidationStateChanged();
        }
        Dispose({ disposing : true });
    }
}

class Microsoft_AspNetCore_Components_Forms_InputCheckbox extends Microsoft_AspNetCore_Components_Forms_InputBase(bool)
{
    constructor()
    {
        super();
    }
    /*ElementReference*/ _backingField_Element = null;
    /*ElementReference*/ get Element()
    {
        return _backingField_Element;
    }
    /*ElementReference*/ set Element(value)
    {
        _backingField_Element = value;
    }
    /*bool*/ TryParseValueFromString(/*string*/ value, /*bool*/ result, /*string*/ validationErrorMessage)
    {
                throw new NotSupportedException(nameof(CurrentValue)nameof(CurrentValueAsString));
;
    }
}

const Microsoft_AspNetCore_Components_Forms_InputDate$_1 = (TValue) => class extends Microsoft_AspNetCore_Components_Forms_InputBase(TValue)
{
    /*string*/ DateFormat = "yyyy-MM-dd";
    /*string*/ DateTimeLocalFormat = "yyyy-MM-ddTHH:mm:ss";
    /*string*/ MonthFormat = "yyyy-MM";
    /*string*/ TimeFormat = "HH:mm:ss";
    /*string*/ _typeAttributeValue = null;
    /*string*/ _format = null;
    /*string*/ _parsingErrorMessage = null;
    /*InputDateType*/ _backingField_Type = null;
    /*InputDateType*/ get Type()
    {
        return _backingField_Type;
    }
    /*InputDateType*/ set Type(value)
    {
        _backingField_Type = value;
    }
    /*string*/ _backingField_ParsingErrorMessage = null;
    /*string*/ get ParsingErrorMessage()
    {
        return _backingField_ParsingErrorMessage;
    }
    /*string*/ set ParsingErrorMessage(value)
    {
        _backingField_ParsingErrorMessage = value;
    }
    /*ElementReference*/ _backingField_Element = null;
    /*ElementReference*/ get Element()
    {
        return _backingField_Element;
    }
    /*ElementReference*/ set Element(value)
    {
        _backingField_Element = value;
    }
    constructor()
    {
        super();
        /*var*/ let type = Nullable.GetUnderlyingType(TValue) ?? TValue;
        if (type != DateTime && type != DateTimeOffset)
        {
            throw new InvalidOperationException(.GetType()type);
        }
    }
    /*void*/ OnParametersSet()
    {
        /*string*/ let formatDescription = null;
        switch(Type)
        {
            case InputDateType.Date:
            {
                _typeAttributeValue = "date";
                _format = DateFormat;
                formatDescription = "date";
                break;
            }
            case InputDateType.DateTimeLocal:
            {
                _typeAttributeValue = "datetime-local";
                _format = DateTimeLocalFormat;
                formatDescription = "date and time";
                break;
            }
            case InputDateType.Month:
            {
                _typeAttributeValue = "month";
                _format = MonthFormat;
                formatDescription = "year and month";
                break;
            }
            case InputDateType.Time:
            {
                _typeAttributeValue = "time";
                _format = TimeFormat;
                formatDescription = "time";
                break;
            }
            default:            {
                throw new InvalidOperationException(nameof(InputDateType)Type);
            }
        }
        //(_typeAttributeValue, _format, var formatDescription) = Type switch
            //{
            //    InputDateType.Date => ("date", DateFormat, "date"),
            //    InputDateType.DateTimeLocal => ("datetime-local", DateTimeLocalFormat, "date and time"),
            //    InputDateType.Month => ("month", MonthFormat, "year and month"),
            //    InputDateType.Time => ("time", TimeFormat, "time"),
            //    _ => throw new InvalidOperationException($"Unsupported {nameof(InputDateType)} '{Type}'.")
            //};
            _parsingErrorMessage = .IsNullOrEmpty(ParsingErrorMessage)formatDescriptionParsingErrorMessage;
    }
    /*string*/ FormatValueAsString(/*TValue*/ value)
    {
        switch(value)
        {
DateTime            {
                return BindConverter.FormatValue(dateTimeValue, _format, CultureInfo.InvariantCulture);
            }
DateTimeOffset            {
                return BindConverter.FormatValue(dateTimeOffsetValue, _format, CultureInfo.InvariantCulture);
            }
        }
        return .Empty;
    }
    /*bool*/ TryParseValueFromString(/*string*/ value, /*TValue*/ result, /*string*/ validationErrorMessage)
    {
        let $v = { value: set(value){ result = value; } };
        if (BindConverter.TryConvertTo(value, CultureInfo.InvariantCulture, $v))
        {
            Debug.Assert(result != null);
            validationErrorMessage = null;
            return true;
        }
        else 
        {
            validationErrorMessage = .Format(CultureInfo.InvariantCulture, _parsingErrorMessage, DisplayName ?? FieldIdentifier.FieldName);
            return false;
        }
    }
}


class Microsoft_AspNetCore_Components_Forms_InputExtensions extends object
{
    constructor()
    {
        super();
    }
    /*bool*/ TryParseSelectableValueFromString(TValue, /*InputBase<TValue>*/ input, /*string*/ value, /*TValue*/ result, /*string*/ validationErrorMessage)
    {
        {
            if (TValue == )
            {
                let $v = { value: set(value){ result = value; } };
                if (TryConvertToBool(value, $v))
                {
                    validationErrorMessage = null;
                    return true;
                }
            }
            else if (TValue == )
            {
                let $v = { value: set(value){ result = value; } };
                if (TryConvertToNullableBool(value, $v))
                {
                    validationErrorMessage = null;
                    return true;
                }
            }
            let parsedValue = null;
            let $v = { value: set(value){ parsedValue = value; } };
            else if (BindConverter.TryConvertTo(TValue, value, CultureInfo.CurrentCulture, $v))
            {
                result = parsedValue;
                validationErrorMessage = null;
                return true;
            }
            result = default;
            validationErrorMessage = input.DisplayName  ?? input.FieldIdentifier.FieldName;
            return false;
        }
InvalidOperationException        {
            throw new InvalidOperationException(input.GetType()TValue, ex);
        }
    }
    /*bool*/ TryConvertToBool(TValue, /*string*/ value, /*TValue*/ result)
    {
        let mbool = null;
        let $v = { value: set(value){ mbool = value; } };
        if (.TryParse(value, $v))
        {
            result = TValuembool;
            return true;
        }
        result = default;
        return false;
    }
    /*bool*/ TryConvertToNullableBool(TValue, /*string*/ value, /*TValue*/ result)
    {
        if (.IsNullOrEmpty(value))
        {
            result = default;
            return true;
        }
        let $v = { value: set(value){ result = value; } };
        return TryConvertToBool(value, $v);
    }
}

class Microsoft_AspNetCore_Components_Forms_InputFile extends Microsoft_AspNetCore_Components_Forms_IInputFileJsCallbacks(Microsoft_AspNetCore_Components_ComponentBase)
{
    constructor()
    {
        super();
    }
    /*ElementReference*/ _inputFileElement = null;
    /*EventCallback<InputFileChangeEventArgs>*/ _backingField_OnChange = null;
    /*EventCallback<InputFileChangeEventArgs>*/ get OnChange()
    {
        return _backingField_OnChange;
    }
    /*EventCallback<InputFileChangeEventArgs>*/ set OnChange(value)
    {
        _backingField_OnChange = value;
    }
    /*ElementReference*/ get Element()
    {
        return _inputFileElement;
    }
    /*ElementReference*/ set Element(value)
    {
        _inputFileElement = value;
    }
    /*void*/ OnAfterRender(/*bool*/ firstRender)
    {
        if (firstRender)
        {
            //_jsCallbacksRelay = new InputFileJsCallbacksRelay(this);
                InputFileInterop.Init(, _inputFileElement.Element.As(HTMLInputElement));
        }
        super.OnAfterRender(firstRender);
    }
    /*Stream*/ OpenReadStream(/*BrowserFile*/ file, /*long*/ maxAllowedSize, /*CancellationToken*/ cancellationToken)
    {
        new BrowserFileStream(_inputFileElement.Element.As(HTMLInputElement), file, maxAllowedSize, cancellationToken);
    }
    /*Task<IBrowserFile>*/ async ConvertToImageFileAsync(/*BrowserFile*/ file, /*string*/ format, /*int*/ maxWidth, /*int*/ maxHeight)
    {
        /*var*/ let imageFile = await InputFileInterop.ToImageFile(_inputFileElement.Element.As(HTMLInputElement), file.Id, format, maxWidth, maxHeight);
        if (imageFile)
        {
            throw new InvalidOperationException("ToImageFile returned an unexpected null result.");
        }
        imageFile.Owner  = ;
        return imageFile;
    }
    /*Task*/ NotifyChange(/*BrowserFile[]*/ files)
    {
        BlazorJs.forEach(files, function(file, $_i)
        {
            file.Owner  = ;
        });
        return OnChange.InvokeAsync(new InputFileChangeEventArgs(files));
    }
}

const Microsoft_AspNetCore_Components_Forms_InputNumber$_1 = (TValue) => class extends Microsoft_AspNetCore_Components_Forms_InputBase(TValue)
{
    constructor()
    {
        super();
        TValue = $_TValue;
    }
    /*string*/ _stepAttributeValue = GetStepAttributeValue();
    /*string*/ GetStepAttributeValue()
    {
        /*// Unwrap Nullable<T>, because InputBase already deals with the Nullable aspect
            // of it for us. We will only get asked to parse the T for nonempty inputs.
            var*/ let targetType = Nullable.GetUnderlyingType(TValue) ?? TValue;
        if (targetType ==  || targetType ==  || targetType ==  || targetType ==  || targetType ==  || targetType == )
        {
            return "any";
        }
        else 
        {
            throw new InvalidOperationException(targetType);
        }
    }
    /*string*/ _backingField_ParsingErrorMessage = null;
    /*string*/ get ParsingErrorMessage()
    {
        return _backingField_ParsingErrorMessage;
    }
    /*string*/ set ParsingErrorMessage(value)
    {
        _backingField_ParsingErrorMessage = value;
    }
    /*ElementReference*/ _backingField_Element = null;
    /*ElementReference*/ get Element()
    {
        return _backingField_Element;
    }
    /*ElementReference*/ set Element(value)
    {
        _backingField_Element = value;
    }
    /*bool*/ TryParseValueFromString(/*string*/ value, /*TValue*/ result, /*string*/ validationErrorMessage)
    {
        let $v = { value: set(value){ result = value; } };
        if (BindConverter.TryConvertTo(TValue, value, CultureInfo.InvariantCulture, $v))
        {
            validationErrorMessage = null;
            return true;
        }
        else 
        {
            validationErrorMessage = .Format(CultureInfo.InvariantCulture, ParsingErrorMessage, DisplayName ?? FieldIdentifier.FieldName);
            return false;
        }
    }
    /*string*/ FormatValueAsString(/*TValue*/ value)
    {
        switch(value)
        {
            {
                return BindConverter.FormatValue(mint, CultureInfo.InvariantCulture);
            }
            {
                return BindConverter.FormatValue(mlong, CultureInfo.InvariantCulture);
            }
            {
                return BindConverter.FormatValue(mshort, CultureInfo.InvariantCulture);
            }
            {
                return BindConverter.FormatValue(mfloat, CultureInfo.InvariantCulture);
            }
            {
                return BindConverter.FormatValue(mdouble, CultureInfo.InvariantCulture);
            }
            {
                return BindConverter.FormatValue(mdecimal, CultureInfo.InvariantCulture);
            }
            default:            {
                if (value == null)
                return null;
                throw new InvalidOperationException(value.GetType());
            }
        }
    }
}

const Microsoft_AspNetCore_Components_Forms_InputRadio$_1 = (TValue) => class extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
        TValue = $_TValue;
    }
    /*bool*/ _trueValueToggle = null;
    /*InputRadioContext*/ _backingField_Context = null;
    /*InputRadioContext*/ get Context()
    {
        return _backingField_Context;
    }
    /*InputRadioContext*/ set Context(value)
    {
        _backingField_Context = value;
    }
    /*TValue*/ _backingField_Value = null;
    /*TValue*/ get Value()
    {
        return _backingField_Value;
    }
    /*TValue*/ set Value(value)
    {
        _backingField_Value = value;
    }
    /*string*/ _backingField_Name = null;
    /*string*/ get Name()
    {
        return _backingField_Name;
    }
    /*string*/ set Name(value)
    {
        _backingField_Name = value;
    }
    /*ElementReference*/ _backingField_Element = null;
    /*ElementReference*/ get Element()
    {
        return _backingField_Element;
    }
    /*ElementReference*/ set Element(value)
    {
        _backingField_Element = value;
    }
    /*InputRadioContext*/ _backingField_CascadedContext = null;
    /*InputRadioContext*/ get CascadedContext()
    {
        return _backingField_CascadedContext;
    }
    /*InputRadioContext*/ set CascadedContext(value)
    {
        _backingField_CascadedContext = value;
    }
    /*void*/ OnParametersSet()
    {
        Context = .IsNullOrEmpty(Name)CascadedContextCascadedContextFindContextInAncestors(Name);
        if (Context == null)
        {
            throw new InvalidOperationException(.GetType()InputRadioGroup_$1 + );
        }
    }
    /*string*/ GetToggledTrueValue()
    {
        _trueValueToggle = _trueValueToggle;
        return _trueValueToggle"a""b";
    }
}

class Microsoft_AspNetCore_Components_Forms_InputRadioContext extends object
{
    /*IInputRadioValueProvider*/ _valueProvider = null;
    /*InputRadioContext*/ _backingField_ParentContext = null;
    /*InputRadioContext*/ get ParentContext()
    {
        return _backingField_ParentContext;
    }
    /*EventCallback<ChangeEventArgs>*/ _backingField_ChangeEventCallback = null;
    /*EventCallback<ChangeEventArgs>*/ get ChangeEventCallback()
    {
        return _backingField_ChangeEventCallback;
    }
    /*object*/ get CurrentValue()
    {
        return _valueProvider.CurrentValue;
    }
    /*string*/ _backingField_GroupName = null;
    /*string*/ get GroupName()
    {
        return _backingField_GroupName;
    }
    /*string*/ set GroupName(value)
    {
        _backingField_GroupName = value;
    }
    /*string*/ _backingField_FieldClass = null;
    /*string*/ get FieldClass()
    {
        return _backingField_FieldClass;
    }
    /*string*/ set FieldClass(value)
    {
        _backingField_FieldClass = value;
    }
    constructor(/*IInputRadioValueProvider*/ valueProvider, /*InputRadioContext*/ parentContext, /*EventCallback<ChangeEventArgs>*/ changeEventCallback)
    {
        super();
        _valueProvider = valueProvider;
        ParentContext = parentContext;
        ChangeEventCallback = changeEventCallback;
    }
    /*InputRadioContext*/ FindContextInAncestors(/*string*/ groupName)
    {
        .Equals(GroupName, groupName)ParentContextFindContextInAncestors(groupName);
    }
}

const Microsoft_AspNetCore_Components_Forms_InputRadioGroup$_1 = (TValue) => class extends Microsoft_AspNetCore_Components_IInputRadioValueProvider(Microsoft_AspNetCore_Components_Forms_InputBase)
{
    constructor()
    {
        super();
        TValue = $_TValue;
    }
    /*string*/ _defaultGroupName = Guid.NewGuid().ToString("N");
    /*InputRadioContext*/ _context = null;
    /*RenderFragment*/ _backingField_ChildContent = null;
    /*RenderFragment*/ get ChildContent()
    {
        return _backingField_ChildContent;
    }
    /*RenderFragment*/ set ChildContent(value)
    {
        _backingField_ChildContent = value;
    }
    /*string*/ _backingField_Name = null;
    /*string*/ get Name()
    {
        return _backingField_Name;
    }
    /*string*/ set Name(value)
    {
        _backingField_Name = value;
    }
    /*InputRadioContext*/ _backingField_CascadedContext = null;
    /*InputRadioContext*/ get CascadedContext()
    {
        return _backingField_CascadedContext;
    }
    /*InputRadioContext*/ set CascadedContext(value)
    {
        _backingField_CascadedContext = value;
    }
    /*object*/ get CurrentValue()
    {
        return CurrentValue;
    }
    /*void*/ OnParametersSet()
    {
        if (_context)
        {
            /*var*/ let changeEventCallback = EventCallback.Factory.CreateBinder(string, , function(/**/ __value)
            {
CurrentValueAsString = __value            }, CurrentValueAsString);
            _context = new InputRadioContext(, CascadedContext, changeEventCallback);
        }
        else if (_context.ParentContext  != CascadedContext)
        {
            throw new InvalidOperationException("An InputRadioGroup cannot change context after creation");
        }
        if (.IsNullOrEmpty(Name))
        {
            // Prefer the explicitly-specified group name over anything else.
                _context.GroupName  = Name;
        }
        else if (.IsNullOrEmpty(NameAttributeValue))
        {
            // If the user specifies a "name" attribute, or we're using "name" as a form field identifier, use that.
                _context.GroupName  = NameAttributeValue;
        }
        else 
        {
            // Otherwise, just use a GUID to disambiguate this group's radio inputs from any others on the page.
                _context.GroupName  = _defaultGroupName;
        }
        _context.FieldClass  = EditContextFieldCssClass(FieldIdentifier);
    }
    /*bool*/ TryParseValueFromString(/*string*/ value, /*TValue*/ result, /*string*/ validationErrorMessage)
    {
        let $v = { value: set(value){ result = value; } };
        let $v = { value: set(value){ validationErrorMessage = value; } };
        .TryParseSelectableValueFromString(value, $v, $v);
    }
}

const Microsoft_AspNetCore_Components_Forms_InputSelect$_1 = (TValue) => class extends Microsoft_AspNetCore_Components_Forms_InputBase(TValue)
{
    /*bool*/ _isMultipleSelect = null;
    constructor()
    {
        super();
        _isMultipleSelect = TValue.IsArray;
    }
    /*RenderFragment*/ _backingField_ChildContent = null;
    /*RenderFragment*/ get ChildContent()
    {
        return _backingField_ChildContent;
    }
    /*RenderFragment*/ set ChildContent(value)
    {
        _backingField_ChildContent = value;
    }
    /*ElementReference*/ _backingField_Element = null;
    /*ElementReference*/ get Element()
    {
        return _backingField_Element;
    }
    /*ElementReference*/ set Element(value)
    {
        _backingField_Element = value;
    }
    /*bool*/ TryParseValueFromString(/*string*/ value, /*TValue*/ result, /*string*/ validationErrorMessage)
    {
        let $v = { value: set(value){ result = value; } };
        let $v = { value: set(value){ validationErrorMessage = value; } };
        .TryParseSelectableValueFromString(value, $v, $v);
    }
    /*string*/ FormatValueAsString(/*TValue*/ value)
    {
        if (TValue == )
        {
            return value"true""false";
        }
        else if (TValue == )
        {
            return value == null && value"true""false";
        }
        return super.FormatValueAsString(value);
    }
    /*void*/ SetCurrentValueAsStringArray(/*string[]*/ value)
    {
        let result = null;
        let $v = { value: set(value){ result = value; } };
        CurrentValue = BindConverter.TryConvertTo(TValue, value, CultureInfo.CurrentCulture, $v)resultdefault;
    }
}

class Microsoft_AspNetCore_Components_Forms_InputText extends Microsoft_AspNetCore_Components_Forms_InputBase(string)
{
    constructor()
    {
        super();
    }
    /*ElementReference*/ _backingField_Element = null;
    /*ElementReference*/ get Element()
    {
        return _backingField_Element;
    }
    /*ElementReference*/ set Element(value)
    {
        _backingField_Element = value;
    }
    /*bool*/ TryParseValueFromString(/*string*/ value, /*string*/ result, /*string*/ validationErrorMessage)
    {
        result = value;
        validationErrorMessage = null;
        return true;
    }
}

class Microsoft_AspNetCore_Components_Forms_InputTextArea extends Microsoft_AspNetCore_Components_Forms_InputBase(string)
{
    constructor()
    {
        super();
    }
    /*ElementReference*/ _backingField_Element = null;
    /*ElementReference*/ get Element()
    {
        return _backingField_Element;
    }
    /*ElementReference*/ set Element(value)
    {
        _backingField_Element = value;
    }
    /*bool*/ TryParseValueFromString(/*string*/ value, /*string*/ result, /*string*/ validationErrorMessage)
    {
        result = value;
        validationErrorMessage = null;
        return true;
    }
}

class Microsoft_AspNetCore_Components_Rendering_RenderTreeBuilderExtensions extends object
{
    constructor()
    {
        super();
    }
    /*void*/ AddAttributeIfNotNullOrEmpty(/*RenderTreeBuilder*/ builder, /*int*/ sequence, /*string*/ name, /*string*/ value)
    {
        if (.IsNullOrEmpty(value))
        {
            builder.AddAttribute(sequence, name, value);
        }
    }
}

const Microsoft_AspNetCore_Components_Forms_ValidationMessage$_1 = (TValue) => class extends Microsoft_AspNetCore_Components_ComponentBase
{
    /*EditContext*/ _previousEditContext = null;
    /*Expression<Func<TValue>>*/ _previousFieldAccessor = null;
    /*EventHandler<ValidationStateChangedEventArgs>*/ _validationStateChangedHandler = null;
    /*FieldIdentifier*/ _fieldIdentifier = null;
    /*EditContext*/ _backingField_CurrentEditContext = null;
    /*EditContext*/ get CurrentEditContext()
    {
        return _backingField_CurrentEditContext;
    }
    /*EditContext*/ set CurrentEditContext(value)
    {
        _backingField_CurrentEditContext = value;
    }
    /*Expression<Func<TValue>>*/ _backingField_For = null;
    /*Expression<Func<TValue>>*/ get For()
    {
        return _backingField_For;
    }
    /*Expression<Func<TValue>>*/ set For(value)
    {
        _backingField_For = value;
    }
    constructor()
    {
        super();
        _validationStateChangedHandler = function(/**/ sender, /**/ eventArgs)
        {
            return StateHasChanged();
        };
    }
    /*void*/ OnParametersSet()
    {
        if (CurrentEditContext == null)
        {
            throw new InvalidOperationException(GetType() + nameof(EditContext)GetType() + nameof(EditForm));
        }
        if (For == null)
        {
            throw new InvalidOperationException(GetType() + nameof(For));
        }
        else if (For != _previousFieldAccessor)
        {
            _fieldIdentifier = FieldIdentifier.Create(For);
            _previousFieldAccessor = For;
        }
        if (CurrentEditContext != _previousEditContext)
        {
            DetachValidationStateChangedListener();
            CurrentEditContext.OnValidationStateChanged  += _validationStateChangedHandler;
            _previousEditContext = CurrentEditContext;
        }
    }
    /*void*/ Dispose(/*bool*/ disposing)
    {
    }
    /*void*/ Dispose()
    {
        super.Dispose();
        DetachValidationStateChangedListener();
        Dispose({ disposing : true });
    }
    /*void*/ DetachValidationStateChangedListener()
    {
        if (_previousEditContext != null)
        {
            _previousEditContext.OnValidationStateChanged  -= _validationStateChangedHandler;
        }
    }
}

class Microsoft_AspNetCore_Components_Forms_ValidationSummary extends Microsoft_AspNetCore_Components_ComponentBase
{
    /*EditContext*/ _previousEditContext = null;
    /*EventHandler<ValidationStateChangedEventArgs>*/ _validationStateChangedHandler = null;
    /*object*/ _backingField_Model = null;
    /*object*/ get Model()
    {
        return _backingField_Model;
    }
    /*object*/ set Model(value)
    {
        _backingField_Model = value;
    }
    /*EditContext*/ _backingField_CurrentEditContext = null;
    /*EditContext*/ get CurrentEditContext()
    {
        return _backingField_CurrentEditContext;
    }
    /*EditContext*/ set CurrentEditContext(value)
    {
        _backingField_CurrentEditContext = value;
    }
    constructor()
    {
        super();
        _validationStateChangedHandler = function(/**/ sender, /**/ eventArgs)
        {
            return StateHasChanged();
        };
    }
    /*void*/ OnParametersSet()
    {
        if (CurrentEditContext == null)
        {
            throw new InvalidOperationException(nameof(ValidationSummary) + nameof(EditContext)nameof(ValidationSummary) + nameof(EditForm));
        }
        if (CurrentEditContext != _previousEditContext)
        {
            DetachValidationStateChangedListener();
            CurrentEditContext.OnValidationStateChanged  += _validationStateChangedHandler;
            _previousEditContext = CurrentEditContext;
        }
    }
    /*void*/ Dispose(/*bool*/ disposing)
    {
    }
    /*void*/ Dispose()
    {
        super.Dispose();
        DetachValidationStateChangedListener();
        Dispose({ disposing : true });
    }
    /*void*/ DetachValidationStateChangedListener()
    {
        if (_previousEditContext != null)
        {
            _previousEditContext.OnValidationStateChanged  -= _validationStateChangedHandler;
        }
    }
}

Task_$1ItemsProviderRequest
class Microsoft_AspNetCore_Components_Web_Virtualization_ItemsProviderRequest extends System_ValueType
{
    /*int*/ _backingField_StartIndex = null;
    /*int*/ get StartIndex()
    {
        return _backingField_StartIndex;
    }
    /*int*/ _backingField_Count = null;
    /*int*/ get Count()
    {
        return _backingField_Count;
    }
    /*CancellationToken*/ _backingField_CancellationToken = null;
    /*CancellationToken*/ get CancellationToken()
    {
        return _backingField_CancellationToken;
    }
    constructor(/*int*/ startIndex, /*int*/ count, /*CancellationToken*/ cancellationToken)
    {
        super();
        StartIndex = startIndex;
        Count = count;
        CancellationToken = cancellationToken;
    }
}

const Microsoft_AspNetCore_Components_Web_Virtualization_ItemsProviderResult$_1 = (TItem) => class extends System_ValueType
{
    /*IEnumerable<TItem>*/ _backingField_Items = null;
    /*IEnumerable<TItem>*/ get Items()
    {
        return _backingField_Items;
    }
    /*int*/ _backingField_TotalItemCount = null;
    /*int*/ get TotalItemCount()
    {
        return _backingField_TotalItemCount;
    }
    constructor(/*IEnumerable<TItem>*/ items, /*int*/ totalItemCount)
    {
        super();
        Items = items;
        TotalItemCount = totalItemCount;
    }
}

const Microsoft_AspNetCore_Components_Web_Virtualization_IVirtualizeJsCallbacks = (Base) => class extends Base
{
}

class Microsoft_AspNetCore_Components_Web_Virtualization_PlaceholderContext extends System_ValueType
{
    /*int*/ _backingField_Index = null;
    /*int*/ get Index()
    {
        return _backingField_Index;
    }
    /*float*/ _backingField_Size = null;
    /*float*/ get Size()
    {
        return _backingField_Size;
    }
    constructor(/*int*/ index, /*float*/ size)
    {
        super();
        Index = index;
        Size = size;
    }
}

const Microsoft_AspNetCore_Components_Web_Virtualization_Virtualize$_1 = (TItem) => class extends Microsoft_AspNetCore_Components_Web_Virtualization_IVirtualizeJsCallbacks(Microsoft_AspNetCore_Components_ComponentBase)
{
    constructor()
    {
        super();
        TItem = $_TItem;
    }
    /*HTMLElement*/ _spacerBefore = null;
    /*HTMLElement*/ _spacerAfter = null;
    /*int*/ _itemsBefore = null;
    /*int*/ _visibleItemCapacity = null;
    /*int*/ _unusedItemCapacity = null;
    /*int*/ _itemCount = null;
    /*int*/ _loadedItemsStartIndex = null;
    /*int*/ _lastRenderedItemCount = null;
    /*int*/ _lastRenderedPlaceholderCount = null;
    /*float*/ _itemSize = null;
    /*IEnumerable<TItem>*/ _loadedItems = null;
    /*CancellationTokenSource*/ _refreshCts = null;
    /*Exception*/ _refreshException = null;
    /*ItemsProviderDelegate<TItem>*/ _itemsProvider = null;
    /*RenderFragment<TItem>*/ _itemTemplate = null;
    /*RenderFragment<PlaceholderContext>*/ _placeholder = null;
    /*RenderFragment*/ _emptyContent = null;
    /*bool*/ _loading = null;
    /*RenderFragment<TItem>*/ _backingField_ChildContent = null;
    /*RenderFragment<TItem>*/ get ChildContent()
    {
        return _backingField_ChildContent;
    }
    /*RenderFragment<TItem>*/ set ChildContent(value)
    {
        _backingField_ChildContent = value;
    }
    /*RenderFragment<TItem>*/ _backingField_ItemContent = null;
    /*RenderFragment<TItem>*/ get ItemContent()
    {
        return _backingField_ItemContent;
    }
    /*RenderFragment<TItem>*/ set ItemContent(value)
    {
        _backingField_ItemContent = value;
    }
    /*RenderFragment<PlaceholderContext>*/ _backingField_Placeholder = null;
    /*RenderFragment<PlaceholderContext>*/ get Placeholder()
    {
        return _backingField_Placeholder;
    }
    /*RenderFragment<PlaceholderContext>*/ set Placeholder(value)
    {
        _backingField_Placeholder = value;
    }
    /*RenderFragment*/ _backingField_EmptyContent = null;
    /*RenderFragment*/ get EmptyContent()
    {
        return _backingField_EmptyContent;
    }
    /*RenderFragment*/ set EmptyContent(value)
    {
        _backingField_EmptyContent = value;
    }
    /*float*/ _backingField_ItemSize = null;
    /*float*/ get ItemSize()
    {
        return _backingField_ItemSize;
    }
    /*float*/ set ItemSize(value)
    {
        _backingField_ItemSize = value;
    }
    /*ItemsProviderDelegate<TItem>*/ _backingField_ItemsProvider = null;
    /*ItemsProviderDelegate<TItem>*/ get ItemsProvider()
    {
        return _backingField_ItemsProvider;
    }
    /*ItemsProviderDelegate<TItem>*/ set ItemsProvider(value)
    {
        _backingField_ItemsProvider = value;
    }
    /*ICollection<TItem>*/ _backingField_Items = null;
    /*ICollection<TItem>*/ get Items()
    {
        return _backingField_Items;
    }
    /*ICollection<TItem>*/ set Items(value)
    {
        _backingField_Items = value;
    }
    /*int*/ _backingField_OverscanCount = null;
    /*int*/ get OverscanCount()
    {
        return _backingField_OverscanCount;
    }
    /*int*/ set OverscanCount(value)
    {
        _backingField_OverscanCount = value;
    }
    /*string*/ _backingField_SpacerElement = null;
    /*string*/ get SpacerElement()
    {
        return _backingField_SpacerElement;
    }
    /*string*/ set SpacerElement(value)
    {
        _backingField_SpacerElement = value;
    }
    /*int*/ _backingField_MaxItemCount = null;
    /*int*/ get MaxItemCount()
    {
        return _backingField_MaxItemCount;
    }
    /*int*/ set MaxItemCount(value)
    {
        _backingField_MaxItemCount = value;
    }
    /*Task*/ async RefreshDataAsync()
    {
        await RefreshDataCoreAsync({ renderOnSuccess : false });
    }
    /*void*/ OnParametersSet()
    {
        if (ItemSize <= 0)
        {
            throw new InvalidOperationException(GetType()nameof(ItemSize));
        }
        if (_itemSize <= 0)
        {
            _itemSize = ItemSize;
        }
        if (ItemsProvider != null)
        {
            if (Items != null)
            {
                throw new InvalidOperationException(GetType() + nameof(Items)nameof(ItemsProvider));
            }
            _itemsProvider = ItemsProvider;
        }
        else if (Items != null)
        {
            _itemsProvider = DefaultItemsProvider;
            /*// When we have a fixed set of in-memory data, it doesn't cost anything to
                // re-query it on each cycle, so do that. This means the developer can add/remove
                // items in the collection and see the UI update without having to call RefreshDataAsync.
                var*/ let refreshTask = RefreshDataCoreAsync({ renderOnSuccess : false });
            // We know it's synchronous and has its own error handling
                Debug.Assert(refreshTask.IsCompleted  && refreshTask.IsFaulted);
        }
        else 
        {
            throw new InvalidOperationException(GetType()nameof(Items)nameof(ItemsProvider) + );
        }
        _itemTemplate = ItemContent ?? ChildContent;
        _placeholder = Placeholder ?? DefaultPlaceholder;
        _emptyContent = EmptyContent;
    }
    /*void*/ OnAfterRender(/*bool*/ firstRender)
    {
        if (firstRender)
        {
            VirtualizeJs.InitializeAsync(, _spacerBefore, _spacerAfter);
        }
        super.OnAfterRender(firstRender);
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ builder, /*object*/ key)
    {
        if (_refreshException != null)
        {
            /*var*/ let oldRefreshException = _refreshException;
            _refreshException = null;
            throw oldRefreshException;
        }
        _spacerBefore = builder.Element(SpacerElement, function(/*UIElementAttribute*/ attribute)
        {
            attribute.Set("style", GetSpacerStyle(_itemsBefore));
        }, { sequenceNumber : Utility.Virtualize_SpacerElementBefore_SequenceNumber });
        /*var*/ let lastItemIndex = Math.Min(_itemsBefore + _visibleItemCapacity, _itemCount);
        /*var*/ let renderIndex = _itemsBefore;
        /*var*/ let placeholdersBeforeCount = Math.Min(_loadedItemsStartIndex, lastItemIndex);
        for(; renderIndex < placeholdersBeforeCount; renderIndex++)
        {
            // This is a rare case where it's valid for the sequence number to be programmatically incremented.
                // This is only true because we know for certain that no other content will be alongside it.
                builder.Content(_placeholder(new PlaceholderContext(renderIndex, _itemSize)), { sequenceNumber : Utility.Virtualize_PlaceholderBefore_SequenceNumber });
        });
        _lastRenderedItemCount = 0;
        if (_loadedItems != null && _loading && _itemCount == 0 && _emptyContent != null)
        {
            builder.Content(_emptyContent, { sequenceNumber : Utility.Virtualize_EmptyContent_SequenceNumber });
        }
        else if (_loadedItems != null && _itemTemplate != null)
        {
            /*var*/ let itemsToShow = _loadedItems.Skip(_itemsBefore - _loadedItemsStartIndex).Take(lastItemIndex - _loadedItemsStartIndex);
            BlazorJs.forEach(itemsToShow, function(item, $_i)
            {
                builder.Content(_itemTemplate(item), { key : item, sequenceNumber : Utility.Virtualize_Item_SequenceNumber });
                _lastRenderedItemCount++;
            });
            renderIndex += _lastRenderedItemCount;
        }
        _lastRenderedPlaceholderCount = Math.Max(0, lastItemIndex - _itemsBefore - _lastRenderedItemCount);
        for(; renderIndex < lastItemIndex; renderIndex++)
        {
            builder.Content(_placeholder(new PlaceholderContext(renderIndex, _itemSize)), { sequenceNumber : Utility.Virtualize_PlaceholderAfter_SequenceNumber });
        });
        /*var*/ let itemsAfter = Math.Max(0, _itemCount - _visibleItemCapacity - _itemsBefore);
        _spacerAfter = builder.Element(SpacerElement, function(/*UIElementAttribute*/ attribute)
        {
            attribute.Set("style", GetSpacerStyle(itemsAfter, _unusedItemCapacity));
        }, { sequenceNumber : Utility.Virtualize_SpacerElementAfter_SequenceNumber });
    }
    /*string*/ GetSpacerStyle(/*int*/ itemsInSpacer, /*int*/ numItemsGapAbove)
    {
        numItemsGapAbove == 0GetSpacerStyle(itemsInSpacer)itemsInSpacer * _itemSize.ToString(CultureInfo.InvariantCulture)numItemsGapAbove * _itemSize.ToString(CultureInfo.InvariantCulture);
    }
    /*string*/ GetSpacerStyle(/*int*/ itemsInSpacer)
    {
        itemsInSpacer * _itemSize.ToString(CultureInfo.InvariantCulture);
    }
    /*void*/ OnBeforeSpacerVisible(/*float*/ spacerSize, /*float*/ spacerSeparation, /*float*/ containerSize)
    {
        let itemsBefore = null;
        let $v = { value: set(value){ itemsBefore = value; } };
        let visibleItemCapacity = null;
        let $v = { value: set(value){ visibleItemCapacity = value; } };
        let unusedItemCapacity = null;
        let $v = { value: set(value){ unusedItemCapacity = value; } };
        CalcualteItemDistribution(spacerSize, spacerSeparation, containerSize, $v, $v, $v);
        if (itemsBefore == _itemsBefore && itemsBefore > 0)
        {
            itemsBefore--;
        }
        UpdateItemDistribution(itemsBefore, visibleItemCapacity, unusedItemCapacity);
    }
    /*void*/ OnAfterSpacerVisible(/*float*/ spacerSize, /*float*/ spacerSeparation, /*float*/ containerSize)
    {
        let itemsAfter = null;
        let $v = { value: set(value){ itemsAfter = value; } };
        let visibleItemCapacity = null;
        let $v = { value: set(value){ visibleItemCapacity = value; } };
        let unusedItemCapacity = null;
        let $v = { value: set(value){ unusedItemCapacity = value; } };
        CalcualteItemDistribution(spacerSize, spacerSeparation, containerSize, $v, $v, $v);
        /*var*/ let itemsBefore = Math.Max(0, _itemCount - itemsAfter - visibleItemCapacity);
        if (itemsBefore == _itemsBefore && itemsBefore < _itemCount - visibleItemCapacity)
        {
            itemsBefore++;
        }
        UpdateItemDistribution(itemsBefore, visibleItemCapacity, unusedItemCapacity);
    }
    /*void*/ CalcualteItemDistribution(/*float*/ spacerSize, /*float*/ spacerSeparation, /*float*/ containerSize, /*int*/ itemsInSpacer, /*int*/ visibleItemCapacity, /*int*/ unusedItemCapacity)
    {
        if (_lastRenderedItemCount > 0)
        {
            _itemSize = spacerSeparation - _lastRenderedPlaceholderCount * _itemSize / _lastRenderedItemCount;
        }
        if (_itemSize <= 0)
        {
            // At this point, something unusual has occurred, likely due to misuse of this component.
                // Reset the calculated item size to the user-provided item size.
                _itemSize = ItemSize;
        }
        /*// This AppContext data was added as a stopgap for .NET 8 and earlier, since it was added in a patch
            // where we couldn't add new public API. For backcompat we still support the AppContext setting, but
            // new applications should use the much more convenient MaxItemCount parameter.
            var*/ let maxItemCount = MaxItemCount;
        itemsInSpacer = Math.Max(0, Math.Floor(spacerSize / _itemSize) - OverscanCount);
        visibleItemCapacity = Math.Ceiling(containerSize / _itemSize) + 2 * OverscanCount;
        unusedItemCapacity = Math.Max(0, visibleItemCapacity - maxItemCount);
        visibleItemCapacity -= unusedItemCapacity;
    }
    /*void*/ UpdateItemDistribution(/*int*/ itemsBefore, /*int*/ visibleItemCapacity, /*int*/ unusedItemCapacity)
    {
        if (itemsBefore + visibleItemCapacity > _itemCount)
        {
            itemsBefore = Math.Max(0, _itemCount - visibleItemCapacity);
        }
        if (itemsBefore != _itemsBefore || visibleItemCapacity != _visibleItemCapacity || unusedItemCapacity != _unusedItemCapacity)
        {
            _itemsBefore = itemsBefore;
            _visibleItemCapacity = visibleItemCapacity;
            _unusedItemCapacity = unusedItemCapacity;
            /*var*/ let refreshTask = RefreshDataCoreAsync({ renderOnSuccess : true });
            if (refreshTask.IsCompleted)
            {
                StateHasChanged();
            }
        }
    }
    /*Task*/ async RefreshDataCoreAsync(/*bool*/ renderOnSuccess)
    {
        _refreshCtsCancel();
        /*CancellationToken*/ let cancellationToken;
        if (_itemsProvider == DefaultItemsProvider)
        {
            // If we're using the DefaultItemsProvider (because the developer supplied a fixed
                // Items collection) we know it will complete synchronously, and there's no point
                // instantiating a new CancellationTokenSource
                _refreshCts = null;
            cancellationToken = CancellationToken.None;
        }
        else 
        {
            _refreshCts = new CancellationTokenSource();
            cancellationToken = _refreshCts.Token;
            _loading = true;
        }
        /*var*/ let request = new ItemsProviderRequest(_itemsBefore, _visibleItemCapacity, cancellationToken);
        {
            /*var*/ let result = await _itemsProvider(request);
            if (cancellationToken.IsCancellationRequested)
            {
                _itemCount = result.TotalItemCount;
                _loadedItems = result.Items;
                _loadedItemsStartIndex = request.StartIndex;
                _loading = false;
                if (renderOnSuccess)
                {
                    StateHasChanged();
                }
            }
        }
Exception        {
            if (e instanceof OperationCanceledException, oce = e && oce.CancellationToken.Equals(cancellationToken))
            {
            }
            else 
            {
                // Cache this exception so the renderer can throw it.
                    _refreshException = e;
                // Re-render the component to throw the exception.
                    StateHasChanged();
            }
        }
    }
    /*Task<ItemsProviderResult<TItem>>*/ DefaultItemsProvider(/*ItemsProviderRequest*/ request)
    {
        return Task.FromResult(new ItemsProviderResult_$1(TItem, Items.Skip(request.StartIndex).Take(request.Count), Items.Count));
    }
    /*RenderFragment*/ DefaultPlaceholder(/*PlaceholderContext*/ context)
    {
        function(/**/ builder, /**/ key)
        {
            builder.Element("div", function(/*UIElementAttribute*/ attribute)
            {
                attribute.Set("style", _itemSize.ToString(CultureInfo.InvariantCulture));
            }, { sequenceNumber : Utility.Virtualize_DefaultPlaceholder_SequenceNumber });
        };
    }
    /*void*/ Dispose()
    {
        _refreshCtsCancel();
        super.Dispose();
    }
}

const Microsoft_AspNetCore_Components_Web_Virtualization_Virtualize$_1 = (TItem) => class extends Microsoft_AspNetCore_Components_Web_Virtualization_IVirtualizeJsCallbacks(Microsoft_AspNetCore_Components_ComponentBase)
{
    constructor()
    {
        super();
        TItem = $_TItem;
    }
}

class Microsoft_AspNetCore_Components_Web_Virtualization_VirtualizeJs extends object
{
    constructor()
    {
        super();
    }
    /*HTMLElement*/ FindClosestScrollContainer(/*HTMLElement*/ element)
    {
        if (element == null || element == document.body  || element == document.documentElement)
        {
            return null;
        }
        /*var*/ let style = getComputedStyle(element);
        if (style.overflowY  != "visible")
        {
            return element;
        }
        return FindClosestScrollContainer(element.parentElement);
    }
    /*void*/ InitializeAsync(/*IVirtualizeJsCallbacks*/ virtualize, /*HTMLElement*/ spacerBefore, /*HTMLElement*/ spacerAfter, { /*int*/ rootMargin = 50})
    {
        /*// Overflow anchoring can cause an ongoing scroll loop, because when we resize the spacers, the browser
            // would update the scroll position to compensate. Then the spacer would remain visible and we'd keep on
            // trying to resize it.
            var*/ let scrollContainer = FindClosestScrollContainer(spacerBefore);
        scrollContainer ?? document.documentElement.style"overflowAnchor" = "none";
        /*var*/ let rangeBetweenSpacers = document.createRange();
        if (isValidTableElement(spacerAfter.parentElement))
        {
            spacerBefore.style.display  = "table-row";
            spacerAfter.style.display  = "table-row";
        }
        /*var*/ let intersectionObserver = new IntersectionObserver(IntersectionCallback, new IntersectionObserverInit()root = scrollContainerrootMargin = rootMargin);
        intersectionObserver.observe(spacerBefore);
        intersectionObserver.observe(spacerAfter);
        /*var*/ let mutationObserverBefore = CreateSpacerMutationObserver(spacerBefore);
        /*var*/ let mutationObserverAfter = CreateSpacerMutationObserver(spacerAfter);
//          const {
            //              observersByDotNetObjectId, id
            //          } = getObserversMapEntry(dotNetHelper);
            //          observersByDotNetObjectId[id] = {
            //              intersectionObserver,
            //  mutationObserverBefore,
            //  mutationObserverAfter,
            //};
            MutationObserverHTMLElement        {
            /*// Without the use of thresholds, IntersectionObserver only detects binary changes in visibility,
                // so if a spacer gets resized but remains visible, no additional callbacks will occur. By unobserving
                // and reobserving spacers when they get resized, the intersection callback will re-run if they remain visible.
                var*/ let observerOptions = new MutationObserverInit()attributes = true;
            /*var*/ let mutationObserver = new MutationObserver(function(/**/ mutations, /**/ observer)
            {
                if (isValidTableElement(spacer.parentElement))
                {
                    observer.disconnect();
                    spacer.style.display  = "table-row";
                    observer.observe(spacer, observerOptions);
                }
                intersectionObserver.unobserve(spacer);
                intersectionObserver.observe(spacer);
            });
            mutationObserver.observe(spacer, observerOptions);
            return mutationObserver;
        }
IntersectionObserverEntryIntersectionObserver        {
            entries.ForEach(function(/**/ entry)
            {
                if (entry.isIntersecting)
                {
                    return ;
                }
                // To compute the ItemSize, work out the separation between the two spacers. We can't just measure an individual element
                    // because each conceptual item could be made from multiple elements. Using getBoundingClientRect allows for the size to be
                    // a fractional value. It's important not to add or subtract any such fractional values (e.g., to subtract the 'top' of
                    // one item from the 'bottom' of another to get the distance between them) because floating point errors would cause
                    // scrolling glitches.
                    rangeBetweenSpacers.setStartAfter(spacerBefore);
                rangeBetweenSpacers.setEndBefore(spacerAfter);
                /*var*/ let spacerSeparation = rangeBetweenSpacers.getBoundingClientRect().As(ClientRect).height;
                /*var*/ let containerSize = entry.rootBounds.As(ClientRect)height;
                if (entry.target  == spacerBefore)
                {
                    virtualize.OnBeforeSpacerVisible(entry.intersectionRect.As(ClientRect).top  - entry.boundingClientRect.As(ClientRect).top, spacerSeparation, containerSize);
                }
                else if (entry.target  == spacerAfter && spacerAfter.offsetHeight  > 0)
                {
                    // When we first start up, both the "before" and "after" spacers will be visible, but it's only relevant to raise a
                        // single event to load the initial data. To avoid raising two events, skip the one for the "after" spacer if we know
                        // it's meaningless to talk about any overlap into it.
                       virtualize.OnAfterSpacerVisible(entry.boundingClientRect.As(ClientRect).bottom  - entry.intersectionRect.As(ClientRect).bottom, spacerSeparation, containerSize);
                }
            });
        }
HTMLElement        {
            if (element == null)
            {
                return false;
            }
            return H5.Script.InstanceOf(element, HTMLTableElement) && element.style.display  == "" || element.style.display  == "table" || H5.Script.InstanceOf(element, HTMLTableSectionElement) && element.style.display  == "" || element.style.display  == "table-row-group";
        }
    }
}





















class Microsoft_Extensions_Configuration_ConfigurationExtension extends object
{
    constructor()
    {
        super();
    }
    /*void*/ AddJsonStream(/*IConfigurationBuilder*/ configuration, /*Stream*/ stream)
    {
        throw new NotImplementedException();
    }
    /*bool*/ Exists(/*IConfiguration*/ configuration)
    {
        throw new NotImplementedException();
    }
    /*T*/ Get(T, /*IConfiguration*/ configuration)
    {
        throw new NotImplementedException();
    }
}

const Microsoft_Extensions_Configuration_IConfiguration = (Base) => class extends Base
{
}

const Microsoft_Extensions_Configuration_IConfigurationBuilder = (Base) => class extends Base
{
    /*IDictionary<string, object>*/ _backingField_Properties = null;
    /*IDictionary<string, object>*/ get Properties()
    {
        return _backingField_Properties;
    }
    /*IList<IConfigurationSource>*/ _backingField_Sources = null;
    /*IList<IConfigurationSource>*/ get Sources()
    {
        return _backingField_Sources;
    }
}

const Microsoft_Extensions_Configuration_IConfigurationSection = (Base) => class extends Base
{
    /*//
        // Summary:
        //     Gets the key this section occupies in its parent.
        string*/ _backingField_Key = null;
    /*//
        // Summary:
        //     Gets the key this section occupies in its parent.
        string*/ get Key()
    {
        return _backingField_Key;
    }
    /*//
        // Summary:
        //     Gets the full path to this section within the Microsoft.Extensions.Configuration.IConfiguration.
        string*/ _backingField_Path = null;
    /*//
        // Summary:
        //     Gets the full path to this section within the Microsoft.Extensions.Configuration.IConfiguration.
        string*/ get Path()
    {
        return _backingField_Path;
    }
    /*//
        // Summary:
        //     Gets or sets the section value.
        string*/ _backingField_Value = null;
    /*//
        // Summary:
        //     Gets or sets the section value.
        string*/ get Value()
    {
        return _backingField_Value;
    }
    /*//
        // Summary:
        //     Gets or sets the section value.
        string*/ set Value(value)
    {
        _backingField_Value = value;
    }
}

const Microsoft_Extensions_DependencyInjection_IServiceCollection = (Base) => class extends Base
{
}

class Microsoft_Extensions_DependencyInjection_ServiceCollectionServiceExtensions extends object
{
    constructor()
    {
        super();
    }
    /*IServiceCollection*/ AddTransient(/*IServiceCollection*/ services, /*Type*/ serviceType, /*Type*/ implementationType)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(implementationType, "implementationType");
        return Add(services, serviceType, implementationType, ServiceLifetime.Transient);
    }
    /*IServiceCollection*/ AddTransient(/*IServiceCollection*/ services, /*Type*/ serviceType, /*Func<IServiceProvider, object>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return Add(services, serviceType, implementationFactory, ServiceLifetime.Transient);
    }
    /*IServiceCollection*/ AddTransient(TService, TImplementation, /*IServiceCollection*/ services)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        return services.AddTransient(TService, TImplementation);
    }
    /*IServiceCollection*/ AddTransient(/*IServiceCollection*/ services, /*Type*/ serviceType)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        return services.AddTransient(serviceType, serviceType);
    }
    /*IServiceCollection*/ AddTransient(TService, /*IServiceCollection*/ services)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        return services.AddTransient(TService);
    }
    /*IServiceCollection*/ AddTransient(TService, /*IServiceCollection*/ services, /*Func<IServiceProvider, TService>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return services.AddTransient(TService, function(/**/ sp)
        {
            return implementationFactory(sp);
        });
    }
    /*IServiceCollection*/ AddTransient(TService, TImplementation, /*IServiceCollection*/ services, /*Func<IServiceProvider, TImplementation>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return services.AddTransient(TService, function(/**/ sp)
        {
            return implementationFactory(sp);
        });
    }
    /*IServiceCollection*/ AddScoped(/*IServiceCollection*/ services, /*Type*/ serviceType, /*Type*/ implementationType)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(implementationType, "implementationType");
        return Add(services, serviceType, implementationType, ServiceLifetime.Scoped);
    }
    /*IServiceCollection*/ AddScoped(/*IServiceCollection*/ services, /*Type*/ serviceType, /*Func<IServiceProvider, object>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return Add(services, serviceType, implementationFactory, ServiceLifetime.Scoped);
    }
    /*IServiceCollection*/ AddScoped(TService, TImplementation, /*IServiceCollection*/ services)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        return services.AddScoped(TService, TImplementation);
    }
    /*IServiceCollection*/ AddScoped(/*IServiceCollection*/ services, /*Type*/ serviceType)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        return services.AddScoped(serviceType, serviceType);
    }
    /*IServiceCollection*/ AddScoped(TService, /*IServiceCollection*/ services)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        return services.AddScoped(TService);
    }
    /*IServiceCollection*/ AddScoped(TService, /*IServiceCollection*/ services, /*Func<IServiceProvider, TService>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return services.AddScoped(TService, function(/**/ sp)
        {
            return implementationFactory(sp);
        });
    }
    /*IServiceCollection*/ AddScoped(TService, TImplementation, /*IServiceCollection*/ services, /*Func<IServiceProvider, TImplementation>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return services.AddScoped(TService, function(/**/ sp)
        {
            return implementationFactory(sp);
        });
    }
    /*IServiceCollection*/ AddSingleton(/*IServiceCollection*/ services, /*Type*/ serviceType, /*Type*/ implementationType)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(implementationType, "implementationType");
        return Add(services, serviceType, implementationType, ServiceLifetime.Singleton);
    }
    /*IServiceCollection*/ AddSingleton(/*IServiceCollection*/ services, /*Type*/ serviceType, /*Func<IServiceProvider, object>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return Add(services, serviceType, implementationFactory, ServiceLifetime.Singleton);
    }
    /*IServiceCollection*/ AddSingleton(TService, TImplementation, /*IServiceCollection*/ services)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        return services.AddSingleton(TService, TImplementation);
    }
    /*IServiceCollection*/ AddSingleton(/*IServiceCollection*/ services, /*Type*/ serviceType)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        return services.AddSingleton(serviceType, serviceType);
    }
    /*IServiceCollection*/ AddSingleton(TService, /*IServiceCollection*/ services)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        return services.AddSingleton(TService);
    }
    /*IServiceCollection*/ AddSingleton(TService, /*IServiceCollection*/ services, /*Func<IServiceProvider, TService>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return services.AddSingleton(TService, implementationFactory);
    }
    /*IServiceCollection*/ AddSingleton(TService, TImplementation, /*IServiceCollection*/ services, /*Func<IServiceProvider, TImplementation>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return services.AddSingleton(TService, implementationFactory);
    }
    /*IServiceCollection*/ AddSingleton(/*IServiceCollection*/ services, /*Type*/ serviceType, /*object*/ implementationInstance)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(implementationInstance, "implementationInstance");
        /*ServiceDescriptor*/ let item = new ServiceDescriptor(serviceType, implementationInstance);
        services.Add(item);
        return services;
    }
    /*IServiceCollection*/ AddSingleton(TService, /*IServiceCollection*/ services, /*TService*/ implementationInstance)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(implementationInstance, "implementationInstance");
        return services.AddSingleton(TService, implementationInstance);
    }
    /*IServiceCollection*/ Add(/*IServiceCollection*/ collection, /*Type*/ serviceType, /*Type*/ implementationType, /*ServiceLifetime*/ lifetime)
    {
        /*ServiceDescriptor*/ let item = new ServiceDescriptor(serviceType, implementationType, lifetime);
        collection.Add(item);
        return collection;
    }
    /*IServiceCollection*/ Add(/*IServiceCollection*/ collection, /*Type*/ serviceType, /*Func<IServiceProvider, object>*/ implementationFactory, /*ServiceLifetime*/ lifetime)
    {
        /*ServiceDescriptor*/ let item = new ServiceDescriptor(serviceType, implementationFactory, lifetime);
        collection.Add(item);
        return collection;
    }
    /*IServiceCollection*/ AddKeyedTransient(/*IServiceCollection*/ services, /*Type*/ serviceType, /*object*/ serviceKey, /*Type*/ implementationType)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(implementationType, "implementationType");
        return AddKeyed(services, serviceType, serviceKey, implementationType, ServiceLifetime.Transient);
    }
    /*IServiceCollection*/ AddKeyedTransient(/*IServiceCollection*/ services, /*Type*/ serviceType, /*object*/ serviceKey, /*Func<IServiceProvider, object, object>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return AddKeyed(services, serviceType, serviceKey, implementationFactory, ServiceLifetime.Transient);
    }
    /*IServiceCollection*/ AddKeyedTransient(TService, TImplementation, /*IServiceCollection*/ services, /*object*/ serviceKey)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        return services.AddKeyedTransient(TService, serviceKey, TImplementation);
    }
    /*IServiceCollection*/ AddKeyedTransient(/*IServiceCollection*/ services, /*Type*/ serviceType, /*object*/ serviceKey)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        return services.AddKeyedTransient(serviceType, serviceKey, serviceType);
    }
    /*IServiceCollection*/ AddKeyedTransient(TService, /*IServiceCollection*/ services, /*object*/ serviceKey)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        return services.AddKeyedTransient(TService, serviceKey);
    }
    /*IServiceCollection*/ AddKeyedTransient(TService, /*IServiceCollection*/ services, /*object*/ serviceKey, /*Func<IServiceProvider, object, TService>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return services.AddKeyedTransient(TService, serviceKey, function(/**/ sp, /**/ key)
        {
            return implementationFactory(sp, key);
        });
    }
    /*IServiceCollection*/ AddKeyedTransient(TService, TImplementation, /*IServiceCollection*/ services, /*object*/ serviceKey, /*Func<IServiceProvider, object, TImplementation>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return services.AddKeyedTransient(TService, serviceKey, function(/**/ sp, /**/ key)
        {
            return implementationFactory(sp, key);
        });
    }
    /*IServiceCollection*/ AddKeyedScoped(/*IServiceCollection*/ services, /*Type*/ serviceType, /*object*/ serviceKey, /*Type*/ implementationType)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(implementationType, "implementationType");
        return AddKeyed(services, serviceType, serviceKey, implementationType, ServiceLifetime.Scoped);
    }
    /*IServiceCollection*/ AddKeyedScoped(/*IServiceCollection*/ services, /*Type*/ serviceType, /*object*/ serviceKey, /*Func<IServiceProvider, object, object>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return AddKeyed(services, serviceType, serviceKey, implementationFactory, ServiceLifetime.Scoped);
    }
    /*IServiceCollection*/ AddKeyedScoped(TService, TImplementation, /*IServiceCollection*/ services, /*object*/ serviceKey)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        return services.AddKeyedScoped(TService, serviceKey, TImplementation);
    }
    /*IServiceCollection*/ AddKeyedScoped(/*IServiceCollection*/ services, /*Type*/ serviceType, /*object*/ serviceKey)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        return services.AddKeyedScoped(serviceType, serviceKey, serviceType);
    }
    /*IServiceCollection*/ AddKeyedScoped(TService, /*IServiceCollection*/ services, /*object*/ serviceKey)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        return services.AddKeyedScoped(TService, serviceKey);
    }
    /*IServiceCollection*/ AddKeyedScoped(TService, /*IServiceCollection*/ services, /*object*/ serviceKey, /*Func<IServiceProvider, object, TService>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return services.AddKeyedScoped(TService, serviceKey, function(/**/ sp, /**/ key)
        {
            return implementationFactory(sp, key);
        });
    }
    /*IServiceCollection*/ AddKeyedScoped(TService, TImplementation, /*IServiceCollection*/ services, /*object*/ serviceKey, /*Func<IServiceProvider, object, TImplementation>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return services.AddKeyedScoped(TService, serviceKey, function(/**/ sp, /**/ key)
        {
            return implementationFactory(sp, key);
        });
    }
    /*IServiceCollection*/ AddKeyedSingleton(/*IServiceCollection*/ services, /*Type*/ serviceType, /*object*/ serviceKey, /*Type*/ implementationType)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(implementationType, "implementationType");
        return AddKeyed(services, serviceType, serviceKey, implementationType, ServiceLifetime.Singleton);
    }
    /*IServiceCollection*/ AddKeyedSingleton(/*IServiceCollection*/ services, /*Type*/ serviceType, /*object*/ serviceKey, /*Func<IServiceProvider, object, object>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return AddKeyed(services, serviceType, serviceKey, implementationFactory, ServiceLifetime.Singleton);
    }
    /*IServiceCollection*/ AddKeyedSingleton(TService, TImplementation, /*IServiceCollection*/ services, /*object*/ serviceKey)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        return services.AddKeyedSingleton(TService, serviceKey, TImplementation);
    }
    /*IServiceCollection*/ AddKeyedSingleton(/*IServiceCollection*/ services, /*Type*/ serviceType, /*object*/ serviceKey)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        return services.AddKeyedSingleton(serviceType, serviceKey, serviceType);
    }
    /*IServiceCollection*/ AddKeyedSingleton(TService, /*IServiceCollection*/ services, /*object*/ serviceKey)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        return services.AddKeyedSingleton(TService, serviceKey, TService);
    }
    /*IServiceCollection*/ AddKeyedSingleton(TService, /*IServiceCollection*/ services, /*object*/ serviceKey, /*Func<IServiceProvider, object, TService>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return services.AddKeyedSingleton(TService, serviceKey, implementationFactory);
    }
    /*IServiceCollection*/ AddKeyedSingleton(TService, TImplementation, /*IServiceCollection*/ services, /*object*/ serviceKey, /*Func<IServiceProvider, object, TImplementation>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return services.AddKeyedSingleton(TService, serviceKey, implementationFactory);
    }
    /*IServiceCollection*/ AddKeyedSingleton(/*IServiceCollection*/ services, /*Type*/ serviceType, /*object*/ serviceKey, /*object*/ implementationInstance)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(implementationInstance, "implementationInstance");
        /*ServiceDescriptor*/ let item = new ServiceDescriptor(serviceType, serviceKey, implementationInstance);
        services.Add(item);
        return services;
    }
    /*IServiceCollection*/ AddKeyedSingleton(TService, /*IServiceCollection*/ services, /*object*/ serviceKey, /*TService*/ implementationInstance)
    {
        ThrowHelperExtension.ThrowIfNull(services, "services");
        ThrowHelperExtension.ThrowIfNull(implementationInstance, "implementationInstance");
        return services.AddKeyedSingleton(TService, serviceKey, implementationInstance);
    }
    /*IServiceCollection*/ AddKeyed(/*IServiceCollection*/ collection, /*Type*/ serviceType, /*object*/ serviceKey, /*Type*/ implementationType, /*ServiceLifetime*/ lifetime)
    {
        /*ServiceDescriptor*/ let item = new ServiceDescriptor(serviceType, serviceKey, implementationType, lifetime);
        collection.Add(item);
        return collection;
    }
    /*IServiceCollection*/ AddKeyed(/*IServiceCollection*/ collection, /*Type*/ serviceType, /*object*/ serviceKey, /*Func<IServiceProvider, object, object>*/ implementationFactory, /*ServiceLifetime*/ lifetime)
    {
        /*ServiceDescriptor*/ let item = new ServiceDescriptor(serviceType, serviceKey, implementationFactory, lifetime);
        collection.Add(item);
        return collection;
    }
}

class Microsoft_JSInterop_DotNetObjectReference extends object
{
    constructor()
    {
        super();
    }
    /*DotNetObjectReference<TValue>*/ Create(TValue, /*TValue*/ value)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(value);
        return new DotNetObjectReference_$1(TValue, value);
    }
}

const Microsoft_JSInterop_DotNetObjectReference$_1 = (TValue) => class extends System_IDisposable(Microsoft_JSInterop_Infrastructure_IDotNetObjectReference(object))
{
TValue    /*TValue*/ _value = null;
    /*long*/ _objectId = null;
    /*JSRuntime*/ _jsRuntime = null;
    constructor(/*TValue*/ value)
    {
        super();
        _value = value;
    }
    /*TValue*/ get Value()
    {
        ThrowIfDisposed();
        return _value;
    }
    /*long*/ get ObjectId()
    {
        ThrowIfDisposed();
        Debug.Assert(_objectId != 0, "Accessing ObjectId without tracking is always incorrect.");
        return _objectId;
    }
    /*long*/ set ObjectId(value)
    {
        ThrowIfDisposed();
        _objectId = value;
    }
    /*JSRuntime*/ get JSRuntime()
    {
        ThrowIfDisposed();
        return _jsRuntime;
    }
    /*JSRuntime*/ set JSRuntime(value)
    {
        ThrowIfDisposed();
        _jsRuntime = value;
    }
    /*object*/ get Value()
    {
        return Value;
    }
    /*bool*/ _backingField_Disposed = null;
    /*bool*/ get Disposed()
    {
        return _backingField_Disposed;
    }
    /*bool*/ set Disposed(value)
    {
        _backingField_Disposed = value;
    }
    /*void*/ Dispose()
    {
        if (Disposed)
        {
            Disposed = true;
            _jsRuntimeReleaseObjectReference(_objectId);
        }
    }
    /*void*/ ThrowIfDisposed()
    {
        if (Disposed)
        throw new ObjectDisposedException("disposed");
    }
}

class Microsoft_JSInterop_DotNetStreamReference extends System_IDisposable(object)
{
    constructor(/*Stream*/ stream, /*bool*/ leaveOpen)
    {
        super();
        Stream = stream ??         throw new ArgumentNullException(nameof(stream));
;
        LeaveOpen = leaveOpen;
    }
    /*Stream*/ _backingField_Stream = null;
    /*Stream*/ get Stream()
    {
        return _backingField_Stream;
    }
    /*bool*/ _backingField_LeaveOpen = null;
    /*bool*/ get LeaveOpen()
    {
        return _backingField_LeaveOpen;
    }
    /*void*/ Dispose()
    {
        if (LeaveOpen)
        {
            Stream.Dispose();
        }
    }
}

const Microsoft_JSInterop_IJSInProcessObjectReference = (Base) => class extends Base
{
}

const Microsoft_JSInterop_IJSInProcessRuntime = (Base) => class extends Base
{
}

const Microsoft_JSInterop_IJSObjectReference = (Base) => class extends Base
{
}

const Microsoft_JSInterop_IJSRuntime = (Base) => class extends Base
{
}

const Microsoft_JSInterop_IJSStreamReference = (Base) => class extends Base
{
    /*/// <summary>
        /// Length of the <see cref="Stream"/> provided by JavaScript.
        /// </summary>
        long*/ _backingField_Length = null;
    /*/// <summary>
        /// Length of the <see cref="Stream"/> provided by JavaScript.
        /// </summary>
        long*/ get Length()
    {
        return _backingField_Length;
    }
}

 = 0 = 1 = 2 = 3
class Microsoft_JSInterop_JSCallResultTypeHelper extends object
{
    constructor()
    {
        super();
    }
    /*Assembly*/ _currentAssembly = JSCallResultType.Assembly;
    /*JSCallResultType*/ FromGeneric(TResult)
    {
        if (TResult.Assembly  == _currentAssembly)
        {
            if (TResult == IJSObjectReference || TResult == IJSInProcessObjectReference)
            {
                return JSCallResultType.JSObjectReference;
            }
            else if (TResult == IJSStreamReference)
            {
                return JSCallResultType.JSStreamReference;
            }
            else if (TResult == IJSVoidResult)
            {
                return JSCallResultType.JSVoidResult;
            }
        }
        return JSCallResultType.Default;
    }
}

class Microsoft_JSInterop_JSDisconnectedException extends System_Exception
{
    constructor(/*string*/ message)
    {
        super(message);
    }
}

class Microsoft_JSInterop_JSException extends System_Exception
{
    constructor(/*string*/ message)
    {
        super(message);
    }
    constructor(/*string*/ message, /*Exception*/ innerException)
    {
        super(message, innerException);
    }
}

class Microsoft_JSInterop_JSInProcessObjectReferenceExtensions extends object
{
    constructor()
    {
        super();
    }
    /*void*/ InvokeVoid(/*IJSInProcessObjectReference*/ jsObjectReference, /*string*/ identifier, /*object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsObjectReference);
        jsObjectReference.Invoke(IJSVoidResult, identifier, args);
    }
}

class Microsoft_JSInterop_JSInProcessRuntime extends Microsoft_JSInterop_IJSRuntime(Microsoft_JSInterop_IJSInProcessRuntime(Microsoft_JSInterop_JSRuntime))
{
    constructor()
    {
        super();
    }
    /*long*/ SyncCallIndicator = 0;
    /*TValue*/ Invoke(TValue, /*string*/ identifier, /*object[]*/ args)
    {
        Invoke_$1(TValue, identifier, WindowObjectId, JSCallType.FunctionCall, args);
    }
    /*IJSInProcessObjectReference*/ InvokeNew(/*string*/ identifier, /*object[]*/ args)
    {
        Invoke_$1(IJSInProcessObjectReference, identifier, WindowObjectId, JSCallType.NewCall, args);
    }
    /*TValue*/ GetValue(TValue, /*string*/ identifier)
    {
        Invoke_$1(TValue, identifier, WindowObjectId, JSCallType.GetValue);
    }
    /*void*/ SetValue(TValue, /*string*/ identifier, /*TValue*/ value)
    {
        Invoke_$1(IJSVoidResult, identifier, WindowObjectId, JSCallType.SetValue, value);
    }
    /*TValue*/ Invoke(TValue, /*string*/ identifier, /*long*/ targetInstanceId, /*JSCallType*/ callType, /*object[]*/ args)
    {
        /*var*/ let argsJson = args != null && args.Length  != 0JsonSerializer.Serialize(args, JsonSerializerOptions)"[]";
        /*var*/ let resultType = JSCallResultTypeHelper.FromGeneric(TValue);
        /*var*/ let invocationInfo = new JSInvocationInfo()AsyncHandle = SyncCallIndicatorTargetInstanceId = targetInstanceIdIdentifier = identifierCallType = callTypeResultType = resultTypeArgsJson = argsJson;
        /*var*/ let resultJson = InvokeJS(invocationInfo);
        if (resultJson == null)
        {
            return default;
        }
        /*var*/ let result = JsonSerializer.Deserialize(TValue, resultJson, JsonSerializerOptions);
        ByteArraysToBeRevived.Clear();
        return result;
    }
    /*string*/ InvokeJS(/*string*/ identifier, /*string*/ argsJson)
    {
        InvokeJS(identifier, argsJson, JSCallResultType.Default, WindowObjectId);
    }
}

class Microsoft_JSInterop_JSInProcessRuntimeExtensions extends object
{
    constructor()
    {
        super();
    }
    /*void*/ InvokeVoid(/*IJSInProcessRuntime*/ jsRuntime, /*string*/ identifier, /*object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsRuntime);
        jsRuntime.Invoke(IJSVoidResult, identifier, args);
    }
}

class Microsoft_JSInterop_JSInvokableAttribute extends System_Attribute
{
    /*string*/ _backingField_Identifier = null;
    /*string*/ get Identifier()
    {
        return _backingField_Identifier;
    }
    constructor()
    {
        super();
    }
    constructor(/*string*/ identifier)
    {
        super();
        ArgumentExceptionExtension.ThrowIfNullOrEmpty(identifier);
        Identifier = identifier;
    }
}

class Microsoft_JSInterop_JSObjectReferenceExtensions extends object
{
    constructor()
    {
        super();
    }
    /*Task*/ async InvokeVoidAsync(/*IJSObjectReference*/ jsObjectReference, /*string*/ identifier, /*object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsObjectReference);
        await jsObjectReference.InvokeAsync(IJSVoidResult, identifier, args);
    }
    /*Task<TValue>*/ InvokeAsync(TValue, /*IJSObjectReference*/ jsObjectReference, /*string*/ identifier, /*object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsObjectReference);
        return jsObjectReference.InvokeAsync(TValue, identifier, args);
    }
    /*Task<TValue>*/ InvokeAsync(TValue, /*IJSObjectReference*/ jsObjectReference, /*string*/ identifier, /*CancellationToken*/ cancellationToken, /*object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsObjectReference);
        return jsObjectReference.InvokeAsync(TValue, identifier, cancellationToken, args);
    }
    /*Task*/ async InvokeVoidAsync(/*IJSObjectReference*/ jsObjectReference, /*string*/ identifier, /*CancellationToken*/ cancellationToken, /*object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsObjectReference);
        await jsObjectReference.InvokeAsync(IJSVoidResult, identifier, cancellationToken, args);
    }
    /*Task<TValue>*/ async InvokeAsync(TValue, /*IJSObjectReference*/ jsObjectReference, /*string*/ identifier, /*TimeSpan*/ timeout, /*object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsObjectReference);
        /*var*/ let cancellationTokenSource = timeout == TimeSpan.MaxValue nullnew CancellationTokenSource(timeout);
        /*var*/ let cancellationToken = cancellationTokenSourceToken ?? CancellationToken.None;
        {
            return await jsObjectReference.InvokeAsync(TValue, identifier, cancellationToken, args);
        }
        {
            cancellationTokenSourceDispose();
        }
    }
    /*Task*/ async InvokeVoidAsync(/*IJSObjectReference*/ jsObjectReference, /*string*/ identifier, /*TimeSpan*/ timeout, /*object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsObjectReference);
        /*var*/ let cancellationTokenSource = timeout == TimeSpan.MaxValue nullnew CancellationTokenSource(timeout);
        /*var*/ let cancellationToken = cancellationTokenSourceToken ?? CancellationToken.None;
        {
            await jsObjectReference.InvokeAsync(IJSVoidResult, identifier, cancellationToken, args);
        }
        {
            cancellationTokenSourceDispose();
        }
    }
    /*Task<IJSObjectReference>*/ InvokeNewAsync(/*IJSObjectReference*/ jsObjectReference, /*string*/ identifier, /*object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsObjectReference);
        return jsObjectReference.InvokeNewAsync(identifier, args);
    }
    /*Task<IJSObjectReference>*/ InvokeNewAsync(/*IJSObjectReference*/ jsObjectReference, /*string*/ identifier, /*CancellationToken*/ cancellationToken, /*object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsObjectReference);
        return jsObjectReference.InvokeNewAsync(identifier, cancellationToken, args);
    }
    /*Task<IJSObjectReference>*/ InvokeNewAsync(/*IJSObjectReference*/ jsObjectReference, /*string*/ identifier, /*TimeSpan*/ timeout, /*object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsObjectReference);
        /*var*/ let cancellationTokenSource = timeout == TimeSpan.MaxValue nullnew CancellationTokenSource(timeout);
        /*var*/ let cancellationToken = cancellationTokenSourceToken ?? CancellationToken.None;
        {
            return jsObjectReference.InvokeNewAsync(identifier, cancellationToken, args);
        }
        {
            cancellationTokenSourceDispose();
        }
    }
}

class Microsoft_JSInterop_JSRuntime extends System_IDisposable(Microsoft_JSInterop_IJSRuntime(object))
{
    /*long*/ WindowObjectId = 0;
    /*long*/ _nextObjectReferenceId = null;
    /*long*/ _nextPendingTaskId = 1;
    /*ConcurrentDictionary<long, object>*/ _pendingTasks = new ConcurrentDictionary_$2(long, object);
    /*ConcurrentDictionary<long, IDotNetObjectReference>*/ _trackedRefsById = new ConcurrentDictionary_$2(long, IDotNetObjectReference);
    /*ConcurrentDictionary<long, CancellationTokenRegistration>*/ _cancellationRegistrations = new ConcurrentDictionary_$2(long, CancellationTokenRegistration);
    /*List<byte[]>*/ ByteArraysToBeRevived = new List_$1(byte[]);
    constructor()
    {
        super();
        JsonSerializerOptions = new JsonSerializerOptions();
    }
    /*JsonSerializerOptions*/ _backingField_JsonSerializerOptions = null;
    /*JsonSerializerOptions*/ get JsonSerializerOptions()
    {
        return _backingField_JsonSerializerOptions;
    }
    /*TimeSpan?*/ _backingField_DefaultAsyncTimeout = null;
    /*TimeSpan?*/ get DefaultAsyncTimeout()
    {
        return _backingField_DefaultAsyncTimeout;
    }
    /*TimeSpan?*/ set DefaultAsyncTimeout(value)
    {
        _backingField_DefaultAsyncTimeout = value;
    }
    /*Task<TValue>*/ InvokeAsync(TValue, /*string*/ identifier, /*object[]*/ args)
    {
        InvokeAsync_$1(TValue, WindowObjectId, identifier, JSCallType.FunctionCall, args);
    }
    /*Task<TValue>*/ InvokeAsync(TValue, /*string*/ identifier, /*CancellationToken*/ cancellationToken, /*object[]*/ args)
    {
        InvokeAsync_$1(TValue, WindowObjectId, identifier, JSCallType.FunctionCall, cancellationToken, args);
    }
    /*Task<IJSObjectReference>*/ InvokeNewAsync(/*string*/ identifier, /*object[]*/ args)
    {
        InvokeAsync_$1(IJSObjectReference, WindowObjectId, identifier, JSCallType.NewCall, args);
    }
    /*Task<IJSObjectReference>*/ InvokeNewAsync(/*string*/ identifier, /*CancellationToken*/ cancellationToken, /*object[]*/ args)
    {
        InvokeAsync_$1(IJSObjectReference, WindowObjectId, identifier, JSCallType.NewCall, cancellationToken, args);
    }
    /*Task<TValue>*/ GetValueAsync(TValue, /*string*/ identifier)
    {
        InvokeAsync_$1(TValue, WindowObjectId, identifier, JSCallType.GetValue, null);
    }
    /*Task<TValue>*/ GetValueAsync(TValue, /*string*/ identifier, /*CancellationToken*/ cancellationToken)
    {
        InvokeAsync_$1(TValue, WindowObjectId, identifier, JSCallType.GetValue, cancellationToken, null);
    }
    /*Task*/ async SetValueAsync(TValue, /*string*/ identifier, /*TValue*/ value)
    {
        await InvokeAsync_$1(IJSVoidResult, WindowObjectId, identifier, JSCallType.SetValue, [ value ]);
    }
    /*Task*/ async SetValueAsync(TValue, /*string*/ identifier, /*TValue*/ value, /*CancellationToken*/ cancellationToken)
    {
        await InvokeAsync_$1(IJSVoidResult, WindowObjectId, identifier, JSCallType.SetValue, cancellationToken, [ value ]);
    }
    /*Task<TValue>*/ async InvokeAsync(TValue, /*long*/ targetInstanceId, /*string*/ identifier, /*JSCallType*/ callType, /*object[]*/ args)
    {
        if (DefaultAsyncTimeout.HasValue)
        {
            /*var*/ let cts = new CancellationTokenSource(DefaultAsyncTimeout.Value);
            {
                return await InvokeAsync_$1(TValue, targetInstanceId, identifier, callType, cts.Token, args);
            }
            {
                cts.Dispose();
            }
        }
        return await InvokeAsync_$1(TValue, targetInstanceId, identifier, callType, CancellationToken.None, args);
    }
    /*Task<TValue>*/ InvokeAsync(TValue, /*long*/ targetInstanceId, /*string*/ identifier, /*JSCallType*/ callType, /*CancellationToken*/ cancellationToken, /*object[]*/ args)
    {
        /*var*/ let taskId = _nextPendingTaskId++;
        /*var*/ let tcs = new TaskCompletionSource_$1(TValue);
        if (cancellationToken.CanBeCanceled)
        {
            _cancellationRegistrationstaskId = cancellationToken.Register(function()
            {
                tcs.TrySetCanceled(cancellationToken);
                CleanupTasksAndRegistrations(taskId);
            });
        }
        _pendingTaskstaskId = tcs;
        {
            if (cancellationToken.IsCancellationRequested)
            {
                tcs.TrySetCanceled(cancellationToken);
                CleanupTasksAndRegistrations(taskId);
                return tcs.Task;
            }
            /*var*/ let argsJson = args != null && args.Length  != 0JsonSerializer.Serialize(args, JsonSerializerOptions)"[]";
            /*var*/ let resultType = JSCallResultTypeHelper.FromGeneric(TValue);
            /*var*/ let invocationInfo = new JSInvocationInfo()AsyncHandle = taskIdTargetInstanceId = targetInstanceIdIdentifier = identifierCallType = callTypeResultType = resultTypeArgsJson = argsJson;
            BeginInvokeJS(invocationInfo);
            return tcs.Task;
        }
        {
            CleanupTasksAndRegistrations(taskId);
            throw ;
        }
    }
    /*void*/ CleanupTasksAndRegistrations(/*long*/ taskId)
    {
        let $v = { value: set(value){ _ = value; } };
        _pendingTasks.TryRemove(taskId, $v);
        let registration = null;
        let $v = { value: set(value){ registration = value; } };
        if (_cancellationRegistrations.TryRemove(taskId, $v))
        {
            registration.Dispose();
        }
    }
    /*void*/ BeginInvokeJS(/*long*/ taskId, /*string*/ identifier, /*string*/ argsJson)
    {
        BeginInvokeJS(taskId, identifier, argsJson, JSCallResultType.Default, WindowObjectId);
    }
    /*void*/ SendByteArray(/*int*/ id, /*byte[]*/ data)
    {
        throw new NotSupportedException("JSRuntime subclasses are responsible for implementing byte array transfer to JS.");
    }
    /*void*/ ReceiveByteArray(/*int*/ id, /*byte[]*/ data)
    {
        if (id == 0)
        {
            // Starting a new transfer, clear out previously stored byte arrays
                // in case they haven't been cleared already.
                ByteArraysToBeRevived.Clear();
        }
        if (id != ByteArraysToBeRevived.Count)
        {
            throw new ArgumentOutOfRangeException(idByteArraysToBeRevived.Count, { innerException : null });
        }
        ByteArraysToBeRevived.Add(data);
    }
    /*Task<Stream>*/ ReadJSDataAsStreamAsync(/*IJSStreamReference*/ jsStreamReference, /*long*/ totalLength, { /*CancellationToken*/ cancellationToken = default})
    {
        throw new NotSupportedException("The current JavaScript runtime does not support reading data streams.");
    }
    /*bool*/ EndInvokeJS(/*long*/ taskId, /*bool*/ succeeded, /*object*/ jsResult)
    {
        let tcs = null;
        let $v = { value: set(value){ tcs = value; } };
        if (_pendingTasks.TryRemove(taskId, $v))
        {
            return false;
        }
        CleanupTasksAndRegistrations(taskId);
        {
            if (succeeded)
            {
                /*var*/ let resultType = TaskGenericsUtil.GetTaskCompletionSourceResultType(tcs);
                /*//var result = JsonSerializer.Deserialize(ref jsonReader, resultType, JsonSerializerOptions);
                    var*/ let result = JsonSerializer.Convert(jsResult, resultType);
                ByteArraysToBeRevived.Clear();
                TaskGenericsUtil.SetTaskCompletionSourceResult(tcs, result);
            }
            else 
            {
                /*var*/ let exceptionText = jsResult.As(string) ?? .Empty;
                TaskGenericsUtil.SetTaskCompletionSourceException(tcs, new JSException(exceptionText));
            }
            return true;
        }
Exception        {
            /*var*/ let message = exception.Message;
            TaskGenericsUtil.SetTaskCompletionSourceException(tcs, new JSException(message, exception));
            return false;
        }
    }
    /*Task*/ TransmitStreamAsync(/*long*/ streamId, /*DotNetStreamReference*/ dotNetStreamReference)
    {
        if (dotNetStreamReference.LeaveOpen)
        {
            dotNetStreamReference.Stream.Dispose();
        }
        throw new NotSupportedException("The current JS runtime does not support sending streams from .NET to JS.");
    }
    /*long*/ BeginTransmittingStream(/*DotNetStreamReference*/ dotNetStreamReference)
    {
        /*// It's fine to share the ID sequence
            var*/ let streamId = _nextObjectReferenceId++;
        // Fire and forget sending the stream so the client can proceed to
            // reading the stream.
            _ = TransmitStreamAsync(streamId, dotNetStreamReference);
        return streamId;
    }
    /*long*/ TrackObjectReference(TValue, /*DotNetObjectReference<TValue>*/ dotNetObjectReference)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(dotNetObjectReference);
        dotNetObjectReference.ThrowIfDisposed();
        /*var*/ let jsRuntime = dotNetObjectReference.JSRuntime;
        if (jsRuntime)
        {
            /*var*/ let dotNetObjectId = _nextObjectReferenceId++;
            dotNetObjectReference.JSRuntime  = ;
            dotNetObjectReference.ObjectId  = dotNetObjectId;
            _trackedRefsByIddotNetObjectId = dotNetObjectReference;
        }
        else if (ReferenceEquals(, jsRuntime))
        {
            throw new InvalidOperationException(dotNetObjectReference.GetType().Namenameof(JSRuntime) + nameof(DotNetObjectReference_$1)nameof(DotNetObjectReference_$1));
        }
        Debug.Assert(dotNetObjectReference.ObjectId  != 0);
        return dotNetObjectReference.ObjectId;
    }
    /*IDotNetObjectReference*/ GetObjectReference(/*long*/ dotNetObjectId)
    {
        let dotNetObjectRef = null;
        let $v = { value: set(value){ dotNetObjectRef = value; } };
        return _trackedRefsById.TryGetValue(dotNetObjectId, $v)dotNetObjectRef        throw new ArgumentException(dotNetObjectId, nameof(dotNetObjectId));
;
    }
    /*void*/ ReleaseObjectReference(/*long*/ dotNetObjectId)
    {
        let $v = { value: set(value){ _ = value; } };
        _trackedRefsById.TryRemove(dotNetObjectId, $v);
    }
    /*void*/ Dispose()
    {
        ByteArraysToBeRevived.Clear();
    }
}

class Microsoft_JSInterop_JSRuntimeExtensions extends object
{
    constructor()
    {
        super();
    }
    /*Task*/ async InvokeVoidAsync(/*IJSRuntime*/ jsRuntime, /*string*/ identifier, /*object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsRuntime);
        await jsRuntime.InvokeAsync(IJSVoidResult, identifier, args);
    }
    /*Task<TValue>*/ InvokeAsync(TValue, /*IJSRuntime*/ jsRuntime, /*string*/ identifier, /*object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsRuntime);
        return jsRuntime.InvokeAsync(TValue, identifier, args);
    }
    /*Task<TValue>*/ InvokeAsync(TValue, /*IJSRuntime*/ jsRuntime, /*string*/ identifier, /*CancellationToken*/ cancellationToken, /*object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsRuntime);
        return jsRuntime.InvokeAsync(TValue, identifier, cancellationToken, args);
    }
    /*Task*/ async InvokeVoidAsync(/*IJSRuntime*/ jsRuntime, /*string*/ identifier, /*CancellationToken*/ cancellationToken, /*object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsRuntime);
        await jsRuntime.InvokeAsync(IJSVoidResult, identifier, cancellationToken, args);
    }
    /*Task<TValue>*/ async InvokeAsync(TValue, /*IJSRuntime*/ jsRuntime, /*string*/ identifier, /*TimeSpan*/ timeout, /*object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsRuntime);
        /*var*/ let cancellationTokenSource = timeout == TimeSpan.MaxValue nullnew CancellationTokenSource(timeout);
        /*var*/ let cancellationToken = cancellationTokenSourceToken ?? CancellationToken.None;
        {
            return await jsRuntime.InvokeAsync(TValue, identifier, cancellationToken, args);
        }
        {
            cancellationTokenSourceDispose();
        }
    }
    /*Task*/ async InvokeVoidAsync(/*IJSRuntime*/ jsRuntime, /*string*/ identifier, /*TimeSpan*/ timeout, /*object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsRuntime);
        /*var*/ let cancellationTokenSource = timeout == TimeSpan.MaxValue nullnew CancellationTokenSource(timeout);
        /*var*/ let cancellationToken = cancellationTokenSourceToken ?? CancellationToken.None;
        {
            await jsRuntime.InvokeAsync(IJSVoidResult, identifier, cancellationToken, args);
        }
        {
            cancellationTokenSourceDispose();
        }
    }
    /*Task<IJSObjectReference>*/ InvokeNewAsync(/*IJSRuntime*/ jsRuntime, /*string*/ identifier, /*object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsRuntime);
        return jsRuntime.InvokeNewAsync(identifier, args);
    }
    /*Task<IJSObjectReference>*/ InvokeNewAsync(/*IJSRuntime*/ jsRuntime, /*string*/ identifier, /*CancellationToken*/ cancellationToken, /*object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsRuntime);
        return jsRuntime.InvokeNewAsync(identifier, cancellationToken, args);
    }
    /*Task<IJSObjectReference>*/ InvokeNewAsync(/*IJSRuntime*/ jsRuntime, /*string*/ identifier, /*TimeSpan*/ timeout, /*object[]*/ args)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(jsRuntime);
        /*var*/ let cancellationTokenSource = timeout == TimeSpan.MaxValue nullnew CancellationTokenSource(timeout);
        /*var*/ let cancellationToken = cancellationTokenSourceToken ?? CancellationToken.None;
        {
            return jsRuntime.InvokeNewAsync(identifier, cancellationToken, args);
        }
        {
            cancellationTokenSourceDispose();
        }
    }
}

class BlazorJs_ServiceProvider_BrowserServiceProvider extends H5_IH5Class(System_Collections_IEnumerable(System_Collections_Generic_IEnumerable<System_ServiceDescriptor>(System_Collections_Generic_ICollection<System_ServiceDescriptor>(System_Collections_Generic_IList<System_ServiceDescriptor>(Microsoft_Extensions_DependencyInjection_IServiceCollection(System_IServiceProvider(System_Collections_Generic_List)))))))
{
    /*//List<ServiceDescriptor> serviceDescriptors = new List<ServiceDescriptor>();
        List<IServiceResolver>*/ _resolvers = new List_$1(IServiceResolver);
    /*Dictionary<(Type, object), object>*/ _resolvedServices = new Dictionary_$2((Type, object), object);
    constructor()
    {
        super();
        _resolvers.Add(new ServiceCollectionResolver());
    }
    /*object*/ ResolveSingle(/*Type*/ serviceType, /*object*/ serviceKey, /*ServiceLifetime*/ currentScope)
    {
        BlazorJs.forEach(_resolvers, function(_resolver, $_i)
        {
            /*var*/ let service = _resolver.TryResolve(, serviceType, serviceKey, false, currentScope);
            if (service != null)
            return service;
        });
        return null;
    }
    /*//MethodInfo? castToServiceType;
        IEnumerable<object>*/ ResolveMany(/*Type*/ serviceType, /*object*/ serviceKey, /*ServiceLifetime*/ currentScope)
    {
        /*List<object>*/ let services = new List_$1(object);
        BlazorJs.forEach(_resolvers, function(_resolver, $_i)
        {
            /*var*/ let service = _resolver.TryResolve(, serviceType, serviceKey, true, currentScope);
            if (service != null)
            services.AddRange(IEnumerable_$1service);
        });
        /*var*/ let castToServiceType = Enumerable.GetMethod("Cast").MakeGenericMethod(serviceType);
        /*var*/ let resolvedServices = castToServiceType.Invoke(null, [ services ]);
        return IEnumerable_$1resolvedServices;
    }
    /*object*/ Resolve(/*Type*/ serviceType, /*object*/ serviceKey, /*ServiceLifetime*/ currentScope)
    {
        if (serviceType.IsGenericType  && serviceType.GetGenericTypeDefinition() == IEnumerable_$1 && true)
        {
            /*var*/ let innerType = serviceType.GetGenericArguments()0;
            return ResolveMany(innerType, serviceKey, currentScope);
        }
        return ResolveSingle(serviceType, serviceKey, currentScope);
    }
    /*object*/ GetServiceInternal(/*Type*/ serviceType, /*object*/ serviceKey)
    {
        {
            let service = null;
            let $v = { value: set(value){ service = value; } };
            if (_resolvedServices.TryGetValue(serviceTypeserviceKey, $v))
            return service;
            service = Resolve(serviceType, serviceKey, ServiceLifetime.Singleton);
            if (service != null)
            _resolvedServices.Add(serviceTypeserviceKey, service);
            return service;
        }
    }
    /*object*/ GetService(/*Type*/ serviceType)
    {
        return GetServiceInternal(serviceType, null);
    }
    /*object*/ GetKeyedService(/*Type*/ serviceType, /*object*/ serviceKey)
    {
        return GetServiceInternal(serviceType, serviceKey);
    }
    /*object*/ GetRequiredKeyedService(/*Type*/ serviceType, /*object*/ serviceKey)
    {
        return GetServiceInternal(serviceType, serviceKey) ??         throw new InvalidOperationException(serviceType.FullName);
;
    }
}

const BlazorJs_ServiceProvider_IServiceResolver = (Base) => class extends Base
{
}

class BlazorJs_ServiceProvider_ServiceCollectionResolver extends BlazorJs_ServiceProvider_IServiceResolver(object)
{
    /*IServiceCollection*/ _services = null;
    /*Dictionary<(Type, object), Dictionary<ServiceDescriptor, ServiceInstanceActivator>>*/ _activators = new Dictionary_$2((Type, object), Dictionary<ServiceDescriptor, ServiceInstanceActivator>);
    constructor(/*IServiceCollection*/ services)
    {
        super();
        _services = services;
    }
    /*Dictionary<ServiceDescriptor, ServiceInstanceActivator>*/ GetActivators(/*Type*/ serviceType, /*object*/ serviceKey, /*IServiceProvider*/ serviceProvider)
    {
        let activatorsForSeviceDescriptors = null;
        let $v = { value: set(value){ activatorsForSeviceDescriptors = value; } };
        if (_activators.TryGetValue(serviceTypeserviceKey, $v))
        {
            activatorsForSeviceDescriptors = new Dictionary_$2(ServiceDescriptor, ServiceInstanceActivator);
            _activatorsserviceTypeserviceKey = activatorsForSeviceDescriptors;
            _services.Match(serviceType, serviceKey, function(/**/ descriptor)
            {
                let activator = null;
                let $v = { value: set(value){ activator = value; } };
                if (activatorsForSeviceDescriptors.TryGetValue(descriptor, $v))
                {
                    /*ServiceInstanceActivator*/ let instanceActivator = null;
                    if (descriptor.IsKeyedService  && descriptor.KeyedImplementationFactory  != null || descriptor.IsKeyedService  && descriptor.ImplementationFactory  != null)
                    {
                        instanceActivator = new ServiceFactoryInstanceActivator(descriptor);
                    }
                    else if (descriptor.IsKeyedService  && descriptor.KeyedImplementationInstance  != null || descriptor.IsKeyedService  && descriptor.ImplementationInstance  != null)
                    {
                        instanceActivator = new ServiceInstanceInstanceActivator(descriptor);
                    }
                    else if (descriptor.IsKeyedService  && descriptor.KeyedImplementationType  != null || descriptor.IsKeyedService  && descriptor.ImplementationType  != null)
                    {
                        instanceActivator = new ServiceConstructorActivator(descriptor, serviceType, serviceKey, serviceProvider);
                    }
                    else 
                    {
                        throw new InvalidOperationException("Unknown Error");
                    }
                    activatorsForSeviceDescriptorsdescriptor = instanceActivator;
                }
            });
        }
        return activatorsForSeviceDescriptors;
    }
    /*object*/ TryResolve(/*IServiceProvider*/ serviceProvider, /*Type*/ serviceType, /*object*/ serviceKey, /*bool*/ all, /*ServiceLifetime*/ currentScope)
    {
        {
            /*var*/ let activatorsForType = GetActivators(serviceType, serviceKey, serviceProvider);
            if (activatorsForType.Any() && all)
            {
                return null;
            }
            if (all)
            {
                return activatorsForType.Select(function(/**/ a)
                {
a.Value.Activate(serviceProvider)                });
            }
            else 
            {
                /*var*/ let activator = activatorsForType.First();
                return activator.Value.Activate(serviceProvider);
            }
        }
    }
}

class BlazorJs_ServiceProvider_ServiceConstructorActivator extends BlazorJs_ServiceProvider_ServiceInstanceActivator
{
    /*Type*/ implementationType = null;
    /*ConstructorInfo*/ constructor = null;
    /*object*/ serviceKey = null;
    constructor(/*ServiceDescriptor*/ descriptor, /*Type*/ serviceType, /*object*/ serviceKey, /*IServiceProvider*/ serviceProvider)
    {
        super(descriptor);
        implementationType = descriptor.IsKeyedService descriptor.KeyedImplementationType descriptor.ImplementationType;
        if (implementationType.IsGenericTypeDefinition  && serviceType.IsGenericType)
        {
            /*var*/ let args = serviceType.GetGenericArguments();
            implementationType = implementationType.MakeGenericType(args);
        }
        /*var*/ let constructors = implementationType.GetConstructors();
        if (constructors.Length  == 0)
        {
            throw new InvalidOperationException(implementationType.Name);
        }
        else if (constructors.Length  > 1)
        {
            /*int*/ let maxW = 0;
            BlazorJs.forEach(constructors, function(c, $_i)
            {
                /*var*/ let w = 0;
                /*var*/ let parameters = c.GetParameters();
                if (parameters.All(function(/**/ p)
                {
                    {
                        return IServiceCollectionserviceProvider.GetServiceDescriptors(p.ParameterType, null).Any();
                    }
                }))
                {
                    /*var*/ let parametersCount = parameters.Length;
                    w = parametersCount;
                }
                if (w > maxW)
                {
                    constructor = c;
                    maxW = w;
                }
            });
            if (constructor == null)
            throw new InvalidOperationException(serviceType.FullName);
        }
        else 
        {
            constructor = constructors0;
        }
        .serviceKey  = serviceKey;
    }
    /*object*/ Activate(/*IServiceProvider*/ serviceProvider)
    {
        /*var*/ let types = constructor.GetParameters();
        /*var*/ let parameters = types.Select(function(/**/ t)
        {
            {
                if (serviceKey != null)
                {
                    /*var*/ let service = serviceProvider.GetKeyedService(t.ParameterType, serviceKey);
                    if (service != null)
                    return service;
                }
                return serviceProvider.GetRequiredService(t.ParameterType);
            }
        }).ToArray();
        return constructor.Invoke(parameters);
    }
}

class BlazorJs_ServiceProvider_ServiceFactoryInstanceActivator extends BlazorJs_ServiceProvider_ServiceInstanceActivator
{
    constructor(/*ServiceDescriptor*/ descriptor)
    {
        super(descriptor);
    }
    /*object*/ Activate(/*IServiceProvider*/ serviceProvider)
    {
        if (Descriptor.IsKeyedService)
        return Descriptor.KeyedImplementationFactory(serviceProvider, Descriptor.ServiceKey);
        else 
        return Descriptor.ImplementationFactory(serviceProvider);
    }
}

class BlazorJs_ServiceProvider_ServiceInstanceActivator extends object
{
    /*ServiceDescriptor*/ _backingField_Descriptor = null;
    /*ServiceDescriptor*/ get Descriptor()
    {
        return _backingField_Descriptor;
    }
    constructor(/*ServiceDescriptor*/ descriptor)
    {
        super();
        Descriptor = descriptor;
    }
}

class BlazorJs_ServiceProvider_ServiceInstanceInstanceActivator extends BlazorJs_ServiceProvider_ServiceInstanceActivator
{
    constructor(/*ServiceDescriptor*/ descriptor)
    {
        super(descriptor);
    }
    /*object*/ Activate(/*IServiceProvider*/ serviceProvider)
    {
        if (Descriptor.IsKeyedService)
        return Descriptor.KeyedImplementationInstance;
        else 
        return Descriptor.ImplementationInstance;
    }
}

Systemclass System_ArgumentExceptionExtension extends object
{
    constructor()
    {
        super();
    }
    /*void*/ ThrowIfNullOrEmpty(/*string*/ o)
    {
        if (.IsNullOrEmpty(o))
        throw new NullReferenceException();
    }
    /*void*/ ThrowIfNullOrWhiteSpace(/*string*/ o)
    {
        if (.IsNullOrWhiteSpace(o))
        throw new NullReferenceException();
    }
}

Systemclass System_ArgumentNullExceptionExtension extends object
{
    constructor()
    {
        super();
    }
    /*void*/ ThrowIfNull(/*object*/ o, { /*string*/ name = null})
    {
        if (o == null)
        throw new NullReferenceException();
    }
}

Systemclass System_DateOnly extends System_ValueType
{
    constructor()
    {
        super();
    }
}

Systemclass System_HashCode extends object
{
    constructor()
    {
        super();
    }
    /*int*/ code = 897534562;
    /*void*/ Add(/*object*/ c)
    {
        /*var*/ let cc = c.GetHashCode();
        code ^= cc;
    }
    /*int*/ ToHashCode()
    {
        return code;
    }
    /*int*/ Combine(T1, T2, /*T1*/ t1, /*T2*/ t2)
    {
        /*HashCode*/ let hc = new HashCode();
        hc.Add(t1);
        hc.Add(t2);
        return hc.ToHashCode();
    }
    /*int*/ Combine(T1, T2, T3, /*T1*/ t1, /*T2*/ t2, /*T3*/ t3)
    {
        /*HashCode*/ let hc = new HashCode();
        hc.Add(t1);
        hc.Add(t2);
        hc.Add(t3);
        return hc.ToHashCode();
    }
    /*int*/ Combine(T1, T2, T3, T4, /*T1*/ t1, /*T2*/ t2, /*T3*/ t3, /*T4*/ t4)
    {
        /*HashCode*/ let hc = new HashCode();
        hc.Add(t1);
        hc.Add(t2);
        hc.Add(t3);
        hc.Add(t4);
        return hc.ToHashCode();
    }
    /*int*/ Combine(T1, T2, T3, T4, T5, /*T1*/ t1, /*T2*/ t2, /*T3*/ t3, /*T4*/ t4, /*T5*/ t5)
    {
        /*HashCode*/ let hc = new HashCode();
        hc.Add(t1);
        hc.Add(t2);
        hc.Add(t3);
        hc.Add(t4);
        hc.Add(t5);
        return hc.ToHashCode();
    }
    /*int*/ Combine(T1, T2, T3, T4, T5, T6, /*T1*/ t1, /*T2*/ t2, /*T3*/ t3, /*T4*/ t4, /*T5*/ t5, /*T6*/ t6)
    {
        /*HashCode*/ let hc = new HashCode();
        hc.Add(t1);
        hc.Add(t2);
        hc.Add(t3);
        hc.Add(t4);
        hc.Add(t5);
        hc.Add(t6);
        return hc.ToHashCode();
    }
    /*int*/ Combine(T1, T2, T3, T4, T5, T6, T7, /*T1*/ t1, /*T2*/ t2, /*T3*/ t3, /*T4*/ t4, /*T5*/ t5, /*T6*/ t6, /*T7*/ t7)
    {
        /*HashCode*/ let hc = new HashCode();
        hc.Add(t1);
        hc.Add(t2);
        hc.Add(t3);
        hc.Add(t4);
        hc.Add(t5);
        hc.Add(t6);
        hc.Add(t7);
        return hc.ToHashCode();
    }
    /*int*/ Combine(T1, T2, T3, T4, T5, T6, T7, T8, /*T1*/ t1, /*T2*/ t2, /*T3*/ t3, /*T4*/ t4, /*T5*/ t5, /*T6*/ t6, /*T7*/ t7, /*T8*/ t8)
    {
        /*HashCode*/ let hc = new HashCode();
        hc.Add(t1);
        hc.Add(t2);
        hc.Add(t3);
        hc.Add(t4);
        hc.Add(t5);
        hc.Add(t6);
        hc.Add(t7);
        hc.Add(t8);
        return hc.ToHashCode();
    }
}

Systemconst System_IAsyncEnumerable$_1 = (T, Base) => class extends Base
{
}
const System_IAsyncEnumerator$_1 = (T, Base) => class extends Base
{
    /*T*/ _backingField_Current = null;
    /*T*/ get Current()
    {
        return _backingField_Current;
    }
}
const System_IAsyncDisposable = (Base) => class extends Base
{
}

Systemclass System_Index extends H5_IH5Class(System_IEquatable<System_Index>(System_ValueType))
{
    constructor(/*int*/ value, /*bool*/ fromEnd)
    {
        super();
        Value = value;
        IsFromEnd = fromEnd;
    }
    /*Index*/ _backingField_End = null;
    /*Index*/ get End()
    {
        return _backingField_End;
    }
    /*Index*/ _backingField_Start = null;
    /*Index*/ get Start()
    {
        return _backingField_Start;
    }
    /*bool*/ _backingField_IsFromEnd = null;
    /*bool*/ get IsFromEnd()
    {
        return _backingField_IsFromEnd;
    }
    /*int*/ _backingField_Value = null;
    /*int*/ get Value()
    {
        return _backingField_Value;
    }
    /*Index*/ FromEnd(/*int*/ value)
    {
        new Index(value, true);
    }
    /*Index*/ FromStart(/*int*/ value)
    {
        new Index(value, false);
    }
    /*bool*/ Equals(/*Index*/ other)
    {
        other.Value  == Value && other.IsFromEnd  == IsFromEnd;
    }
    /*bool*/ Equals(/*object*/ value)
    {
        if (value instanceof Index, other = value)
        return Equals(other);
        return false;
    }
    /*int*/ GetHashCode()
    {
        return HashCode.Combine(Value, IsFromEnd);
    }
    /*int*/ GetOffset(/*int*/ length)
    {
        if (IsFromEnd)
        {
            return length - 1 - Value;
        }
        return Value;
    }
    /*string*/ ToString()
    {
        return Value.ToString();
    }
Index    new Index(value, value < 0);
Index    value.Value;
}

Systemconst System_IProgress$_1 = (in T, Base) => class extends Base
{
}

Systemconst System_IServiceScope = (Base) => class extends Base
{
    /*IServiceProvider*/ _backingField_Service = null;
    /*IServiceProvider*/ get Service()
    {
        return _backingField_Service;
    }
}
class System_ServiceProviderExtensions extends object
{
    constructor()
    {
        super();
    }
    class System_ServiceScope extends System_IServiceScope(object)
    {
        /*IServiceProvider*/ _backingField_Service = null;
        /*IServiceProvider*/ get Service()
        {
            return _backingField_Service;
        }
        /*IServiceProvider*/ set Service(value)
        {
            _backingField_Service = value;
        }
        constructor(/*IServiceProvider*/ serviceProvider)
        {
            super();
            Service = serviceProvider;
        }
    }
    /*IServiceScope*/ CreateScope(/*IServiceProvider*/ serviceProvider)
    {
        return new ServiceScope(serviceProvider);
    }
}


Systemclass System_Range extends H5_IH5Class(System_IEquatable<System_Range>(System_ValueType))
{
    constructor(/*Index*/ start, /*Index*/ end)
    {
        super();
        Start = start;
        End = end;
    }
    /*Range*/ _backingField_All = null;
    /*Range*/ get All()
    {
        return _backingField_All;
    }
    /*Index*/ _backingField_End = null;
    /*Index*/ get End()
    {
        return _backingField_End;
    }
    /*Index*/ _backingField_Start = null;
    /*Index*/ get Start()
    {
        return _backingField_Start;
    }
    /*Range*/ EndAt(/*Index*/ end)
    {
        new Range(0, end);
    }
    /*Range*/ StartAt(/*Index*/ start)
    {
        new Range(start, 1);
    }
    /*bool*/ Equals(/*object*/ value)
    {
        if (value instanceof Range, other = value)
        return Equals(other);
        return false;
    }
    /*bool*/ Equals(/*Range*/ other)
    {
        return Start.Equals(other.Start) && End.Equals(other.End);
    }
    /*int*/ GetHashCode()
    {
        return HashCode.Combine(Start, End);
    }
    /*(int Offset, int Length)*/ GetOffsetAndLength(/*int*/ length)
    {
        /*var*/ let startOffset = Start.GetOffset(length);
        return startOffsetlength/*TODO*/;
    }
    /*string*/ ToString()
    {
        return Start.ToString() + " to " + End.ToString();
    }
    /*int*/ get Length()
    {
        return End - Start + 1;
    }
}

Systemconst System_ReadOnlyMemory$_1 = (T) => class extends System_ValueType
{
    /*ReadOnlySpan<T>*/ Empty = default;
    /*ReadOnlySpan<T>*/ _span = null;
    constructor(/*T[]*/ t, /*int*/ offset, /*int*/ length)
    {
        super();
        _span = new ReadOnlySpan_$1(T, t, offset, length);
    }
    constructor(/*ReadOnlySpan<T>*/ span)
    {
        super();
        ._span  = span;
    }
    /*ReadOnlySpan<T>*/ get Span()
    {
        return _span;
    }
    /*int*/ get Length()
    {
        return _span.Length;
    }
    /*ReadOnlyMemory<T>*/ Slice(/*int*/ start, { /*int*/ length = 1})
    {
        new ReadOnlyMemory_$1(T, _span.Slice(start, length));
    }
}

Systemconst System_ReadOnlySpan$_1 = (T) => class extends H5_IH5Class(System_Collections_IEnumerable(System_Collections_Generic_IEnumerable<T>(System_ValueType)))
{
    /*T[]*/ _t = null;
    /*int*/ _offset = null;
    /*int*/ _length = null;
    /*ReadOnlySpan<T>*/ Empty = default;
    constructor(/*T[]*/ t, /*int*/ offset, /*int*/ length)
    {
        super();
        _t = t;
        _offset = offset;
        if (length == 1)
        {
            if (t != null)
            length = t.Length  - offset;
            else 
            length = 0;
        }
        _length = length;
    }
    /*int*/ get Offset()
    {
        return _offset;
    }
    /*bool*/ get IsEmpty()
    {
        return _length == 0;
    }
    /*int*/ get Length()
    {
        return _length;
    }
T    _tindex + _offset;
    /*void*/ ForEach(/*Func<T, int, bool>*/ iterator)
    {
        for(/*int*/ let i = 0; i < Length; i++)
        {
            if (iterator(i, i) == false)
            break;
        });
    }
    /*void*/ ReverseForEach(/*Func<T, int, bool>*/ iterator)
    {
        for(/*int*/ let i = Length - 1; i >= 0; i--)
        {
            if (iterator(i, i) == false)
            break;
        });
    }
ReadOnlySpan_$1Range    Slice(index.Start, index.Length);
    /*ReadOnlySpan<T>*/ Slice(/*int*/ start, { /*int*/ length = 1})
    {
        if (length == 1)
        {
            length = _length - start + _offset;
        }
        return new ReadOnlySpan_$1(T, _t, start + _offset, length);
    }
    /*void*/ CopyTo(/*Span<T>*/ destination)
    {
        ForEach(function(/**/ t, /**/ i)
        {
            destinationi = t;
            return true;
        });
    }
    /*void*/ CopyTo(/*Stream*/ destination)
    {
        destination.Write(_t, _offset, _length);
    }
    /*T[]*/ ToArray()
    {
        /*var*/ let newT = new Array(Length);
        ForEach(function(/**/ t, /**/ i)
        {
            newTi = t;
            return true;
        });
        return newT;
    }
    /*bool*/ Contains(/*T*/ c)
    {
        /*bool*/ let result = false;
        ForEach(function(/**/ t, /**/ i)
        {
            if (c.Equals(t))
            {
                result = true;
                return false;
            }
            return true;
        });
        return result;
    }
    /*bool*/ ContainsAny(/*T[]*/ chars)
    {
        /*bool*/ let result = false;
        ForEach(function(/**/ t, /**/ i)
        {
            if (chars.Any(function(/**/ c)
            {
c.Equals(t)            }))
            {
                result = true;
                return false;
            }
            return true;
        });
        return result;
    }
    /*bool*/ ContainsAnyExcept(/*T[]*/ chars)
    {
        /*bool*/ let result = false;
        ForEach(function(/**/ t, /**/ i)
        {
            if (chars.Any(function(/**/ c)
            {
c.Equals(t)            }))
            {
                result = true;
                return false;
            }
            return true;
        });
        return result;
    }
    /*int*/ IndexOf(/*T*/ c)
    {
        /*int*/ let index = 1;
        ForEach(function(/**/ t, /**/ i)
        {
            if (c.Equals(t))
            {
                index = i;
                return false;
            }
            return true;
        });
        return index;
    }
    /*int*/ LastIndexOf(/*T*/ c)
    {
        /*int*/ let index = 1;
        ReverseForEach(function(/**/ t, /**/ i)
        {
            if (c.Equals(t))
            {
                index = i;
                return false;
            }
            return true;
        });
        return index;
    }
    /*int*/ IndexOfAny(/*T[]*/ chars)
    {
        /*int*/ let index = 1;
        ForEach(function(/**/ t, /**/ i)
        {
            if (chars.Any(function(/**/ c)
            {
c.Equals(t)            }))
            {
                index = i;
                return false;
            }
            return true;
        });
        return index;
    }
    /*int*/ IndexOfAnyExcept(/*T[]*/ chars)
    {
        /*int*/ let index = 1;
        ForEach(function(/**/ t, /**/ i)
        {
            if (chars.Any(function(/**/ c)
            {
c.Equals(t)            }))
            {
                index = i;
                return false;
            }
            return true;
        });
        return index;
    }
    /*bool*/ StartsWith(/*T*/ needle)
    {
        return _length > 0 && 0.Equals(needle);
    }
    /*bool*/ StartsWith(/*ReadOnlySpan<T>*/ other)
    {
        if (Length < other.Length)
        return false;
        /*bool*/ let starts = true;
        /*var*/ let me = ;
        other.ForEach(function(/**/ t, /**/ i)
        {
            /*bool*/ let eq = t.Equals(mei);
            if (eq)
            {
                return true;
            }
            starts = false;
            return false;
        });
        return starts;
    }
    /*int*/ Split(/*Span<Range>*/ ranges, /*T*/ delimiter)
    {
        /*int*/ let r_i = 0;
        /*int*/ let start = 0;
        ForEach(function(/**/ t, /**/ i)
        {
            if (delimiter.Equals(t))
            {
                rangesr_i++ = new Range(start, i - 1);
                start = i + 1;
            }
            return true;
        });
        if (start > 0)
        {
            rangesr_i++ = new Range(start, Length - 1);
        }
        return r_i;
    }
ReadOnlySpan_$1T    {
        return new ReadOnlySpan_$1(T, ts);
    }
ReadOnlySpan_$1    {
        return span.ToString();
    }
    /*string*/ ToString()
    {
        if (T == )
        return ReadOnlySpan_$1.AsString();
        return super.ToString();
    }
    /*IEnumerator<T>*/ GetEnumerator()
    {
        return new ReadOnlySpanEnumerator();
    }
    /*IEnumerator*/ GetEnumerator()
    {
        return new ReadOnlySpanEnumerator();
    }
    class System_ReadOnlySpanEnumerator extends System_Collections_IEnumerator(System_IDisposable(System_Collections_Generic_IEnumerator<T>(object)))
    {
        /*ReadOnlySpan<T>*/ span = null;
        /*int*/ index = 1;
        constructor(/*ReadOnlySpan<T>*/ span)
        {
            super();
            .span  = span;
        }
        /*T*/ get Current()
        {
            return spanindex;
        }
        /*object*/ get Current()
        {
            return spanindex;
        }
        /*void*/ Dispose()
        {
            throw new NotImplementedException();
        }
        /*bool*/ MoveNext()
        {
            index++;
            return index < span.Length;
        }
        /*void*/ Reset()
        {
            index = 1;
        }
    }
}

Systemclass System_ServiceDescriptor extends object
{
    /*Type*/ _implementationType = null;
    /*object*/ _implementationInstance = null;
    /*object*/ _implementationFactory = null;
    /*ServiceLifetime*/ _backingField_Lifetime = null;
    /*ServiceLifetime*/ get Lifetime()
    {
        return _backingField_Lifetime;
    }
    /*object*/ _backingField_ServiceKey = null;
    /*object*/ get ServiceKey()
    {
        return _backingField_ServiceKey;
    }
    /*Type*/ _backingField_ServiceType = null;
    /*Type*/ get ServiceType()
    {
        return _backingField_ServiceType;
    }
    /*Type*/ get ImplementationType()
    {
        if (IsKeyedService)
        {
            ThrowKeyedDescriptor();
        }
        return _implementationType;
    }
    /*Type*/ get KeyedImplementationType()
    {
        if (IsKeyedService)
        {
            ThrowNonKeyedDescriptor();
        }
        return _implementationType;
    }
    /*object*/ get ImplementationInstance()
    {
        if (IsKeyedService)
        {
            ThrowKeyedDescriptor();
        }
        return _implementationInstance;
    }
    /*object*/ get KeyedImplementationInstance()
    {
        if (IsKeyedService)
        {
            ThrowNonKeyedDescriptor();
        }
        return _implementationInstance;
    }
    /*Func<IServiceProvider, object>*/ get ImplementationFactory()
    {
        if (IsKeyedService)
        {
            ThrowKeyedDescriptor();
        }
        return Func_$2_implementationFactory;
    }
    /*Func<IServiceProvider, object, object>*/ get KeyedImplementationFactory()
    {
        if (IsKeyedService)
        {
            ThrowNonKeyedDescriptor();
        }
        return Func_$3_implementationFactory;
    }
    /*bool*/ get IsKeyedService()
    {
        return ServiceKey != null;
    }
    constructor(/*Type*/ serviceType, /*Type*/ implementationType, /*ServiceLifetime*/ lifetime)
    {
        super(serviceType, null, implementationType, lifetime);
    }
    constructor(/*Type*/ serviceType, /*object*/ serviceKey, /*Type*/ implementationType, /*ServiceLifetime*/ lifetime)
    {
        super(serviceType, serviceKey, lifetime);
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(implementationType, "implementationType");
        _implementationType = implementationType;
    }
    constructor(/*Type*/ serviceType, /*object*/ instance)
    {
        super(serviceType, null, instance);
    }
    constructor(/*Type*/ serviceType, /*object*/ serviceKey, /*object*/ instance)
    {
        super(serviceType, serviceKey, ServiceLifetime.Singleton);
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(instance, "instance");
        _implementationInstance = instance;
    }
    constructor(/*Type*/ serviceType, /*Func<IServiceProvider, object>*/ factory, /*ServiceLifetime*/ lifetime)
    {
        super(serviceType, null, lifetime);
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(factory, "factory");
        _implementationFactory = factory;
    }
    constructor(/*Type*/ serviceType, /*object*/ serviceKey, /*Func<IServiceProvider, object, object>*/ factory, /*ServiceLifetime*/ lifetime)
    {
        super(serviceType, serviceKey, lifetime);
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(factory, "factory");
        if (serviceKey == null)
        {
            /*Func<IServiceProvider, object>*/ let implementationFactory = function(/**/ sp)
            {
                return factory(sp, null);
            };
            _implementationFactory = implementationFactory;
        }
        else 
        {
            _implementationFactory = factory;
        }
    }
    constructor(/*Type*/ serviceType, /*object*/ serviceKey, /*ServiceLifetime*/ lifetime)
    {
        super();
        Lifetime = lifetime;
        ServiceType = serviceType;
        ServiceKey = serviceKey;
    }
    /*string*/ ToString()
    {
        /*string*/ let text = "ServiceType"ServiceType"Lifetime"Lifetime;
        if (IsKeyedService)
        {
            text += "ServiceKey"ServiceKey;
            if (KeyedImplementationType != null)
            {
                return text + "KeyedImplementationType"KeyedImplementationType;
            }
            if (KeyedImplementationFactory != null)
            {
                return text + "KeyedImplementationFactory"KeyedImplementationFactory/*.Method*/;
            }
            return text + "KeyedImplementationInstance"KeyedImplementationInstance;
        }
        if (ImplementationType != null)
        {
            return text + "ImplementationType"ImplementationType;
        }
        if (ImplementationFactory != null)
        {
            return text + "ImplementationFactory"ImplementationFactory/*.Method*/;
        }
        return text + "ImplementationInstance"ImplementationInstance;
    }
    /*Type*/ GetImplementationType()
    {
        if (ServiceKey == null)
        {
            if (ImplementationType != null)
            {
                return ImplementationType;
            }
            if (ImplementationInstance != null)
            {
                return ImplementationInstance.GetType();
            }
            if (ImplementationFactory != null)
            {
                /*Type[]*/ let genericTypeArguments = ImplementationFactory.GetType().GetGenericArguments();
                return genericTypeArguments1;
            }
        }
        else 
        {
            if (KeyedImplementationType != null)
            {
                return KeyedImplementationType;
            }
            if (KeyedImplementationInstance != null)
            {
                return KeyedImplementationInstance.GetType();
            }
            if (KeyedImplementationFactory != null)
            {
                /*Type[]*/ let genericTypeArguments2 = KeyedImplementationFactory.GetType().GetGenericArguments();
                return genericTypeArguments22;
            }
        }
        return null;
    }
    /*ServiceDescriptor*/ Transient(TService, TImplementation)
    {
        return DescribeKeyed_$2(TService, TImplementation, null, ServiceLifetime.Transient);
    }
    /*ServiceDescriptor*/ KeyedTransient(TService, TImplementation, /*object*/ serviceKey)
    {
        return DescribeKeyed_$2(TService, TImplementation, serviceKey, ServiceLifetime.Transient);
    }
    /*ServiceDescriptor*/ Transient(/*Type*/ service, /*Type*/ implementationType)
    {
        ThrowHelperExtension.ThrowIfNull(service, "service");
        ThrowHelperExtension.ThrowIfNull(implementationType, "implementationType");
        return Describe(service, implementationType, ServiceLifetime.Transient);
    }
    /*ServiceDescriptor*/ KeyedTransient(/*Type*/ service, /*object*/ serviceKey, /*Type*/ implementationType)
    {
        ThrowHelperExtension.ThrowIfNull(service, "service");
        ThrowHelperExtension.ThrowIfNull(implementationType, "implementationType");
        return DescribeKeyed(service, serviceKey, implementationType, ServiceLifetime.Transient);
    }
    /*ServiceDescriptor*/ Transient(TService, TImplementation, /*Func<IServiceProvider, TImplementation>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return Describe(TService, function(/**/ sp)
        {
            return implementationFactory(sp);
        }, ServiceLifetime.Transient);
    }
    /*ServiceDescriptor*/ KeyedTransient(TService, TImplementation, /*object*/ serviceKey, /*Func<IServiceProvider, object, TImplementation>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return DescribeKeyed(TService, serviceKey, function(/**/ sp, /**/ key)
        {
            return implementationFactory(sp, key);
        }, ServiceLifetime.Transient);
    }
    /*ServiceDescriptor*/ Transient(TService, /*Func<IServiceProvider, TService>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return Describe(TService, function(/**/ sp)
        {
            return implementationFactory(sp);
        }, ServiceLifetime.Transient);
    }
    /*ServiceDescriptor*/ KeyedTransient(TService, /*object*/ serviceKey, /*Func<IServiceProvider, object, TService>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return DescribeKeyed(TService, serviceKey, function(/**/ sp, /**/ key)
        {
            return implementationFactory(sp, key);
        }, ServiceLifetime.Transient);
    }
    /*ServiceDescriptor*/ Transient(/*Type*/ service, /*Func<IServiceProvider, object>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(service, "service");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return Describe(service, implementationFactory, ServiceLifetime.Transient);
    }
    /*ServiceDescriptor*/ KeyedTransient(/*Type*/ service, /*object*/ serviceKey, /*Func<IServiceProvider, object, object>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(service, "service");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return DescribeKeyed(service, serviceKey, implementationFactory, ServiceLifetime.Transient);
    }
    /*ServiceDescriptor*/ Scoped(TService, TImplementation)
    {
        return DescribeKeyed_$2(TService, TImplementation, null, ServiceLifetime.Scoped);
    }
    /*ServiceDescriptor*/ KeyedScoped(TService, TImplementation, /*object*/ serviceKey)
    {
        return DescribeKeyed_$2(TService, TImplementation, serviceKey, ServiceLifetime.Scoped);
    }
    /*ServiceDescriptor*/ Scoped(/*Type*/ service, /*Type*/ implementationType)
    {
        return Describe(service, implementationType, ServiceLifetime.Scoped);
    }
    /*ServiceDescriptor*/ KeyedScoped(/*Type*/ service, /*object*/ serviceKey, /*Type*/ implementationType)
    {
        return DescribeKeyed(service, serviceKey, implementationType, ServiceLifetime.Scoped);
    }
    /*ServiceDescriptor*/ Scoped(TService, TImplementation, /*Func<IServiceProvider, TImplementation>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return Describe(TService, function(/**/ sp)
        {
            return implementationFactory(sp);
        }, ServiceLifetime.Scoped);
    }
    /*ServiceDescriptor*/ KeyedScoped(TService, TImplementation, /*object*/ serviceKey, /*Func<IServiceProvider, object, TImplementation>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return DescribeKeyed(TService, serviceKey, function(/**/ sp, /**/ key)
        {
            return implementationFactory(sp, key);
        }, ServiceLifetime.Scoped);
    }
    /*ServiceDescriptor*/ Scoped(TService, /*Func<IServiceProvider, TService>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return Describe(TService, function(/**/ sp)
        {
            return implementationFactory(sp);
        }, ServiceLifetime.Scoped);
    }
    /*ServiceDescriptor*/ KeyedScoped(TService, /*object*/ serviceKey, /*Func<IServiceProvider, object, TService>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return DescribeKeyed(TService, serviceKey, function(/**/ sp, /**/ key)
        {
            return implementationFactory(sp, key);
        }, ServiceLifetime.Scoped);
    }
    /*ServiceDescriptor*/ Scoped(/*Type*/ service, /*Func<IServiceProvider, object>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(service, "service");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return Describe(service, implementationFactory, ServiceLifetime.Scoped);
    }
    /*ServiceDescriptor*/ KeyedScoped(/*Type*/ service, /*object*/ serviceKey, /*Func<IServiceProvider, object, object>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(service, "service");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return DescribeKeyed(service, serviceKey, implementationFactory, ServiceLifetime.Scoped);
    }
    /*ServiceDescriptor*/ Singleton(TService, TImplementation)
    {
        return DescribeKeyed_$2(TService, TImplementation, null, ServiceLifetime.Singleton);
    }
    /*ServiceDescriptor*/ KeyedSingleton(TService, TImplementation, /*object*/ serviceKey)
    {
        return DescribeKeyed_$2(TService, TImplementation, serviceKey, ServiceLifetime.Singleton);
    }
    /*ServiceDescriptor*/ Singleton(/*Type*/ service, /*Type*/ implementationType)
    {
        ThrowHelperExtension.ThrowIfNull(service, "service");
        ThrowHelperExtension.ThrowIfNull(implementationType, "implementationType");
        return Describe(service, implementationType, ServiceLifetime.Singleton);
    }
    /*ServiceDescriptor*/ KeyedSingleton(/*Type*/ service, /*object*/ serviceKey, /*Type*/ implementationType)
    {
        ThrowHelperExtension.ThrowIfNull(service, "service");
        ThrowHelperExtension.ThrowIfNull(implementationType, "implementationType");
        return DescribeKeyed(service, serviceKey, implementationType, ServiceLifetime.Singleton);
    }
    /*ServiceDescriptor*/ Singleton(TService, TImplementation, /*Func<IServiceProvider, TImplementation>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return Describe(TService, function(/**/ sp)
        {
            return implementationFactory(sp);
        }, ServiceLifetime.Singleton);
    }
    /*ServiceDescriptor*/ KeyedSingleton(TService, TImplementation, /*object*/ serviceKey, /*Func<IServiceProvider, object, TImplementation>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return DescribeKeyed(TService, serviceKey, function(/**/ sp, /**/ key)
        {
            return implementationFactory(sp, key);
        }, ServiceLifetime.Singleton);
    }
    /*ServiceDescriptor*/ Singleton(TService, /*Func<IServiceProvider, TService>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return Describe(TService, function(/**/ sp)
        {
            return implementationFactory(sp);
        }, ServiceLifetime.Singleton);
    }
    /*ServiceDescriptor*/ KeyedSingleton(TService, /*object*/ serviceKey, /*Func<IServiceProvider, object, TService>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return DescribeKeyed(TService, serviceKey, function(/**/ sp, /**/ key)
        {
            return implementationFactory(sp, key);
        }, ServiceLifetime.Singleton);
    }
    /*ServiceDescriptor*/ Singleton(/*Type*/ serviceType, /*Func<IServiceProvider, object>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return Describe(serviceType, implementationFactory, ServiceLifetime.Singleton);
    }
    /*ServiceDescriptor*/ KeyedSingleton(/*Type*/ serviceType, /*object*/ serviceKey, /*Func<IServiceProvider, object, object>*/ implementationFactory)
    {
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(implementationFactory, "implementationFactory");
        return DescribeKeyed(serviceType, serviceKey, implementationFactory, ServiceLifetime.Singleton);
    }
    /*ServiceDescriptor*/ Singleton(TService, /*TService*/ implementationInstance)
    {
        ThrowHelperExtension.ThrowIfNull(implementationInstance, "implementationInstance");
        return Singleton(TService, implementationInstance);
    }
    /*ServiceDescriptor*/ KeyedSingleton(TService, /*object*/ serviceKey, /*TService*/ implementationInstance)
    {
        ThrowHelperExtension.ThrowIfNull(implementationInstance, "implementationInstance");
        return KeyedSingleton(TService, serviceKey, implementationInstance);
    }
    /*ServiceDescriptor*/ Singleton(/*Type*/ serviceType, /*object*/ implementationInstance)
    {
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(implementationInstance, "implementationInstance");
        return new ServiceDescriptor(serviceType, implementationInstance);
    }
    /*ServiceDescriptor*/ KeyedSingleton(/*Type*/ serviceType, /*object*/ serviceKey, /*object*/ implementationInstance)
    {
        ThrowHelperExtension.ThrowIfNull(serviceType, "serviceType");
        ThrowHelperExtension.ThrowIfNull(implementationInstance, "implementationInstance");
        return new ServiceDescriptor(serviceType, serviceKey, implementationInstance);
    }
    /*ServiceDescriptor*/ DescribeKeyed(TService, TImplementation, /*object*/ serviceKey, /*ServiceLifetime*/ lifetime)
    {
        return DescribeKeyed(TService, serviceKey, TImplementation, lifetime);
    }
    /*ServiceDescriptor*/ Describe(/*Type*/ serviceType, /*Type*/ implementationType, /*ServiceLifetime*/ lifetime)
    {
        return new ServiceDescriptor(serviceType, implementationType, lifetime);
    }
    /*ServiceDescriptor*/ DescribeKeyed(/*Type*/ serviceType, /*object*/ serviceKey, /*Type*/ implementationType, /*ServiceLifetime*/ lifetime)
    {
        return new ServiceDescriptor(serviceType, serviceKey, implementationType, lifetime);
    }
    /*ServiceDescriptor*/ Describe(/*Type*/ serviceType, /*Func<IServiceProvider, object>*/ implementationFactory, /*ServiceLifetime*/ lifetime)
    {
        return new ServiceDescriptor(serviceType, implementationFactory, lifetime);
    }
    /*ServiceDescriptor*/ DescribeKeyed(/*Type*/ serviceType, /*object*/ serviceKey, /*Func<IServiceProvider, object, object>*/ implementationFactory, /*ServiceLifetime*/ lifetime)
    {
        return new ServiceDescriptor(serviceType, serviceKey, implementationFactory, lifetime);
    }
    /*void*/ ThrowKeyedDescriptor()
    {
        throw new InvalidOperationException("Key descriptor misuse");
    }
    /*void*/ ThrowNonKeyedDescriptor()
    {
        throw new InvalidOperationException("Non key descriptor misuse");
    }
}

System
Systemclass System_ServiceProviderExtension extends object
{
    constructor()
    {
        super();
    }
    /*T*/ GetService(T, /*IServiceProvider*/ provider)
    {
        return Tprovider.GetService(T);
    }
    /*object*/ GetRequiredService(/*IServiceProvider*/ provider, /*Type*/ type)
    {
        /*var*/ let t = provider.GetService(type);
        if (t == null)
        {
            throw new InvalidOperationException(type.FullName);
        }
        return t;
    }
    /*T*/ GetRequiredService(T, /*IServiceProvider*/ provider)
    {
        /*var*/ let t = Tprovider.GetService(T);
        if (t == null)
        {
            throw new InvalidOperationException(T.FullName);
        }
        return t;
    }
    /*IEnumerable<ServiceDescriptor>*/ GetServiceDescriptors(/*IServiceCollection*/ services, /*Type*/ serviceType, /*object*/ serviceKey)
    {
        /*var*/ let descriptors = services.Where(function(/**/ s)
        {
s.ServiceType  == serviceType && s.ServiceKey  == serviceKey || s.ServiceKeyEquals(serviceKey) ?? false        });
        if (serviceType.IsGenericType)
        {
            /*var*/ let openGenericType = serviceType.GetGenericTypeDefinition();
            /*var*/ let _descriptors = services.Where(function(/**/ s)
            {
s.ServiceType  == openGenericType            });
            descriptors = descriptors.Concat(_descriptors);
        }
        return descriptors;
    }
    /*void*/ Match(/*IServiceCollection*/ services, /*Type*/ serviceType, /*object*/ serviceKey, /*Action<ServiceDescriptor>*/ action)
    {
        /*var*/ let openGenericType = serviceType.IsGenericType serviceType.GetGenericTypeDefinition()null;
        for(/*int*/ let i = 0; i < services.Count; i++)
        {
            /*var*/ let service = servicesi;
            if (service.ServiceType  == serviceType || openGenericType != null && service.ServiceType  == openGenericType)
            {
                if (service.ServiceKey  == serviceKey || service.ServiceKeyEquals(serviceKey) ?? false)
                {
                    action(service);
                }
            }
        });
    }
}

Systemconst System_Span$_1 = (T) => class extends System_ValueType
{
    /*ReadOnlySpan<T>*/ read = null;
    /*T[]*/ _t = null;
    constructor(/*int*/ length)
    {
        super(new Array(length), 0, length);
    }
    constructor(/*T[]*/ t, /*int*/ offset, /*int*/ length)
    {
        super();
        _t = t;
        read = new ReadOnlySpan_$1(T, t, offset, length);
    }
    /*bool*/ get IsEmpty()
    {
        return read.IsEmpty;
    }
    /*int*/ get Length()
    {
        return read.Length;
    }
    /*int*/ get Offset()
    {
        return read.Offset;
    }
    /*int*/ get Count()
    {
        return read.Length;
    }
    /*T[]*/ get Array()
    {
        return _t;
    }
T    _tindex + Offset;
    _tindex + Offset = value;
Span_$1T    {
        return new Span_$1(T, ts);
    }
    /*void*/ ForEach(/*Func<T, int, bool>*/ iterator)
    {
        read.ForEach(iterator);
    }
    /*Span<T>*/ Slice(/*int*/ start, { /*int*/ length = 1})
    {
        if (length == 1)
        {
            length = Length - start + Offset;
        }
        return new Span_$1(T, _t, start + Offset, length);
    }
    /*void*/ CopyTo(/*Span<T>*/ destination)
    {
        read.CopyTo(destination);
    }
    /*T[]*/ ToArray()
    {
        read.ToArray();
    }
    /*int*/ CopyFrom(/*Stream*/ stream)
    {
        /*var*/ let l = Math.Min(Length, stream.Length);
        stream.Read(_t, Offset, l);
        return l;
    }
    /*int*/ CopyFrom(/*T[]*/ data)
    {
        /*var*/ let l = Math.Min(Length, data.Length);
        for(/*int*/ let i = 0; i < Length; i++)
        {
_ti = datai        });
        return data.Length;
    }
Span_$1Range    Slice(index.Start, index.Length);
    /*bool*/ Contains(/*T*/ t)
    {
        return read.Contains(t);
    }
ReadOnlySpan_$1Span_$1    {
        return span.read;
    }
}

Systemclass System_SpanExtensions extends object
{
    constructor()
    {
        super();
    }
    /*ReadOnlySpan<char>*/ AsSpan(/*string*/ str, { /*int*/ startIndex = 0, /*int*/ length = 1})
    {
        return new ReadOnlySpan_$1(char, strToArray(), startIndex, length);
    }
    /*ReadOnlyMemory<char>*/ AsMemory(/*string*/ str, { /*int*/ startIndex = 0, /*int*/ length = 1})
    {
        return new ReadOnlyMemory_$1(char, strToArray(), startIndex, length);
    }
    /*ReadOnlySpan<T>*/ AsReadOnlySpan(T, /*T[]*/ str, { /*int*/ startIndex = 0, /*int*/ length = 1})
    {
        return new ReadOnlySpan_$1(T, str, startIndex, length);
    }
    /*Span<T>*/ AsSpan(T, /*T[]*/ str, { /*int*/ startIndex = 0, /*int*/ length = 1})
    {
        return new Span_$1(T, str, startIndex, length);
    }
    /*string*/ AsString(/*ReadOnlySpan<char>*/ span)
    {
        /*StringBuilder*/ let builder = new StringBuilder();
        span.ForEach(function(/**/ t, /**/ i)
        {
            builder.Append(t);
            return true;
        });
        return builder.ToString();
    }
    /*string*/ AsString(/*Span<char>*/ span)
    {
        /*StringBuilder*/ let builder = new StringBuilder();
        span.ForEach(function(/**/ t, /**/ i)
        {
            builder.Append(t);
            return true;
        });
        return builder.ToString();
    }
    /*bool*/ IsTrimCandidate(/*char*/ c, { /*ReadOnlySpan<char>?*/ needle = null})
    {
        if (needle == null)
        {
            return .IsWhiteSpace(c);
        }
        return needle.Value.IndexOf(c) >= 0;
    }
    /*ReadOnlySpan<char>*/ TrimStart(/*ReadOnlySpan<char>*/ span, { /*ReadOnlySpan<char>?*/ needle = null})
    {
        /*int*/ let start = 0;
        while(IsTrimCandidate(spanstart, needle) && start < span.Length)
        {
start++        }
        if (span.Length  - 1 >= start)
        {
            return span.Slice(start, span.Length  - start);
        }
        return ReadOnlySpan_$1.Empty;
    }
    /*ReadOnlySpan<char>*/ TrimStart(/*ReadOnlySpan<char>*/ span, { /*string*/ needle = null})
    {
        return span.TrimStart(needle != nullneedle.AsSpan()ReadOnlySpan_$1null);
    }
    /*ReadOnlySpan<char>*/ TrimEnd(/*ReadOnlySpan<char>*/ span, { /*ReadOnlySpan<char>?*/ needle = null})
    {
        /*int*/ let end = span.Length;
        while(IsTrimCandidate(spanend, needle) && end > 0)
        {
end--        }
        if (end >= 0)
        {
            return span.Slice(0, end - 0);
        }
        return ReadOnlySpan_$1.Empty;
    }
    /*ReadOnlySpan<char>*/ TrimEnd(/*ReadOnlySpan<char>*/ span, { /*string*/ needle = null})
    {
        return span.TrimEnd(needle != nullneedle.AsSpan()ReadOnlySpan_$1null);
    }
    /*ReadOnlySpan<char>*/ Trim(/*ReadOnlySpan<char>*/ span, { /*ReadOnlySpan<char>?*/ needle = null})
    {
        return span.TrimStart(needle).TrimEnd(needle);
    }
    /*ReadOnlySpan<char>*/ Trim(/*ReadOnlySpan<char>*/ span, /*char*/ c)
    {
        return span.Trim(c.ToString().AsSpan());
    }
    /*ReadOnlyMemory<char>*/ TrimStart(/*ReadOnlyMemory<char>*/ memory, { /*ReadOnlySpan<char>?*/ sets = null})
    {
        return new ReadOnlyMemory_$1(char, memory.Span.TrimStart(sets));
    }
    /*ReadOnlyMemory<char>*/ TrimStart(/*ReadOnlyMemory<char>*/ memory, /*char*/ c)
    {
        return new ReadOnlyMemory_$1(char, memory.Span.TrimStart(c.ToString().AsSpan()));
    }
    /*ReadOnlyMemory<char>*/ TrimEnd(/*ReadOnlyMemory<char>*/ memory, { /*ReadOnlySpan<char>?*/ sets = null})
    {
        return new ReadOnlyMemory_$1(char, memory.Span.TrimEnd(sets));
    }
    /*ReadOnlyMemory<char>*/ TrimEnd(/*ReadOnlyMemory<char>*/ memory, /*char*/ c)
    {
        return new ReadOnlyMemory_$1(char, memory.Span.TrimEnd(c.ToString().AsSpan()));
    }
    /*ReadOnlyMemory<char>*/ Trim(/*ReadOnlyMemory<char>*/ memory)
    {
        return new ReadOnlyMemory_$1(char, memory.Span.Trim());
    }
    /*ReadOnlyMemory<char>*/ Trim(/*ReadOnlyMemory<char>*/ memory, /*char*/ c)
    {
        return new ReadOnlyMemory_$1(char, memory.Span.Trim(c));
    }
    /*int*/ IndexOf(/*ReadOnlySpan<char>*/ span, /*string*/ sequence)
    {
        /*int*/ let index = 1;
        /*int*/ let seq_i = 0;
        span.ForEach(function(/**/ t, /**/ i)
        {
            if (sequenceseq_i.Equals(t))
            {
                if (index == 1)
                index = i;
                seq_i++;
                if (seq_i >= sequence.Length)
                return false;
            }
            else 
            {
                index = 1;
                seq_i = 0;
            }
            return true;
        });
        return index;
    }
    /*int*/ LastIndexOf(/*ReadOnlySpan<char>*/ span, /*string*/ sequence)
    {
        /*int*/ let index = 1;
        /*int*/ let seq_i = sequence.Length  - 1;
        span.ReverseForEach(function(/**/ t, /**/ i)
        {
            if (sequenceseq_i.Equals(t))
            {
                if (index == 1)
                index = i;
                seq_i--;
                if (seq_i < 0)
                return false;
            }
            else 
            {
                index = 1;
                seq_i = sequence.Length  - 1;
            }
            return true;
        });
        return index;
    }
    /*int*/ IndexOfAny(/*ReadOnlySpan<char>*/ span, /*string*/ chars)
    {
        return span.IndexOfAny(chars.ToArray());
    }
    /*int*/ IndexOfAnyExcept(/*ReadOnlySpan<char>*/ span, /*string*/ chars)
    {
        return span.IndexOfAnyExcept(chars.ToArray());
    }
    /*int*/ IndexOfAnyExceptInRange(/*ReadOnlySpan<char>*/ span, /*char*/ start, /*char*/ end)
    {
        /*int*/ let result = 1;
        span.ForEach(function(/**/ t, /**/ i)
        {
            /*bool*/ let inRange = t > start && t < end;
            if (inRange)
            {
                result = i;
                return false;
            }
            return true;
        });
        return result;
    }
    /*bool*/ ContainsAnyExceptInRange(/*ReadOnlySpan<char>*/ span, /*char*/ start, /*char*/ end)
    {
        /*bool*/ let result = false;
        span.ForEach(function(/**/ t, /**/ i)
        {
            /*bool*/ let inRange = t > start && t < end;
            if (inRange)
            {
                result = true;
                return false;
            }
            return true;
        });
        return result;
    }
    /*bool*/ ContainsAnyExcept(/*ReadOnlySpan<char>*/ span, /*string*/ chars)
    {
        return span.ContainsAnyExcept(chars.ToArray());
    }
    /*bool*/ IsEqual(/*ReadOnlySpan<char>*/ span, /*string*/ other, { /*StringComparison*/ comparison = StringComparison.Ordinal})
    {
        if (span.Length  != other.Length)
        return false;
        /*bool*/ let equals = true;
        span.ForEach(function(/**/ t, /**/ i)
        {
            /*bool*/ let eq = false;
            switch(comparison)
            {
                default:                {
                    eq = t == otheri;
                    break;
                }
                case StringComparison.CurrentCultureIgnoreCase:
                case StringComparison.InvariantCultureIgnoreCase:
                case StringComparison.OrdinalIgnoreCase:
                {
                    eq = .ToLower(t) == .ToLower(otheri);
                    break;
                }
            }
            if (eq)
            {
                return true;
            }
            equals = false;
            return false;
        });
        return equals;
    }
    /*bool*/ StartsWith(/*ReadOnlySpan<char>*/ span, /*string*/ other, { /*StringComparison*/ comparison = StringComparison.Ordinal})
    {
        if (span.Length  < other.Length)
        return false;
        /*bool*/ let starts = true;
        other.AsSpan().ForEach(function(/**/ t, /**/ i)
        {
            /*bool*/ let eq = false;
            switch(comparison)
            {
                default:                {
                    eq = t == spani;
                    break;
                }
                case StringComparison.CurrentCultureIgnoreCase:
                case StringComparison.InvariantCultureIgnoreCase:
                case StringComparison.OrdinalIgnoreCase:
                {
                    eq = .ToLower(t) == .ToLower(spani);
                    break;
                }
            }
            if (eq)
            {
                return true;
            }
            starts = false;
            return false;
        });
        return starts;
    }
}

Systemclass System_StringExtensions extends object
{
    constructor()
    {
        super();
    }
    /*bool*/ Contains(/*string*/ s, /*char*/ c)
    {
        return s.Contains(c.ToString());
    }
    /*bool*/ EndsWith(/*string*/ s, /*char*/ c)
    {
        return s.EndsWith(c.ToString());
    }
    /*bool*/ StartsWith(/*string*/ s, /*char*/ c)
    {
        return s.StartsWith(c.ToString());
    }
    /*string[]*/ Split(/*string*/ s, /*string*/ c)
    {
        throw new NotImplementedException();
    }
}

Systemclass System_TargetInvocationException extends System_Exception
{
    constructor()
    {
        super();
    }
    constructor(/*string*/ message)
    {
        super(message);
    }
    constructor(/*string*/ message, /*Exception*/ innerException)
    {
        super(message, innerException);
    }
}

Systemclass System_TimeOnly extends System_ValueType
{
    constructor()
    {
        super();
    }
}

Systemclass System_TypeExtensions extends object
{
    constructor()
    {
        super();
    }
    /*Type[]*/ FindInterfaces(/*Type*/ type, /*TypeFilter*/ filter, /*object*/ filterCriteria)
    {
        return type.GetInterfaces().Where(function(/**/ t)
        {
filter(t, filterCriteria)        }).ToArray();
    }
    /*IEnumerable<PropertyInfo>*/ GetRuntimeProperties(/*Type*/ type)
    {
        return type.GetProperties();
    }
    /*T*/ GetCustomAttribute(T, /*Type*/ type, { /*bool*/ inherit = false})
    {
        return type.GetCustomAttributes(T, inherit).SingleOrDefault().As(T);
    }
    /*T*/ GetCustomAttribute(T, /*MemberInfo*/ type, { /*bool*/ inherit = false})
    {
        return type.GetCustomAttributes(T, inherit).SingleOrDefault().As(T);
    }
    /*bool*/ IsDefined(T, /*Type*/ type)
    {
        return type.GetCustomAttributes(T, true).Any();
    }
    /*bool*/ IsDefined(/*Type*/ type, /*Type*/ attributeType)
    {
        return type.GetCustomAttributes(attributeType, true).Any();
    }
    /*Type*/ MakeGenericType(/*Type*/ type, /*Type*/ gType)
    {
        return type.MakeGenericType(gType);
    }
    /*Type*/ MakeGenericType(/*Type*/ type, /*Type*/ gType1, /*Type*/ gType2)
    {
        return type.MakeGenericType(gType1gType2);
    }
    /*Type*/ MakeGenericType(/*Type*/ type, /*Type*/ gType1, /*Type*/ gType2, /*Type*/ gType3)
    {
        return type.MakeGenericType(gType1gType2gType3);
    }
}

Systemclass System_UriExtension extends object
{
    constructor()
    {
        super();
    }
    /*bool*/ IsAbsoluteUri(/*Uri*/ uri)
    {
        return uri.AbsoluteUri.StartsWith("http");
    }
    /*string*/ OriginalString(/*Uri*/ uri)
    {
        return uri.ToString();
    }
    /*bool*/ TryCreate(/*string*/ uriString, /*UriKind*/ uriKind, /*Uri*/ uri)
    {
        {
            uri = new Uri(uriString);
        }
        {
            uri = null;
            return false;
        }
        return true;
    }
    /*bool*/ IsHex(/*char*/ c)
    {
        return c >= '0' && c <= '9' || c >= 'A' && c <= 'f' || c >= 'a' && c <= 'f';
    }
    /*byte*/ Nibble(/*char*/ c)
    {
        return c >= '0' && c <= '9'c - '0'c >= 'A' && c <= 'f'c - 'A' + 10c >= 'a' && c <= 'f'c - 'a' + 10        throw new InvalidOperationException(c);
;
    }
    /*bool*/ IsHexEncoding(/*string*/ dataString, /*int*/ index)
    {
        return dataStringindex == '%' && IsHex(dataStringindex + 1) && IsHex(dataStringindex + 1);
    }
    /*int*/ HexUnescape(/*string*/ dataString, /*int*/ index)
    {
        index = index + 1;
        /*int*/ let result = 0;
        while(IsHex(dataStringindex))
        {
            result <<= 4;
            result |= Nibble(dataStringindex);
            index++;
        }
        return result;
    }
    /*char*/ Hex2Char(/*char*/ upper, /*char*/ lower)
    {
        return Nibble(upper) << 4 | Nibble(lower);
    }
    /*void*/ Decode(/*char[]*/ source, /*char[]*/ destination, /*int*/ writtenLength)
    {
        /*int*/ let iSource = 0;
        /*int*/ let iDestination = 0;
        while(iSource < source.Length)
        {
            if (sourceiSource == '%' && iSource + 2 < source.Length  && IsHex(sourceiSource + 1) && IsHex(sourceiSource + 2))
            {
                destinationiDestination++ = Hex2Char(sourceiSource + 1, sourceiSource + 2);
                iSource += 3;
            }
            else 
            {
                destinationiDestination++ = sourceiSource;
                iSource++;
            }
        }
        writtenLength = iDestination;
    }
}

const System_Buffers_ArrayPool$_1 = (T) => class extends object
{
    constructor()
    {
        super();
        T = $_T;
    }
    /*ArrayPool<T>*/ Shared = new ArrayPool_$1(T);
    /*T[]*/ Rent(/*int*/ len)
    {
        return new Array(len);
    }
    /*void*/ Return(/*T[]*/ t)
    {
    }
}

 = 0 = 1 = 2 = 3
const System_Collections_Concurrent_ConcurrentDictionary$_2 = (TKey, TValue) => class extends System_Collections_Generic_Dictionary(TKey, TValue)
{
    constructor()
    {
        super();
    }
    constructor(/*int*/ capacity)
    {
        super(capacity);
    }
    /*TValue*/ GetOrAdd(/*TKey*/ key, /*Func<TKey, TValue>*/ create)
    {
        let value = null;
        let $v = { value: set(value){ value = value; } };
        if (TryGetValue(key, $v))
        return value;
        value = create(key);
        key = value;
        return value;
    }
    /*TValue*/ GetOrAdd(T, /*TKey*/ key, /*Func<TKey, T, TValue>*/ create, /*T*/ t)
    {
        let value = null;
        let $v = { value: set(value){ value = value; } };
        if (TryGetValue(key, $v))
        return value;
        value = create(key, t);
        key = value;
        return value;
    }
    /*bool*/ TryRemove(/*TKey*/ key, /*TValue*/ value)
    {
        let $v = { value: set(value){ value = value; } };
        if (TryGetValue(key, $v))
        {
            return true;
        }
        value = default;
        return false;
    }
}

class System_Collections_Generic_DictionaryExtension extends object
{
    constructor()
    {
        super();
    }
    /*TValue*/ GetOrAdd(TKey, TValue, /*Dictionary<TKey, TValue>*/ dictionary, /*TKey*/ key, /*Func<TKey, TValue>*/ createValue)
    {
        let value = null;
        let $v = { value: set(value){ value = value; } };
        if (dictionary.TryGetValue(key, $v))
        return value;
        value = createValue(key);
        dictionarykey = value;
        return value;
    }
}

class System_Collections_Specialized_NameValueCollection extends System_Collections_Generic_Dictionary(string, object)
{
    constructor()
    {
        super();
    }
    /*string[]*/ get AllKeys()
    {
        return super.Keys.ToArray();
    }
    Dictionary_$2nameToString();
    Dictionary_$2name = value;
    /*void*/ Add(/*string*/ name, /*string*/ value)
    {
        let evalue = null;
        let $v = { value: set(value){ evalue = value; } };
        if (super.TryGetValue(name, $v) && evalue != null)
        {
            value += evalue + ";" + value;
        }
        super.Add(name, value);
    }
    /*string[]*/ GetValues(/*string*/ name)
    {
        let evalue = null;
        let $v = { value: set(value){ evalue = value; } };
        if (super.TryGetValue(name, $v))
        {
            return evalueToString().Split(';');
        }
        return null;
    }
}

class System_ComponentModel_TypeDescriptor extends object
{
    constructor()
    {
        super();
    }
    /*TypeDescriptor*/ GetConverter(/*Type*/ type)
    {
        throw new NotImplementedException();
    }
    /*object*/ ConvertFromInvariantString(/*string*/ text)
    {
        throw new NotImplementedException();
    }
}





class System_ComponentModel_DataAnnotations_AssociationAttribute extends System_Attribute
{
    /*string*/ name = null;
    /*string*/ thisKey = null;
    /*string*/ otherKey = null;
    /*bool*/ isForeignKey = null;
    constructor(/*string*/ name, /*string*/ thisKey, /*string*/ otherKey)
    {
        super();
        .name  = name;
        .thisKey  = thisKey;
        .otherKey  = otherKey;
    }
    /*string*/ get Name()
    {
        return .name;
    }
    /*string*/ get ThisKey()
    {
        return .thisKey;
    }
    /*string*/ get OtherKey()
    {
        return .otherKey;
    }
    /*bool*/ get IsForeignKey()
    {
        return .isForeignKey;
    }
    /*bool*/ set IsForeignKey(value)
    {
        .isForeignKey  = value;
    }
    /*IEnumerable<string>*/ get ThisKeyMembers()
    {
        return GetKeyMembers(.ThisKey);
    }
    /*IEnumerable<string>*/ get OtherKeyMembers()
    {
        return GetKeyMembers(.OtherKey);
    }
    /*string[]*/ GetKeyMembers(/*string*/ key)
    {
        return key.Replace(" ", .Empty).Split(',');
    }
}

class System_ComponentModel_DataAnnotations_BindableTypeAttribute extends System_Attribute
{
    constructor()
    {
        super();
        IsBindable = true;
    }
    /*bool*/ _backingField_IsBindable = null;
    /*bool*/ get IsBindable()
    {
        return _backingField_IsBindable;
    }
    /*bool*/ set IsBindable(value)
    {
        _backingField_IsBindable = value;
    }
}

class System_ComponentModel_DataAnnotations_CompareAttribute extends System_ComponentModel_DataAnnotations_ValidationAttribute
{
    constructor(/*string*/ otherProperty)
    {
        super("CompareAttribute_MustMatch");
        if (otherProperty == null)
        {
            throw new ArgumentNullException("otherProperty");
        }
        OtherProperty = otherProperty;
    }
    /*string*/ _backingField_OtherProperty = null;
    /*string*/ get OtherProperty()
    {
        return _backingField_OtherProperty;
    }
    /*string*/ set OtherProperty(value)
    {
        _backingField_OtherProperty = value;
    }
    /*string*/ _backingField_OtherPropertyDisplayName = null;
    /*string*/ get OtherPropertyDisplayName()
    {
        return _backingField_OtherPropertyDisplayName;
    }
    /*string*/ set OtherPropertyDisplayName(value)
    {
        _backingField_OtherPropertyDisplayName = value;
    }
    /*string*/ FormatErrorMessage(/*string*/ name)
    {
        return String.Format(CultureInfo.CurrentCulture, ErrorMessageString, name, OtherPropertyDisplayName ?? OtherProperty);
    }
    /*bool*/ get RequiresValidationContext()
    {
        return true;
    }
    /*ValidationResult*/ IsValid(/*object*/ value, /*ValidationContext*/ validationContext)
    {
        /*PropertyInfo*/ let otherPropertyInfo = validationContext.ObjectType.GetProperty(OtherProperty);
        if (otherPropertyInfo == null)
        {
            return new ValidationResult("CompareAttribute_UnknownProperty" + OtherProperty);
        }
        /*object*/ let otherPropertyValue = otherPropertyInfo.GetValue(validationContext.ObjectInstance, null);
        if (Equals(value, otherPropertyValue))
        {
            if (OtherPropertyDisplayName == null)
            {
                OtherPropertyDisplayName = GetDisplayNameForProperty(validationContext.ObjectType, OtherProperty);
            }
            return new ValidationResult(FormatErrorMessage(validationContext.DisplayName));
        }
        return null;
    }
    /*string*/ GetDisplayNameForProperty(/*Type*/ containerType, /*string*/ propertyName)
    {
        /*//ICustomTypeDescriptor typeDescriptor = GetTypeDescriptor(containerType);
            //PropertyDescriptor property = typeDescriptor.GetProperties().Find(propertyName, true);
            var*/ let property = containerType.GetProperty(propertyName);
        if (property == null)
        {
            throw new ArgumentException("Common_PropertyNotFound");
        }
        /*IEnumerable<Attribute>*/ let attributes = property.GetCustomAttributes().Cast(Attribute);
        /*DisplayAttribute*/ let display = attributes.OfType(DisplayAttribute).FirstOrDefault();
        if (display != null)
        {
            return display.GetName();
        }
        return propertyName;
    }
}

class System_ComponentModel_DataAnnotations_ConcurrencyCheckAttribute extends System_Attribute
{
    constructor()
    {
        super();
    }
}

class System_ComponentModel_DataAnnotations_CreditCardAttribute extends System_ComponentModel_DataAnnotations_DataTypeAttribute
{
    constructor()
    {
        super(DataType.CreditCard);
        // DevDiv 468241: set DefaultErrorMessage not ErrorMessage, allowing user to set
            // ErrorMessageResourceType and ErrorMessageResourceName to use localized messages.
            DefaultErrorMessage = "CreditCardAttribute_Invalid";
    }
    /*bool*/ IsValid(/*object*/ value)
    {
        if (value == null)
        {
            return true;
        }
        /*string*/ let ccValue = value as ;
        if (ccValue == null)
        {
            return false;
        }
        ccValue = ccValue.Replace("-", "");
        ccValue = ccValue.Replace(" ", "");
        /*int*/ let checksum = 0;
        /*bool*/ let evenDigit = false;
        BlazorJs.forEach(ccValue.Reverse(), function(digit, $_i)
        {
            if (digit < '0' || digit > '9')
            {
                return false;
            }
            /*int*/ let digitValue = digit - '0' * evenDigit21;
            evenDigit = evenDigit;
            while(digitValue > 0)
            {
                checksum += digitValue % 10;
                digitValue /= 10;
            }
        });
        return checksum % 10 == 0;
    }
}

class System_ComponentModel_DataAnnotations_CustomValidationAttribute extends System_ComponentModel_DataAnnotations_ValidationAttribute
{
    /*Type*/ _validatorType = null;
    /*string*/ _method = null;
    /*MethodInfo*/ _methodInfo = null;
    /*bool*/ _isSingleArgumentMethod = null;
    /*string*/ _lastMessage = null;
    /*Type*/ _valuesType = null;
    /*Tuple<string, Type>*/ _typeId = null;
    constructor(/*Type*/ validatorType, /*string*/ method)
    {
        super(function()
        {
            return "CustomValidationAttribute_ValidationError";
        });
        ._validatorType  = validatorType;
        ._method  = method;
    }
    /*Type*/ get ValidatorType()
    {
        return ._validatorType;
    }
    /*string*/ get Method()
    {
        return ._method;
    }
    /*ValidationResult*/ IsValid(/*object*/ value, /*ValidationContext*/ validationContext)
    {
        .ThrowIfAttributeNotWellFormed();
        /*MethodInfo*/ let methodInfo = ._methodInfo;
        /*// If the value is not of the correct type and cannot be converted, fail
            // to indicate it is not acceptable.  The convention is that IsValid is merely a probe,
            // and clients are not expecting exceptions.
            object*/ let convertedValue;
        let $v = { value: set(value){ convertedValue = value; } };
        if (.TryConvertValue(value, $v))
        {
            return new ValidationResult("CustomValidationAttribute_Type_Conversion_Failed");
        }
        /*// Invoke the method.  Catch TargetInvocationException merely to unwrap it.
            // Callers don't know Reflection is being used and will not typically see
            // the real exception
            //try {
            // 1-parameter form is ValidationResult Method(object value)
            // 2-parameter form is ValidationResult Method(object value, ValidationContext context),
            object[]*/ let methodParams = ._isSingleArgumentMethod
[ convertedValue ][ convertedValuevalidationContext ];
        /*ValidationResult*/ let result = ValidationResultmethodInfo.Invoke(null, methodParams);
        ._lastMessage  = null;
        if (result != null)
        {
            ._lastMessage  = result.ErrorMessage;
        }
        return result;
    }
    /*string*/ FormatErrorMessage(/*string*/ name)
    {
        .ThrowIfAttributeNotWellFormed();
        if (.IsNullOrEmpty(._lastMessage))
        {
            return String.Format(CultureInfo.CurrentCulture, ._lastMessage, name);
        }
        return super.FormatErrorMessage(name);
    }
    /*string*/ CheckAttributeWellFormed()
    {
        return .ValidateValidatorTypeParameter() ?? .ValidateMethodParameter();
    }
    /*string*/ ValidateValidatorTypeParameter()
    {
        if (._validatorType  == null)
        {
            return "CustomValidationAttribute_ValidatorType_Required";
        }
        return null;
    }
    /*string*/ ValidateMethodParameter()
    {
        if (String.IsNullOrEmpty(._method))
        {
            return "CustomValidationAttribute_Method_Required";
        }
        /*// Named method must be public and static
            MethodInfo*/ let methodInfo = ._validatorType.GetMethod(._method, BindingFlags.Public  | BindingFlags.Static);
        if (methodInfo == null)
        {
            return "CustomValidationAttribute_Method_Not_Found";
        }
        if (methodInfo.ReturnType  != ValidationResult)
        {
            return "CustomValidationAttribute_Method_Must_Return_ValidationResult";
        }
        /*ParameterInfo[]*/ let parameterInfos = methodInfo.GetParameters();
        if (parameterInfos.Length  == 0)
        {
            return "CustomValidationAttribute_Method_Signature";
        }
        ._isSingleArgumentMethod  = parameterInfos.Length  == 1;
        if (._isSingleArgumentMethod)
        {
            if (parameterInfos.Length  != 2 || parameterInfos1.ParameterType  != ValidationContext)
            {
                return "CustomValidationAttribute_Method_Signature";
            }
        }
        ._methodInfo  = methodInfo;
        ._valuesType  = parameterInfos0.ParameterType;
        return null;
    }
    /*void*/ ThrowIfAttributeNotWellFormed()
    {
        /*string*/ let errorMessage = CheckAttributeWellFormed();
        if (errorMessage != null)
        {
            throw new InvalidOperationException(errorMessage);
        }
    }
    /*bool*/ TryConvertValue(/*object*/ value, /*object*/ convertedValue)
    {
        convertedValue = null;
        /*Type*/ let t = ._valuesType;
        if (value == null)
        {
            if (t.IsValueType  && t.IsGenericType  || t.GetGenericTypeDefinition() != Nullable_$1)
            {
                return false;
            }
            return true;
        }
        if (t.IsAssignableFrom(value.GetType()))
        {
            convertedValue = value;
            return true;
        }
        {
            convertedValue = Convert.ChangeType(value, t, CultureInfo.CurrentCulture);
            return true;
        }
FormatException        {
            return false;
        }
InvalidCastException        {
            return false;
        }
NotSupportedException        {
            return false;
        }
    }
}


class System_ComponentModel_DataAnnotations_DataTypeAttribute extends System_ComponentModel_DataAnnotations_ValidationAttribute
{
    /*DataType*/ _backingField_DataType = null;
    /*DataType*/ get DataType()
    {
        return _backingField_DataType;
    }
    /*DataType*/ set DataType(value)
    {
        _backingField_DataType = value;
    }
    /*string*/ _backingField_CustomDataType = null;
    /*string*/ get CustomDataType()
    {
        return _backingField_CustomDataType;
    }
    /*string*/ set CustomDataType(value)
    {
        _backingField_CustomDataType = value;
    }
    /*string*/ GetDataTypeName()
    {
        .EnsureValidDataType();
        if (DataType == DataType.Custom)
        {
            return .CustomDataType;
        }
        else 
        {
            return _dataTypeStringsDataType;
        }
    }
    /*DisplayFormatAttribute*/ _backingField_DisplayFormat = null;
    /*DisplayFormatAttribute*/ get DisplayFormat()
    {
        return _backingField_DisplayFormat;
    }
    /*DisplayFormatAttribute*/ set DisplayFormat(value)
    {
        _backingField_DisplayFormat = value;
    }
    constructor(/*DataType*/ dataType)
    {
        super();
        DataType = dataType;
        switch(dataType)
        {
            case DataType.Date:
            {
                .DisplayFormat  = new DisplayFormatAttribute();
                .DisplayFormat.DataFormatString  = "{0:d}";
                .DisplayFormat.ApplyFormatInEditMode  = true;
                break;
            }
            case DataType.Time:
            {
                .DisplayFormat  = new DisplayFormatAttribute();
                .DisplayFormat.DataFormatString  = "{0:t}";
                .DisplayFormat.ApplyFormatInEditMode  = true;
                break;
            }
            case DataType.Currency:
            {
                .DisplayFormat  = new DisplayFormatAttribute();
                .DisplayFormat.DataFormatString  = "{0:C}";
                break;
            }
        }
    }
    constructor(/*string*/ customDataType)
    {
        super(DataType.Custom);
        .CustomDataType  = customDataType;
    }
    /*bool*/ IsValid(/*object*/ value)
    {
        .EnsureValidDataType();
        return true;
    }
    /*void*/ EnsureValidDataType()
    {
        if (.DataType  == DataType.Custom  && String.IsNullOrEmpty(.CustomDataType))
        {
            throw new InvalidOperationException("DataTypeAttribute_EmptyDataTypeString");
        }
    }
    /*string[]*/ _dataTypeStrings = Enum.GetNames(DataType);
}

class System_ComponentModel_DataAnnotations_DisplayAttribute extends System_Attribute
{
    /*Type*/ _resourceType = null;
    /*LocalizableString*/ _shortName = new LocalizableString("ShortName");
    /*LocalizableString*/ _name = new LocalizableString("Name");
    /*LocalizableString*/ _description = new LocalizableString("Description");
    /*LocalizableString*/ _prompt = new LocalizableString("Prompt");
    /*LocalizableString*/ _groupName = new LocalizableString("GroupName");
    /*bool?*/ _autoGenerateField = null;
    /*bool?*/ _autoGenerateFilter = null;
    /*int?*/ _order = null;
    constructor()
    {
        super();
    }
    /*string*/ get ShortName()
    {
        return ._shortName.Value;
    }
    /*string*/ set ShortName(value)
    {
        if (._shortName.Value  != value)
        {
            ._shortName.Value  = value;
        }
    }
    /*string*/ get Name()
    {
        return ._name.Value;
    }
    /*string*/ set Name(value)
    {
        if (._name.Value  != value)
        {
            ._name.Value  = value;
        }
    }
    /*string*/ get Description()
    {
        return ._description.Value;
    }
    /*string*/ set Description(value)
    {
        if (._description.Value  != value)
        {
            ._description.Value  = value;
        }
    }
    /*string*/ get Prompt()
    {
        return ._prompt.Value;
    }
    /*string*/ set Prompt(value)
    {
        if (._prompt.Value  != value)
        {
            ._prompt.Value  = value;
        }
    }
    /*string*/ get GroupName()
    {
        return ._groupName.Value;
    }
    /*string*/ set GroupName(value)
    {
        if (._groupName.Value  != value)
        {
            ._groupName.Value  = value;
        }
    }
    /*Type*/ get ResourceType()
    {
        return ._resourceType;
    }
    /*Type*/ set ResourceType(value)
    {
        if (._resourceType  != value)
        {
            ._resourceType  = value;
            ._shortName.ResourceType  = value;
            ._name.ResourceType  = value;
            ._description.ResourceType  = value;
            ._prompt.ResourceType  = value;
            ._groupName.ResourceType  = value;
        }
    }
    /*bool*/ get AutoGenerateField()
    {
        if (._autoGenerateField.HasValue)
        {
            throw new InvalidOperationException("DisplayAttribute_PropertyNotSet");
        }
        return ._autoGenerateField.Value;
    }
    /*bool*/ set AutoGenerateField(value)
    {
        ._autoGenerateField  = value;
    }
    /*bool*/ get AutoGenerateFilter()
    {
        if (._autoGenerateFilter.HasValue)
        {
            throw new InvalidOperationException("DisplayAttribute_PropertyNotSet");
        }
        return ._autoGenerateFilter.Value;
    }
    /*bool*/ set AutoGenerateFilter(value)
    {
        ._autoGenerateFilter  = value;
    }
    /*int*/ get Order()
    {
        if (._order.HasValue)
        {
            throw new InvalidOperationException("DisplayAttribute_PropertyNotSet");
        }
        return ._order.Value;
    }
    /*int*/ set Order(value)
    {
        ._order  = value;
    }
    /*string*/ GetShortName()
    {
        return ._shortName.GetLocalizableValue() ?? .GetName();
    }
    /*string*/ GetName()
    {
        return ._name.GetLocalizableValue();
    }
    /*string*/ GetDescription()
    {
        return ._description.GetLocalizableValue();
    }
    /*string*/ GetPrompt()
    {
        return ._prompt.GetLocalizableValue();
    }
    /*string*/ GetGroupName()
    {
        return ._groupName.GetLocalizableValue();
    }
    /*bool?*/ GetAutoGenerateField()
    {
        return ._autoGenerateField;
    }
    /*bool?*/ GetAutoGenerateFilter()
    {
        return ._autoGenerateFilter;
    }
    /*int?*/ GetOrder()
    {
        return ._order;
    }
}

class System_ComponentModel_DataAnnotations_DisplayColumnAttribute extends System_Attribute
{
    constructor(/*string*/ displayColumn)
    {
        super(displayColumn, null);
    }
    constructor(/*string*/ displayColumn, /*string*/ sortColumn)
    {
        super(displayColumn, sortColumn, false);
    }
    constructor(/*string*/ displayColumn, /*string*/ sortColumn, /*bool*/ sortDescending)
    {
        super();
        .DisplayColumn  = displayColumn;
        .SortColumn  = sortColumn;
        .SortDescending  = sortDescending;
    }
    /*string*/ _backingField_DisplayColumn = null;
    /*string*/ get DisplayColumn()
    {
        return _backingField_DisplayColumn;
    }
    /*string*/ set DisplayColumn(value)
    {
        _backingField_DisplayColumn = value;
    }
    /*string*/ _backingField_SortColumn = null;
    /*string*/ get SortColumn()
    {
        return _backingField_SortColumn;
    }
    /*string*/ set SortColumn(value)
    {
        _backingField_SortColumn = value;
    }
    /*bool*/ _backingField_SortDescending = null;
    /*bool*/ get SortDescending()
    {
        return _backingField_SortDescending;
    }
    /*bool*/ set SortDescending(value)
    {
        _backingField_SortDescending = value;
    }
}

class System_ComponentModel_DataAnnotations_DisplayFormatAttribute extends System_Attribute
{
    /*string*/ _backingField_DataFormatString = null;
    /*string*/ get DataFormatString()
    {
        return _backingField_DataFormatString;
    }
    /*string*/ set DataFormatString(value)
    {
        _backingField_DataFormatString = value;
    }
    /*string*/ _backingField_NullDisplayText = null;
    /*string*/ get NullDisplayText()
    {
        return _backingField_NullDisplayText;
    }
    /*string*/ set NullDisplayText(value)
    {
        _backingField_NullDisplayText = value;
    }
    /*bool*/ _backingField_ConvertEmptyStringToNull = null;
    /*bool*/ get ConvertEmptyStringToNull()
    {
        return _backingField_ConvertEmptyStringToNull;
    }
    /*bool*/ set ConvertEmptyStringToNull(value)
    {
        _backingField_ConvertEmptyStringToNull = value;
    }
    /*bool*/ _backingField_ApplyFormatInEditMode = null;
    /*bool*/ get ApplyFormatInEditMode()
    {
        return _backingField_ApplyFormatInEditMode;
    }
    /*bool*/ set ApplyFormatInEditMode(value)
    {
        _backingField_ApplyFormatInEditMode = value;
    }
    /*bool*/ _backingField_HtmlEncode = null;
    /*bool*/ get HtmlEncode()
    {
        return _backingField_HtmlEncode;
    }
    /*bool*/ set HtmlEncode(value)
    {
        _backingField_HtmlEncode = value;
    }
    constructor()
    {
        super();
        .ConvertEmptyStringToNull  = true;
        .HtmlEncode  = true;
    }
}

class System_ComponentModel_DataAnnotations_EditableAttribute extends System_Attribute
{
    /*bool*/ _backingField_AllowEdit = null;
    /*bool*/ get AllowEdit()
    {
        return _backingField_AllowEdit;
    }
    /*bool*/ set AllowEdit(value)
    {
        _backingField_AllowEdit = value;
    }
    /*bool*/ _backingField_AllowInitialValue = null;
    /*bool*/ get AllowInitialValue()
    {
        return _backingField_AllowInitialValue;
    }
    /*bool*/ set AllowInitialValue(value)
    {
        _backingField_AllowInitialValue = value;
    }
    constructor(/*bool*/ allowEdit)
    {
        super();
        .AllowEdit  = allowEdit;
        .AllowInitialValue  = allowEdit;
    }
}

class System_ComponentModel_DataAnnotations_EmailAddressAttribute extends System_ComponentModel_DataAnnotations_DataTypeAttribute
{
    /*Regex*/ _regex = CreateRegEx();
    constructor()
    {
        super(DataType.EmailAddress);
        // DevDiv 468241: set DefaultErrorMessage not ErrorMessage, allowing user to set
            // ErrorMessageResourceType and ErrorMessageResourceName to use localized messages.
            DefaultErrorMessage = "EmailAddressAttribute_Invalid";
    }
    /*bool*/ IsValid(/*object*/ value)
    {
        if (value == null)
        {
            return true;
        }
        /*string*/ let valueAsString = value as ;
        if (_regex != null)
        {
            return valueAsString != null && _regex.Match(valueAsString).Length  > 0;
        }
        else 
        {
            /*int*/ let atCount = 0;
            BlazorJs.forEach(valueAsString, function(c, $_i)
            {
                if (c == '@')
                {
                    atCount++;
                }
            });
            return valueAsString != null && atCount == 1 && valueAsString0 != '@' && valueAsStringvalueAsString.Length  - 1 != '@';
        }
    }
    /*Regex*/ CreateRegEx()
    {
        /*string*/ let pattern = @"^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?$";
        /*RegexOptions*/ let options = RegexOptions.IgnoreCase  | RegexOptions.ExplicitCapture;
        /*// Set explicit regex match timeout, sufficient enough for email parsing
            // Unless the global REGEX_DEFAULT_MATCH_TIMEOUT is already set
            TimeSpan*/ let matchTimeout = TimeSpan.FromSeconds(2);
        {
            return new Regex(pattern, options, matchTimeout);
        }
        {
        }
        return new Regex(pattern, options);
    }
}

class System_ComponentModel_DataAnnotations_EnumDataTypeAttribute extends System_ComponentModel_DataAnnotations_DataTypeAttribute
{
    /*Type*/ _backingField_EnumType = null;
    /*Type*/ get EnumType()
    {
        return _backingField_EnumType;
    }
    /*Type*/ set EnumType(value)
    {
        _backingField_EnumType = value;
    }
    constructor(/*Type*/ enumType)
    {
        super("Enumeration");
        .EnumType  = enumType;
    }
    /*bool*/ IsValid(/*object*/ value)
    {
        if (.EnumType  == null)
        {
            throw new InvalidOperationException("EnumDataTypeAttribute_TypeCannotBeNull");
        }
        if (.EnumType.IsEnum)
        {
            throw new InvalidOperationException("EnumDataTypeAttribute_TypeNeedsToBeAnEnum");
        }
        if (value == null)
        {
            return true;
        }
        /*string*/ let stringValue = value as ;
        if (stringValue != null && String.IsNullOrEmpty(stringValue))
        {
            return true;
        }
        /*Type*/ let valueType = value.GetType();
        if (valueType.IsEnum  && .EnumType  != valueType)
        {
            return false;
        }
        if (valueType.IsValueType  && valueType != )
        {
            return false;
        }
        if (valueType ==  || valueType ==  || valueType ==  || valueType ==  || valueType == )
        {
            return false;
        }
        /*object*/ let convertedValue;
        if (valueType.IsEnum)
        {
            Debug.Assert(valueType == value.GetType(), "The valueType should equal the Type of the value");
            convertedValue = value;
        }
        else 
        {
            {
                if (stringValue != null)
                {
                    convertedValue = Enum.Parse(.EnumType, stringValue, false);
                }
                else 
                {
                    convertedValue = Enum.ToObject(.EnumType, value);
                }
            }
ArgumentException            {
                return false;
            }
        }
        if (IsEnumTypeInFlagsMode(.EnumType))
        {
            /*// 



                string*/ let underlying = GetUnderlyingTypeValueString(.EnumType, convertedValue);
            /*string*/ let converted = convertedValue.ToString();
            return underlying.Equals(converted);
        }
        else 
        {
            return Enum.IsDefined(.EnumType, convertedValue);
        }
    }
    /*bool*/ IsEnumTypeInFlagsMode(/*Type*/ enumType)
    {
        return enumType.GetCustomAttributes(FlagsAttribute, false).Length  != 0;
    }
    /*string*/ GetUnderlyingTypeValueString(/*Type*/ enumType, /*object*/ enumValue)
    {
        return Convert.ChangeType(enumValue, enumType/*)*/, CultureInfo.InvariantCulture).ToString();
    }
}

class System_ComponentModel_DataAnnotations_FileExtensionsAttribute extends System_ComponentModel_DataAnnotations_DataTypeAttribute
{
    /*string*/ _extensions = null;
    constructor()
    {
        super(DataType.Upload);
        // DevDiv 468241: set DefaultErrorMessage not ErrorMessage, allowing user to set
            // ErrorMessageResourceType and ErrorMessageResourceName to use localized messages.
            DefaultErrorMessage = "FileExtensionsAttribute_Invalid";
    }
    /*string*/ get Extensions()
    {
        return String.IsNullOrWhiteSpace(_extensions)"png,jpg,jpeg,gif"_extensions;
    }
    /*string*/ set Extensions(value)
    {
        _extensions = value;
    }
    /*string*/ get ExtensionsFormatted()
    {
        return ExtensionsParsed.Aggregate(function(/**/ left, /**/ right)
        {
            return left + ", " + right;
        });
    }
    /*string*/ get ExtensionsNormalized()
    {
        return Extensions.Replace(" ", "").Replace(".", "").ToLower();
    }
    /*IEnumerable<string>*/ get ExtensionsParsed()
    {
        return ExtensionsNormalized.Split(',').Select(function(/**/ e)
        {
"." + e        });
    }
    /*string*/ FormatErrorMessage(/*string*/ name)
    {
        return String.Format(CultureInfo.CurrentCulture, ErrorMessageString, name, ExtensionsFormatted);
    }
    /*bool*/ IsValid(/*object*/ value)
    {
        if (value == null)
        {
            return true;
        }
        /*string*/ let valueAsString = value as ;
        if (valueAsString != null)
        {
            return ValidateExtension(valueAsString);
        }
        return false;
    }
    /*bool*/ ValidateExtension(/*string*/ fileName)
    {
        {
            return ExtensionsParsed.Contains(Path.GetExtension(fileName).ToLower());
        }
ArgumentException        {
            return false;
        }
    }
}

class System_ComponentModel_DataAnnotations_FilterUIHintAttribute extends System_Attribute
{
    /*UIHintAttribute.UIHintImplementation*/ _implementation = null;
    /*string*/ get FilterUIHint()
    {
        return ._implementation.UIHint;
    }
    /*string*/ get PresentationLayer()
    {
        return ._implementation.PresentationLayer;
    }
    /*IDictionary<string, object>*/ get ControlParameters()
    {
        return ._implementation.ControlParameters;
    }
    constructor(/*string*/ filterUIHint)
    {
        super(filterUIHint, null, new Array(0));
    }
    constructor(/*string*/ filterUIHint, /*string*/ presentationLayer)
    {
        super(filterUIHint, presentationLayer, new Array(0));
    }
    constructor(/*string*/ filterUIHint, /*string*/ presentationLayer, /*object[]*/ controlParameters)
    {
        super();
        ._implementation  = new UIHintAttributeUIHintImplementation(filterUIHint, presentationLayer, controlParameters);
    }
    /*int*/ GetHashCode()
    {
        return ._implementation.GetHashCode();
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        /*var*/ let otherAttribute = obj as FilterUIHintAttribute;
        if (otherAttribute == null)
        {
            return false;
        }
        return ._implementation.Equals(otherAttribute._implementation);
    }
}

const System_ComponentModel_DataAnnotations_IValidatableObject = (Base) => class extends Base
{
}

class System_ComponentModel_DataAnnotations_KeyAttribute extends System_Attribute
{
    constructor()
    {
        super();
    }
}

class System_ComponentModel_DataAnnotations_LocalAppContextSwitches extends object
{
    constructor()
    {
        super();
    }
    /*bool*/ get UseLegacyRegExTimeout()
    {
        return false;
    }
}

class System_ComponentModel_DataAnnotations_LocalizableString extends object
{
    /*string*/ _propertyName = null;
    /*string*/ _propertyValue = null;
    /*Type*/ _resourceType = null;
    /*Func<string>*/ _cachedResult = null;
    constructor(/*string*/ propertyName)
    {
        super();
        ._propertyName  = propertyName;
    }
    /*string*/ get Value()
    {
        return ._propertyValue;
    }
    /*string*/ set Value(value)
    {
        if (._propertyValue  != value)
        {
            .ClearCache();
            ._propertyValue  = value;
        }
    }
    /*Type*/ get ResourceType()
    {
        return ._resourceType;
    }
    /*Type*/ set ResourceType(value)
    {
        if (._resourceType  != value)
        {
            .ClearCache();
            ._resourceType  = value;
        }
    }
    /*void*/ ClearCache()
    {
        ._cachedResult  = null;
    }
    /*string*/ GetLocalizableValue()
    {
        if (._cachedResult  == null)
        {
            if (._propertyValue  == null || ._resourceType  == null)
            {
                ._cachedResult  = function()
                {
                    return ._propertyValue;
                };
            }
            else 
            {
                /*// Get the property from the resource type for this resource key
                    PropertyInfo*/ let property = ._resourceType.GetProperty(._propertyValue);
                /*// We need to detect bad configurations so that we can throw exceptions accordingly
                    bool*/ let badlyConfigured = false;
                if (property == null || property.PropertyType  != )
                {
                    badlyConfigured = true;
                }
                else 
                {
                    /*// Ensure the getter for the property is available as public static
                        MethodInfo*/ let getter = property.GetMethod;
                    if (getter == null || getter.IsPublic  && getter.IsStatic)
                    {
                        badlyConfigured = true;
                    }
                }
                if (badlyConfigured)
                {
                    /*string*/ let exceptionMessage = "LocalizableString_LocalizationFailed";
                    ._cachedResult  = function()
                    {
                        throw new InvalidOperationException(exceptionMessage);
                    };
                }
                else 
                {
                    ._cachedResult  = function()
                    {
                        return property.GetValue(null, null);
                    };
                }
            }
        }
        return ._cachedResult();
    }
}

class System_ComponentModel_DataAnnotations_MaxLengthAttribute extends System_ComponentModel_DataAnnotations_ValidationAttribute
{
    /*int*/ MaxAllowableLength = 1;
    /*int*/ _backingField_Length = null;
    /*int*/ get Length()
    {
        return _backingField_Length;
    }
    /*int*/ set Length(value)
    {
        _backingField_Length = value;
    }
    constructor(/*int*/ length)
    {
        super(function()
        {
            return DefaultErrorMessageString;
        });
        Length = length;
    }
    constructor()
    {
        super(function()
        {
            return DefaultErrorMessageString;
        });
        Length = MaxAllowableLength;
    }
    /*string*/ get DefaultErrorMessageString()
    {
        return "MaxLengthAttribute_ValidationError";
    }
    /*bool*/ IsValid(/*object*/ value)
    {
        // Check the lengths for legality
            EnsureLegalLengths();
        /*var*/ let length = 0;
        if (value == null)
        {
            return true;
        }
        else 
        {
            /*var*/ let str = value as ;
            if (str != null)
            {
                length = str.Length;
            }
            else 
            {
                // We expect a cast exception if a non-{string|array} property was passed in.
                    length = Arrayvalue.Length;
            }
        }
        return MaxAllowableLength == Length || length <= Length;
    }
    /*string*/ FormatErrorMessage(/*string*/ name)
    {
        return .Format(CultureInfo.CurrentCulture, ErrorMessageString, name, Length);
    }
    /*void*/ EnsureLegalLengths()
    {
        if (Length == 0 || Length < 1)
        {
            throw new InvalidOperationException("MaxLengthAttribute_InvalidMaxLength");
        }
    }
}


class System_ComponentModel_DataAnnotations_MetadataTypeAttribute extends System_Attribute
{
    /*Type*/ _metadataClassType = null;
    /*Type*/ get MetadataClassType()
    {
        if (_metadataClassType == null)
        {
            throw new InvalidOperationException("MetadataTypeAttribute_TypeCannotBeNull");
        }
        return _metadataClassType;
    }
    constructor(/*Type*/ metadataClassType)
    {
        super();
        _metadataClassType = metadataClassType;
    }
}

class System_ComponentModel_DataAnnotations_MinLengthAttribute extends System_ComponentModel_DataAnnotations_ValidationAttribute
{
    /*int*/ _backingField_Length = null;
    /*int*/ get Length()
    {
        return _backingField_Length;
    }
    /*int*/ set Length(value)
    {
        _backingField_Length = value;
    }
    constructor(/*int*/ length)
    {
        super("MinLengthAttribute_ValidationError");
        Length = length;
    }
    /*bool*/ IsValid(/*object*/ value)
    {
        // Check the lengths for legality
            EnsureLegalLengths();
        /*var*/ let length = 0;
        if (value == null)
        {
            return true;
        }
        else 
        {
            /*var*/ let str = value as ;
            if (str != null)
            {
                length = str.Length;
            }
            else 
            {
                // We expect a cast exception if a non-{string|array} property was passed in.
                    length = Arrayvalue.Length;
            }
        }
        return length >= Length;
    }
    /*string*/ FormatErrorMessage(/*string*/ name)
    {
        return .Format(CultureInfo.CurrentCulture, ErrorMessageString, name, Length);
    }
    /*void*/ EnsureLegalLengths()
    {
        if (Length < 0)
        {
            throw new InvalidOperationException("MinLengthAttribute_InvalidMinLength");
        }
    }
}

class System_ComponentModel_DataAnnotations_PhoneAttribute extends System_ComponentModel_DataAnnotations_DataTypeAttribute
{
    /*Regex*/ _regex = CreateRegEx();
    /*string*/ _additionalPhoneNumberCharacters = "-.()";
    constructor()
    {
        super(DataType.PhoneNumber);
        // DevDiv 468241: set DefaultErrorMessage not ErrorMessage, allowing user to set
            // ErrorMessageResourceType and ErrorMessageResourceName to use localized messages.
            DefaultErrorMessage = "PhoneAttribute_Invalid";
    }
    /*bool*/ IsValid(/*object*/ value)
    {
        if (value == null)
        {
            return true;
        }
        /*string*/ let valueAsString = value as ;
        if (_regex != null)
        {
            return valueAsString != null && _regex.Match(valueAsString).Length  > 0;
        }
        else 
        {
            if (valueAsString == null)
            {
                return false;
            }
            valueAsString = valueAsString.Replace("+", .Empty).TrimEnd();
            valueAsString = RemoveExtension(valueAsString);
            /*bool*/ let digitFound = false;
            BlazorJs.forEach(valueAsString, function(c, $_i)
            {
                if (Char.IsDigit(c))
                {
                    digitFound = true;
                    break;
                }
            });
            if (digitFound)
            {
                return false;
            }
            BlazorJs.forEach(valueAsString, function(c, $_i)
            {
                if (Char.IsDigit(c) || Char.IsWhiteSpace(c) || _additionalPhoneNumberCharacters.IndexOf(c) != 1)
                {
                    return false;
                }
            });
            return true;
        }
    }
    /*Regex*/ CreateRegEx()
    {
        /*string*/ let pattern = @"^(\+\s?)?((?<!\+.*)\(\+?\d+([\s\-\.]?\d+)?\)|\d+)([\s\-\.]?(\(\d+([\s\-\.]?\d+)?\)|\d+))*(\s?(x|ext\.?)\s?\d+)?$";
        /*RegexOptions*/ let options = RegexOptions.IgnoreCase  | RegexOptions.ExplicitCapture;
        /*// Set explicit regex match timeout, sufficient enough for phone parsing
            // Unless the global REGEX_DEFAULT_MATCH_TIMEOUT is already set
            TimeSpan*/ let matchTimeout = TimeSpan.FromSeconds(2);
        {
            return new Regex(pattern, options, matchTimeout);
        }
        {
        }
        return new Regex(pattern, options);
    }
    /*string*/ RemoveExtension(/*string*/ potentialPhoneNumber)
    {
        /*int*/ let lastIndexOfExtension = potentialPhoneNumber.ToLower().LastIndexOf("ext.");
        if (lastIndexOfExtension >= 0)
        {
            /*string*/ let extension = potentialPhoneNumber.Substring(lastIndexOfExtension + 4);
            if (MatchesExtension(extension))
            {
                return potentialPhoneNumber.Substring(0, lastIndexOfExtension);
            }
        }
        lastIndexOfExtension = potentialPhoneNumber.ToLower().LastIndexOf("ext");
        if (lastIndexOfExtension >= 0)
        {
            /*string*/ let extension = potentialPhoneNumber.Substring(lastIndexOfExtension + 3);
            if (MatchesExtension(extension))
            {
                return potentialPhoneNumber.Substring(0, lastIndexOfExtension);
            }
        }
        lastIndexOfExtension = potentialPhoneNumber.ToLower().LastIndexOf("x");
        if (lastIndexOfExtension >= 0)
        {
            /*string*/ let extension = potentialPhoneNumber.Substring(lastIndexOfExtension + 1);
            if (MatchesExtension(extension))
            {
                return potentialPhoneNumber.Substring(0, lastIndexOfExtension);
            }
        }
        return potentialPhoneNumber;
    }
    /*bool*/ MatchesExtension(/*string*/ potentialExtension)
    {
        potentialExtension = potentialExtension.TrimStart();
        if (potentialExtension.Length  == 0)
        {
            return false;
        }
        BlazorJs.forEach(potentialExtension, function(c, $_i)
        {
            if (Char.IsDigit(c))
            {
                return false;
            }
        });
        return true;
    }
}

class System_ComponentModel_DataAnnotations_RangeAttribute extends System_ComponentModel_DataAnnotations_ValidationAttribute
{
    /*object*/ _backingField_Minimum = null;
    /*object*/ get Minimum()
    {
        return _backingField_Minimum;
    }
    /*object*/ set Minimum(value)
    {
        _backingField_Minimum = value;
    }
    /*object*/ _backingField_Maximum = null;
    /*object*/ get Maximum()
    {
        return _backingField_Maximum;
    }
    /*object*/ set Maximum(value)
    {
        _backingField_Maximum = value;
    }
    /*Type*/ _backingField_OperandType = null;
    /*Type*/ get OperandType()
    {
        return _backingField_OperandType;
    }
    /*Type*/ set OperandType(value)
    {
        _backingField_OperandType = value;
    }
    /*Func<object, object>*/ _backingField_Conversion = null;
    /*Func<object, object>*/ get Conversion()
    {
        return _backingField_Conversion;
    }
    /*Func<object, object>*/ set Conversion(value)
    {
        _backingField_Conversion = value;
    }
    constructor(/*int*/ minimum, /*int*/ maximum)
    {
        super();
        .Minimum  = minimum;
        .Maximum  = maximum;
        .OperandType  = ;
    }
    constructor(/*double*/ minimum, /*double*/ maximum)
    {
        super();
        .Minimum  = minimum;
        .Maximum  = maximum;
        .OperandType  = ;
    }
    constructor(/*Type*/ type, /*string*/ minimum, /*string*/ maximum)
    {
        super();
        .OperandType  = type;
        .Minimum  = minimum;
        .Maximum  = maximum;
    }
    constructor()
    {
        super(function()
        {
            return "RangeAttribute_ValidationError";
        });
    }
    /*void*/ Initialize(/*IComparable*/ minimum, /*IComparable*/ maximum, /*Func<object, object>*/ conversion)
    {
        if (minimum.CompareTo(maximum) > 0)
        {
            throw new InvalidOperationException("RangeAttribute_MinGreaterThanMax");
        }
        .Minimum  = minimum;
        .Maximum  = maximum;
        .Conversion  = conversion;
    }
    /*bool*/ IsValid(/*object*/ value)
    {
        .SetupConversion();
        if (value == null)
        {
            return true;
        }
        /*string*/ let s = value as ;
        if (s != null && String.IsNullOrEmpty(s))
        {
            return true;
        }
        /*object*/ let convertedValue = null;
        {
            convertedValue = .Conversion(value);
        }
FormatException        {
            return false;
        }
InvalidCastException        {
            return false;
        }
NotSupportedException        {
            return false;
        }
        /*IComparable*/ let min = IComparable.Minimum;
        /*IComparable*/ let max = IComparable.Maximum;
        return min.CompareTo(convertedValue) <= 0 && max.CompareTo(convertedValue) >= 0;
    }
    /*string*/ FormatErrorMessage(/*string*/ name)
    {
        .SetupConversion();
        return String.Format(CultureInfo.CurrentCulture, ErrorMessageString, name, .Minimum, .Maximum);
    }
    /*void*/ SetupConversion()
    {
        if (.Conversion  == null)
        {
            /*object*/ let minimum = .Minimum;
            /*object*/ let maximum = .Maximum;
            if (minimum == null || maximum == null)
            {
                throw new InvalidOperationException("RangeAttribute_Must_Set_Min_And_Max");
            }
            /*// Careful here -- OperandType could be int or double if they used the long form of the ctor.
                // But the min and max would still be strings.  Do use the type of the min/max operands to condition
                // the following code.
                Type*/ let operandType = minimum.GetType();
            if (operandType == )
            {
                .Initialize(minimum, maximum, function(/**/ v)
                {
Convert.ToInt32(v, CultureInfo.InvariantCulture)                });
            }
            else if (operandType == )
            {
                .Initialize(minimum, maximum, function(/**/ v)
                {
Convert.ToDouble(v, CultureInfo.InvariantCulture)                });
            }
            else 
            {
                /*Type*/ let type = .OperandType;
                if (type == null)
                {
                    throw new InvalidOperationException("RangeAttribute_Must_Set_Operand_Type");
                }
                /*Type*/ let comparableType = IComparable;
                if (comparableType.IsAssignableFrom(type))
                {
                    throw new InvalidOperationException("RangeAttribute_ArbitraryTypeNotIComparable");
                }
                /*//#if SILVERLIGHT
                    Func<object, object>*/ let conversion = function(/**/ value)
                {
value != null && value.GetType() == typevalueConvert.ChangeType(value, type, CultureInfo.CurrentCulture)                };
                /*IComparable*/ let min = IComparableconversion(minimum);
                /*IComparable*/ let max = IComparableconversion(maximum);
                .Initialize(min, max, conversion);
            }
        }
    }
}

class System_ComponentModel_DataAnnotations_RegularExpressionAttribute extends System_ComponentModel_DataAnnotations_ValidationAttribute
{
    /*string*/ _backingField_Pattern = null;
    /*string*/ get Pattern()
    {
        return _backingField_Pattern;
    }
    /*string*/ set Pattern(value)
    {
        _backingField_Pattern = value;
    }
    /*int*/ get MatchTimeoutInMilliseconds()
    {
        return _matchTimeoutInMilliseconds;
    }
    /*int*/ set MatchTimeoutInMilliseconds(value)
    {
        _matchTimeoutInMilliseconds = value;
        _matchTimeoutSet = true;
    }
    /*int*/ _matchTimeoutInMilliseconds = null;
    /*bool*/ _matchTimeoutSet = null;
    /*Regex*/ _backingField_Regex = null;
    /*Regex*/ get Regex()
    {
        return _backingField_Regex;
    }
    /*Regex*/ set Regex(value)
    {
        _backingField_Regex = value;
    }
    constructor(/*string*/ pattern)
    {
        super(function()
        {
            return "RegexAttribute_ValidationError";
        });
        .Pattern  = pattern;
    }
    /*bool*/ IsValid(/*object*/ value)
    {
        .SetupRegex();
        /*// Convert the value to a string
            string*/ let stringValue = Convert.ToString(value, CultureInfo.CurrentCulture);
        if (String.IsNullOrEmpty(stringValue))
        {
            return true;
        }
        /*Match*/ let m = .Regex.Match(stringValue);
        return m.Success  && m.Index  == 0 && m.Length  == stringValue.Length;
    }
    /*string*/ FormatErrorMessage(/*string*/ name)
    {
        .SetupRegex();
        return String.Format(CultureInfo.CurrentCulture, ErrorMessageString, name, .Pattern);
    }
    /*void*/ SetupRegex()
    {
        if (.Regex  == null)
        {
            if (.IsNullOrEmpty(.Pattern))
            {
                throw new InvalidOperationException("RegularExpressionAttribute_Empty_Pattern");
            }
            if (_matchTimeoutSet)
            {
                MatchTimeoutInMilliseconds = GetDefaultTimeout();
            }
            Regex = MatchTimeoutInMilliseconds == 1new Regex(Pattern)Regex = new Regex(Pattern, RegexOptions, TimeSpan.FromMilliseconds(MatchTimeoutInMilliseconds));
        }
    }
    /*int*/ GetDefaultTimeout()
    {
        if (LocalAppContextSwitches.UseLegacyRegExTimeout)
        {
            return 1;
        }
        else 
        {
            return 2000;
        }
    }
}

class System_ComponentModel_DataAnnotations_RequiredAttribute extends System_ComponentModel_DataAnnotations_ValidationAttribute
{
    constructor()
    {
        super(function()
        {
            return "RequiredAttribute_ValidationError";
        });
    }
    /*bool*/ _backingField_AllowEmptyStrings = null;
    /*bool*/ get AllowEmptyStrings()
    {
        return _backingField_AllowEmptyStrings;
    }
    /*bool*/ set AllowEmptyStrings(value)
    {
        _backingField_AllowEmptyStrings = value;
    }
    /*bool*/ IsValid(/*object*/ value)
    {
        if (value == null)
        {
            return false;
        }
        /*// only check string length if empty strings are not allowed
            var*/ let stringValue = value as ;
        if (stringValue != null && AllowEmptyStrings)
        {
            return stringValue.Trim().Length  != 0;
        }
        return true;
    }
}

class System_ComponentModel_DataAnnotations_ScaffoldColumnAttribute extends System_Attribute
{
    /*bool*/ _backingField_Scaffold = null;
    /*bool*/ get Scaffold()
    {
        return _backingField_Scaffold;
    }
    /*bool*/ set Scaffold(value)
    {
        _backingField_Scaffold = value;
    }
    constructor(/*bool*/ scaffold)
    {
        super();
        Scaffold = scaffold;
    }
}
class System_ComponentModel_DataAnnotations_ScaffoldTableAttribute extends System_Attribute
{
    /*bool*/ _backingField_Scaffold = null;
    /*bool*/ get Scaffold()
    {
        return _backingField_Scaffold;
    }
    /*bool*/ set Scaffold(value)
    {
        _backingField_Scaffold = value;
    }
    constructor(/*bool*/ scaffold)
    {
        super();
        Scaffold = scaffold;
    }
}

class System_ComponentModel_DataAnnotations_StringLengthAttribute extends System_ComponentModel_DataAnnotations_ValidationAttribute
{
    /*int*/ _backingField_MaximumLength = null;
    /*int*/ get MaximumLength()
    {
        return _backingField_MaximumLength;
    }
    /*int*/ set MaximumLength(value)
    {
        _backingField_MaximumLength = value;
    }
    /*int*/ _backingField_MinimumLength = null;
    /*int*/ get MinimumLength()
    {
        return _backingField_MinimumLength;
    }
    /*int*/ set MinimumLength(value)
    {
        _backingField_MinimumLength = value;
    }
    constructor(/*int*/ maximumLength)
    {
        super(function()
        {
            return "StringLengthAttribute_ValidationError";
        });
        .MaximumLength  = maximumLength;
    }
    /*bool*/ IsValid(/*object*/ value)
    {
        .EnsureLegalLengths();
        /*// Automatically pass if value is null. RequiredAttribute should be used to assert a value is not null.
            // We expect a cast exception if a non-string was passed in.
            int*/ let length = value == null0value.Length;
        return value == null || length >= .MinimumLength  && length <= .MaximumLength;
    }
    /*string*/ FormatErrorMessage(/*string*/ name)
    {
        .EnsureLegalLengths();
        /*bool*/ let useErrorMessageWithMinimum = .MinimumLength  != 0 && .CustomErrorMessageSet;
        /*string*/ let errorMessage = useErrorMessageWithMinimum"StringLengthAttribute_ValidationErrorIncludingMinimum".ErrorMessageString;
        return String.Format(CultureInfo.CurrentCulture, errorMessage, name, .MaximumLength, .MinimumLength);
    }
    /*void*/ EnsureLegalLengths()
    {
        if (.MaximumLength  < 0)
        {
            throw new InvalidOperationException("StringLengthAttribute_InvalidMaxLength");
        }
        if (.MaximumLength  < .MinimumLength)
        {
            throw new InvalidOperationException("DataAnnotationsResources.RangeAttribute_MinGreaterThanMax");
        }
    }
}

class System_ComponentModel_DataAnnotations_TimestampAttribute extends System_Attribute
{
    constructor()
    {
        super();
    }
}

class System_ComponentModel_DataAnnotations_UIHintAttribute extends System_Attribute
{
    /*UIHintImplementation*/ _implementation = null;
    /*string*/ get UIHint()
    {
        return ._implementation.UIHint;
    }
    /*string*/ get PresentationLayer()
    {
        return ._implementation.PresentationLayer;
    }
    /*IDictionary<string, object>*/ get ControlParameters()
    {
        return ._implementation.ControlParameters;
    }
    constructor(/*string*/ uiHint)
    {
        super(uiHint, null, new Array(0));
    }
    constructor(/*string*/ uiHint, /*string*/ presentationLayer)
    {
        super(uiHint, presentationLayer, new Array(0));
    }
    constructor(/*string*/ uiHint, /*string*/ presentationLayer, /*object[]*/ controlParameters)
    {
        super();
        ._implementation  = new UIHintImplementation(uiHint, presentationLayer, controlParameters);
    }
    /*int*/ GetHashCode()
    {
        return ._implementation.GetHashCode();
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        /*var*/ let otherAttribute = obj as UIHintAttribute;
        if (otherAttribute == null)
        {
            return false;
        }
        return ._implementation.Equals(otherAttribute._implementation);
    }
    class System_ComponentModel_DataAnnotations_UIHintImplementation extends object
    {
        /*IDictionary<string, object>*/ _controlParameters = null;
        /*object[]*/ _inputControlParameters = null;
        /*string*/ _backingField_UIHint = null;
        /*string*/ get UIHint()
        {
            return _backingField_UIHint;
        }
        /*string*/ set UIHint(value)
        {
            _backingField_UIHint = value;
        }
        /*string*/ _backingField_PresentationLayer = null;
        /*string*/ get PresentationLayer()
        {
            return _backingField_PresentationLayer;
        }
        /*string*/ set PresentationLayer(value)
        {
            _backingField_PresentationLayer = value;
        }
        /*IDictionary<string, object>*/ get ControlParameters()
        {
            if (._controlParameters  == null)
            {
                ._controlParameters  = .BuildControlParametersDictionary();
            }
            return ._controlParameters;
        }
        constructor(/*string*/ uiHint, /*string*/ presentationLayer, /*object[]*/ controlParameters)
        {
            super();
            .UIHint  = uiHint;
            .PresentationLayer  = presentationLayer;
            if (controlParameters != null)
            {
                ._inputControlParameters  = new Array(controlParameters.Length);
                Array.Copy(controlParameters, ._inputControlParameters, controlParameters.Length);
            }
        }
        /*int*/ GetHashCode()
        {
            /*var*/ let a = .UIHint  ?? String.Empty;
            /*var*/ let b = .PresentationLayer  ?? String.Empty;
            return a.GetHashCode() ^ b.GetHashCode();
        }
        /*bool*/ Equals(/*object*/ obj)
        {
            /*// don't need to perform a type check on obj since this is an internal partial class
                var*/ let otherImplementation = UIHintImplementationobj;
            if (.UIHint  != otherImplementation.UIHint  || .PresentationLayer  != otherImplementation.PresentationLayer)
            {
                return false;
            }
            /*IDictionary<string, object>*/ let leftParams;
            /*IDictionary<string, object>*/ let rightParams;
            {
                leftParams = .ControlParameters;
                rightParams = otherImplementation.ControlParameters;
            }
InvalidOperationException            {
                return false;
            }
            Debug.Assert(leftParams != null, "leftParams shouldn't be null");
            Debug.Assert(rightParams != null, "rightParams shouldn't be null");
            if (leftParams.Count  != rightParams.Count)
            {
                return false;
            }
            else 
            {
                return leftParams.OrderBy(function(/**/ p)
                {
p.Key                }).SequenceEqual(rightParams.OrderBy(function(/**/ p)
                {
p.Key                }));
            }
        }
        /*IDictionary<string, object>*/ BuildControlParametersDictionary()
        {
            /*IDictionary<string, object>*/ let controlParameters = new Dictionary_$2(string, object);
            /*object[]*/ let inputControlParameters = ._inputControlParameters;
            if (inputControlParameters == null || inputControlParameters.Length  == 0)
            {
                return controlParameters;
            }
            if (inputControlParameters.Length  % 2 != 0)
            {
                throw new InvalidOperationException("UIHintImplementation_NeedEvenNumberOfControlParameters");
            }
            for(/*int*/ let i = 0; i < inputControlParameters.Length; i += 2)
            {
                /*object*/ let key = inputControlParametersi;
                /*object*/ let value = inputControlParametersi + 1;
                if (key == null)
                {
                    throw new InvalidOperationException("UIHintImplementation_ControlParameterKeyIsNull");
                }
                /*string*/ let keyString = key as ;
                if (keyString == null)
                {
                    throw new InvalidOperationException("UIHintImplementation_ControlParameterKeyIsNotAString");
                }
                if (controlParameters.ContainsKey(keyString))
                {
                    throw new InvalidOperationException("UIHintImplementation_ControlParameterKeyOccursMoreThanOnce");
                }
                controlParameterskeyString = value;
            });
            return controlParameters;
        }
    }
}

class System_ComponentModel_DataAnnotations_UrlAttribute extends System_ComponentModel_DataAnnotations_DataTypeAttribute
{
    /*Regex*/ _regex = CreateRegEx();
    constructor()
    {
        super(DataType.Url);
        // DevDiv 468241: set DefaultErrorMessage not ErrorMessage, allowing user to set
            // ErrorMessageResourceType and ErrorMessageResourceName to use localized messages.
            DefaultErrorMessage = "UrlAttribute_Invalid";
    }
    /*bool*/ IsValid(/*object*/ value)
    {
        if (value == null)
        {
            return true;
        }
        /*string*/ let valueAsString = value as ;
        if (_regex != null)
        {
            return valueAsString != null && _regex.Match(valueAsString).Length  > 0;
        }
        else 
        {
            return valueAsString != null && valueAsString.StartsWith("http://", StringComparison.InvariantCultureIgnoreCase) || valueAsString.StartsWith("https://", StringComparison.InvariantCultureIgnoreCase) || valueAsString.StartsWith("ftp://", StringComparison.InvariantCultureIgnoreCase);
        }
    }
    /*Regex*/ CreateRegEx()
    {
        /*string*/ let pattern = @"^(https?|ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$";
        /*RegexOptions*/ let options = RegexOptions.IgnoreCase  | RegexOptions.ExplicitCapture;
        /*// Set explicit regex match timeout, sufficient enough for url parsing
            // Unless the global REGEX_DEFAULT_MATCH_TIMEOUT is already set
            TimeSpan*/ let matchTimeout = TimeSpan.FromSeconds(2);
        {
            return new Regex(pattern, options, matchTimeout);
        }
        {
        }
        return new Regex(pattern, options);
    }
}

class System_ComponentModel_DataAnnotations_ValidationAttribute extends System_Attribute
{
    /*string*/ _errorMessage = null;
    /*Func<string>*/ _errorMessageResourceAccessor = null;
    /*string*/ _errorMessageResourceName = null;
    /*Type*/ _errorMessageResourceType = null;
    /*string*/ _defaultErrorMessage = null;
    /*bool*/ _hasBaseIsValid = null;
    constructor()
    {
        super(function()
        {
            return "ValidationAttribute_ValidationError";
        });
    }
    constructor(/*string*/ errorMessage)
    {
        super(function()
        {
            return errorMessage;
        });
    }
    constructor(/*Func<string>*/ errorMessageAccessor)
    {
        super();
        ._errorMessageResourceAccessor  = errorMessageAccessor;
    }
    /*string*/ get DefaultErrorMessage()
    {
        return ._defaultErrorMessage;
    }
    /*string*/ set DefaultErrorMessage(value)
    {
        ._defaultErrorMessage  = value;
        ._errorMessageResourceAccessor  = null;
        .CustomErrorMessageSet  = true;
    }
    /*string*/ get ErrorMessageString()
    {
        .SetupResourceAccessor();
        return ._errorMessageResourceAccessor();
    }
    /*bool*/ _backingField_CustomErrorMessageSet = null;
    /*bool*/ get CustomErrorMessageSet()
    {
        return _backingField_CustomErrorMessageSet;
    }
    /*bool*/ set CustomErrorMessageSet(value)
    {
        _backingField_CustomErrorMessageSet = value;
    }
    /*bool*/ get RequiresValidationContext()
    {
        return false;
    }
    /*string*/ get ErrorMessage()
    {
        return ._errorMessage  ?? ._defaultErrorMessage;
    }
    /*string*/ set ErrorMessage(value)
    {
        ._errorMessage  = value;
        ._errorMessageResourceAccessor  = null;
        .CustomErrorMessageSet  = true;
        if (value == null)
        {
            ._defaultErrorMessage  = null;
        }
    }
    /*string*/ get ErrorMessageResourceName()
    {
        return ._errorMessageResourceName;
    }
    /*string*/ set ErrorMessageResourceName(value)
    {
        ._errorMessageResourceName  = value;
        ._errorMessageResourceAccessor  = null;
        .CustomErrorMessageSet  = true;
    }
    /*Type*/ get ErrorMessageResourceType()
    {
        return ._errorMessageResourceType;
    }
    /*Type*/ set ErrorMessageResourceType(value)
    {
        ._errorMessageResourceType  = value;
        ._errorMessageResourceAccessor  = null;
        .CustomErrorMessageSet  = true;
    }
    /*void*/ SetupResourceAccessor()
    {
        if (._errorMessageResourceAccessor  == null)
        {
            /*string*/ let localErrorMessage = .ErrorMessage;
            /*bool*/ let resourceNameSet = .IsNullOrEmpty(._errorMessageResourceName);
            /*bool*/ let errorMessageSet = .IsNullOrEmpty(._errorMessage);
            /*bool*/ let resourceTypeSet = ._errorMessageResourceType  != null;
            /*bool*/ let defaultMessageSet = .IsNullOrEmpty(._defaultErrorMessage);
            if (resourceNameSet && errorMessageSet || resourceNameSet || errorMessageSet || defaultMessageSet)
            {
                throw new InvalidOperationException("ValidationAttribute_Cannot_Set_ErrorMessage_And_Resource");
            }
            if (resourceTypeSet != resourceNameSet)
            {
                throw new InvalidOperationException("ValidationAttribute_NeedBothResourceTypeAndResourceName");
            }
            if (resourceNameSet)
            {
                .SetResourceAccessorByPropertyLookup();
            }
            else 
            {
                ._errorMessageResourceAccessor  =                 {
                    return localErrorMessage;
                }
;
            }
        }
    }
    /*void*/ SetResourceAccessorByPropertyLookup()
    {
        if (._errorMessageResourceType  != null && .IsNullOrEmpty(._errorMessageResourceName))
        {
            /*//#if SILVERLIGHT
                var*/ let property = ._errorMessageResourceType.GetProperty(._errorMessageResourceName, BindingFlags.Public  | BindingFlags.Static);
            if (property == null)
            {
                throw new InvalidOperationException("ValidationAttribute_ResourceTypeDoesNotHaveProperty");
            }
            if (property.PropertyType  != )
            {
                throw new InvalidOperationException("ValidationAttribute_ResourcePropertyNotStringType");
            }
            ._errorMessageResourceAccessor  =             {
                return property.GetValue(null, null);
            }
;
        }
        else 
        {
            throw new InvalidOperationException("ValidationAttribute_NeedBothResourceTypeAndResourceName");
        }
    }
    /*string*/ FormatErrorMessage(/*string*/ name)
    {
        return String.Format(CultureInfo.CurrentCulture, .ErrorMessageString, name);
    }
    /*bool*/ IsValid(/*object*/ value)
    {
        if (._hasBaseIsValid)
        {
            ._hasBaseIsValid  = true;
        }
        return .IsValid(value, null) == null;
    }
    /*ValidationResult*/ IsValid(/*object*/ value, /*ValidationContext*/ validationContext)
    {
        if (._hasBaseIsValid)
        {
            throw new NotImplementedException("ValidationAttribute_IsValid_NotImplemented");
        }
        /*ValidationResult*/ let result = ValidationResult.Success;
        if (.IsValid(value))
        {
            /*string[]*/ let memberNames = validationContext.MemberName  != null[ validationContext.MemberName  ]null;
            result = new ValidationResult(.FormatErrorMessage(validationContext.DisplayName), memberNames);
        }
        return result;
    }
    /*ValidationResult*/ GetValidationResult(/*object*/ value, /*ValidationContext*/ validationContext)
    {
        if (validationContext == null)
        {
            throw new ArgumentNullException("validationContext");
        }
        /*ValidationResult*/ let result = .IsValid(value, validationContext);
        if (result != null)
        {
            /*bool*/ let hasErrorMessage = result != null.IsNullOrEmpty(result.ErrorMessage)false;
            if (hasErrorMessage)
            {
                /*string*/ let errorMessage = .FormatErrorMessage(validationContext.DisplayName);
                result = new ValidationResult(errorMessage, result.MemberNames);
            }
        }
        return result;
    }
    /*void*/ Validate(/*object*/ value, /*string*/ name)
    {
        if (.IsValid(value))
        {
            throw new ValidationException(.FormatErrorMessage(name), , value);
        }
    }
    /*void*/ Validate(/*object*/ value, /*ValidationContext*/ validationContext)
    {
        if (validationContext == null)
        {
            throw new ArgumentNullException("validationContext");
        }
        /*ValidationResult*/ let result = .GetValidationResult(value, validationContext);
        if (result != null)
        {
            throw new ValidationException(result, , value);
        }
    }
}

class System_ComponentModel_DataAnnotations_ValidationAttributeStore extends object
{
    constructor()
    {
        super();
    }
    /*ValidationAttributeStore*/ _singleton = new ValidationAttributeStore();
    /*Dictionary<Type, TypeStoreItem>*/ _typeStoreItems = new Dictionary_$2(Type, TypeStoreItem);
    /*ValidationAttributeStore*/ get Instance()
    {
        return _singleton;
    }
    /*IEnumerable<ValidationAttribute>*/ GetTypeValidationAttributes(/*ValidationContext*/ validationContext)
    {
        EnsureValidationContext(validationContext);
        /*TypeStoreItem*/ let item = .GetTypeStoreItem(validationContext.ObjectType);
        return item.ValidationAttributes;
    }
    /*DisplayAttribute*/ GetTypeDisplayAttribute(/*ValidationContext*/ validationContext)
    {
        EnsureValidationContext(validationContext);
        /*TypeStoreItem*/ let item = .GetTypeStoreItem(validationContext.ObjectType);
        return item.DisplayAttribute;
    }
    /*IEnumerable<ValidationAttribute>*/ GetPropertyValidationAttributes(/*ValidationContext*/ validationContext)
    {
        EnsureValidationContext(validationContext);
        /*TypeStoreItem*/ let typeItem = .GetTypeStoreItem(validationContext.ObjectType);
        /*PropertyStoreItem*/ let item = typeItem.GetPropertyStoreItem(validationContext.MemberName);
        return item.ValidationAttributes;
    }
    /*DisplayAttribute*/ GetPropertyDisplayAttribute(/*ValidationContext*/ validationContext)
    {
        EnsureValidationContext(validationContext);
        /*TypeStoreItem*/ let typeItem = .GetTypeStoreItem(validationContext.ObjectType);
        /*PropertyStoreItem*/ let item = typeItem.GetPropertyStoreItem(validationContext.MemberName);
        return item.DisplayAttribute;
    }
    /*Type*/ GetPropertyType(/*ValidationContext*/ validationContext)
    {
        EnsureValidationContext(validationContext);
        /*TypeStoreItem*/ let typeItem = .GetTypeStoreItem(validationContext.ObjectType);
        /*PropertyStoreItem*/ let item = typeItem.GetPropertyStoreItem(validationContext.MemberName);
        return item.PropertyType;
    }
    /*bool*/ IsPropertyContext(/*ValidationContext*/ validationContext)
    {
        EnsureValidationContext(validationContext);
        /*TypeStoreItem*/ let typeItem = .GetTypeStoreItem(validationContext.ObjectType);
        /*PropertyStoreItem*/ let item = null;
        let $v = { value: set(value){ item = value; } };
        return typeItem.TryGetPropertyStoreItem(validationContext.MemberName, $v);
    }
    /*TypeStoreItem*/ GetTypeStoreItem(/*Type*/ type)
    {
        if (type == null)
        {
            throw new ArgumentNullException("type");
        }
._typeStoreItems        {
            /*TypeStoreItem*/ let item = null;
            let $v = { value: set(value){ item = value; } };
            if (._typeStoreItems.TryGetValue(type, $v))
            {
                /*IEnumerable<Attribute>*/ let attributes = //#if SILVERLIGHT
 Enumerable.Cast(Attribute, type.GetCustomAttributes(true));
                //#else
                    // TypeDescriptor.GetAttributes(type).Cast<Attribute>();
                    //#endif
                    item = new TypeStoreItem(type, attributes);
                ._typeStoreItemstype = item;
            }
            return item;
        }
    }
    /*void*/ EnsureValidationContext(/*ValidationContext*/ validationContext)
    {
        if (validationContext == null)
        {
            throw new ArgumentNullException("validationContext");
        }
    }
    class System_ComponentModel_DataAnnotations_StoreItem extends object
    {
        /*IEnumerable<ValidationAttribute>*/ _emptyValidationAttributeEnumerable = new Array(0);
        /*IEnumerable<ValidationAttribute>*/ _validationAttributes = null;
        constructor(/*IEnumerable<Attribute>*/ attributes)
        {
            super();
            ._validationAttributes  = attributes.OfType(ValidationAttribute);
            .DisplayAttribute  = attributes.OfType(DisplayAttribute).SingleOrDefault();
        }
        /*IEnumerable<ValidationAttribute>*/ get ValidationAttributes()
        {
            return ._validationAttributes;
        }
        /*DisplayAttribute*/ _backingField_DisplayAttribute = null;
        /*DisplayAttribute*/ get DisplayAttribute()
        {
            return _backingField_DisplayAttribute;
        }
        /*DisplayAttribute*/ set DisplayAttribute(value)
        {
            _backingField_DisplayAttribute = value;
        }
    }
    class System_ComponentModel_DataAnnotations_TypeStoreItem extends System_ComponentModel_DataAnnotations_ValidationAttributeStore_StoreItem
    {
        /*object*/ _syncRoot = new ();
        /*Type*/ _type = null;
        /*Dictionary<string, PropertyStoreItem>*/ _propertyStoreItems = null;
        constructor(/*Type*/ type, /*IEnumerable<Attribute>*/ attributes)
        {
            super(attributes);
            ._type  = type;
        }
        /*PropertyStoreItem*/ GetPropertyStoreItem(/*string*/ propertyName)
        {
            /*PropertyStoreItem*/ let item = null;
            let $v = { value: set(value){ item = value; } };
            if (.TryGetPropertyStoreItem(propertyName, $v))
            {
                throw new ArgumentException("AttributeStore_Unknown_Property", nameof(propertyName));
            }
            return item;
        }
        /*bool*/ TryGetPropertyStoreItem(/*string*/ propertyName, /*PropertyStoreItem*/ item)
        {
            if (.IsNullOrEmpty(propertyName))
            {
                throw new ArgumentNullException("propertyName");
            }
            if (._propertyStoreItems  == null)
            {
._syncRoot                {
                    if (._propertyStoreItems  == null)
                    {
                        ._propertyStoreItems  = .CreatePropertyStoreItems();
                    }
                }
            }
            let $v = { value: set(value){ item = value; } };
            if (._propertyStoreItems.TryGetValue(propertyName, $v))
            {
                return false;
            }
            return true;
        }
        /*Dictionary<string, PropertyStoreItem>*/ CreatePropertyStoreItems()
        {
            /*Dictionary<string, PropertyStoreItem>*/ let propertyStoreItems = new Dictionary_$2(string, PropertyStoreItem);
            /*//#if SILVERLIGHT
                PropertyInfo[]*/ let properties = ._type.GetProperties();
            BlazorJs.forEach(properties, function(property, $_i)
            {
                /*PropertyStoreItem*/ let item = new PropertyStoreItem(property.PropertyType, Enumerable.Cast(Attribute, property.GetCustomAttributes(true)));
                propertyStoreItemsproperty.Name = item;
            });
            return propertyStoreItems;
        }
    }
    class System_ComponentModel_DataAnnotations_PropertyStoreItem extends System_ComponentModel_DataAnnotations_ValidationAttributeStore_StoreItem
    {
        /*Type*/ _propertyType = null;
        constructor(/*Type*/ propertyType, /*IEnumerable<Attribute>*/ attributes)
        {
            super(attributes);
            ._propertyType  = propertyType;
        }
        /*Type*/ get PropertyType()
        {
            return ._propertyType;
        }
    }
}

class System_ComponentModel_DataAnnotations_ValidationContext extends System_IServiceProvider(object)
{
    /*Func<Type, object>*/ _serviceProvider = null;
    /*object*/ _objectInstance = null;
    /*string*/ _memberName = null;
    /*string*/ _displayName = null;
    /*Dictionary<object, object>*/ _items = null;
    constructor(/*object*/ instance)
    {
        super(instance, null, null);
    }
    constructor(/*object*/ instance, /*IDictionary<object, object>*/ items)
    {
        super(instance, null, items);
    }
    constructor(/*object*/ instance, /*IServiceProvider*/ serviceProvider, /*IDictionary<object, object>*/ items)
    {
        super();
        if (instance == null)
        {
            throw new ArgumentNullException("instance");
        }
        if (serviceProvider != null)
        {
            .InitializeServiceProvider(function(/**/ serviceType)
            {
serviceProvider.GetService(serviceType)            });
        }
        if (items != null)
        {
            ._items  = new Dictionary_$2(object, object, items);
        }
        else 
        {
            ._items  = new Dictionary_$2(object, object);
        }
        ._objectInstance  = instance;
    }
    /*object*/ get ObjectInstance()
    {
        return ._objectInstance;
    }
    /*Type*/ get ObjectType()
    {
        return .ObjectInstance.GetType();
    }
    /*string*/ get DisplayName()
    {
        if (.IsNullOrEmpty(._displayName))
        {
            ._displayName  = .GetDisplayName();
            if (.IsNullOrEmpty(._displayName))
            {
                ._displayName  = .MemberName;
                if (.IsNullOrEmpty(._displayName))
                {
                    ._displayName  = .ObjectType.Name;
                }
            }
        }
        return ._displayName;
    }
    /*string*/ set DisplayName(value)
    {
        if (.IsNullOrEmpty(value))
        {
            throw new ArgumentNullException("value");
        }
        ._displayName  = value;
    }
    /*string*/ get MemberName()
    {
        return ._memberName;
    }
    /*string*/ set MemberName(value)
    {
        ._memberName  = value;
    }
    /*IDictionary<object, object>*/ get Items()
    {
        return ._items;
    }
    /*string*/ GetDisplayName()
    {
        /*string*/ let displayName = null;
        /*ValidationAttributeStore*/ let store = ValidationAttributeStore.Instance;
        /*DisplayAttribute*/ let displayAttribute = null;
        if (.IsNullOrEmpty(._memberName))
        {
            displayAttribute = store.GetTypeDisplayAttribute();
        }
        else if (store.IsPropertyContext())
        {
            displayAttribute = store.GetPropertyDisplayAttribute();
        }
        if (displayAttribute != null)
        {
            displayName = displayAttribute.GetName();
        }
        return displayName ?? .MemberName;
    }
    /*void*/ InitializeServiceProvider(/*Func<Type, object>*/ serviceProvider)
    {
        ._serviceProvider  = serviceProvider;
    }
    /*object*/ GetService(/*Type*/ serviceType)
    {
        /*object*/ let service = null;
        if (._serviceProvider  != null)
        {
            service = ._serviceProvider(serviceType);
        }
        return service;
    }
    /*object*/ GetKeyedService(/*Type*/ type, /*object*/ key)
    {
        return GetService(type);
    }
}

class System_ComponentModel_DataAnnotations_ValidationException extends System_Exception
{
    /*ValidationResult*/ _validationResult = null;
    /*ValidationAttribute*/ _backingField_ValidationAttribute = null;
    /*ValidationAttribute*/ get ValidationAttribute()
    {
        return _backingField_ValidationAttribute;
    }
    /*ValidationAttribute*/ set ValidationAttribute(value)
    {
        _backingField_ValidationAttribute = value;
    }
    /*ValidationResult*/ get ValidationResult()
    {
        if (._validationResult  == null)
        {
            ._validationResult  = new ValidationResult(.Message);
        }
        return ._validationResult;
    }
    /*object*/ _backingField_Value = null;
    /*object*/ get Value()
    {
        return _backingField_Value;
    }
    /*object*/ set Value(value)
    {
        _backingField_Value = value;
    }
    constructor(/*ValidationResult*/ validationResult, /*ValidationAttribute*/ validatingAttribute, /*object*/ value)
    {
        super(validationResult.ErrorMessage, validatingAttribute, value);
        ._validationResult  = validationResult;
    }
    constructor(/*string*/ errorMessage, /*ValidationAttribute*/ validatingAttribute, /*object*/ value)
    {
        super(errorMessage);
        .Value  = value;
        .ValidationAttribute  = validatingAttribute;
    }
    constructor()
    {
        super();
    }
    constructor(/*string*/ message)
    {
        super(message);
    }
    constructor(/*string*/ message, /*Exception*/ innerException)
    {
        super(message, innerException);
    }
}

class System_ComponentModel_DataAnnotations_ValidationResult extends object
{
    /*IEnumerable<string>*/ _memberNames = null;
    /*string*/ _errorMessage = null;
    /*ValidationResult*/ Success = null;
    constructor(/*string*/ errorMessage)
    {
        super(errorMessage, null);
    }
    constructor(/*string*/ errorMessage, /*IEnumerable<string>*/ memberNames)
    {
        super();
        ._errorMessage  = errorMessage;
        ._memberNames  = memberNames ?? new Array(0);
    }
    constructor(/*ValidationResult*/ validationResult)
    {
        super();
        if (validationResult == null)
        {
            throw new ArgumentNullException("validationResult");
        }
        ._errorMessage  = validationResult._errorMessage;
        ._memberNames  = validationResult._memberNames;
    }
    /*IEnumerable<string>*/ get MemberNames()
    {
        return ._memberNames;
    }
    /*string*/ get ErrorMessage()
    {
        return ._errorMessage;
    }
    /*string*/ set ErrorMessage(value)
    {
        ._errorMessage  = value;
    }
    /*string*/ ToString()
    {
        return .ErrorMessage  ?? super.ToString();
    }
}

class System_ComponentModel_DataAnnotations_Validator extends object
{
    constructor()
    {
        super();
    }
    /*ValidationAttributeStore*/ _store = ValidationAttributeStore.Instance;
    /*bool*/ TryValidateProperty(/*object*/ value, /*ValidationContext*/ validationContext, /*ICollection<ValidationResult>*/ validationResults)
    {
        /*// Throw if value cannot be assigned to this property.  That is not a validation exception.
            Type*/ let propertyType = _store.GetPropertyType(validationContext);
        /*string*/ let propertyName = validationContext.MemberName;
        EnsureValidPropertyType(propertyName, propertyType, value);
        /*bool*/ let result = true;
        /*bool*/ let breakOnFirstError = validationResults == null;
        /*IEnumerable<ValidationAttribute>*/ let attributes = _store.GetPropertyValidationAttributes(validationContext);
        BlazorJs.forEach(GetValidationErrors(value, validationContext, attributes, breakOnFirstError), function(err, $_i)
        {
            result = false;
            if (validationResults != null)
            {
                validationResults.Add(err.ValidationResult);
            }
        });
        return result;
    }
    /*bool*/ TryValidateObject(/*object*/ instance, /*ValidationContext*/ validationContext, /*ICollection<ValidationResult>*/ validationResults)
    {
        return TryValidateObject(instance, validationContext, validationResults, false);
    }
    /*bool*/ TryValidateObject(/*object*/ instance, /*ValidationContext*/ validationContext, /*ICollection<ValidationResult>*/ validationResults, /*bool*/ validateAllProperties)
    {
        if (instance == null)
        {
            throw new ArgumentNullException("instance");
        }
        if (validationContext != null && instance != validationContext.ObjectInstance)
        {
            throw new ArgumentException("Validator_InstanceMustMatchValidationContextInstance", nameof(instance));
        }
        /*bool*/ let result = true;
        /*bool*/ let breakOnFirstError = validationResults == null;
        BlazorJs.forEach(GetObjectValidationErrors(instance, validationContext, validateAllProperties, breakOnFirstError), function(err, $_i)
        {
            result = false;
            if (validationResults != null)
            {
                validationResults.Add(err.ValidationResult);
            }
        });
        return result;
    }
    /*bool*/ TryValidateValue(/*object*/ value, /*ValidationContext*/ validationContext, /*ICollection<ValidationResult>*/ validationResults, /*IEnumerable<ValidationAttribute>*/ validationAttributes)
    {
        /*bool*/ let result = true;
        /*bool*/ let breakOnFirstError = validationResults == null;
        BlazorJs.forEach(GetValidationErrors(value, validationContext, validationAttributes, breakOnFirstError), function(err, $_i)
        {
            result = false;
            if (validationResults != null)
            {
                validationResults.Add(err.ValidationResult);
            }
        });
        return result;
    }
    /*void*/ ValidateProperty(/*object*/ value, /*ValidationContext*/ validationContext)
    {
        /*// Throw if value cannot be assigned to this property.  That is not a validation exception.
            Type*/ let propertyType = _store.GetPropertyType(validationContext);
        EnsureValidPropertyType(validationContext.MemberName, propertyType, value);
        /*IEnumerable<ValidationAttribute>*/ let attributes = _store.GetPropertyValidationAttributes(validationContext);
        /*ValidationError*/ let err = GetValidationErrors(value, validationContext, attributes, false).FirstOrDefault();
        if (err != null)
        {
            err.ThrowValidationException();
        }
    }
    /*void*/ ValidateObject(/*object*/ instance, /*ValidationContext*/ validationContext)
    {
        ValidateObject(instance, validationContext, false);
    }
    /*void*/ ValidateObject(/*object*/ instance, /*ValidationContext*/ validationContext, /*bool*/ validateAllProperties)
    {
        if (instance == null)
        {
            throw new ArgumentNullException("instance");
        }
        if (validationContext == null)
        {
            throw new ArgumentNullException("validationContext");
        }
        if (instance != validationContext.ObjectInstance)
        {
            throw new ArgumentException("Validator_InstanceMustMatchValidationContextInstance", nameof(instance));
        }
        /*ValidationError*/ let err = GetObjectValidationErrors(instance, validationContext, validateAllProperties, false).FirstOrDefault();
        if (err != null)
        {
            err.ThrowValidationException();
        }
    }
    /*void*/ ValidateValue(/*object*/ value, /*ValidationContext*/ validationContext, /*IEnumerable<ValidationAttribute>*/ validationAttributes)
    {
        if (validationContext == null)
        {
            throw new ArgumentNullException("validationContext");
        }
        /*ValidationError*/ let err = GetValidationErrors(value, validationContext, validationAttributes, false).FirstOrDefault();
        if (err != null)
        {
            err.ThrowValidationException();
        }
    }
    /*ValidationContext*/ CreateValidationContext(/*object*/ instance, /*ValidationContext*/ validationContext)
    {
        if (validationContext == null)
        {
            throw new ArgumentNullException("validationContext");
        }
        /*// Create a new context using the existing ValidationContext that acts as an IServiceProvider and contains our existing items.
            ValidationContext*/ let context = new ValidationContext(instance, validationContext, validationContext.Items);
        return context;
    }
    /*bool*/ CanBeAssigned(/*Type*/ destinationType, /*object*/ value)
    {
        if (destinationType == null)
        {
            throw new ArgumentNullException("destinationType");
        }
        if (value == null)
        {
            return destinationType.IsValueType  || destinationType.IsGenericType  && destinationType.GetGenericTypeDefinition() == Nullable_$1;
        }
        return destinationType.IsAssignableFrom(value.GetType());
    }
    /*void*/ EnsureValidPropertyType(/*string*/ propertyName, /*Type*/ propertyType, /*object*/ value)
    {
        if (CanBeAssigned(propertyType, value))
        {
            throw new ArgumentException("Validator_Property_Value_Wrong_Type", nameof(value));
        }
    }
    /*IEnumerable<ValidationError>*/ GetObjectValidationErrors(/*object*/ instance, /*ValidationContext*/ validationContext, /*bool*/ validateAllProperties, /*bool*/ breakOnFirstError)
    {
        if (instance == null)
        {
            throw new ArgumentNullException("instance");
        }
        if (validationContext == null)
        {
            throw new ArgumentNullException("validationContext");
        }
        /*// Step 1: Validate the object properties' validation attributes
            List<ValidationError>*/ let errors = new List_$1(ValidationError);
        errors.AddRange(GetObjectPropertyValidationErrors(instance, validationContext, validateAllProperties, breakOnFirstError));
        if (errors.Any())
        {
            return errors;
        }
        /*// Step 2: Validate the object's validation attributes
            IEnumerable<ValidationAttribute>*/ let attributes = _store.GetTypeValidationAttributes(validationContext);
        errors.AddRange(GetValidationErrors(instance, validationContext, attributes, breakOnFirstError));
        if (errors.Any())
        {
            return errors;
        }
        /*// Step 3: Test for IValidatableObject implementation
            IValidatableObject*/ let validatable = instance as IValidatableObject;
        if (validatable != null)
        {
            /*IEnumerable<ValidationResult>*/ let results = validatable.Validate(validationContext);
            BlazorJs.forEach(results.Where(function(/**/ r)
            {
r != ValidationResult.Success            }), function(result, $_i)
            {
                errors.Add(new ValidationError(null, instance, result));
            });
        }
        return errors;
    }
    /*IEnumerable<ValidationError>*/ GetObjectPropertyValidationErrors(/*object*/ instance, /*ValidationContext*/ validationContext, /*bool*/ validateAllProperties, /*bool*/ breakOnFirstError)
    {
        /*ICollection<KeyValuePair<ValidationContext, object>>*/ let properties = GetPropertyValues(instance, validationContext);
        /*List<ValidationError>*/ let errors = new List_$1(ValidationError);
        BlazorJs.forEach(properties, function(property, $_i)
        {
            /*// get list of all validation attributes for this property
                IEnumerable<ValidationAttribute>*/ let attributes = _store.GetPropertyValidationAttributes(property.Key);
            if (validateAllProperties)
            {
                // validate all validation attributes on this property
                    errors.AddRange(GetValidationErrors(property.Value, property.Key, attributes, breakOnFirstError));
            }
            else 
            {
                /*// only validate the Required attributes
                    RequiredAttribute*/ let reqAttr = attributes.FirstOrDefault(function(/**/ a)
                {
a is RequiredAttribute                }) as RequiredAttribute;
                if (reqAttr != null)
                {
                    /*// Note: we let the [Required] attribute do its own null testing,
                        // since the user may have subclassed it and have a deeper meaning to what 'required' means
                        ValidationResult*/ let validationResult = reqAttr.GetValidationResult(property.Value, property.Key);
                    if (validationResult != ValidationResult.Success)
                    {
                        errors.Add(new ValidationError(reqAttr, property.Value, validationResult));
                    }
                }
            }
            if (breakOnFirstError && errors.Any())
            {
                break;
            }
        });
        return errors;
    }
    /*ICollection<KeyValuePair<ValidationContext, object>>*/ GetPropertyValues(/*object*/ instance, /*ValidationContext*/ validationContext)
    {
        /*//#if SILVERLIGHT
            IEnumerable<PropertyInfo>*/ let properties = instance.GetType().GetProperties()property.GetIndexParameters().Any()property;
        /*List<KeyValuePair<ValidationContext, object>>*/ let items = new List_$1(KeyValuePair<ValidationContext, object>, properties.Count());
        BlazorJs.forEach(properties, function(property, $_i)
        {
            /*ValidationContext*/ let context = CreateValidationContext(instance, validationContext);
            context.MemberName  = property.Name;
            if (_store.GetPropertyValidationAttributes(context).Any())
            {
                items.Add(new KeyValuePair_$2(ValidationContext, object, context, property.GetValue(instance, null)));
            }
        });
        return items;
    }
    /*IEnumerable<ValidationError>*/ GetValidationErrors(/*object*/ value, /*ValidationContext*/ validationContext, /*IEnumerable<ValidationAttribute>*/ attributes, /*bool*/ breakOnFirstError)
    {
        if (validationContext == null)
        {
            throw new ArgumentNullException("validationContext");
        }
        /*List<ValidationError>*/ let errors = new List_$1(ValidationError);
        /*ValidationError*/ let validationError;
        /*// Get the required validator if there is one and test it first, aborting on failure
            RequiredAttribute*/ let required = attributes.FirstOrDefault(function(/**/ a)
        {
a is RequiredAttribute        }) as RequiredAttribute;
        if (required != null)
        {
            let $v = { value: set(value){ validationError = value; } };
            if (TryValidate(value, validationContext, required, $v))
            {
                errors.Add(validationError);
                return errors;
            }
        }
        BlazorJs.forEach(attributes, function(attr, $_i)
        {
            if (attr != required)
            {
                let $v = { value: set(value){ validationError = value; } };
                if (TryValidate(value, validationContext, attr, $v))
                {
                    errors.Add(validationError);
                    if (breakOnFirstError)
                    {
                        break;
                    }
                }
            }
        });
        return errors;
    }
    /*bool*/ TryValidate(/*object*/ value, /*ValidationContext*/ validationContext, /*ValidationAttribute*/ attribute, /*ValidationError*/ validationError)
    {
        if (validationContext == null)
        {
            throw new ArgumentNullException("validationContext");
        }
        /*ValidationResult*/ let validationResult = attribute.GetValidationResult(value, validationContext);
        if (validationResult != ValidationResult.Success)
        {
            validationError = new ValidationError(attribute, value, validationResult);
            return false;
        }
        validationError = null;
        return true;
    }
    class System_ComponentModel_DataAnnotations_ValidationError extends object
    {
        constructor(/*ValidationAttribute*/ validationAttribute, /*object*/ value, /*ValidationResult*/ validationResult)
        {
            super();
            .ValidationAttribute  = validationAttribute;
            .ValidationResult  = validationResult;
            .Value  = value;
        }
        /*object*/ _backingField_Value = null;
        /*object*/ get Value()
        {
            return _backingField_Value;
        }
        /*object*/ set Value(value)
        {
            _backingField_Value = value;
        }
        /*ValidationAttribute*/ _backingField_ValidationAttribute = null;
        /*ValidationAttribute*/ get ValidationAttribute()
        {
            return _backingField_ValidationAttribute;
        }
        /*ValidationAttribute*/ set ValidationAttribute(value)
        {
            _backingField_ValidationAttribute = value;
        }
        /*ValidationResult*/ _backingField_ValidationResult = null;
        /*ValidationResult*/ get ValidationResult()
        {
            return _backingField_ValidationResult;
        }
        /*ValidationResult*/ set ValidationResult(value)
        {
            _backingField_ValidationResult = value;
        }
        /*void*/ ThrowValidationException()
        {
            throw new ValidationException(.ValidationResult, .ValidationAttribute, .Value);
        }
    }
}

class System_Diagnostics_CodeAnalysis_DisallowNullAttribute extends System_Attribute
{
    constructor()
    {
        super();
    }
}

class System_Diagnostics_CodeAnalysis_MaybeNullWhenAttribute extends System_Attribute
{
    constructor(/*bool*/ returnValue)
    {
        super();
        ReturnValue = returnValue;
    }
    /*bool*/ _backingField_ReturnValue = null;
    /*bool*/ get ReturnValue()
    {
        return _backingField_ReturnValue;
    }
}

class System_Diagnostics_CodeAnalysis_NotNullIfNotNullAttribute extends System_Attribute
{
    constructor(/*string*/ parameterName)
    {
        super();
        ParameterName = parameterName;
    }
    /*string*/ _backingField_ParameterName = null;
    /*string*/ get ParameterName()
    {
        return _backingField_ParameterName;
    }
}

class System_Diagnostics_CodeAnalysis_NotNullWhenAttribute extends System_Attribute
{
    constructor(/*bool*/ returnValue)
    {
        super();
    }
    /*bool*/ _backingField_ReturnValue = null;
    /*bool*/ get ReturnValue()
    {
        return _backingField_ReturnValue;
    }
}

class System_Drawing_Color extends H5_IH5Class(System_IEquatable<System_Drawing_Color>(System_ValueType))
{
    constructor(/*byte*/ r, /*byte*/ g, /*byte*/ b, /*byte*/ a)
    {
        super();
        R = r;
        G = g;
        B = b;
        A = a;
    }
    /*byte*/ _backingField_R = null;
    /*byte*/ get R()
    {
        return _backingField_R;
    }
    /*byte*/ _backingField_G = null;
    /*byte*/ get G()
    {
        return _backingField_G;
    }
    /*byte*/ _backingField_B = null;
    /*byte*/ get B()
    {
        return _backingField_B;
    }
    /*byte*/ _backingField_A = null;
    /*byte*/ get A()
    {
        return _backingField_A;
    }
    /*Color*/ FromArgb(/*int*/ alpha, /*int*/ red, /*int*/ green, /*int*/ blue)
    {
        return new Color(red, green, blue, alpha);
    }
    /*Color*/ FromArgb(/*int*/ red, /*int*/ green, /*int*/ blue)
    {
        return new Color(red, green, blue, 255);
    }
    /*bool*/ Equals(/*Color*/ other)
    {
        return A == other.A  && R == other.R  && G == other.G  && B == other.B;
    }
    /*float*/ GetBrightness()
    {
        throw new NotImplementedException();
    }
    /*float*/ GetHue()
    {
        throw new NotImplementedException();
    }
    /*float*/ GetSaturation()
    {
        throw new NotImplementedException();
    }
    /*int*/ ToArgb()
    {
        throw new NotImplementedException();
    }
}

class System_IO_AsyncStream extends System_IO_Stream
{
    constructor()
    {
        super();
    }
    /*IAsyncResult*/ BeginRead(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count, /*AsyncCallback*/ callback, /*object*/ state)
    {
        TaskToAsyncResult.Begin(ReadAsync(buffer, offset, count, default), callback, state);
    }
    /*int*/ EndRead(/*IAsyncResult*/ asyncResult)
    {
        TaskToAsyncResult.End(int, asyncResult);
    }
    /*IAsyncResult*/ BeginWrite(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count, /*AsyncCallback*/ callback, /*object*/ state)
    {
        TaskToAsyncResult.Begin(WriteAsync(buffer, offset, count, default), callback, state);
    }
    /*void*/ EndWrite(/*IAsyncResult*/ asyncResult)
    {
        TaskToAsyncResult.End(asyncResult);
    }
    /*Task<int>*/ ReadAsync(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count, /*CancellationToken*/ cancellationToken)
    {
        ReadAsync(new Span_$1(byte, buffer, offset, count), cancellationToken);
    }
    /*Task*/ WriteAsync(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count, /*CancellationToken*/ cancellationToken)
    {
        WriteAsync(new ReadOnlySpan_$1(byte, buffer, offset, count), cancellationToken);
    }
    /*Task*/ FlushAsync(/*CancellationToken*/ cancellationToken)
    {
        NopAsync(cancellationToken);
    }
    /*void*/ Flush()
    {
    }
    /*void*/ Write(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count)
    {
        WriteAsync(buffer, offset, count, CancellationToken.None).FireAndForget();
    }
    /*int*/ Read(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count)
    {
        return ReadAsync(buffer, offset, count, CancellationToken.None).GetAwaiter().GetResult();
    }
    /*Task*/ NopAsync(/*CancellationToken*/ cancellationToken)
    {
        cancellationToken.IsCancellationRequested         throw new TaskCanceledException();
Task.CompletedTask;
    }
}

class System_IO_Path extends object
{
    constructor()
    {
        super();
    }
    /*string*/ GetExtension(/*string*/ name)
    {
        /*var*/ let dot = name.LastIndexOf('.');
        if (dot >= 0)
        return name.Substring(dot);
        return "";
    }
}

class System_IO_StreamExtensions extends object
{
    constructor()
    {
        super();
    }
    /*Task<int>*/ WriteAsync(/*Stream*/ stream, /*byte[]*/ data, { /*CancellationToken*/ cancellationToken = default})
    {
        stream.Write(data, 0, data.Length);
        return Task.FromResult(data.Length);
    }
    /*Task<int>*/ WriteAsync(/*Stream*/ stream, /*byte[]*/ data, /*int*/ offset, /*int*/ count, { /*CancellationToken*/ cancellationToken = default})
    {
        stream.Write(data, offset, count);
        return Task.FromResult(data.Length);
    }
    /*Task<int>*/ WriteAsync(/*Stream*/ stream, /*ReadOnlySpan<byte>*/ data, { /*CancellationToken*/ cancellationToken = default})
    {
        data.CopyTo(stream);
        return Task.FromResult(data.Length);
    }
    /*Task<int>*/ ReadAsync(/*Stream*/ stream, /*byte[]*/ buffer, /*int*/ offset, /*int*/ count, { /*CancellationToken*/ cancellationToken = default})
    {
        /*int*/ let len = stream.Read(buffer, offset, count);
        return Task.FromResult(len);
    }
    /*Task<int>*/ ReadAsync(/*Stream*/ stream, /*Span<byte>*/ buffer, { /*CancellationToken*/ cancellationToken = default})
    {
        /*var*/ let len = buffer.CopyFrom(stream);
        return Task.FromResult(len);
    }
    /*Task*/ CopyToAsync(/*Stream*/ stream, /*Stream*/ destination, { /*CancellationToken*/ cancellationToken = default})
    {
        throw new NotImplementedException();
    }
    /*Task*/ CopyToAsync(/*Stream*/ stream, /*Stream*/ destination, /*int*/ bufferSize, { /*CancellationToken*/ cancellationToken = default})
    {
        throw new NotImplementedException();
    }
}

class System_IO_TextReaderExtension extends object
{
    constructor()
    {
        super();
    }
    /*Task<string>*/ ReadLineAsync(/*TextReader*/ reader)
    {
        throw new NotImplementedException();
    }
}

class System_Linq_Expressions_ExpressionExtensions extends object
{
    constructor()
    {
        super();
    }
    /*Delegate*/ Compile(/*LambdaExpression*/ expression)
    {
        /*var*/ let exp = expression.Body;
        /*Func<object, object>*/ let _delegate = function(/**/ o)
        {
            return o;
        };
        while(exp != null)
        {
            if (exp instanceof UnaryExpression, un = exp)
            {
                exp = un.Operand;
            }
            else if (exp instanceof MemberExpression, mem = exp)
            {
                /*var*/ let originalDelegate = _delegate;
                _delegate = function(/**/ d)
                {
                    /*var*/ let o = originalDelegate(d);
                    return PropertyInfomem.Member.GetMethod.Invoke(o);
                };
                exp = mem.Expression;
            }
            else if (exp instanceof ParameterExpression, pem = exp)
            {
                if (pem.Name  != "value")
                {
                    /*var*/ let originalDelegate = _delegate;
                    _delegate = function(/**/ d)
                    {
                        return originalDelegate(d)pem.Name;
                    };
                }
                exp = null;
            }
            else 
            {
                throw new InvalidOperationException("Unimplemented expression type");
            }
        }
        return _delegate;
    }
    /*TDelegate*/ Compile(TDelegate, /*Expression<TDelegate>*/ expression)
    {
        return TDelegateCompile(LambdaExpressionexpression);
    }
    /*Expression*/ Update(/*Expression*/ expression, /*Expression*/ expression2)
    {
        throw new NotImplementedException();
    }
}

class System_Net_Http_Ascii extends object
{
    constructor()
    {
        super();
    }
    /*bool*/ IsValid(/*string*/ str)
    {
        return str.All(function(/**/ c)
        {
c < 128        });
    }
    /*bool*/ EqualsIgnoreCase(/*ReadOnlySpan<byte>*/ name, /*string*/ str)
    {
        if (name.Length  != str.Length)
        return false;
        /*bool*/ let equals = true;
        name.ForEach(function(/**/ t, /**/ i)
        {
            /*bool*/ let eq = t == stri;
            if (eq)
            {
                equals = false;
                return false;
            }
            return true;
        });
        return equals;
    }
}

class System_Net_Http_CancellationHelper extends object
{
    constructor()
    {
        super();
    }
    /*string*/ s_cancellationMessage = new OperationCanceledException().Message;
    /*bool*/ ShouldWrapInOperationCanceledException(/*Exception*/ exception, /*CancellationToken*/ cancellationToken)
    {
        exception is OperationCanceledException && cancellationToken.IsCancellationRequested;
    }
    /*Exception*/ CreateOperationCanceledException(/*Exception*/ innerException, /*CancellationToken*/ cancellationToken)
    {
        new TaskCanceledException(s_cancellationMessage, innerException/*, cancellationToken*/);
    }
    /*void*/ ThrowOperationCanceledException(/*Exception*/ innerException, /*CancellationToken*/ cancellationToken)
    {
                throw CreateOperationCanceledException(innerException, cancellationToken);
;
    }
    /*void*/ ThrowIfCancellationRequested(/*CancellationToken*/ cancellationToken)
    {
        ThrowIfCancellationRequested(cancellationToken, { innerException : null });
    }
    /*void*/ ThrowIfCancellationRequested(/*Exception*/ innerException, /*CancellationToken*/ cancellationToken)
    {
        if (cancellationToken.IsCancellationRequested)
        {
            ThrowOperationCanceledException(innerException, cancellationToken);
        }
    }
}

class System_Net_Http_EmptyContent extends System_Net_Http_HttpContent
{
    constructor()
    {
        super();
    }
    /*bool*/ TryComputeLength(/*long*/ length)
    {
        length = 0;
        return true;
    }
    /*void*/ SerializeToStream(/*Stream*/ stream, /*CancellationToken*/ cancellationToken)
    {
    }
    /*Task*/ SerializeToStreamAsync(/*Stream*/ stream)
    {
        Task.CompletedTask;
    }
    /*Task*/ SerializeToStreamAsync(/*Stream*/ stream, /*CancellationToken*/ cancellationToken)
    {
        cancellationToken.IsCancellationRequested         throw new TaskCanceledException();
SerializeToStreamAsync(stream);
    }
    /*Stream*/ CreateContentReadStream(/*CancellationToken*/ cancellationToken)
    {
        EmptyReadStream.Instance;
    }
    /*Task<Stream>*/ CreateContentReadStreamAsync()
    {
        Task.FromResult(Stream, EmptyReadStream.Instance);
    }
    /*Task<Stream>*/ CreateContentReadStreamAsync(/*CancellationToken*/ cancellationToken)
    {
        cancellationToken.IsCancellationRequested         throw new TaskCanceledException();
CreateContentReadStreamAsync();
    }
    /*Stream*/ TryCreateContentReadStream()
    {
        EmptyReadStream.Instance;
    }
    /*bool*/ get AllowDuplex()
    {
        return false;
    }
}

class System_Net_Http_EmptyReadStream extends System_Net_Http_HttpBaseStream
{
    /*EmptyReadStream*/ _backingField_Instance = null;
    /*EmptyReadStream*/ get Instance()
    {
        return _backingField_Instance;
    }
    constructor()
    {
        super();
    }
    /*bool*/ get CanRead()
    {
        return true;
    }
    /*bool*/ get CanWrite()
    {
        return false;
    }
    /*void*/ Dispose(/*bool*/ disposing)
    {
    }
    /*void*/ Close()
    {
    }
    /*Task<int>*/ ReadAsync(/*Span<byte>*/ buffer, /*CancellationToken*/ cancellationToken)
    {
        return cancellationToken.IsCancellationRequested         throw new TaskCanceledException();
Task.FromResult(0);
    }
    /*Task<int>*/ WriteAsync(/*ReadOnlySpan<byte>*/ buffer, /*CancellationToken*/ cancellationToken)
    {
        throw new NotSupportedException("net_http_content_readonly_stream");
    }
    /*int*/ Read(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count)
    {
        return 0;
    }
}

class System_Net_Http_HexConverter extends object
{
    constructor()
    {
        super();
    }
    /*char*/ ToCharUpper(/*int*/ c)
    {
        return c <= 9'0' + c'A' + c - 10;
    }
}

class System_Net_Http_HttpBaseStream extends System_IO_AsyncStream
{
    constructor()
    {
        super();
    }
    /*bool*/ get CanSeek()
    {
        return false;
    }
    /*long*/ Seek(/*long*/ offset, /*SeekOrigin*/ origin)
    {
                throw new NotSupportedException();
;
    }
    /*void*/ SetLength(/*long*/ value)
    {
                throw new NotSupportedException();
;
    }
    /*long*/ get Length()
    {
        return         throw new NotSupportedException();
;
    }
    /*long*/ get Position()
    {
        throw new NotSupportedException();
    }
    /*long*/ set Position(value)
    {
        throw new NotSupportedException();
    }
    /*int*/ ReadByte()
    {
        /*byte[]*/ let b = [ 0 ];
        return Read(b, 0, 1) == 1b01;
    }
    /*void*/ Write(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count)
    {
        // This does sync-over-async, but it also should only end up being used in strange
            // situations.  Either a derived stream overrides this anyway, so the implementation won't be used,
            // or it's being called as part of HttpContent.SerializeToStreamAsync, which means custom
            // content is explicitly choosing to make a synchronous call as part of an asynchronous method.
            WriteAsync(buffer, offset, count, CancellationToken.None).GetAwaiter().GetResult();
    }
    /*void*/ WriteByte(/*byte*/ value)
    {
        Write([ value ], 0, 1);
    }
}

class System_Net_Http_HttpClient extends System_Net_Http_HttpMessageInvoker
{
    /*TimeSpan*/ s_defaultTimeout = TimeSpan.FromSeconds(100);
    /*TimeSpan*/ s_maxTimeout = TimeSpan.FromMilliseconds(.MaxValue);
    /*TimeSpan*/ s_infiniteTimeout = TimeSpan.MaxValue;
    /*HttpCompletionOption*/ DefaultCompletionOption = HttpCompletionOption.ResponseContentRead;
    /*bool*/ _operationStarted = null;
    /*bool*/ _disposed = null;
    /*CancellationTokenSource*/ _pendingRequestsCts = null;
    /*HttpRequestHeaders*/ _defaultRequestHeaders = null;
    /*Version*/ _defaultRequestVersion = HttpRequestMessage.DefaultRequestVersion;
    /*HttpVersionPolicy*/ _defaultVersionPolicy = HttpRequestMessage.DefaultVersionPolicy;
    /*Uri*/ _baseAddress = null;
    /*TimeSpan*/ _timeout = null;
    /*int*/ _maxResponseContentBufferSize = null;
    /*HttpRequestHeaders*/ get DefaultRequestHeaders()
    {
        return _defaultRequestHeaders = _defaultRequestHeaders ?? new HttpRequestHeaders();
    }
    /*Version*/ get DefaultRequestVersion()
    {
        return _defaultRequestVersion;
    }
    /*Version*/ set DefaultRequestVersion(value)
    {
        CheckDisposedOrStarted();
        _defaultRequestVersion = value;
    }
    /*HttpVersionPolicy*/ get DefaultVersionPolicy()
    {
        return _defaultVersionPolicy;
    }
    /*HttpVersionPolicy*/ set DefaultVersionPolicy(value)
    {
        CheckDisposedOrStarted();
        _defaultVersionPolicy = value;
    }
    /*Uri*/ get BaseAddress()
    {
        return _baseAddress;
    }
    /*Uri*/ set BaseAddress(value)
    {
        CheckDisposedOrStarted();
        _baseAddress = value;
    }
    /*TimeSpan*/ get Timeout()
    {
        return _timeout;
    }
    /*TimeSpan*/ set Timeout(value)
    {
        if (value != s_infiniteTimeout)
        {
            if (value == TimeSpan.Zero  || value > s_maxTimeout)
            throw new ArgumentOutOfRangeException();
        }
        CheckDisposedOrStarted();
        _timeout = value;
    }
    /*long*/ get MaxResponseContentBufferSize()
    {
        return _maxResponseContentBufferSize;
    }
    /*long*/ set MaxResponseContentBufferSize(value)
    {
        if (value <= 0)
        throw new ArgumentOutOfRangeException();
        if (value > HttpContent.MaxBufferSize)
        {
            throw new ArgumentOutOfRangeException();
        }
        CheckDisposedOrStarted();
        Debug.Assert(HttpContent.MaxBufferSize  <= .MaxValue);
        _maxResponseContentBufferSize = value;
    }
    constructor()
    {
        super(new BrowserHttpHandler());
    }
    constructor(/*HttpMessageHandler*/ handler)
    {
        super(handler, true);
    }
    constructor(/*HttpMessageHandler*/ handler, /*bool*/ disposeHandler)
    {
        super(handler, disposeHandler);
        _timeout = s_defaultTimeout;
        _maxResponseContentBufferSize = HttpContent.MaxBufferSize;
        _pendingRequestsCts = new CancellationTokenSource();
    }
    /*Task<string>*/ GetStringAsync(/*string*/ requestUri)
    {
        GetStringAsync(CreateUri(requestUri));
    }
    /*Task<string>*/ GetStringAsync(/*Uri*/ requestUri)
    {
        GetStringAsync(requestUri, CancellationToken.None);
    }
    /*Task<string>*/ GetStringAsync(/*string*/ requestUri, /*CancellationToken*/ cancellationToken)
    {
        GetStringAsync(CreateUri(requestUri), cancellationToken);
    }
    /*Task<string>*/ GetStringAsync(/*Uri*/ requestUri, /*CancellationToken*/ cancellationToken)
    {
        /*HttpRequestMessage*/ let request = CreateRequestMessage(HttpMethod.Get, requestUri);
        // Called outside of async state machine to propagate certain exception even without awaiting the returned task.
            CheckRequestBeforeSend(request);
        return GetStringAsyncCore(request, cancellationToken);
    }
    /*Task<string>*/ async GetStringAsyncCore(/*HttpRequestMessage*/ request, /*CancellationToken*/ cancellationToken)
    {
        CancellationTokenSourceCancellationTokenSource = PrepareCancellationTokenSource(cancellationToken);
        /*HttpResponseMessage*/ let response = null;
        /*HttpContent.LimitArrayPoolWriteStream*/ let buffer = null;
        /*Stream*/ let responseStream = null;
        {
            // Wait for the response message and make sure it completed successfully.
                response = await super.SendAsync(request, cts.Token);
            ThrowForNullResponse(response);
            response.EnsureSuccessStatusCode();
            /*// Get the response content.
                HttpContent*/ let c = response.Content;
            // Since the underlying byte[] will never be exposed, we use an ArrayPool-backed
                // stream to which we copy all of the data from the response.
                buffer = new HttpContentLimitArrayPoolWriteStream(_maxResponseContentBufferSize, c.Headers.ContentLength.GetValueOrDefault(), { getFinalSizeFromPool : true });
            responseStream = c.TryReadAsStream();
            if (responseStream == null)
            {
                responseStream = await c.ReadAsStreamAsync(cts.Token);
            }
            {
                responseStream.CopyTo(buffer);
            }
ExceptionHttpContent.StreamCopyExceptionNeedsWrapping(e)            {
                throw HttpContent.WrapStreamCopyException(e);
            }
            return HttpContent.ReadBufferAsString(buffer, c.Headers);
        }
Exception        {
            HandleFailure(e, response, cts, cancellationToken, pendingRequestsCts);
            throw ;
        }
        {
            FinishSend(response, cts, disposeCts);
            bufferDispose();
            responseStreamDispose();
        }
    }
    /*Task<byte[]>*/ GetByteArrayAsync(/*string*/ requestUri)
    {
        GetByteArrayAsync(CreateUri(requestUri));
    }
    /*Task<byte[]>*/ GetByteArrayAsync(/*Uri*/ requestUri)
    {
        GetByteArrayAsync(requestUri, CancellationToken.None);
    }
    /*Task<byte[]>*/ GetByteArrayAsync(/*string*/ requestUri, /*CancellationToken*/ cancellationToken)
    {
        GetByteArrayAsync(CreateUri(requestUri), cancellationToken);
    }
    /*Task<byte[]>*/ GetByteArrayAsync(/*Uri*/ requestUri, /*CancellationToken*/ cancellationToken)
    {
        /*HttpRequestMessage*/ let request = CreateRequestMessage(HttpMethod.Get, requestUri);
        // Called outside of async state machine to propagate certain exception even without awaiting the returned task.
            CheckRequestBeforeSend(request);
        return GetByteArrayAsyncCore(request, cancellationToken);
    }
    /*Task<byte[]>*/ async GetByteArrayAsyncCore(/*HttpRequestMessage*/ request, /*CancellationToken*/ cancellationToken)
    {
        CancellationTokenSourceCancellationTokenSource = PrepareCancellationTokenSource(cancellationToken);
        /*HttpResponseMessage*/ let response = null;
        /*HttpContent.LimitArrayPoolWriteStream*/ let buffer = null;
        /*Stream*/ let responseStream = null;
        {
            // Wait for the response message and make sure it completed successfully.
                response = await super.SendAsync(request, cts.Token);
            ThrowForNullResponse(response);
            response.EnsureSuccessStatusCode();
            /*// Get the response content.
                HttpContent*/ let c = response.Content;
            // If we got a content length, then we assume that it's correct. If that's the case,
                // we can opportunistically allocate the exact-sized buffer while buffering the content.
                // If we didn't get a content length, then we assume we're going to have to grow
                // the buffer potentially several times and that it's unlikely the underlying buffer
                // at the end will be the exact size needed, in which case it's more beneficial to use
                // ArrayPool buffers and copy out to a new array at the end.
                buffer = new HttpContentLimitArrayPoolWriteStream(_maxResponseContentBufferSize, c.Headers.ContentLength.GetValueOrDefault(), { getFinalSizeFromPool : false });
            responseStream = c.TryReadAsStream() ?? await c.ReadAsStreamAsync(cts.Token);
            {
                responseStream.CopyTo(buffer);
            }
ExceptionHttpContent.StreamCopyExceptionNeedsWrapping(e)            {
                throw HttpContent.WrapStreamCopyException(e);
            }
            return buffer.ToArray();
        }
Exception        {
            HandleFailure(e, response, cts, cancellationToken, pendingRequestsCts);
            throw ;
        }
        {
            bufferDispose();
            responseStreamDispose();
            FinishSend(response, cts, disposeCts);
        }
    }
    /*Task<Stream>*/ GetStreamAsync(/*string*/ requestUri)
    {
        GetStreamAsync(CreateUri(requestUri));
    }
    /*Task<Stream>*/ GetStreamAsync(/*string*/ requestUri, /*CancellationToken*/ cancellationToken)
    {
        GetStreamAsync(CreateUri(requestUri), cancellationToken);
    }
    /*Task<Stream>*/ GetStreamAsync(/*Uri*/ requestUri)
    {
        GetStreamAsync(requestUri, CancellationToken.None);
    }
    /*Task<Stream>*/ GetStreamAsync(/*Uri*/ requestUri, /*CancellationToken*/ cancellationToken)
    {
        /*HttpRequestMessage*/ let request = CreateRequestMessage(HttpMethod.Get, requestUri);
        // Called outside of async state machine to propagate certain exception even without awaiting the returned task.
            CheckRequestBeforeSend(request);
        return GetStreamAsyncCore(request, cancellationToken);
    }
    /*Task<Stream>*/ async GetStreamAsyncCore(/*HttpRequestMessage*/ request, /*CancellationToken*/ cancellationToken)
    {
        CancellationTokenSourceCancellationTokenSource = PrepareCancellationTokenSource(cancellationToken);
        /*HttpResponseMessage*/ let response = null;
        {
            // Wait for the response message and make sure it completed successfully.
                response = await super.SendAsync(request, cts.Token);
            ThrowForNullResponse(response);
            response.EnsureSuccessStatusCode();
            /*HttpContent*/ let c = response.Content;
            return c.TryReadAsStream() ?? await c.ReadAsStreamAsync(cancellationToken);
        }
Exception        {
            HandleFailure(e, response, cts, cancellationToken, pendingRequestsCts);
            throw ;
        }
        {
            FinishSend(response, cts, disposeCts);
        }
    }
    /*Task<HttpResponseMessage>*/ GetAsync(/*string*/ requestUri)
    {
        GetAsync(CreateUri(requestUri));
    }
    /*Task<HttpResponseMessage>*/ GetAsync(/*Uri*/ requestUri)
    {
        GetAsync(requestUri, DefaultCompletionOption);
    }
    /*Task<HttpResponseMessage>*/ GetAsync(/*string*/ requestUri, /*HttpCompletionOption*/ completionOption)
    {
        GetAsync(CreateUri(requestUri), completionOption);
    }
    /*Task<HttpResponseMessage>*/ GetAsync(/*Uri*/ requestUri, /*HttpCompletionOption*/ completionOption)
    {
        GetAsync(requestUri, completionOption, CancellationToken.None);
    }
    /*Task<HttpResponseMessage>*/ GetAsync(/*string*/ requestUri, /*CancellationToken*/ cancellationToken)
    {
        GetAsync(CreateUri(requestUri), cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ GetAsync(/*Uri*/ requestUri, /*CancellationToken*/ cancellationToken)
    {
        GetAsync(requestUri, DefaultCompletionOption, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ GetAsync(/*string*/ requestUri, /*HttpCompletionOption*/ completionOption, /*CancellationToken*/ cancellationToken)
    {
        GetAsync(CreateUri(requestUri), completionOption, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ GetAsync(/*Uri*/ requestUri, /*HttpCompletionOption*/ completionOption, /*CancellationToken*/ cancellationToken)
    {
        SendAsync(CreateRequestMessage(HttpMethod.Get, requestUri), completionOption, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ PostAsync(/*string*/ requestUri, /*HttpContent*/ content)
    {
        PostAsync(CreateUri(requestUri), content);
    }
    /*Task<HttpResponseMessage>*/ PostAsync(/*Uri*/ requestUri, /*HttpContent*/ content)
    {
        PostAsync(requestUri, content, CancellationToken.None);
    }
    /*Task<HttpResponseMessage>*/ PostAsync(/*string*/ requestUri, /*HttpContent*/ content, /*CancellationToken*/ cancellationToken)
    {
        PostAsync(CreateUri(requestUri), content, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ PostAsync(/*Uri*/ requestUri, /*HttpContent*/ content, /*CancellationToken*/ cancellationToken)
    {
        /*HttpRequestMessage*/ let request = CreateRequestMessage(HttpMethod.Post, requestUri);
        request.Content  = content;
        return SendAsync(request, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ PutAsync(/*string*/ requestUri, /*HttpContent*/ content)
    {
        PutAsync(CreateUri(requestUri), content);
    }
    /*Task<HttpResponseMessage>*/ PutAsync(/*Uri*/ requestUri, /*HttpContent*/ content)
    {
        PutAsync(requestUri, content, CancellationToken.None);
    }
    /*Task<HttpResponseMessage>*/ PutAsync(/*string*/ requestUri, /*HttpContent*/ content, /*CancellationToken*/ cancellationToken)
    {
        PutAsync(CreateUri(requestUri), content, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ PutAsync(/*Uri*/ requestUri, /*HttpContent*/ content, /*CancellationToken*/ cancellationToken)
    {
        /*HttpRequestMessage*/ let request = CreateRequestMessage(HttpMethod.Put, requestUri);
        request.Content  = content;
        return SendAsync(request, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ PatchAsync(/*string*/ requestUri, /*HttpContent*/ content)
    {
        PatchAsync(CreateUri(requestUri), content);
    }
    /*Task<HttpResponseMessage>*/ PatchAsync(/*Uri*/ requestUri, /*HttpContent*/ content)
    {
        PatchAsync(requestUri, content, CancellationToken.None);
    }
    /*Task<HttpResponseMessage>*/ PatchAsync(/*string*/ requestUri, /*HttpContent*/ content, /*CancellationToken*/ cancellationToken)
    {
        PatchAsync(CreateUri(requestUri), content, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ PatchAsync(/*Uri*/ requestUri, /*HttpContent*/ content, /*CancellationToken*/ cancellationToken)
    {
        /*HttpRequestMessage*/ let request = CreateRequestMessage(HttpMethod.Patch, requestUri);
        request.Content  = content;
        return SendAsync(request, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ DeleteAsync(/*string*/ requestUri)
    {
        DeleteAsync(CreateUri(requestUri));
    }
    /*Task<HttpResponseMessage>*/ DeleteAsync(/*Uri*/ requestUri)
    {
        DeleteAsync(requestUri, CancellationToken.None);
    }
    /*Task<HttpResponseMessage>*/ DeleteAsync(/*string*/ requestUri, /*CancellationToken*/ cancellationToken)
    {
        DeleteAsync(CreateUri(requestUri), cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ DeleteAsync(/*Uri*/ requestUri, /*CancellationToken*/ cancellationToken)
    {
        SendAsync(CreateRequestMessage(HttpMethod.Delete, requestUri), cancellationToken);
    }
    /*HttpResponseMessage*/ Send(/*HttpRequestMessage*/ request)
    {
        Send(request, DefaultCompletionOption, { cancellationToken : default });
    }
    /*HttpResponseMessage*/ Send(/*HttpRequestMessage*/ request, /*HttpCompletionOption*/ completionOption)
    {
        Send(request, completionOption, { cancellationToken : default });
    }
    /*HttpResponseMessage*/ Send(/*HttpRequestMessage*/ request, /*CancellationToken*/ cancellationToken)
    {
        Send(request, DefaultCompletionOption, cancellationToken);
    }
    /*HttpResponseMessage*/ Send(/*HttpRequestMessage*/ request, /*HttpCompletionOption*/ completionOption, /*CancellationToken*/ cancellationToken)
    {
        CheckRequestBeforeSend(request);
        CancellationTokenSourceCancellationTokenSource = PrepareCancellationTokenSource(cancellationToken);
        /*HttpResponseMessage*/ let response = null;
        {
            // Wait for the send request to complete, getting back the response.
                response = super.Send(request, cts.Token);
            ThrowForNullResponse(response);
            if (ShouldBufferResponse(completionOption, request))
            {
                response.Content.LoadIntoBuffer(_maxResponseContentBufferSize, cts.Token);
            }
            return response;
        }
Exception        {
            HandleFailure(e, response, cts, cancellationToken, pendingRequestsCts);
            throw ;
        }
        {
            FinishSend(response, cts, disposeCts);
        }
    }
    /*Task<HttpResponseMessage>*/ SendAsync(/*HttpRequestMessage*/ request)
    {
        SendAsync(request, DefaultCompletionOption, CancellationToken.None);
    }
    /*Task<HttpResponseMessage>*/ SendAsync(/*HttpRequestMessage*/ request, /*CancellationToken*/ cancellationToken)
    {
        SendAsync(request, DefaultCompletionOption, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ SendAsync(/*HttpRequestMessage*/ request, /*HttpCompletionOption*/ completionOption)
    {
        SendAsync(request, completionOption, CancellationToken.None);
    }
    /*Task<HttpResponseMessage>*/ SendAsync(/*HttpRequestMessage*/ request, /*HttpCompletionOption*/ completionOption, /*CancellationToken*/ cancellationToken)
    {
        // Called outside of async state machine to propagate certain exception even without awaiting the returned task.
            CheckRequestBeforeSend(request);
        CancellationTokenSourceCancellationTokenSource = PrepareCancellationTokenSource(cancellationToken);
        return Core(request, completionOption, cts, disposeCts, pendingRequestsCts, cancellationToken);
Task_$1HttpRequestMessageHttpCompletionOptionCancellationTokenSourceCancellationTokenSourceCancellationToken        {
            /*HttpResponseMessage*/ let response = null;
            {
                // Wait for the send request to complete, getting back the response.
                    response = await super.SendAsync(innerRequest, innerCts.Token);
                ThrowForNullResponse(response);
                if (ShouldBufferResponse(innerCompletionOption, innerRequest))
                {
                    await response.Content.LoadIntoBufferAsync(_maxResponseContentBufferSize, innerCts.Token);
                }
                return response;
            }
Exception            {
                HandleFailure(e, response, innerCts, originalCancellationToken, innerPendingRequestsCts);
                throw ;
            }
            {
                FinishSend(response, innerCts, innerDisposeCts);
            }
        }
    }
    /*void*/ CheckRequestBeforeSend(/*HttpRequestMessage*/ request)
    {
        if (request == null)
        throw new ArgumentNullException();
        if (_disposed)
        throw new ObjectDisposedException("request");
        CheckRequestMessage(request);
        SetOperationStarted();
        // PrepareRequestMessage will resolve the request address against the base address.
            PrepareRequestMessage(request);
    }
    /*void*/ ThrowForNullResponse(/*HttpResponseMessage*/ response)
    {
        if (response)
        {
            throw new InvalidOperationException();
        }
    }
    /*bool*/ ShouldBufferResponse(/*HttpCompletionOption*/ completionOption, /*HttpRequestMessage*/ request)
    {
        completionOption == HttpCompletionOption.ResponseContentRead  && .Equals(request.Method.Method, "HEAD", StringComparison.OrdinalIgnoreCase);
    }
    /*void*/ HandleFailure(/*Exception*/ e, /*HttpResponseMessage*/ response, /*CancellationTokenSource*/ cts, /*CancellationToken*/ cancellationToken, /*CancellationTokenSource*/ pendingRequestsCts)
    {
        responseDispose();
        /*Exception*/ let toThrow = null;
        if (e instanceof OperationCanceledException, oce = e)
        {
            if (cancellationToken.IsCancellationRequested)
            {
                if (oce.CancellationToken.Equals(cancellationToken))
                {
                    // We got a cancellation exception, and the caller requested cancellation, but the exception doesn't contain that token.
                        // Massage things so that the cancellation exception we propagate appropriately contains the caller's token (it's possible
                        // multiple things caused cancellation, in which case we can attribute it to the caller's token, or it's possible the
                        // exception contains the linked token source, in which case that token isn't meaningful to the caller).
                        e = toThrow = new TaskCanceledException(oce.Message, oce);
                }
            }
            else if (cts.IsCancellationRequested  && pendingRequestsCts.IsCancellationRequested)
            {
                if (cancellationToken.IsCancellationRequested)
                {
                    Debug.Assert(_timeout.TotalSeconds  > 0);
                    e = toThrow = new TaskCanceledException("", new TimeoutException(e.Message, e));
                }
            }
        }
        else if (e is HttpRequestException && cts.IsCancellationRequested)
        {
            // If the cancellation token source was canceled, race conditions abound, and we consider the failure to be
                // caused by the cancellation (e.g. WebException when reading from canceled response stream).
                e = toThrow = CancellationHelper.CreateOperationCanceledException(e, cts.Token);
        }
        if (toThrow != null)
        {
            throw toThrow;
        }
    }
    /*void*/ FinishSend(/*HttpResponseMessage*/ response, /*CancellationTokenSource*/ cts, /*bool*/ disposeCts)
    {
        if (disposeCts)
        {
            cts.Dispose();
        }
    }
    /*void*/ Dispose(/*bool*/ disposing)
    {
        if (disposing && _disposed)
        {
            _disposed = true;
            // Cancel all pending requests (if any). Note that we don't call CancelPendingRequests() but cancel
                // the CTS directly. The reason is that CancelPendingRequests() would cancel the current CTS and create
                // a new CTS. We don't want a new CTS in this case.
                _pendingRequestsCts.Cancel();
            _pendingRequestsCts.Dispose();
        }
        super.Dispose(disposing);
    }
    /*void*/ SetOperationStarted()
    {
        if (_operationStarted)
        {
            _operationStarted = true;
        }
    }
    /*void*/ CheckDisposedOrStarted()
    {
        if (_disposed)
        throw new ObjectDisposedException("");
        if (_operationStarted)
        {
            throw new InvalidOperationException("net_http_operation_started");
        }
    }
    /*void*/ CheckRequestMessage(/*HttpRequestMessage*/ request)
    {
        if (request.MarkAsSent())
        {
            throw new InvalidOperationException("net_http_client_request_already_sent");
        }
    }
    /*void*/ PrepareRequestMessage(/*HttpRequestMessage*/ request)
    {
        /*Uri*/ let requestUri = null;
        if (request.RequestUri  == null && _baseAddress == null)
        {
            throw new InvalidOperationException("net_http_client_invalid_requesturi");
        }
        if (request.RequestUri  == null)
        {
            requestUri = _baseAddress;
        }
        else 
        {
            if (request.RequestUri.IsAbsoluteUri())
            {
                if (_baseAddress == null)
                {
                    throw new InvalidOperationException("net_http_client_invalid_requesturi");
                }
                else 
                {
                    requestUri = new Uri(_baseAddressToString() + request.RequestUri.ToString());
                }
            }
        }
        if (requestUri != null)
        {
            request.RequestUri  = requestUri;
        }
        if (_defaultRequestHeaders != null)
        {
            request.Headers.AddHeaders(_defaultRequestHeaders);
        }
    }
    /*(CancellationTokenSource TokenSource, bool DisposeTokenSource, CancellationTokenSource PendingRequestsCts)*/ PrepareCancellationTokenSource(/*CancellationToken*/ cancellationToken)
    {
        /*// We need a CancellationTokenSource to use with the request.  We always have the global
            // _pendingRequestsCts to use, plus we may have a token provided by the caller, and we may
            // have a timeout.  If we have a timeout or a caller-provided token, we need to create a new
            // CTS (we can't, for example, timeout the pending requests CTS, as that could cancel other
            // unrelated operations).  Otherwise, we can use the pending requests CTS directly.

            // Snapshot the current pending requests cancellation source. It can change concurrently due to cancellation being requested
            // and it being replaced, and we need a stable view of it: if cancellation occurs and the caller's token hasn't been canceled,
            // it's either due to this source or due to the timeout, and checking whether this source is the culprit is reliable whereas
            // it's more approximate checking elapsed time.
            CancellationTokenSource*/ let pendingRequestsCts = _pendingRequestsCts;
        /*bool*/ let hasTimeout = _timeout != s_infiniteTimeout;
        if (hasTimeout || cancellationToken.CanBeCanceled)
        {
            /*CancellationTokenSource*/ let cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken, pendingRequestsCts.Token);
            if (hasTimeout)
            {
                cts.CancelAfter(_timeout);
            }
            return ctsDisposeTokenSource : truependingRequestsCts;
        }
        return pendingRequestsCtsDisposeTokenSource : falsependingRequestsCts;
    }
    /*Uri*/ CreateUri(/*string*/ uri)
    {
        .IsNullOrEmpty(uri)nullnew Uri(uri);
    }
    /*HttpRequestMessage*/ CreateRequestMessage(/*HttpMethod*/ method, /*Uri*/ uri)
    {
        new HttpRequestMessage(method, uri)Version = _defaultRequestVersionVersionPolicy = _defaultVersionPolicy;
    }
}

 = 0
class System_Net_Http_HttpContent extends System_IDisposable(object)
{
    /*HttpContentHeaders*/ _headers = null;
    /*LimitArrayPoolWriteStream*/ _bufferedContent = null;
    /*object*/ _contentReadStream = null;
    /*bool*/ _disposed = null;
    /*bool*/ _canCalculateLength = null;
    /*int*/ MaxBufferSize = .MaxValue;
    /*Encoding*/ DefaultStringEncoding = Encoding.UTF8;
    /*int*/ UTF8CodePage = 65001;
    /*int*/ UTF32CodePage = 12000;
    /*int*/ UnicodeCodePage = 1200;
    /*int*/ BigEndianUnicodeCodePage = 1201;
    /*ReadOnlySpan<byte>*/ get UTF8Preamble()
    {
        return [ 0xEF0xBB0xBF ];
    }
    /*ReadOnlySpan<byte>*/ get UTF32Preamble()
    {
        return [ 0xFF0xFE0x000x00 ];
    }
    /*ReadOnlySpan<byte>*/ get UnicodePreamble()
    {
        return [ 0xFF0xFE ];
    }
    /*ReadOnlySpan<byte>*/ get BigEndianUnicodePreamble()
    {
        return [ 0xFE0xFF ];
    }
    /*HttpContentHeaders*/ get Headers()
    {
        return _headers = _headers ?? new HttpContentHeaders();
    }
    /*bool*/ get IsBuffered()
    {
        return _bufferedContent;
    }
    constructor()
    {
        super();
        // We start with the assumption that we can calculate the content length.
            _canCalculateLength = true;
    }
    /*MemoryStream*/ CreateMemoryStreamFromBufferedContent()
    {
        Debug.Assert(IsBuffered);
        return new MemoryStream(_bufferedContent.GetSingleBuffer(), 0, _bufferedContent.Length, { writable : false });
    }
    /*Task<string>*/ ReadAsStringAsync()
    {
        ReadAsStringAsync(CancellationToken.None);
    }
    /*Task<string>*/ ReadAsStringAsync(/*CancellationToken*/ cancellationToken)
    {
        CheckDisposed();
        return WaitAndReturnAsync(LoadIntoBufferAsync(cancellationToken), , function(/**/ s)
        {
s.ReadBufferedContentAsString()        });
    }
    /*string*/ ReadBufferedContentAsString()
    {
        Debug.Assert(IsBuffered);
        return ReadBufferAsString(_bufferedContent, Headers);
    }
    /*string*/ ReadBufferAsString(/*LimitArrayPoolWriteStream*/ stream, /*HttpContentHeaders*/ headers)
    {
        if (stream.Length  == 0)
        {
            return .Empty;
        }
        /*// We don't validate the Content-Encoding header: If the content was encoded, it's the caller's
            // responsibility to make sure to only call ReadAsString() on already decoded content. E.g. if the
            // Content-Encoding is 'gzip' the user should set HttpClientHandler.AutomaticDecompression to get a
            // decoded response stream.
            ReadOnlySpan<byte>*/ let firstBuffer = stream.GetFirstBuffer();
        Debug.Assert(firstBuffer.Length  >= 4 || firstBuffer.Length  == stream.Length);
        /*Encoding*/ let encoding = null;
        /*int*/ let bomLength = 1;
        /*string*/ let charset = headers.ContentTypeCharSet;
        if (charset != null)
        {
            {
                if (charset.Length  > 2 && charset.StartsWith("\"") && charset.EndsWith("\""))
                {
                    encoding = Encoding.GetEncoding(charset.Substring(1, charset.Length  - 2));
                }
                else 
                {
                    encoding = Encoding.GetEncoding(charset);
                }
                // Byte-order-mark (BOM) characters may be present even if a charset was specified.
                    bomLength = GetPreambleLength(firstBuffer, encoding);
            }
ArgumentException            {
                throw new InvalidOperationException("net_http_content_invalid_charset", e);
            }
        }
        if (encoding == null)
        {
            let $v = { value: set(value){ encoding = value; } };
            let $v = { value: set(value){ bomLength = value; } };
            if (TryDetectEncoding(firstBuffer, $v, $v))
            {
                // Use the default encoding (UTF8) if we couldn't detect one.
                    encoding = DefaultStringEncoding;
                // We already checked to see if the data had a UTF8 BOM in TryDetectEncoding
                    // and DefaultStringEncoding is UTF8, so the bomLength is 0.
                    bomLength = 0;
            }
        }
        if (firstBuffer.Length  == stream.Length)
        {
            return encoding.GetString(firstBuffer.Slice(bomLength).ToArray());
        }
        else 
        {
            /*byte[]*/ let buffer = new Array((int)stream.Length);
            stream.CopyToCore(buffer);
            /*string*/ let result = encoding.GetString(buffer, bomLength, buffer.Length  - bomLength);
            return result;
        }
    }
    /*Task<byte[]>*/ ReadAsByteArrayAsync()
    {
        ReadAsByteArrayAsync(CancellationToken.None);
    }
    /*Task<byte[]>*/ ReadAsByteArrayAsync(/*CancellationToken*/ cancellationToken)
    {
        CheckDisposed();
        return WaitAndReturnAsync(LoadIntoBufferAsync(cancellationToken), , function(/**/ s)
        {
s.ReadBufferedContentAsByteArray()        });
    }
    /*byte[]*/ ReadBufferedContentAsByteArray()
    {
        Debug.Assert(_bufferedContent != null);
        return _bufferedContent.CreateCopy();
    }
    /*Stream*/ ReadAsStream()
    {
        ReadAsStream(CancellationToken.None);
    }
    /*Stream*/ ReadAsStream(/*CancellationToken*/ cancellationToken)
    {
        CheckDisposed();
        if (_contentReadStream == null)
        {
            /*Stream*/ let s = IsBufferedCreateMemoryStreamFromBufferedContent()CreateContentReadStream(cancellationToken);
            _contentReadStream = s;
            return s;
        }
        else if (_contentReadStream instanceof Stream, stream = _contentReadStream)
        {
            return stream;
        }
        else 
        {
            throw new HttpRequestException("net_http_content_read_as_stream_has_task");
        }
    }
    /*Task<Stream>*/ ReadAsStreamAsync()
    {
        ReadAsStreamAsync(CancellationToken.None);
    }
    /*Task<Stream>*/ ReadAsStreamAsync(/*CancellationToken*/ cancellationToken)
    {
        CheckDisposed();
        if (_contentReadStream == null)
        {
            /*Task<Stream>*/ let t = IsBufferedTask.FromResult(Stream, CreateMemoryStreamFromBufferedContent())CreateContentReadStreamAsync(cancellationToken);
            _contentReadStream = t;
            return t;
        }
        else if (_contentReadStream instanceof Task_$1, t = _contentReadStream)
        {
            return t;
        }
        else 
        {
            Debug.Assert(_contentReadStream is Stream, _contentReadStream);
            /*Task<Stream>*/ let ts = Task.FromResult(Stream_contentReadStream);
            _contentReadStream = ts;
            return ts;
        }
    }
    /*Stream*/ TryReadAsStream()
    {
        CheckDisposed();
        if (_contentReadStream == null)
        {
            /*Stream*/ let s = IsBufferedCreateMemoryStreamFromBufferedContent()TryCreateContentReadStream();
            _contentReadStream = s;
            return s;
        }
        else if (_contentReadStream instanceof Stream, s = _contentReadStream)
        {
            return s;
        }
        else 
        {
            Debug.Assert(_contentReadStream is Task_$1, _contentReadStream);
            /*Task<Stream>*/ let t = Task_$1_contentReadStream;
            return t.Status  == TaskStatus.RanToCompletion t.Result null;
        }
    }
    /*void*/ SerializeToStream(/*Stream*/ stream, /*CancellationToken*/ cancellationToken)
    {
        throw new NotSupportedException("net_http_missing_sync_implementation");
    }
    /*Task*/ SerializeToStreamAsync(/*Stream*/ stream, /*CancellationToken*/ cancellationToken)
    {
        SerializeToStreamAsync(stream);
    }
    /*bool*/ get AllowDuplex()
    {
        return true;
    }
    /*void*/ CopyTo(/*Stream*/ stream, /*CancellationToken*/ cancellationToken)
    {
        CheckDisposed();
        if (stream == null)
        throw new ArgumentNullException(nameof(stream));
        {
            if (IsBuffered)
            {
                stream.Write(_bufferedContent.GetSingleBuffer(), 0, _bufferedContent.Length);
            }
            else 
            {
                SerializeToStream(stream, cancellationToken);
            }
        }
ExceptionStreamCopyExceptionNeedsWrapping(e)        {
            throw GetStreamCopyException(e);
        }
    }
    /*Task*/ CopyToAsync(/*Stream*/ stream)
    {
        CopyToAsync(stream, CancellationToken.None);
    }
    /*Task*/ async WaitAsync(/*Task*/ copyTask)
    {
        {
            await copyTask;
        }
ExceptionStreamCopyExceptionNeedsWrapping(e)        {
            throw WrapStreamCopyException(e);
        }
    }
    /*Task*/ CopyToAsync(/*Stream*/ stream, /*CancellationToken*/ cancellationToken)
    {
        CheckDisposed();
        if (stream == null)
        throw new ArgumentNullException(nameof(stream));
        {
            return WaitAsync(InternalCopyToAsync(stream, cancellationToken));
        }
ExceptionStreamCopyExceptionNeedsWrapping(e)        {
            throw GetStreamCopyException(e);
        }
    }
    /*Task*/ InternalCopyToAsync(/*Stream*/ stream, /*CancellationToken*/ cancellationToken)
    {
        if (IsBuffered)
        {
            return stream.WriteAsync(_bufferedContent.GetSingleBuffer(), cancellationToken);
        }
        /*Task*/ let task = SerializeToStreamAsync(stream, cancellationToken);
        CheckTaskNotNull(task);
        return task;
    }
    /*void*/ LoadIntoBuffer(/*long*/ maxBufferSize, /*CancellationToken*/ cancellationToken)
    {
        CheckDisposed();
        let tempBuffer = null;
        let $v = { value: set(value){ tempBuffer = value; } };
        let error = null;
        let $v = { value: set(value){ error = value; } };
        if (CreateTemporaryBuffer(maxBufferSize, $v, $v))
        {
            return ;
        }
        if (tempBuffer == null)
        {
            throw error;
        }
        /*// Register for cancellation and tear down the underlying stream in case of cancellation/timeout.
            // We're only comfortable disposing of the HttpContent instance like this because LoadIntoBuffer is internal and
            // we're only using it on content instances we get back from a handler's Send call that haven't been given out to the user yet.
            // If we were to ever make LoadIntoBuffer public, we'd need to rethink this.
            CancellationTokenRegistration*/ let cancellationRegistration = cancellationToken.Register(function(/**/ s)
        {
HttpContents.Dispose()        }, );
        {
            SerializeToStream(tempBuffer, cancellationToken);
        }
Exception        {
            tempBuffer.Dispose();
            if (CancellationHelper.ShouldWrapInOperationCanceledException(e, cancellationToken))
            {
                throw CancellationHelper.CreateOperationCanceledException(e, cancellationToken);
            }
            if (StreamCopyExceptionNeedsWrapping(e))
            {
                throw GetStreamCopyException(e);
            }
            throw ;
        }
        {
            // Clean up the cancellation registration.
                cancellationRegistration.Dispose();
        }
        tempBuffer.ReallocateIfPooled();
        _bufferedContent = tempBuffer;
    }
    /*Task*/ LoadIntoBufferAsync()
    {
        LoadIntoBufferAsync(MaxBufferSize);
    }
    /*Task*/ LoadIntoBufferAsync(/*long*/ maxBufferSize)
    {
        LoadIntoBufferAsync(maxBufferSize, CancellationToken.None);
    }
    /*Task*/ LoadIntoBufferAsync(/*CancellationToken*/ cancellationToken)
    {
        LoadIntoBufferAsync(MaxBufferSize, cancellationToken);
    }
    /*Task*/ LoadIntoBufferAsync(/*long*/ maxBufferSize, /*CancellationToken*/ cancellationToken)
    {
        CheckDisposed();
        let tempBuffer = null;
        let $v = { value: set(value){ tempBuffer = value; } };
        let error = null;
        let $v = { value: set(value){ error = value; } };
        if (CreateTemporaryBuffer(maxBufferSize, $v, $v))
        {
            return Task.CompletedTask;
        }
        if (tempBuffer == null)
        {
            throw error;
        }
        {
            /*Task*/ let task = SerializeToStreamAsync(tempBuffer, cancellationToken);
            CheckTaskNotNull(task);
            return LoadIntoBufferAsyncCore(task, tempBuffer);
        }
Exception        {
            tempBuffer.Dispose();
            if (StreamCopyExceptionNeedsWrapping(e))
            {
                throw GetStreamCopyException(e);
            }
            throw ;
        }
    }
    /*Task*/ async LoadIntoBufferAsyncCore(/*Task*/ serializeToStreamTask, /*LimitArrayPoolWriteStream*/ tempBuffer)
    {
        {
            await serializeToStreamTask;
        }
Exception        {
            tempBuffer.Dispose();
            /*Exception*/ let we = GetStreamCopyException(e);
            if (we != e)
            throw we;
            throw ;
        }
        tempBuffer.ReallocateIfPooled();
        _bufferedContent = tempBuffer;
    }
    /*Stream*/ CreateContentReadStream(/*CancellationToken*/ cancellationToken)
    {
        LoadIntoBuffer(MaxBufferSize, cancellationToken);
        return CreateMemoryStreamFromBufferedContent();
    }
    /*Task<Stream>*/ CreateContentReadStreamAsync()
    {
        return WaitAndReturnAsync(LoadIntoBufferAsync(), , function(/**/ s)
        {
Streams.CreateMemoryStreamFromBufferedContent()        });
    }
    /*Task<Stream>*/ CreateContentReadStreamAsync(/*CancellationToken*/ cancellationToken)
    {
        return CreateContentReadStreamAsync();
    }
    /*Stream*/ TryCreateContentReadStream()
    {
        null;
    }
    /*long?*/ GetComputedOrBufferLength()
    {
        CheckDisposed();
        if (IsBuffered)
        {
            return _bufferedContent.Length;
        }
        if (_canCalculateLength)
        {
            /*long*/ let length;
            let $v = { value: set(value){ length = value; } };
            if (TryComputeLength($v))
            {
                return length;
            }
            // Set flag to make sure next time we don't try to compute the length, since we know that we're unable
                // to do so.
                _canCalculateLength = false;
        }
        return null;
    }
    /*bool*/ CreateTemporaryBuffer(/*long*/ maxBufferSize, /*LimitArrayPoolWriteStream*/ tempBuffer, /*Exception*/ error)
    {
        if (maxBufferSize > HttpContent.MaxBufferSize)
        {
            throw new ArgumentOutOfRangeException(nameof(maxBufferSize), maxBufferSize, "net_http_content_buffersize_limit");
        }
        if (IsBuffered)
        {
            // If we already buffered the content, just return false.
                tempBuffer = default;
            error = default;
            return false;
        }
        /*// If we have a Content-Length allocate the right amount of buffer up-front. Also check whether the
            // content length exceeds the max. buffer size.
            long*/ let contentLength = Headers.ContentLength.GetValueOrDefault();
        Debug.Assert(contentLength >= 0);
        if (contentLength > maxBufferSize)
        {
            tempBuffer = null;
            error = CreateOverCapacityException(maxBufferSize);
        }
        else 
        {
            tempBuffer = new LimitArrayPoolWriteStream(maxBufferSize, contentLength, { getFinalSizeFromPool : false });
            error = null;
        }
        return true;
    }
    /*void*/ Dispose(/*bool*/ disposing)
    {
        if (disposing && _disposed)
        {
            _disposed = true;
            if (_contentReadStream != null)
            {
                /*Stream*/ let s = _contentReadStream as Stream ?? _contentReadStream instanceof Task_$1, t = _contentReadStream && t.Status  == TaskStatus.RanToCompletion t.Result null;
                sDispose();
                _contentReadStream = null;
            }
            if (IsBuffered)
            {
                _bufferedContent.Dispose();
            }
        }
    }
    /*void*/ Dispose()
    {
        Dispose(true);
    }
    /*void*/ CheckDisposed()
    {
        if (_disposed)
        throw new ObjectDisposedException("");
    }
    /*void*/ CheckTaskNotNull(/*Task*/ task)
    {
        if (task == null)
        {
            /*var*/ let e = new InvalidOperationException("net_http_content_no_task_returned");
            throw e;
        }
    }
    /*bool*/ StreamCopyExceptionNeedsWrapping(/*Exception*/ e)
    {
        e is IOException || e is ObjectDisposedException;
    }
    /*Exception*/ GetStreamCopyException(/*Exception*/ originalException)
    {
        return StreamCopyExceptionNeedsWrapping(originalException)WrapStreamCopyException(originalException)originalException;
    }
    /*Exception*/ WrapStreamCopyException(/*Exception*/ e)
    {
        Debug.Assert(StreamCopyExceptionNeedsWrapping(e));
        /*HttpRequestError*/ let error = e instanceof HttpIOException, ioEx = eioEx.HttpRequestError HttpRequestError.Unknown;
        return new HttpRequestException(error, "net_http_content_stream_copy_error", e);
    }
    /*int*/ GetPreambleLength(/*ReadOnlySpan<byte>*/ data, /*Encoding*/ encoding)
    {
        Debug.Assert(encoding != null);
        switch(encoding.CodePage)
        {
            case UTF8CodePage:
            {
                return data.StartsWith(UTF8Preamble)UTF8Preamble.Length 0;
            }
            case UTF32CodePage:
            {
                return data.StartsWith(UTF32Preamble)UTF32Preamble.Length 0;
            }
            case UnicodeCodePage:
            {
                return data.StartsWith(UnicodePreamble)UnicodePreamble.Length 0;
            }
            case BigEndianUnicodeCodePage:
            {
                return data.StartsWith(BigEndianUnicodePreamble)BigEndianUnicodePreamble.Length 0;
            }
            default:            {
                return 0;
            }
        }
    }
    /*bool*/ TryDetectEncoding(/*ReadOnlySpan<byte>*/ data, /*Encoding*/ encoding, /*int*/ preambleLength)
    {
        if (data.StartsWith(UTF8Preamble))
        {
            encoding = Encoding.UTF8;
            preambleLength = UTF8Preamble.Length;
            return true;
        }
        if (data.StartsWith(UTF32Preamble))
        {
            encoding = Encoding.UTF32;
            preambleLength = UTF32Preamble.Length;
            return true;
        }
        if (data.StartsWith(UnicodePreamble))
        {
            encoding = Encoding.Unicode;
            preambleLength = UnicodePreamble.Length;
            return true;
        }
        if (data.StartsWith(BigEndianUnicodePreamble))
        {
            encoding = Encoding.BigEndianUnicode;
            preambleLength = BigEndianUnicodePreamble.Length;
            return true;
        }
        encoding = null;
        preambleLength = 0;
        return false;
    }
    /*Task<TResult>*/ async WaitAndReturnAsync(TState, TResult, /*Task*/ waitTask, /*TState*/ state, /*Func<TState, TResult>*/ returnFunc)
    {
        await waitTask;
        return returnFunc(state);
    }
    /*HttpRequestException*/ CreateOverCapacityException(/*long*/ maxBufferSize)
    {
        return new HttpRequestException(HttpRequestError.ConfigurationLimitExceeded, "net_http_content_buffersize_exceeded");
    }
    class System_Net_Http_LimitArrayPoolWriteStream extends System_IO_AsyncStream
    {
        /*int*/ MinInitialBufferSize = 16 * 1024;
        /*int*/ MaxInitialBufferSize = 16 * 1024 * 1024;
        /*int*/ ResizeFactor = 2;
        /*int*/ LastResizeFactor = 4;
        /*int*/ _maxBufferSize = null;
        /*int*/ _expectedFinalSize = null;
        /*bool*/ _shouldPoolFinalSize = null;
        /*bool*/ _lastBufferIsPooled = null;
        /*byte[]*/ _lastBuffer = null;
        /*byte[][]*/ _pooledBuffers = null;
        /*int*/ _lastBufferOffset = null;
        /*int*/ _totalLength = null;
        constructor(/*int*/ maxBufferSize, /*long*/ expectedFinalSize, /*bool*/ getFinalSizeFromPool)
        {
            super();
            Debug.Assert(maxBufferSize >= 0);
            Debug.Assert(expectedFinalSize >= 0);
            if (expectedFinalSize > maxBufferSize)
            {
                throw CreateOverCapacityException(maxBufferSize);
            }
            _maxBufferSize = maxBufferSize;
            _expectedFinalSize = expectedFinalSize;
            _shouldPoolFinalSize = getFinalSizeFromPool || expectedFinalSize == 0;
            _lastBufferIsPooled = false;
            _lastBuffer = new Array(0);
        }
        /*void*/ Dispose(/*bool*/ disposing)
        {
            ReturnAllPooledBuffers();
            super.Dispose(disposing);
        }
        /*byte[]*/ ToArray()
        {
            Debug.Assert(_shouldPoolFinalSize || _expectedFinalSize == 0);
            if (_lastBufferIsPooled && _totalLength == _lastBuffer.Length)
            {
                Debug.Assert(_pooledBuffers);
                return _lastBuffer;
            }
            if (_totalLength == 0)
            {
                return new Array(0);
            }
            /*byte[]*/ let buffer = new Array(_totalLength);
            CopyToCore(buffer);
            return buffer;
        }
        /*byte[]*/ GetSingleBuffer()
        {
            Debug.Assert(_lastBufferIsPooled);
            Debug.Assert(_pooledBuffers);
            return _lastBuffer;
        }
        /*ReadOnlySpan<byte>*/ GetFirstBuffer()
        {
            return _pooledBuffers instanceof , buffers = _pooledBuffersbuffers0_lastBuffer.AsReadOnlySpan(0, _totalLength);
        }
        /*byte[]*/ CreateCopy()
        {
            Debug.Assert(_lastBufferIsPooled);
            Debug.Assert(_pooledBuffers);
            Debug.Assert(_lastBufferOffset == _totalLength);
            Debug.Assert(_lastBufferOffset <= _lastBuffer.Length);
            return _lastBuffer.AsSpan(0, _totalLength).ToArray();
        }
        /*void*/ ReallocateIfPooled()
        {
            Debug.Assert(_lastBufferIsPooled || _pooledBuffers);
            if (_lastBufferIsPooled)
            {
                /*byte[]*/ let newBuffer = new Array(_totalLength);
                CopyToCore(newBuffer);
                ReturnAllPooledBuffers();
                _lastBuffer = newBuffer;
                _lastBufferOffset = newBuffer.Length;
            }
        }
        /*Task<int>*/ ReadAsync(/*Span<byte>*/ buffer, /*CancellationToken*/ cancellationToken)
        {
            throw new NotImplementedException();
        }
        /*Task<int>*/ WriteAsync(/*ReadOnlySpan<byte>*/ buffer, /*CancellationToken*/ cancellationToken)
        {
            if (_maxBufferSize - _totalLength < buffer.Length)
            {
                throw CreateOverCapacityException(_maxBufferSize);
            }
            /*byte[]*/ let lastBuffer = _lastBuffer;
            /*int*/ let offset = _lastBufferOffset;
            if (lastBuffer.Length  - offset >= buffer.Length)
            {
                buffer.CopyTo(lastBuffer.AsSpan(offset));
                _lastBufferOffset = offset + buffer.Length;
                _totalLength += buffer.Length;
            }
            else 
            {
                GrowAndWrite(buffer);
            }
            return Task.FromResult(buffer.Length);
        }
        /*void*/ GrowAndWrite(/*ReadOnlySpan<byte>*/ buffer)
        {
            Debug.Assert(_totalLength + buffer.Length  <= _maxBufferSize);
            /*int*/ let lastBufferCapacity = _lastBuffer.Length;
            /*// Start by doubling the current array size.
                int*/ let newBufferCapacity = Math.Min(lastBufferCapacity * ResizeFactor, 100 * 1024 * 1024);
            // If the required length is longer than Array.MaxLength, we'll let the runtime throw.
                newBufferCapacity = Math.Max(newBufferCapacity, _totalLength + buffer.Length);
            if (lastBufferCapacity == 0)
            {
                /*int*/ let minCapacity = _expectedFinalSize == 0MinInitialBufferSizeMath.Min(_expectedFinalSize, MaxInitialBufferSize / LastResizeFactor);
                newBufferCapacity = Math.Max(newBufferCapacity, minCapacity);
            }
            /*// Avoid having the last buffer expand beyond the size limit too much.
                // It may still go beyond the limit somewhat due to the ArrayPool's buffer sizes being powers of 2.
                int*/ let currentTotalCapacity = _totalLength - _lastBufferOffset + lastBufferCapacity;
            /*int*/ let remainingUntilMaxCapacity = _maxBufferSize - currentTotalCapacity;
            newBufferCapacity = Math.Min(newBufferCapacity, remainingUntilMaxCapacity);
            /*int*/ let newTotalCapacity = currentTotalCapacity + newBufferCapacity;
            Debug.Assert(newBufferCapacity > 0);
            /*byte[]*/ let newBuffer;
            if (_shouldPoolFinalSize && newTotalCapacity >= _expectedFinalSize / LastResizeFactor)
            {
                // We knew the Content-Length upfront, and the caller needs an exactly-sized, non-pooled, buffer.
                    // It's almost certain that the final length will match the expected size,
                    // so we switch from pooled buffers to a regular array now to reduce memory copies.
                    // It's possible we're writing more bytes than the expected final size if the handler/content is not
                    // enforcing Content-Length correctness. Such requests will likely throw later on anyway.
                    newBuffer = new Array(_totalLength + buffer.Length <= _expectedFinalSize ? _expectedFinalSize : newTotalCapacity);
                CopyToCore(newBuffer);
                ReturnAllPooledBuffers();
                buffer.CopyTo(newBuffer.AsSpan(_totalLength));
                _totalLength += buffer.Length;
                _lastBufferOffset = _totalLength;
                _lastBufferIsPooled = false;
            }
            else if (lastBufferCapacity == 0)
            {
                // This is the first write call, allocate the initial buffer.
                    Debug.Assert(_pooledBuffers);
                Debug.Assert(_lastBufferOffset == 0);
                Debug.Assert(_totalLength == 0);
                newBuffer = ArrayPool_$1.Shared.Rent(newBufferCapacity);
                Debug.Assert(_shouldPoolFinalSize || newBuffer.Length  != _expectedFinalSize);
                buffer.CopyTo(newBuffer);
                _totalLength = _lastBufferOffset = buffer.Length;
                _lastBufferIsPooled = true;
            }
            else 
            {
                Debug.Assert(_lastBufferIsPooled);
                _totalLength += buffer.Length;
                /*// When buffers are stored in '_pooledBuffers', they are assumed to be full.
                    // Copy as many bytes as we can fit into the current buffer now.
                    Span<byte>*/ let remainingInCurrentBuffer = _lastBuffer.AsSpan(_lastBufferOffset);
                Debug.Assert(remainingInCurrentBuffer.Length  < buffer.Length);
                buffer.Slice(0, remainingInCurrentBuffer.Length).CopyTo(remainingInCurrentBuffer);
                buffer = buffer.Slice(remainingInCurrentBuffer.Length);
                newBuffer = ArrayPool_$1.Shared.Rent(newBufferCapacity);
                buffer.CopyTo(newBuffer);
                _lastBufferOffset = buffer.Length;
                /*// Find the first empty slot in '_pooledBuffers', resizing the array if needed.
                    int*/ let bufferCount = 0;
                if (_pooledBuffers)
                {
                    // Starting with 4 buffers means we'll have capacity for at least
                        // 16 KB + 32 KB + 64 KB + 128 KB + 256 KB (last buffer) = 496 KB
                        //_pooledBuffers = new byte[][4];
                        _pooledBuffers = [  ];
                }
                else 
                {
                    /*byte[][]*/ let buffers = _pooledBuffers;
                    while(bufferCount < buffers.Length  && buffersbufferCount)
                    {
                        bufferCount++;
                    }
                    if (bufferCount == buffers.Length)
                    {
                        Debug.Assert(bufferCount <= 16);
                        // After the first resize, we should have enough capacity for at least ~8 MB.
                            // ~128 MB after the second, ~2 GB after the third.
                        let $v = { value: set(value){ _pooledBuffers = value; } };
                            Array.Resize($v, bufferCount + 4);
                    }
                }
                _pooledBuffersbufferCount = _lastBuffer;
            }
            _lastBuffer = newBuffer;
        }
        /*void*/ CopyToCore(/*Span<byte>*/ destination)
        {
            Debug.Assert(destination.Length  >= _totalLength);
            if (_pooledBuffers instanceof , buffers = _pooledBuffers)
            {
                Debug.Assert(buffers.Length  > 0 && buffers0);
                BlazorJs.forEach(buffers, function(buffer, $_i)
                {
                    if (buffer)
                    {
                        break;
                    }
                    Debug.Assert(destination.Length  >= buffer.Length);
                    buffer.AsSpan().CopyTo(destination);
                    destination = destination.Slice(buffer.Length);
                });
            }
            Debug.Assert(_lastBufferOffset <= _lastBuffer.Length);
            Debug.Assert(_lastBufferOffset <= destination.Length);
            _lastBuffer.AsSpan(0, _lastBufferOffset).CopyTo(destination);
        }
        /*void*/ ReturnAllPooledBuffers()
        {
            if (_pooledBuffers instanceof , buffers = _pooledBuffers)
            {
                _pooledBuffers = null;
                BlazorJs.forEach(buffers, function(buffer, $_i)
                {
                    if (buffer)
                    {
                        break;
                    }
                    ArrayPool_$1.Shared.Return(buffer);
                });
            }
            Debug.Assert(_lastBuffer);
            /*byte[]*/ let lastBuffer = _lastBuffer;
            _lastBuffer = null;
            if (_lastBufferIsPooled)
            {
                _lastBufferIsPooled = false;
                ArrayPool_$1.Shared.Return(lastBuffer);
            }
        }
        /*void*/ Flush()
        {
        }
        /*Task*/ FlushAsync(/*CancellationToken*/ cancellationToken)
        {
            Task.CompletedTask;
        }
        /*long*/ get Length()
        {
            return _totalLength;
        }
        /*bool*/ get CanWrite()
        {
            return true;
        }
        /*bool*/ get CanRead()
        {
            return false;
        }
        /*bool*/ get CanSeek()
        {
            return false;
        }
        /*long*/ get Position()
        {
            throw new NotSupportedException();
        }
        /*long*/ set Position(value)
        {
            throw new NotSupportedException();
        }
        /*int*/ Read(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count)
        {
            throw new NotSupportedException();
        }
        /*long*/ Seek(/*long*/ offset, /*SeekOrigin*/ origin)
        {
            throw new NotSupportedException();
        }
        /*void*/ SetLength(/*long*/ value)
        {
            throw new NotSupportedException();
        }
    }
}

class System_Net_Http_HttpHandlerDefaults extends object
{
    constructor()
    {
        super();
    }
    /*int*/ DefaultInitialHttp2StreamWindowSize = 65535;
}

class System_Net_Http_HttpIOException extends System_IO_IOException
{
    constructor(/*HttpRequestError*/ httpRequestError, /*string*/ message, /*Exception*/ innerException)
    {
        super(message, innerException);
        HttpRequestError = httpRequestError;
    }
    /*HttpRequestError*/ _backingField_HttpRequestError = null;
    /*HttpRequestError*/ get HttpRequestError()
    {
        return _backingField_HttpRequestError;
    }
    /*string*/ get Message()
    {
        return super.MessageHttpRequestError;
    }
}

class System_Net_Http_HttpMessageHandler extends System_IDisposable(object)
{
    constructor()
    {
        super();
    }
    /*HttpResponseMessage*/ Send(/*HttpRequestMessage*/ request, /*CancellationToken*/ cancellationToken)
    {
        throw new NotSupportedException();
    }
    /*void*/ Dispose(/*bool*/ disposing)
    {
    }
    /*void*/ Dispose()
    {
        Dispose(true);
    }
}

class System_Net_Http_HttpMessageInvoker extends System_IDisposable(object)
{
    /*bool*/ _disposed = null;
    /*bool*/ _disposeHandler = null;
    /*HttpMessageHandler*/ _handler = null;
    constructor(/*HttpMessageHandler*/ handler)
    {
        super(handler, true);
    }
    constructor(/*HttpMessageHandler*/ handler, /*bool*/ disposeHandler)
    {
        super();
        _handler = handler;
        _disposeHandler = disposeHandler;
    }
    /*HttpResponseMessage*/ Send(/*HttpRequestMessage*/ request, /*CancellationToken*/ cancellationToken)
    {
        return _handler.Send(request, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ SendAsync(/*HttpRequestMessage*/ request, /*CancellationToken*/ cancellationToken)
    {
        return _handler.SendAsync(request, cancellationToken);
    }
    /*void*/ Dispose()
    {
        Dispose(true);
    }
    /*void*/ Dispose(/*bool*/ disposing)
    {
        if (disposing && _disposed)
        {
            _disposed = true;
            if (_disposeHandler)
            {
                _handler.Dispose();
            }
        }
    }
}

class System_Net_Http_HttpMethod extends H5_IH5Class(System_IEquatable<System_Net_Http_HttpMethod>(object))
{
    /*string*/ _method = null;
    /*int*/ _hashcode = null;
    /*HttpMethod*/ _backingField_Get = null;
    /*HttpMethod*/ get Get()
    {
        return _backingField_Get;
    }
    /*HttpMethod*/ _backingField_Put = null;
    /*HttpMethod*/ get Put()
    {
        return _backingField_Put;
    }
    /*HttpMethod*/ _backingField_Post = null;
    /*HttpMethod*/ get Post()
    {
        return _backingField_Post;
    }
    /*HttpMethod*/ _backingField_Delete = null;
    /*HttpMethod*/ get Delete()
    {
        return _backingField_Delete;
    }
    /*HttpMethod*/ _backingField_Head = null;
    /*HttpMethod*/ get Head()
    {
        return _backingField_Head;
    }
    /*HttpMethod*/ _backingField_Options = null;
    /*HttpMethod*/ get Options()
    {
        return _backingField_Options;
    }
    /*HttpMethod*/ _backingField_Trace = null;
    /*HttpMethod*/ get Trace()
    {
        return _backingField_Trace;
    }
    /*HttpMethod*/ _backingField_Patch = null;
    /*HttpMethod*/ get Patch()
    {
        return _backingField_Patch;
    }
    /*HttpMethod*/ _backingField_Connect = null;
    /*HttpMethod*/ get Connect()
    {
        return _backingField_Connect;
    }
    /*string*/ get Method()
    {
        return _method;
    }
    constructor(/*string*/ method)
    {
        super();
        if (.IsNullOrEmpty(method))
        throw new ArgumentException();
        if (HttpRuleParser.IsToken(method.AsSpan()))
        {
            throw new FormatException("net_http_httpmethod_format_error");
        }
        _method = method;
    }
    /*bool*/ Equals(/*HttpMethod*/ other)
    {
        other && .Equals(_method, other._method, StringComparison.OrdinalIgnoreCase);
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        obj instanceof HttpMethod, method = obj && Equals(method);
    }
    /*int*/ GetHashCode()
    {
        if (_hashcode == 0)
        {
            _hashcode = StringComparer.OrdinalIgnoreCase.GetHashCode(_method);
        }
        return _hashcode;
    }
    /*string*/ ToString()
    {
        _method;
    }
HttpMethodHttpMethod    ReferenceEquals(left, null) || ReferenceEquals(right, null)ReferenceEquals(left, right)left.Equals(right);
HttpMethodHttpMethod    left == right;
    /*HttpMethod*/ Parse(/*ReadOnlySpan<char>*/ method)
    {
        GetKnownMethod(method) ?? new HttpMethod(method.ToString());
    }
    /*HttpMethod*/ GetKnownMethod(/*ReadOnlySpan<char>*/ method)
    {
        if (method.Length  >= 3)
        {
            /*HttpMethod*/ let match = null;
            switch(method0 | 0x20)
            {
                case 'c':
                {
                    match = Connect;
                    break;
                }
                case 'd':
                {
                    match = Delete;
                    break;
                }
                case 'g':
                {
                    match = Get;
                    break;
                }
                case 'h':
                {
                    match = Head;
                    break;
                }
                case 'o':
                {
                    match = Options;
                    break;
                }
                case 'p':
                {
                    switch(method.Length)
                    {
                        case 3:
                        {
                            match = Put;
                            break;
                        }
                        case 4:
                        {
                            match = Post;
                            break;
                        }
                        default:                        {
                            match = Patch;
                            break;
                        }
                    }
                    match = Head;
                    break;
                }
                case 't':
                {
                    match = Trace;
                    break;
                }
            }
            if (match && method.IsEqual(match._method, StringComparison.OrdinalIgnoreCase))
            {
                return match;
            }
        }
        return null;
    }
}


 = 0
class System_Net_Http_HttpRequestException extends System_Exception
{
    /*RequestRetryType*/ _backingField_AllowRetry = null;
    /*RequestRetryType*/ get AllowRetry()
    {
        return _backingField_AllowRetry;
    }
    constructor()
    {
        super();
    }
    constructor(/*string*/ message)
    {
        super(message);
    }
    constructor(/*string*/ message, /*Exception*/ inner)
    {
        super(message, inner);
        if (inner != null)
        {
            HResult = inner.HResult;
        }
    }
    constructor(/*string*/ message, /*Exception*/ inner, /*HttpStatusCode?*/ statusCode)
    {
        super(message, inner);
        StatusCode = statusCode;
    }
    constructor(/*HttpRequestError*/ httpRequestError, /*string*/ message, /*Exception*/ inner, /*HttpStatusCode?*/ statusCode)
    {
        super(message, inner, statusCode);
        HttpRequestError = httpRequestError;
    }
    /*HttpRequestError*/ _backingField_HttpRequestError = null;
    /*HttpRequestError*/ get HttpRequestError()
    {
        return _backingField_HttpRequestError;
    }
    /*HttpStatusCode?*/ _backingField_StatusCode = null;
    /*HttpStatusCode?*/ get StatusCode()
    {
        return _backingField_StatusCode;
    }
    constructor(/*HttpRequestError*/ httpRequestError, /*string*/ message, /*Exception*/ inner, /*RequestRetryType*/ allowRetry)
    {
        super(httpRequestError, message, inner);
        AllowRetry = allowRetry;
    }
}

class System_Net_Http_HttpRequestMessage extends System_IDisposable(object)
{
    /*Version*/ get DefaultRequestVersion()
    {
        return HttpVersion.Version11;
    }
    /*HttpVersionPolicy*/ get DefaultVersionPolicy()
    {
        return HttpVersionPolicy.RequestVersionOrLower;
    }
    /*int*/ MessageNotYetSent = 0;
    /*int*/ MessageAlreadySent = 1;
    /*int*/ MessageIsRedirect = 2;
    /*int*/ MessageDisposed = 4;
    /*int*/ _sendStatus = MessageNotYetSent;
    /*HttpMethod*/ _method = null;
    /*Uri*/ _requestUri = null;
    /*HttpRequestHeaders*/ _headers = null;
    /*Version*/ _version = null;
    /*HttpVersionPolicy*/ _versionPolicy = null;
    /*HttpContent*/ _content = null;
    /*HttpRequestOptions*/ _options = null;
    /*Version*/ get Version()
    {
        return _version;
    }
    /*Version*/ set Version(value)
    {
        if (value == null)
        throw new ArgumentNullException();
        CheckDisposed();
        _version = value;
    }
    /*HttpVersionPolicy*/ get VersionPolicy()
    {
        return _versionPolicy;
    }
    /*HttpVersionPolicy*/ set VersionPolicy(value)
    {
        CheckDisposed();
        _versionPolicy = value;
    }
    /*HttpContent*/ get Content()
    {
        return _content;
    }
    /*HttpContent*/ set Content(value)
    {
        CheckDisposed();
        // It's OK to set a 'null' content, even if the method is POST/PUT.
                _content = value;
    }
    /*HttpMethod*/ get Method()
    {
        return _method;
    }
    /*HttpMethod*/ set Method(value)
    {
        if (value == null)
        throw new ArgumentNullException();
        CheckDisposed();
        _method = value;
    }
    /*Uri*/ get RequestUri()
    {
        return _requestUri;
    }
    /*Uri*/ set RequestUri(value)
    {
        CheckDisposed();
        _requestUri = value;
    }
    /*HttpRequestHeaders*/ get Headers()
    {
        return _headers = _headers ?? new HttpRequestHeaders();
    }
    /*bool*/ get HasHeaders()
    {
        return _headers != null;
    }
    /*IDictionary<string, object>*/ get Properties()
    {
        return Options;
    }
    /*HttpRequestOptions*/ get Options()
    {
        return _options = _options ?? new HttpRequestOptions();
    }
    constructor()
    {
        super(HttpMethod.Get, Urinull);
    }
    constructor(/*HttpMethod*/ method, /*Uri*/ requestUri)
    {
        super();
        if (method == null)
        throw new ArgumentNullException();
        // It's OK to have a 'null' request Uri. If HttpClient is used, the 'BaseAddress' will be added.
            // If there is no 'BaseAddress', sending this request message will throw.
            // Note that we also allow the string to be empty: null and empty are considered equivalent.
            _method = method;
        _requestUri = requestUri;
        _version = DefaultRequestVersion;
        _versionPolicy = DefaultVersionPolicy;
    }
    constructor(/*HttpMethod*/ method, /*string*/ requestUri)
    {
        super(method, .IsNullOrEmpty(requestUri)nullnew Uri(requestUri/*, UriKind.RelativeOrAbsolute*/));
    }
    /*string*/ ToString()
    {
        /*StringBuilder*/ let sb = new StringBuilder();
        sb.Append("Method: ");
        sb.Append(_method);
        sb.Append(", RequestUri: '");
        if (_requestUri)
        {
            sb.Append("<null>");
        }
        else 
        {
            sb.Append(_requestUri);
        }
        sb.Append("', Version: ");
        sb.Append(_version);
        sb.Append(", Content: ");
        sb.Append(_content == null"<null>"_content.GetType().ToString());
        sb.AppendLine(", Headers:");
        HeaderUtilities.DumpHeaders(sb, _headers, _contentHeaders);
        return sb.ToString();
    }
    /*bool*/ MarkAsSent()
    {
        let $v = { value: set(value){ _sendStatus = value; } };
        return InterlockedExtension.CompareExchange($v, MessageAlreadySent, MessageNotYetSent) == MessageNotYetSent;
    }
    /*bool*/ WasSentByHttpClient()
    {
        _sendStatus & MessageAlreadySent != 0;
    }
    /*void*/ MarkAsRedirected()
    {
        _sendStatus |= MessageIsRedirect;
    }
    /*bool*/ WasRedirected()
    {
        _sendStatus & MessageIsRedirect != 0;
    }
    /*bool*/ get Disposed()
    {
        return _sendStatus & MessageDisposed != 0;
    }
    /*bool*/ set Disposed(value)
    {
        Debug.Assert(value);
        _sendStatus |= MessageDisposed;
    }
    /*bool*/ get IsExtendedConnectRequest()
    {
        return Method == HttpMethod.Connect  && _headersProtocol != null;
    }
    /*void*/ Dispose(/*bool*/ disposing)
    {
        if (disposing && Disposed)
        {
            Disposed = true;
            _contentDispose();
        }
    }
    /*void*/ Dispose()
    {
        Dispose(true);
    }
    /*void*/ CheckDisposed()
    {
        if (Disposed)
        throw new ObjectDisposedException("");
    }
}

class System_Net_Http_HttpRequestOptions extends System_Collections_Generic_IReadOnlyCollection<System_Collections_Generic_KeyValuePair<string, object>>(System_Collections_Generic_IReadOnlyDictionary<string, object>(H5_IH5Class(System_Collections_IEnumerable(System_Collections_Generic_IEnumerable<System_Collections_Generic_KeyValuePair<string, object>>(System_Collections_Generic_ICollection<System_Collections_Generic_KeyValuePair<string, object>>(System_Collections_Generic_IDictionary<string, object>(object)))))))
{
    /*Dictionary<string, object>*/ _backingField_Options = null;
    /*Dictionary<string, object>*/ get Options()
    {
        return _backingField_Options;
    }
    /*bool*/ TryGetValue(/*string*/ key, /*object*/ value)
    {
        let $v = { value: set(value){ value = value; } };
        Options.TryGetValue(key, $v);
    }
IReadOnlyDictionary_$2    Optionskey;
    /*IEnumerable<string>*/ get Keys()
    {
        return Options.Keys;
    }
    /*IEnumerable<object>*/ get Values()
    {
        return Options.Values;
    }
IDictionary_$2    {
        return Optionskey;
    }
    {
        Optionskey = value;
    }
    /*ICollection<string>*/ get Keys()
    {
        return Options.Keys;
    }
    /*ICollection<object>*/ get Values()
    {
        return Options.Values;
    }
    /*int*/ get Count()
    {
        return Options.Count;
    }
    /*bool*/ get IsReadOnly()
    {
        return IDictionary_$2Options.IsReadOnly;
    }
    /*void*/ Add(/*string*/ key, /*object*/ value)
    {
        Options.Add(key, value);
    }
    /*void*/ Add(/*KeyValuePair<string, object>*/ item)
    {
        IDictionary_$2Options.Add(item);
    }
    /*void*/ Clear()
    {
        Options.Clear();
    }
    /*bool*/ Contains(/*KeyValuePair<string, object>*/ item)
    {
        IDictionary_$2Options.Contains(item);
    }
    /*bool*/ ContainsKey(/*string*/ key)
    {
        Options.ContainsKey(key);
    }
    /*void*/ CopyTo(/*KeyValuePair<string, object>[]*/ array, /*int*/ arrayIndex)
    {
        IDictionary_$2Options.CopyTo(array, arrayIndex);
    }
    /*IEnumerator<KeyValuePair<string, object>>*/ GetEnumerator()
    {
        Options.GetEnumerator();
    }
    /*System.Collections.IEnumerator*/ GetEnumerator()
    {
        SystemCollectionsIEnumerableOptions.GetEnumerator();
    }
    /*bool*/ Remove(/*string*/ key)
    {
        Options.Remove(key);
    }
    /*bool*/ Remove(/*KeyValuePair<string, object>*/ item)
    {
        IDictionary_$2Options.Remove(item);
    }
    /*bool*/ ContainsKey(/*string*/ key)
    {
        Options.ContainsKey(key);
    }
    /*bool*/ TryGetValue(/*string*/ key, /*object*/ value)
    {
        let $v = { value: set(value){ value = value; } };
        Options.TryGetValue(key, $v);
    }
    /*int*/ get Count()
    {
        return Options.Count;
    }
    constructor()
    {
        super();
    }
    /*bool*/ TryGetValue(TValue, /*HttpRequestOptionsKey<TValue>*/ key, /*TValue*/ value)
    {
        let _value = null;
        let $v = { value: set(value){ _value = value; } };
        if (Options.TryGetValue(key.Key, $v) && _value instanceof TValue, tvalue = _value)
        {
            value = tvalue;
            return true;
        }
        value = TValue;
        return false;
    }
    /*void*/ Set(TValue, /*HttpRequestOptionsKey<TValue>*/ key, /*TValue*/ value)
    {
        Optionskey.Key = value;
    }
    /*string*/ DebuggerToString()
    {
        Options.Count;
    }
    class System_Net_Http_HttpRequestOptionsDebugView extends object
    {
        /*HttpRequestOptions*/ options = null;
        constructor(/*HttpRequestOptions*/ options)
        {
            super();
            .options  = options;
        }
        /*KeyValuePair<string, object>[]*/ get Items()
        {
            /*var*/ let dictionary = IDictionary_$2options;
            /*var*/ let items = new Array(dictionary.Count);
            dictionary.CopyTo(items, 0);
            return items;
        }
    }
}

const System_Net_Http_HttpRequestOptionsKey$_1 = (TValue) => class extends System_ValueType
{
    /*string*/ _backingField_Key = null;
    /*string*/ get Key()
    {
        return _backingField_Key;
    }
    constructor(/*string*/ key)
    {
        super();
        Key = key;
    }
}

class System_Net_Http_HttpResponseMessage extends System_IDisposable(object)
{
    /*HttpStatusCode*/ DefaultStatusCode = HttpStatusCode.OK;
    /*Version*/ get DefaultResponseVersion()
    {
        return HttpVersion.Version11;
    }
    /*HttpStatusCode*/ _statusCode = null;
    /*HttpResponseHeaders*/ _headers = null;
    /*HttpResponseHeaders*/ _trailingHeaders = null;
    /*string*/ _reasonPhrase = null;
    /*HttpRequestMessage*/ _requestMessage = null;
    /*Version*/ _version = null;
    /*HttpContent*/ _content = null;
    /*bool*/ _disposed = null;
    /*Version*/ get Version()
    {
        return _version;
    }
    /*Version*/ set Version(value)
    {
        if (value == null)
        throw new ArgumentNullException();
        CheckDisposed();
        _version = value;
    }
    /*void*/ SetVersionWithoutValidation(/*Version*/ value)
    {
        _version = value;
    }
    /*HttpContent*/ get Content()
    {
        return _content = _content ?? new EmptyContent();
    }
    /*HttpContent*/ set Content(value)
    {
        CheckDisposed();
        _content = value;
    }
    /*HttpStatusCode*/ get StatusCode()
    {
        return _statusCode;
    }
    /*HttpStatusCode*/ set StatusCode(value)
    {
        if (value < 0 || value > HttpStatusCode999)
        throw new ArgumentOutOfRangeException();
        CheckDisposed();
        _statusCode = value;
    }
    /*void*/ SetStatusCodeWithoutValidation(/*HttpStatusCode*/ value)
    {
        _statusCode = value;
    }
    /*string*/ get ReasonPhrase()
    {
        if (_reasonPhrase != null)
        {
            return _reasonPhrase;
        }
        return StatusCode.ToString();
    }
    /*string*/ set ReasonPhrase(value)
    {
        if (value != null && HttpRuleParser.ContainsNewLine(value))
        {
            throw new FormatException("net_http_reasonphrase_format_error");
        }
        CheckDisposed();
        _reasonPhrase = value;
    }
    /*void*/ SetReasonPhraseWithoutValidation(/*string*/ value)
    {
        _reasonPhrase = value;
    }
    /*HttpResponseHeaders*/ get Headers()
    {
        return _headers = _headers ?? new HttpResponseHeaders();
    }
    /*HttpResponseHeaders*/ get TrailingHeaders()
    {
        return _trailingHeaders = _trailingHeaders ?? new HttpResponseHeaders({ containsTrailingHeaders : true });
    }
    /*void*/ StoreReceivedTrailingHeaders(/*HttpResponseHeaders*/ headers)
    {
        Debug.Assert(headers.ContainsTrailingHeaders);
        if (_trailingHeaders)
        {
            _trailingHeaders = headers;
        }
        else 
        {
            _trailingHeaders.AddHeaders(headers);
        }
    }
    /*HttpRequestMessage*/ get RequestMessage()
    {
        return _requestMessage;
    }
    /*HttpRequestMessage*/ set RequestMessage(value)
    {
        CheckDisposed();
        _requestMessage = value;
    }
    /*bool*/ get IsSuccessStatusCode()
    {
        return _statusCode >= 200 && _statusCode <= 299;
    }
    constructor()
    {
        super(DefaultStatusCode);
    }
    constructor(/*HttpStatusCode*/ statusCode)
    {
        super();
        if (statusCode < 0 || statusCode > HttpStatusCode999)
        throw new ArgumentOutOfRangeException();
        _statusCode = statusCode;
        _version = DefaultResponseVersion;
    }
    /*HttpResponseMessage*/ EnsureSuccessStatusCode()
    {
        if (IsSuccessStatusCode)
        {
            throw new HttpRequestException(.IsNullOrWhiteSpace(ReasonPhrase)"net_http_message_not_success_statuscode""net_http_message_not_success_statuscode_reason", null, _statusCode);
        }
        return ;
    }
    /*string*/ ToString()
    {
        /*StringBuilder*/ let sb = new StringBuilder();
        sb.Append("StatusCode: ");
        sb.Append(_statusCode);
        sb.Append(", ReasonPhrase: '");
        sb.Append(ReasonPhrase ?? "<null>");
        sb.Append("', Version: ");
        sb.Append(_version);
        sb.Append(", Content: ");
        sb.Append(_content == null"<null>"_content.GetType().ToString());
        sb.AppendLine(", Headers:");
        HeaderUtilities.DumpHeaders(sb, _headers, _contentHeaders);
        if (_trailingHeaders != null)
        {
            sb.AppendLine(", Trailing Headers:");
            HeaderUtilities.DumpHeaders(sb, _trailingHeaders);
        }
        return sb.ToString();
    }
    /*void*/ Dispose(/*bool*/ disposing)
    {
        if (disposing && _disposed)
        {
            _disposed = true;
            _contentDispose();
        }
    }
    /*void*/ Dispose()
    {
        Dispose(true);
    }
    /*void*/ CheckDisposed()
    {
        if (_disposed)
        throw new ObjectDisposedException("");
    }
}

class System_Net_Http_HttpRuleParser extends object
{
    constructor()
    {
        super();
    }
    /*string*/ s_tokenChars = "!#$%&'*+-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ^_`abcdefghijklmnopqrstuvwxyz|~";
    /*string*/ s_tokenBytes = "!#$%&'*+-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ^_`abcdefghijklmnopqrstuvwxyz|~";
    /*string*/ s_hostDelimiterChars = "/ \t\r,";
    /*int*/ MaxNestedCount = 5;
    /*char*/ CR = 13;
    /*char*/ LF = 10;
    /*int*/ MaxInt64Digits = 19;
    /*int*/ MaxInt32Digits = 10;
    /*Encoding*/ get DefaultHttpEncoding()
    {
        return Encoding.Default;
    }
    /*int*/ GetTokenLength(/*string*/ input, /*int*/ startIndex)
    {
        /*ReadOnlySpan<char>*/ let slice = input.AsSpan(startIndex);
        /*int*/ let index = slice.IndexOfAnyExcept(s_tokenChars);
        return index < 0slice.Length index;
    }
    /*bool*/ IsToken(/*ReadOnlySpan<char>*/ input)
    {
        input.ContainsAnyExcept(s_tokenChars);
    }
    /*bool*/ IsToken(/*ReadOnlySpan<byte>*/ input)
    {
        input.ContainsAnyExcept(Encoding.ASCII.GetBytes(s_tokenBytes));
    }
    /*string*/ GetTokenString(/*ReadOnlySpan<byte>*/ input)
    {
        Debug.Assert(IsToken(input));
        return Encoding.ASCII.GetString(input.ToArray());
    }
    /*int*/ GetWhitespaceLength(/*string*/ input, /*int*/ startIndex)
    {
        Debug.Assert(input != null);
        if (startIndex >= input.Length)
        {
            return 0;
        }
        /*int*/ let current = startIndex;
        /*char*/ let c;
        while(current < input.Length)
        {
            c = inputcurrent;
            if (c == ' ' || c == '\t')
            {
                current++;
            }
            return current - startIndex;
        }
        return input.Length  - startIndex;
    }
    /*bool*/ ContainsNewLine(/*string*/ value, { /*int*/ startIndex = 0})
    {
        value.AsSpan(startIndex).ContainsAny('\r', '\n');
    }
    /*int*/ GetNumberLength(/*string*/ input, /*int*/ startIndex, /*bool*/ allowDecimal)
    {
        Debug.Assert(input != null);
        Debug.Assert(startIndex >= 0 && startIndex < input.Length);
        /*int*/ let current = startIndex;
        /*char*/ let c;
        /*// If decimal values are not allowed, we pretend to have read the '.' character already. I.e. if a dot is
            // found in the string, parsing will be aborted.
            bool*/ let haveDot = allowDecimal;
        if (inputcurrent == '.')
        {
            return 0;
        }
        while(current < input.Length)
        {
            c = inputcurrent;
            if (.IsDigit(c))
            {
                current++;
            }
            else if (haveDot && c == '.')
            {
                // Note that value "1." is valid.
                    haveDot = true;
                current++;
            }
            else 
            {
                break;
            }
        }
        return current - startIndex;
    }
    /*int*/ GetHostLength(/*string*/ input, /*int*/ startIndex, /*bool*/ allowToken)
    {
        Debug.Assert(input != null);
        Debug.Assert(startIndex >= 0);
        if (startIndex >= input.Length)
        {
            return 0;
        }
        /*ReadOnlySpan<char>*/ let slice = input.AsSpan(startIndex);
        /*// A 'host' is either a token (if 'allowToken' == true) or a valid host name as defined by the URI RFC.
            // So we first iterate through the string and search for path delimiters and whitespace. When found, stop
            // and try to use the substring as token or URI host name. If it works, we have a host name, otherwise not.
            int*/ let index = slice.IndexOfAny(s_hostDelimiterChars);
        if (index >= 0)
        {
            if (index == 0)
            {
                return 0;
            }
            if (sliceindex == '/')
            {
                return 0;
            }
            slice = slice.Slice(0, index);
        }
        if (allowToken && IsToken(slice) || IsValidHostName(slice))
        {
            return slice.Length;
        }
        return 0;
    }
    /*HttpParseResult*/ GetCommentLength(/*string*/ input, /*int*/ startIndex, /*int*/ length)
    {
        let $v = { value: set(value){ length = value; } };
        return GetExpressionLength(input, startIndex, '(', ')', true, 1, $v);
    }
    /*HttpParseResult*/ GetQuotedStringLength(/*string*/ input, /*int*/ startIndex, /*int*/ length)
    {
        let $v = { value: set(value){ length = value; } };
        return GetExpressionLength(input, startIndex, '"', '"', false, 1, $v);
    }
    /*HttpParseResult*/ GetQuotedPairLength(/*string*/ input, /*int*/ startIndex, /*int*/ length)
    {
        Debug.Assert(input != null);
        Debug.Assert(startIndex >= 0 && startIndex < input.Length);
        length = 0;
        if (inputstartIndex != '\\')
        {
            return HttpParseResult.NotParsed;
        }
        if (startIndex + 2 > input.Length || inputstartIndex + 1 > 127)
        {
            return HttpParseResult.InvalidFormat;
        }
        // It doesn't matter what the char next to '\' is so we can skip along.
            length = 2;
        return HttpParseResult.Parsed;
    }
    /*HttpParseResult*/ GetExpressionLength(/*string*/ input, /*int*/ startIndex, /*char*/ openChar, /*char*/ closeChar, /*bool*/ supportsNesting, /*int*/ nestedCount, /*int*/ length)
    {
        Debug.Assert(input != null);
        Debug.Assert(startIndex >= 0 && startIndex < input.Length);
        length = 0;
        if (inputstartIndex != openChar)
        {
            return HttpParseResult.NotParsed;
        }
        /*int*/ let current = startIndex + 1;
        while(current < input.Length)
        {
            /*// Only check whether we have a quoted char, if we have at least 3 characters left to read (i.e.
                // quoted char + closing char). Otherwise the closing char may be considered part of the quoted char.
                int*/ let quotedPairLength;
            let $v = { value: set(value){ quotedPairLength = value; } };
            if (current + 2 < input.Length && GetQuotedPairLength(input, current, $v) == HttpParseResult.Parsed)
            {
                // We ignore invalid quoted-pairs. Invalid quoted-pairs may mean that it looked like a quoted pair,
                    // but we actually have a quoted-string: e.g. "\\u00FC" ('\' followed by a char >127 - quoted-pair only
                    // allows ASCII chars after '\'; qdtext allows both '\' and >127 chars).
                    current += quotedPairLength;
            }
            /*char*/ let c = inputcurrent;
            if (c == '\r' || c == '\n')
            {
                return HttpParseResult.InvalidFormat;
            }
            if (supportsNesting && c == openChar)
            {
                if (nestedCount > MaxNestedCount)
                {
                    return HttpParseResult.InvalidFormat;
                }
                /*int*/ let nestedLength;
                let $v = { value: set(value){ nestedLength = value; } };
                /*HttpParseResult*/ let nestedResult = GetExpressionLength(input, current, openChar, closeChar, supportsNesting, nestedCount + 1, $v);
                switch(nestedResult)
                {
                    case HttpParseResult.Parsed:
                    {
                        current += nestedLength;
                        break;
                    }
                    case HttpParseResult.NotParsed:
                    {
                        Debug.Fail("'NotParsed' is unexpected: We started nested expression " + "parsing, because we found the open-char. So either it's a valid nested " + "expression or it has invalid format.");
                        break;
                    }
                    case HttpParseResult.InvalidFormat:
                    {
                        return HttpParseResult.InvalidFormat;
                    }
                    default:                    {
                        Debug.Fail("Unknown enum result: " + nestedResult);
                        break;
                    }
                }
            }
            if (inputcurrent == closeChar)
            {
                length = current - startIndex + 1;
                return HttpParseResult.Parsed;
            }
            current++;
        }
        return HttpParseResult.InvalidFormat;
    }
    /*bool*/ IsValidHostName(/*ReadOnlySpan<char>*/ host)
    {
        return true;
    }
}

 = 200
class System_Net_Http_HttpVersion extends object
{
    constructor()
    {
        super();
    }
    /*Version*/ Version11 = new Version();
}



class System_Net_Http_StreamContent extends System_Net_Http_HttpContent
{
    /*Stream*/ _content = null;
    /*int*/ _bufferSize = null;
    /*bool*/ _contentConsumed = null;
    /*long*/ _start = null;
    constructor(/*Stream*/ content)
    {
        super();
        if (content == null)
        throw new ArgumentNullException(nameof(content));
        // Indicate that we should use default buffer size by setting size to 0.
            InitializeContent(content, 0);
    }
    constructor(/*Stream*/ content, /*int*/ bufferSize)
    {
        super();
        if (content == null)
        throw new ArgumentNullException(nameof(content));
        if (bufferSize <= 0)
        throw new ArgumentOutOfRangeException(nameof(bufferSize));
        InitializeContent(content, bufferSize);
    }
    /*void*/ InitializeContent(/*Stream*/ content, /*int*/ bufferSize)
    {
        _content = content;
        _bufferSize = bufferSize;
        if (content.CanSeek)
        {
            _start = content.Position;
        }
    }
    /*void*/ SerializeToStream(/*Stream*/ stream, /*CancellationToken*/ cancellationToken)
    {
        Debug.Assert(stream != null);
        PrepareContent();
        // If the stream can't be re-read, make sure that it gets disposed once it is consumed.
            StreamToStreamCopy.Copy(_content, stream, _bufferSize, _content.CanSeek);
    }
    /*Task*/ SerializeToStreamAsync(/*Stream*/ stream)
    {
        SerializeToStreamAsyncCore(stream, default);
    }
    /*Task*/ SerializeToStreamAsync(/*Stream*/ stream, /*CancellationToken*/ cancellationToken)
    {
        // Only skip the original protected virtual SerializeToStreamAsync if this
            // isn't a derived type that may have overridden the behavior.
            GetType() == StreamContentSerializeToStreamAsyncCore(stream, cancellationToken)super.SerializeToStreamAsync(stream, cancellationToken);
    }
    /*Task*/ SerializeToStreamAsyncCore(/*Stream*/ stream, /*CancellationToken*/ cancellationToken)
    {
        Debug.Assert(stream != null);
        PrepareContent();
        return StreamToStreamCopy.CopyAsync(_content, stream, _bufferSize, _content.CanSeek, cancellationToken);
    }
    /*bool*/ TryComputeLength(/*long*/ length)
    {
        if (_content.CanSeek)
        {
            length = _content.Length  - _start;
            return true;
        }
        else 
        {
            length = 0;
            return false;
        }
    }
    /*void*/ Dispose(/*bool*/ disposing)
    {
        if (disposing)
        {
            _content.Dispose();
        }
        super.Dispose(disposing);
    }
    /*Stream*/ CreateContentReadStream(/*CancellationToken*/ cancellationToken)
    {
        SeekToStartIfSeekable();
        return new ReadOnlyStream(_content);
    }
    /*Task<Stream>*/ CreateContentReadStreamAsync()
    {
        SeekToStartIfSeekable();
        return Task.FromResult(Stream, new ReadOnlyStream(_content));
    }
    /*Stream*/ TryCreateContentReadStream()
    {
        GetType() == StreamContentnew ReadOnlyStream(_content)null;
    }
    /*bool*/ get AllowDuplex()
    {
        return false;
    }
    /*void*/ PrepareContent()
    {
        if (_contentConsumed)
        {
            if (_content.CanSeek)
            {
                _content.Position  = _start;
            }
            else 
            {
                throw new InvalidOperationException("net_http_content_stream_already_read");
            }
        }
        _contentConsumed = true;
    }
    /*void*/ SeekToStartIfSeekable()
    {
        if (_content.CanSeek)
        {
            _content.Position  = _start;
        }
    }
    class System_Net_Http_ReadOnlyStream extends System_IO_Stream
    {
        /*Stream*/ innerStream = null;
        constructor(/*Stream*/ innerStream)
        {
            super();
        }
        /*bool*/ get CanWrite()
        {
            return false;
        }
        /*void*/ Flush()
        {
        }
        /*void*/ SetLength(/*long*/ value)
        {
                        throw new NotSupportedException("net_http_content_readonly_stream");
;
        }
        /*IAsyncResult*/ BeginWrite(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count, /*AsyncCallback*/ callback, /*object*/ state)
        {
                        throw new NotSupportedException("net_http_content_readonly_stream");
;
        }
        /*void*/ EndWrite(/*IAsyncResult*/ asyncResult)
        {
                        throw new NotSupportedException("net_http_content_readonly_stream");
;
        }
        /*void*/ Write(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count)
        {
                        throw new NotSupportedException("net_http_content_readonly_stream");
;
        }
        /*void*/ WriteByte(/*byte*/ value)
        {
                        throw new NotSupportedException("net_http_content_readonly_stream");
;
        }
        /*long*/ Seek(/*long*/ offset, /*SeekOrigin*/ origin)
        {
            throw new NotImplementedException();
        }
        /*int*/ Read(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count)
        {
            throw new NotImplementedException();
        }
        /*int*/ get WriteTimeout()
        {
            return             throw new InvalidOperationException("net_http_content_readonly_stream");
;
        }
        /*int*/ set WriteTimeout(value)
        {
                        throw new InvalidOperationException("net_http_content_readonly_stream");
;
        }
        /*bool*/ get CanRead()
        {
            return innerStream.CanRead;
        }
        /*bool*/ get CanSeek()
        {
            return innerStream.CanSeek;
        }
        /*long*/ get Length()
        {
            return innerStream.Length;
        }
        /*long*/ get Position()
        {
            return innerStream.Position;
        }
        /*long*/ set Position(value)
        {
            innerStream.Position  = value;
        }
    }
}

class System_Net_Http_StreamToStreamCopy extends object
{
    constructor()
    {
        super();
    }
    /*void*/ Copy(/*Stream*/ source, /*Stream*/ destination, /*int*/ bufferSize, /*bool*/ disposeSource)
    {
        Debug.Assert(source != null);
        Debug.Assert(destination != null);
        Debug.Assert(bufferSize >= 0);
        if (bufferSize == 0)
        {
            source.CopyTo(destination);
        }
        else 
        {
            source.CopyTo(destination, bufferSize);
        }
        if (disposeSource)
        {
            DisposeSource(source);
        }
    }
    /*Task*/ CopyAsync(/*Stream*/ source, /*Stream*/ destination, /*int*/ bufferSize, /*bool*/ disposeSource, { /*CancellationToken*/ cancellationToken = CancellationToken})
    {
        Debug.Assert(source != null);
        Debug.Assert(destination != null);
        Debug.Assert(bufferSize >= 0);
        {
            /*Task*/ let copyTask = bufferSize == 0source.CopyToAsync(destination, cancellationToken)source.CopyToAsync(destination, bufferSize, cancellationToken);
            if (disposeSource)
            {
                return copyTask;
            }
            switch(copyTask.Status)
            {
                case TaskStatus.RanToCompletion:
                {
                    DisposeSource(source);
                    return Task.CompletedTask;
                }
                case TaskStatus.Faulted:
                case TaskStatus.Canceled:
                {
                    return copyTask;
                }
                default:                {
                    return DisposeSourceAsync(copyTask, source);
TaskTaskStream                    {
                        await mcopyTask;
                        DisposeSource(msource);
                    }
                }
            }
        }
Exception        {
            throw e;
        }
    }
    /*void*/ DisposeSource(/*Stream*/ source)
    {
        {
            source.Dispose();
        }
Exception        {
        }
    }
}

class System_Net_Http_Json_HttpClientJsonExtensions extends object
{
    constructor()
    {
        super();
    }
    /*Task<object>*/ FromJsonAsyncCore(/*Func<HttpClient, Uri, CancellationToken, Task<HttpResponseMessage>>*/ getMethod, /*HttpClient*/ client, /*Uri*/ requestUri, /*Type*/ type, /*JsonSerializerOptions*/ options, { /*CancellationToken*/ cancellationToken = default})
    {
        FromJsonAsyncCoreImpl_$2(object, (Type, JsonSerializerOptions), getMethod, client, requestUri, function(/**/ stream, /**/ innerOptions, /**/ cancellation)
        {
            return JsonSerializer.DeserializeAsync(stream, innerOptions.Item1, innerOptions.Item2  ?? JsonSerializerOptions.Web, cancellation);
        }, typeoptions, cancellationToken);
    }
    /*Task<TValue>*/ FromJsonAsyncCore(TValue, /*Func<HttpClient, Uri, CancellationToken, Task<HttpResponseMessage>>*/ getMethod, /*HttpClient*/ client, /*Uri*/ requestUri, /*JsonSerializerOptions*/ options, { /*CancellationToken*/ cancellationToken = default})
    {
        FromJsonAsyncCoreImpl_$2(TValue, JsonSerializerOptions, getMethod, client, requestUri, function(/**/ stream, /**/ innerOptions, /**/ cancellation)
        {
            return JsonSerializer.DeserializeAsync(TValue, stream, innerOptions ?? JsonSerializerOptions.Web, cancellation);
        }, options, cancellationToken);
    }
    /*Task<object>*/ FromJsonAsyncCore(/*Func<HttpClient, Uri, CancellationToken, Task<HttpResponseMessage>>*/ getMethod, /*HttpClient*/ client, /*Uri*/ requestUri, /*Type*/ type, /*JsonSerializerContext*/ context, { /*CancellationToken*/ cancellationToken = default})
    {
        FromJsonAsyncCoreImpl_$2(object, (Type, JsonSerializerContext), getMethod, client, requestUri, function(/**/ stream, /**/ options, /**/ cancellation)
        {
            return JsonSerializer.DeserializeAsync(stream, options.Item1, options.Item2, cancellation);
        }, typecontext, cancellationToken);
    }
    /*Task<TValue>*/ FromJsonAsyncCore(TValue, /*Func<HttpClient, Uri, CancellationToken, Task<HttpResponseMessage>>*/ getMethod, /*HttpClient*/ client, /*Uri*/ requestUri, /*JsonTypeInfo<TValue>*/ jsonTypeInfo, /*CancellationToken*/ cancellationToken)
    {
        FromJsonAsyncCoreImpl_$2(TValue, JsonTypeInfo<TValue>, getMethod, client, requestUri, function(/**/ stream, /**/ options, /**/ cancellation)
        {
            return JsonSerializer.DeserializeAsync(stream, options, cancellation);
        }, jsonTypeInfo, cancellationToken);
    }
    /*Task<TValue>*/ FromJsonAsyncCoreImpl(TValue, TJsonOptions, /*Func<HttpClient, Uri, CancellationToken, Task<HttpResponseMessage>>*/ getMethod, /*HttpClient*/ client, /*Uri*/ requestUri, /*Func<Stream, TJsonOptions, CancellationToken, Task<TValue>>*/ deserializeMethod, /*TJsonOptions*/ jsonOptions, /*CancellationToken*/ cancellationToken)
    {
        if (client)
        {
            throw new ArgumentNullException(nameof(client));
        }
        /*TimeSpan*/ let timeout = client.Timeout;
        /*// Create the CTS before the initial SendAsync so that the SendAsync counts against the timeout.
            CancellationTokenSource*/ let linkedCTS = null;
        if (timeout != TimeSpan.MaxValue)
        {
            linkedCTS = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            linkedCTS.CancelAfter(timeout);
        }
        /*// We call SendAsync outside of the async Core method to propagate exception even without awaiting the returned task.
            Task<HttpResponseMessage>*/ let responseTask;
        {
            // Intentionally using cancellationToken instead of the linked one here as HttpClient will enforce the Timeout on its own for this part
                responseTask = getMethod(client, requestUri, cancellationToken);
        }
        {
            linkedCTSDispose();
            throw ;
        }
        /*bool*/ let usingResponseHeadersRead = ReferenceEquals(getMethod, s_deleteAsync);
        return Core(client, responseTask, usingResponseHeadersRead, linkedCTS, deserializeMethod, jsonOptions, cancellationToken);
Task_$1HttpClientTask_$1CancellationTokenSourceFunc_$4TJsonOptionsCancellationToken        {
            /*HttpResponseMessage*/ let response = null;
            /*Stream*/ let readStream = null;
            {
                response = await innerResponseTask;
                response.EnsureSuccessStatusCode();
                {
                    readStream = await GetHttpResponseStreamAsync(innerClient, response, innerUsingResponseHeadersRead, innerCancellationToken);
                    return await innerDeserializeMethod(readStream, innerJsonOptions, innerLinkedCTSToken ?? innerCancellationToken);
                }
OperationCanceledExceptioninnerLinkedCTSToken.IsCancellationRequested  == true && innerCancellationToken.IsCancellationRequested                {
                    /*// Matches how HttpClient throws a timeout exception.
                        string*/ let message = "net_http_request_timedout";
                    throw new TaskCanceledException(message, new TimeoutException(oce.Message, oce));
                }
            }
            {
                responseDispose();
                readStreamDispose();
                innerLinkedCTSDispose();
            }
        }
    }
    /*Uri*/ CreateUri(/*string*/ uri)
    {
        .IsNullOrEmpty(uri)nullnew Uri(uri/*, UriKind.RelativeOrAbsolute*/);
    }
    /*Task<Stream>*/ GetHttpResponseStreamAsync(/*HttpClient*/ client, /*HttpResponseMessage*/ response, /*bool*/ usingResponseHeadersRead, /*CancellationToken*/ cancellationToken)
    {
        Debug.Assert(client.MaxResponseContentBufferSize  > 0 & client.MaxResponseContentBufferSize  <= .MaxValue);
        /*int*/ let contentLengthLimit = client.MaxResponseContentBufferSize;
        if (response.Content.Headers.ContentLength  instanceof  && contentLength > contentLengthLimit)
        {
            LengthLimitReadStream.ThrowExceededBufferLimit(contentLengthLimit);
        }
        /*Task<Stream>*/ let task = HttpContentJsonExtensions.GetContentStreamAsync(response.Content, cancellationToken);
        return usingResponseHeadersReadGetLengthLimitReadStreamAsync(client, task)task;
    }
    /*Task<Stream>*/ async GetLengthLimitReadStreamAsync(/*HttpClient*/ client, /*Task<Stream>*/ task)
    {
        /*Stream*/ let contentStream = await task;
        return new LengthLimitReadStream(contentStream, client.MaxResponseContentBufferSize);
    }
}

class System_Net_Http_Json_HttpClientJsonExtensions extends object
{
    constructor()
    {
        super();
    }
    /*Func<HttpClient, Uri, CancellationToken, Task<HttpResponseMessage>>*/ s_deleteAsync = function(/**/ client, /**/ uri, /**/ cancellation)
    {
        return client.DeleteAsync(uri, cancellation);
    };
    /*Task<object>*/ DeleteFromJsonAsync(/*HttpClient*/ client, /*string*/ requestUri, /*Type*/ type, /*JsonSerializerOptions*/ options, { /*CancellationToken*/ cancellationToken = default})
    {
        DeleteFromJsonAsync(client, CreateUri(requestUri), type, options, cancellationToken);
    }
    /*Task<object>*/ DeleteFromJsonAsync(/*HttpClient*/ client, /*Uri*/ requestUri, /*Type*/ type, /*JsonSerializerOptions*/ options, { /*CancellationToken*/ cancellationToken = default})
    {
        FromJsonAsyncCore(s_deleteAsync, client, requestUri, type, options, cancellationToken);
    }
    /*Task<TValue>*/ DeleteFromJsonAsync(TValue, /*HttpClient*/ client, /*string*/ requestUri, /*JsonSerializerOptions*/ options, { /*CancellationToken*/ cancellationToken = default})
    {
        DeleteFromJsonAsync_$1(TValue, client, CreateUri(requestUri), options, cancellationToken);
    }
    /*Task<TValue>*/ DeleteFromJsonAsync(TValue, /*HttpClient*/ client, /*Uri*/ requestUri, /*JsonSerializerOptions*/ options, { /*CancellationToken*/ cancellationToken = default})
    {
        FromJsonAsyncCore_$1(TValue, s_deleteAsync, client, requestUri, options, cancellationToken);
    }
    /*Task<object>*/ DeleteFromJsonAsync(/*HttpClient*/ client, /*string*/ requestUri, /*Type*/ type, /*JsonSerializerContext*/ context, { /*CancellationToken*/ cancellationToken = default})
    {
        DeleteFromJsonAsync(client, CreateUri(requestUri), type, context, cancellationToken);
    }
    /*Task<object>*/ DeleteFromJsonAsync(/*HttpClient*/ client, /*Uri*/ requestUri, /*Type*/ type, /*JsonSerializerContext*/ context, { /*CancellationToken*/ cancellationToken = default})
    {
        FromJsonAsyncCore(s_deleteAsync, client, requestUri, type, context, cancellationToken);
    }
    /*Task<TValue>*/ DeleteFromJsonAsync(TValue, /*HttpClient*/ client, /*string*/ requestUri, /*JsonTypeInfo<TValue>*/ jsonTypeInfo, { /*CancellationToken*/ cancellationToken = default})
    {
        DeleteFromJsonAsync(client, CreateUri(requestUri), jsonTypeInfo, cancellationToken);
    }
    /*Task<TValue>*/ DeleteFromJsonAsync(TValue, /*HttpClient*/ client, /*Uri*/ requestUri, /*JsonTypeInfo<TValue>*/ jsonTypeInfo, { /*CancellationToken*/ cancellationToken = default})
    {
        FromJsonAsyncCore(s_deleteAsync, client, requestUri, jsonTypeInfo, cancellationToken);
    }
    /*Task<object>*/ DeleteFromJsonAsync(/*HttpClient*/ client, /*string*/ requestUri, /*Type*/ type, { /*CancellationToken*/ cancellationToken = default})
    {
        DeleteFromJsonAsync(client, requestUri, type, cancellationToken, { options : null });
    }
    /*Task<object>*/ DeleteFromJsonAsync(/*HttpClient*/ client, /*Uri*/ requestUri, /*Type*/ type, { /*CancellationToken*/ cancellationToken = default})
    {
        DeleteFromJsonAsync(client, requestUri, type, cancellationToken, { options : null });
    }
    /*Task<TValue>*/ DeleteFromJsonAsync(TValue, /*HttpClient*/ client, /*string*/ requestUri, { /*CancellationToken*/ cancellationToken = default})
    {
        DeleteFromJsonAsync_$1(TValue, client, requestUri, cancellationToken, { options : null });
    }
    /*Task<TValue>*/ DeleteFromJsonAsync(TValue, /*HttpClient*/ client, /*Uri*/ requestUri, { /*CancellationToken*/ cancellationToken = default})
    {
        DeleteFromJsonAsync_$1(TValue, client, requestUri, cancellationToken, { options : null });
    }
}


class System_Net_Http_Json_HttpClientJsonExtensions extends object
{
    constructor()
    {
        super();
    }
    /*Func<HttpClient, Uri, CancellationToken, Task<HttpResponseMessage>>*/ s_getAsync = function(/**/ client, /**/ uri, /**/ cancellation)
    {
        return client.GetAsync(uri, HttpCompletionOption.ResponseHeadersRead, cancellation);
    };
    /*Task<object>*/ GetFromJsonAsync(/*HttpClient*/ client, /*string*/ requestUri, /*Type*/ type, /*JsonSerializerOptions*/ options, { /*CancellationToken*/ cancellationToken = default})
    {
        GetFromJsonAsync(client, CreateUri(requestUri), type, options, cancellationToken);
    }
    /*Task<object>*/ GetFromJsonAsync(/*HttpClient*/ client, /*Uri*/ requestUri, /*Type*/ type, /*JsonSerializerOptions*/ options, { /*CancellationToken*/ cancellationToken = default})
    {
        FromJsonAsyncCore(function(/**/ innerClient, /**/ uri, /**/ cancellation)
        {
            return innerClient.GetAsync(uri, HttpCompletionOption.ResponseHeadersRead, cancellation);
        }, client, requestUri, type, options, cancellationToken);
    }
    /*Task<TValue>*/ GetFromJsonAsync(TValue, /*HttpClient*/ client, /*string*/ requestUri, /*JsonSerializerOptions*/ options, { /*CancellationToken*/ cancellationToken = default})
    {
        GetFromJsonAsync_$1(TValue, client, CreateUri(requestUri), options, cancellationToken);
    }
    /*Task<TValue>*/ GetFromJsonAsync(TValue, /*HttpClient*/ client, /*Uri*/ requestUri, /*JsonSerializerOptions*/ options, { /*CancellationToken*/ cancellationToken = default})
    {
        FromJsonAsyncCore_$1(TValue, s_getAsync, client, requestUri, options, cancellationToken);
    }
    /*Task<object>*/ GetFromJsonAsync(/*HttpClient*/ client, /*string*/ requestUri, /*Type*/ type, /*JsonSerializerContext*/ context, { /*CancellationToken*/ cancellationToken = default})
    {
        GetFromJsonAsync(client, CreateUri(requestUri), type, context, cancellationToken);
    }
    /*Task<object>*/ GetFromJsonAsync(/*HttpClient*/ client, /*Uri*/ requestUri, /*Type*/ type, /*JsonSerializerContext*/ context, { /*CancellationToken*/ cancellationToken = default})
    {
        FromJsonAsyncCore(s_getAsync, client, requestUri, type, context, cancellationToken);
    }
    /*Task<TValue>*/ GetFromJsonAsync(TValue, /*HttpClient*/ client, /*string*/ requestUri, /*JsonTypeInfo<TValue>*/ jsonTypeInfo, { /*CancellationToken*/ cancellationToken = default})
    {
        GetFromJsonAsync(client, CreateUri(requestUri), jsonTypeInfo, cancellationToken);
    }
    /*Task<TValue>*/ GetFromJsonAsync(TValue, /*HttpClient*/ client, /*Uri*/ requestUri, /*JsonTypeInfo<TValue>*/ jsonTypeInfo, { /*CancellationToken*/ cancellationToken = default})
    {
        FromJsonAsyncCore(s_getAsync, client, requestUri, jsonTypeInfo, cancellationToken);
    }
    /*Task<object>*/ GetFromJsonAsync(/*HttpClient*/ client, /*string*/ requestUri, /*Type*/ type, { /*CancellationToken*/ cancellationToken = default})
    {
        GetFromJsonAsync(client, requestUri, type, cancellationToken, { options : null });
    }
    /*Task<object>*/ GetFromJsonAsync(/*HttpClient*/ client, /*Uri*/ requestUri, /*Type*/ type, { /*CancellationToken*/ cancellationToken = default})
    {
        GetFromJsonAsync(client, requestUri, type, cancellationToken, { options : null });
    }
    /*Task<TValue>*/ GetFromJsonAsync(TValue, /*HttpClient*/ client, /*string*/ requestUri, { /*CancellationToken*/ cancellationToken = default})
    {
        GetFromJsonAsync_$1(TValue, client, requestUri, cancellationToken, { options : null });
    }
    /*Task<TValue>*/ GetFromJsonAsync(TValue, /*HttpClient*/ client, /*Uri*/ requestUri, { /*CancellationToken*/ cancellationToken = default})
    {
        GetFromJsonAsync_$1(TValue, client, requestUri, cancellationToken, { options : null });
    }
}

class System_Net_Http_Json_HttpClientJsonExtensions extends object
{
    constructor()
    {
        super();
    }
    /*HttpMethod*/ get HttpPatch()
    {
        return s_httpPatch = s_httpPatch ?? new HttpMethod("PATCH");
    }
    /*HttpMethod*/ s_httpPatch = null;
    /*Task<HttpResponseMessage>*/ PatchAsync(/*HttpClient*/ client, /*string*/ requestUri, /*HttpContent*/ content, /*CancellationToken*/ cancellationToken)
    {
        return client.PatchAsync(CreateUri(requestUri), content, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ PatchAsync(/*HttpClient*/ client, /*Uri*/ requestUri, /*HttpContent*/ content, /*CancellationToken*/ cancellationToken)
    {
        /*// HttpClient.PatchAsync is not available in .NET standard and NET462
            HttpRequestMessage*/ let request = new HttpRequestMessage(HttpPatch, requestUri)Content = content;
        return client.SendAsync(request, cancellationToken);
    }
}

class System_Net_Http_Json_HttpClientJsonExtensions extends object
{
    constructor()
    {
        super();
    }
    /*Task<HttpResponseMessage>*/ PatchAsJsonAsync(TValue, /*HttpClient*/ client, /*string*/ requestUri, /*TValue*/ value, { /*JsonSerializerOptions*/ options = null, /*CancellationToken*/ cancellationToken = default})
    {
        if (client)
        {
            throw new ArgumentNullException(nameof(client));
        }
        /*JsonContent*/ let content = JsonContent.Create(value, options, { mediaType : null });
        return client.PatchAsync(requestUri, content, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ PatchAsJsonAsync(TValue, /*HttpClient*/ client, /*Uri*/ requestUri, /*TValue*/ value, { /*JsonSerializerOptions*/ options = null, /*CancellationToken*/ cancellationToken = default})
    {
        if (client)
        {
            throw new ArgumentNullException(nameof(client));
        }
        /*JsonContent*/ let content = JsonContent.Create(value, options, { mediaType : null });
        return client.PatchAsync(requestUri, content, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ PatchAsJsonAsync(TValue, /*HttpClient*/ client, /*string*/ requestUri, /*TValue*/ value, /*CancellationToken*/ cancellationToken)
    {
        client.PatchAsJsonAsync(requestUri, value, cancellationToken, { options : null });
    }
    /*Task<HttpResponseMessage>*/ PatchAsJsonAsync(TValue, /*HttpClient*/ client, /*Uri*/ requestUri, /*TValue*/ value, /*CancellationToken*/ cancellationToken)
    {
        client.PatchAsJsonAsync(requestUri, value, cancellationToken, { options : null });
    }
    /*Task<HttpResponseMessage>*/ PatchAsJsonAsync(TValue, /*HttpClient*/ client, /*string*/ requestUri, /*TValue*/ value, /*JsonTypeInfo<TValue>*/ jsonTypeInfo, { /*CancellationToken*/ cancellationToken = default})
    {
        if (client)
        {
            throw new ArgumentNullException(nameof(client));
        }
        /*JsonContent*/ let content = JsonContent.Create(value, jsonTypeInfo);
        return client.PatchAsync(requestUri, content, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ PatchAsJsonAsync(TValue, /*HttpClient*/ client, /*Uri*/ requestUri, /*TValue*/ value, /*JsonTypeInfo<TValue>*/ jsonTypeInfo, { /*CancellationToken*/ cancellationToken = default})
    {
        if (client)
        {
            throw new ArgumentNullException(nameof(client));
        }
        /*JsonContent*/ let content = JsonContent.Create(value, jsonTypeInfo);
        return client.PatchAsync(requestUri, content, cancellationToken);
    }
}

class System_Net_Http_Json_HttpClientJsonExtensions extends object
{
    constructor()
    {
        super();
    }
    /*Task<HttpResponseMessage>*/ PostAsJsonAsync(TValue, /*HttpClient*/ client, /*string*/ requestUri, /*TValue*/ value, { /*JsonSerializerOptions*/ options = null, /*CancellationToken*/ cancellationToken = default})
    {
        if (client)
        {
            throw new ArgumentNullException(nameof(client));
        }
        /*JsonContent*/ let content = JsonContent.Create(value, options, { mediaType : null });
        return client.PostAsync(requestUri, content, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ PostAsJsonAsync(TValue, /*HttpClient*/ client, /*Uri*/ requestUri, /*TValue*/ value, { /*JsonSerializerOptions*/ options = null, /*CancellationToken*/ cancellationToken = default})
    {
        if (client)
        {
            throw new ArgumentNullException(nameof(client));
        }
        /*JsonContent*/ let content = JsonContent.Create(value, options, { mediaType : null });
        return client.PostAsync(requestUri, content, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ PostAsJsonAsync(TValue, /*HttpClient*/ client, /*string*/ requestUri, /*TValue*/ value, /*CancellationToken*/ cancellationToken)
    {
        client.PostAsJsonAsync(requestUri, value, cancellationToken, { options : null });
    }
    /*Task<HttpResponseMessage>*/ PostAsJsonAsync(TValue, /*HttpClient*/ client, /*Uri*/ requestUri, /*TValue*/ value, /*CancellationToken*/ cancellationToken)
    {
        client.PostAsJsonAsync(requestUri, value, cancellationToken, { options : null });
    }
    /*Task<HttpResponseMessage>*/ PostAsJsonAsync(TValue, /*HttpClient*/ client, /*string*/ requestUri, /*TValue*/ value, /*JsonTypeInfo<TValue>*/ jsonTypeInfo, { /*CancellationToken*/ cancellationToken = default})
    {
        if (client)
        {
            throw new ArgumentNullException(nameof(client));
        }
        /*JsonContent*/ let content = JsonContent.Create(value, jsonTypeInfo);
        return client.PostAsync(requestUri, content, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ PostAsJsonAsync(TValue, /*HttpClient*/ client, /*Uri*/ requestUri, /*TValue*/ value, /*JsonTypeInfo<TValue>*/ jsonTypeInfo, { /*CancellationToken*/ cancellationToken = default})
    {
        if (client)
        {
            throw new ArgumentNullException(nameof(client));
        }
        /*JsonContent*/ let content = JsonContent.Create(value, jsonTypeInfo);
        return client.PostAsync(requestUri, content, cancellationToken);
    }
}

class System_Net_Http_Json_HttpClientJsonExtensions extends object
{
    constructor()
    {
        super();
    }
    /*Task<HttpResponseMessage>*/ PutAsJsonAsync(TValue, /*HttpClient*/ client, /*string*/ requestUri, /*TValue*/ value, { /*JsonSerializerOptions*/ options = null, /*CancellationToken*/ cancellationToken = default})
    {
        if (client)
        {
            throw new ArgumentNullException(nameof(client));
        }
        /*JsonContent*/ let content = JsonContent.Create(value, options, { mediaType : null });
        return client.PutAsync(requestUri, content, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ PutAsJsonAsync(TValue, /*HttpClient*/ client, /*Uri*/ requestUri, /*TValue*/ value, { /*JsonSerializerOptions*/ options = null, /*CancellationToken*/ cancellationToken = default})
    {
        if (client)
        {
            throw new ArgumentNullException(nameof(client));
        }
        /*JsonContent*/ let content = JsonContent.Create(value, options, { mediaType : null });
        return client.PutAsync(requestUri, content, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ PutAsJsonAsync(TValue, /*HttpClient*/ client, /*string*/ requestUri, /*TValue*/ value, /*CancellationToken*/ cancellationToken)
    {
        client.PutAsJsonAsync(requestUri, value, cancellationToken, { options : null });
    }
    /*Task<HttpResponseMessage>*/ PutAsJsonAsync(TValue, /*HttpClient*/ client, /*Uri*/ requestUri, /*TValue*/ value, /*CancellationToken*/ cancellationToken)
    {
        client.PutAsJsonAsync(requestUri, value, cancellationToken, { options : null });
    }
    /*Task<HttpResponseMessage>*/ PutAsJsonAsync(TValue, /*HttpClient*/ client, /*string*/ requestUri, /*TValue*/ value, /*JsonTypeInfo<TValue>*/ jsonTypeInfo, { /*CancellationToken*/ cancellationToken = default})
    {
        if (client)
        {
            throw new ArgumentNullException(nameof(client));
        }
        /*JsonContent*/ let content = JsonContent.Create(value, jsonTypeInfo);
        return client.PutAsync(requestUri, content, cancellationToken);
    }
    /*Task<HttpResponseMessage>*/ PutAsJsonAsync(TValue, /*HttpClient*/ client, /*Uri*/ requestUri, /*TValue*/ value, /*JsonTypeInfo<TValue>*/ jsonTypeInfo, { /*CancellationToken*/ cancellationToken = default})
    {
        if (client)
        {
            throw new ArgumentNullException(nameof(client));
        }
        /*JsonContent*/ let content = JsonContent.Create(value, jsonTypeInfo);
        return client.PutAsync(requestUri, content, cancellationToken);
    }
}


class System_Net_Http_Json_HttpContentJsonExtensions extends object
{
    constructor()
    {
        super();
    }
    /*string*/ SerializationUnreferencedCodeMessage = "JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.";
    /*string*/ SerializationDynamicCodeMessage = "JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext.";
    /*Task<object>*/ ReadFromJsonAsync(/*HttpContent*/ content, /*Type*/ type, /*JsonSerializerOptions*/ options, { /*CancellationToken*/ cancellationToken = default})
    {
        if (content)
        {
            throw new ArgumentNullException(nameof(content));
        }
        return ReadFromJsonAsyncCore(content, type, options, cancellationToken);
    }
    /*Task<object>*/ ReadFromJsonAsync(/*HttpContent*/ content, /*Type*/ type, { /*CancellationToken*/ cancellationToken = default})
    {
        return ReadFromJsonAsync(content, type, { options : null, cancellationToken : cancellationToken });
    }
    /*Task<T>*/ ReadFromJsonAsync(T, /*HttpContent*/ content, /*JsonSerializerOptions*/ options, { /*CancellationToken*/ cancellationToken = default})
    {
        if (content)
        {
            throw new ArgumentNullException(nameof(content));
        }
        return ReadFromJsonAsyncCore_$1(T, content, options, cancellationToken);
    }
    /*Task<T>*/ ReadFromJsonAsync(T, /*HttpContent*/ content, { /*CancellationToken*/ cancellationToken = default})
    {
        return ReadFromJsonAsync_$1(T, content, { options : null, cancellationToken : cancellationToken });
    }
    /*Task<object>*/ async ReadFromJsonAsyncCore(/*HttpContent*/ content, /*Type*/ type, /*JsonSerializerOptions*/ options, /*CancellationToken*/ cancellationToken)
    {
        const $disposable = null
        try
        {
            $disposable = 
            /*Stream*/ let contentStream = await GetContentStreamAsync(content, cancellationToken);
        }
        finally
        {
            $disposable?.Dispose();
        }
    }
    /*Task<T>*/ async ReadFromJsonAsyncCore(T, /*HttpContent*/ content, /*JsonSerializerOptions*/ options, /*CancellationToken*/ cancellationToken)
    {
        const $disposable = null
        try
        {
            $disposable = 
            /*Stream*/ let contentStream = await GetContentStreamAsync(content, cancellationToken);
        }
        finally
        {
            $disposable?.Dispose();
        }
    }
    /*Task<object>*/ ReadFromJsonAsync(/*HttpContent*/ content, /*Type*/ type, /*JsonSerializerContext*/ context, { /*CancellationToken*/ cancellationToken = default})
    {
        if (content)
        {
            throw new ArgumentNullException(nameof(content));
        }
        return ReadFromJsonAsyncCore(content, type, context, cancellationToken);
    }
    /*Task<T>*/ ReadFromJsonAsync(T, /*HttpContent*/ content, /*JsonTypeInfo<T>*/ jsonTypeInfo, { /*CancellationToken*/ cancellationToken = default})
    {
        if (content)
        {
            throw new ArgumentNullException(nameof(content));
        }
        return ReadFromJsonAsyncCore(content, jsonTypeInfo, cancellationToken);
    }
    /*Task<object>*/ async ReadFromJsonAsyncCore(/*HttpContent*/ content, /*Type*/ type, /*JsonSerializerContext*/ context, /*CancellationToken*/ cancellationToken)
    {
        const $disposable = null
        try
        {
            $disposable = 
            /*Stream*/ let contentStream = await GetContentStreamAsync(content, cancellationToken);
        }
        finally
        {
            $disposable?.Dispose();
        }
    }
    /*Task<T>*/ async ReadFromJsonAsyncCore(T, /*HttpContent*/ content, /*JsonTypeInfo<T>*/ jsonTypeInfo, /*CancellationToken*/ cancellationToken)
    {
        const $disposable = null
        try
        {
            $disposable = 
            /*Stream*/ let contentStream = await GetContentStreamAsync(content, cancellationToken);
        }
        finally
        {
            $disposable?.Dispose();
        }
    }
    /*Task<Stream>*/ GetContentStreamAsync(/*HttpContent*/ content, /*CancellationToken*/ cancellationToken)
    {
        /*Task<Stream>*/ let task = ReadHttpContentStreamAsync(content, cancellationToken);
        return JsonHelpers.GetEncoding(content) instanceof Encoding && sourceEncoding != Encoding.UTF8 GetTranscodingStreamAsync(task, sourceEncoding)task;
    }
    /*Task<Stream>*/ async GetTranscodingStreamAsync(/*Task<Stream>*/ task, /*Encoding*/ sourceEncoding)
    {
        /*Stream*/ let contentStream = await task;
        return GetTranscodingStream(contentStream, sourceEncoding);
    }
}


class System_Net_Http_Json_HttpContentJsonExtensions extends object
{
    constructor()
    {
        super();
    }
    /*Task<Stream>*/ ReadHttpContentStreamAsync(/*HttpContent*/ content, /*CancellationToken*/ cancellationToken)
    {
        if (cancellationToken.IsCancellationRequested)
        {
            throw new TaskCanceledException();
        }
        return content.ReadAsStreamAsync();
    }
    /*TranscodingReadStream*/ GetTranscodingStream(/*Stream*/ contentStream, /*Encoding*/ sourceEncoding)
    {
        return new TranscodingReadStream(contentStream, sourceEncoding);
    }
}

class System_Net_Http_Json_JsonContent extends System_Net_Http_HttpContent
{
    /*JsonTypeInfo*/ _typeInfo = null;
    /*Type*/ get ObjectType()
    {
        return _typeInfo.Type;
    }
    /*object*/ _backingField_Value = null;
    /*object*/ get Value()
    {
        return _backingField_Value;
    }
    constructor(/*object*/ inputValue, /*JsonTypeInfo*/ jsonTypeInfo, /*MediaTypeHeaderValue*/ mediaType)
    {
        super();
        Debug.Assert(jsonTypeInfo);
        Debug.Assert(inputValue || jsonTypeInfo.Type.IsAssignableFrom(inputValue.GetType()));
        Value = inputValue;
        _typeInfo = jsonTypeInfo;
        if (mediaType)
        {
            Headers.ContentType  = mediaType;
        }
        else 
        {
            Headers.TryAddWithoutValidation("Content-Type", JsonHelpers.DefaultMediaType);
        }
    }
    /*JsonContent*/ Create(T, /*T*/ inputValue, { /*MediaTypeHeaderValue*/ mediaType = null, /*JsonSerializerOptions*/ options = null})
    {
        Create(inputValue, JsonHelpers.GetJsonTypeInfo(T, options), mediaType);
    }
    /*JsonContent*/ Create(/*object*/ inputValue, /*Type*/ inputType, { /*MediaTypeHeaderValue*/ mediaType = null, /*JsonSerializerOptions*/ options = null})
    {
        if (inputType == null)
        throw new ArgumentNullException(nameof(inputType));
        EnsureTypeCompatibility(inputValue, inputType);
        return new JsonContent(inputValue, JsonHelpers.GetJsonTypeInfo(inputType, options), mediaType);
    }
    /*JsonContent*/ Create(T, /*T*/ inputValue, /*JsonTypeInfo<T>*/ jsonTypeInfo, { /*MediaTypeHeaderValue*/ mediaType = null})
    {
        if (jsonTypeInfo == null)
        throw new ArgumentNullException(nameof(jsonTypeInfo));
        return new JsonContent(inputValue, jsonTypeInfo, mediaType);
    }
    /*JsonContent*/ Create(/*object*/ inputValue, /*JsonTypeInfo*/ jsonTypeInfo, { /*MediaTypeHeaderValue*/ mediaType = null})
    {
        if (jsonTypeInfo == null)
        throw new ArgumentNullException(nameof(jsonTypeInfo));
        EnsureTypeCompatibility(inputValue, jsonTypeInfo.Type);
        return new JsonContent(inputValue, jsonTypeInfo, mediaType);
    }
    /*Task*/ SerializeToStreamAsync(/*Stream*/ stream)
    {
        SerializeToStreamAsyncCore(stream, CancellationToken.None);
    }
    /*bool*/ TryComputeLength(/*long*/ length)
    {
        length = 0;
        return false;
    }
    /*Task*/ SerializeToStreamAsyncCore(/*Stream*/ targetStream, /*CancellationToken*/ cancellationToken)
    {
        /*Encoding*/ let targetEncoding = JsonHelpers.GetEncoding();
        return targetEncoding != null && targetEncoding != Encoding.UTF8 SerializeToStreamAsyncTranscoding(targetStream, targetEncoding, cancellationToken, { async : true })JsonSerializer.SerializeAsync(targetStream, Value, _typeInfo, cancellationToken);
    }
    /*Task*/ async SerializeToStreamAsyncTranscoding(/*Stream*/ targetStream, /*bool*/ async, /*Encoding*/ targetEncoding, /*CancellationToken*/ cancellationToken)
    {
        // Wrap provided stream into a transcoding stream that buffers the data transcoded from utf-8 to the targetEncoding.
#if NET
            Stream transcodingStream = Encoding.CreateTranscodingStream(targetStream, targetEncoding, Encoding.UTF8, leaveOpen: true);
            try
            {
                if (async)
                {
                    await JsonSerializer.SerializeAsync(transcodingStream, Value, _typeInfo, cancellationToken).ConfigureAwait(false);
                }
                else
                {
                    JsonSerializer.Serialize(transcodingStream, Value, _typeInfo);
                }
            }
            finally
            {
                // Dispose/DisposeAsync will flush any partial write buffers. In practice our partial write
                // buffers should be empty as we expect JsonSerializer to emit only well-formed UTF-8 data.
                if (async)
                {
                    await transcodingStream.DisposeAsync().ConfigureAwait(false);
                }
                else
                {
                    transcodingStream.Dispose();
                }
            }
#else
            Debug.Assert(async, "HttpContent synchronous serialization is only supported since .NET 5.0");
        const $disposable = null
        try
        {
            $disposable = 
            /*TranscodingWriteStream*/ let transcodingStream = new TranscodingWriteStream(targetStream, targetEncoding);
        }
        finally
        {
            $disposable?.Dispose();
        }
    }
    /*void*/ EnsureTypeCompatibility(/*object*/ inputValue, /*Type*/ inputType)
    {
        if (inputValue && inputType.IsAssignableFrom(inputValue.GetType()))
        {
            throw new ArgumentException("SerializeWrongType");
        }
    }
}


class System_Net_Http_Json_JsonHelpers extends object
{
    constructor()
    {
        super();
    }
    /*JsonTypeInfo*/ GetJsonTypeInfo(/*Type*/ type, /*JsonSerializerOptions*/ options)
    {
        Debug.Assert(type);
        return new JsonTypeInfo(type);
    }
    /*string*/ DefaultMediaType = "application/json; charset=utf-8";
    /*Encoding*/ GetEncoding(/*HttpContent*/ content)
    {
        /*Encoding*/ let encoding = null;
        if (content.Headers.ContentTypeCharSet instanceof )
        {
            {
                if (charset.Length  > 2 && charset0 == '\"' && charsetcharset.Length  - 1 == '\"')
                {
                    encoding = Encoding.GetEncoding(charset.Substring(1, charset.Length  - 2));
                }
                else 
                {
                    encoding = Encoding.GetEncoding(charset);
                }
            }
ArgumentException            {
                throw new InvalidOperationException("CharSetInvalid", e);
            }
            Debug.Assert(encoding != null);
        }
        return encoding;
    }
}

class System_Net_Http_Json_LengthLimitReadStream extends System_IO_AsyncStream
{
    /*Stream*/ _innerStream = null;
    /*int*/ _lengthLimit = null;
    /*int*/ _remainingLength = null;
    constructor(/*Stream*/ innerStream, /*int*/ lengthLimit)
    {
        super();
        _innerStream = innerStream;
        _lengthLimit = _remainingLength = lengthLimit;
    }
    /*void*/ CheckLengthLimit(/*int*/ read)
    {
        _remainingLength -= read;
        if (_remainingLength < 0)
        {
            ThrowExceededBufferLimit(_lengthLimit);
        }
    }
    /*void*/ ThrowExceededBufferLimit(/*int*/ limit)
    {
        throw new HttpRequestException("net_http_content_buffersize_exceeded");
    }
    /*bool*/ get CanRead()
    {
        return _innerStream.CanRead;
    }
    /*bool*/ get CanSeek()
    {
        return _innerStream.CanSeek;
    }
    /*bool*/ get CanWrite()
    {
        return false;
    }
    /*Task<int>*/ async ReadAsync(/*Span<byte>*/ buffer, /*CancellationToken*/ cancellationToken)
    {
        /*int*/ let read = await _innerStream.ReadAsync(buffer, cancellationToken);
        CheckLengthLimit(read);
        return read;
    }
    /*int*/ Read(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count)
    {
        /*int*/ let read = _innerStream.Read(buffer, offset, count);
        CheckLengthLimit(read);
        return read;
    }
    /*void*/ Flush()
    {
        _innerStream.Flush();
    }
    /*Task*/ FlushAsync(/*CancellationToken*/ cancellationToken)
    {
        _innerStream.Flush();
        return Task.CompletedTask;
    }
    /*long*/ Seek(/*long*/ offset, /*SeekOrigin*/ origin)
    {
        _innerStream.Seek(offset, origin);
    }
    /*void*/ SetLength(/*long*/ value)
    {
        _innerStream.SetLength(value);
    }
    /*long*/ get Length()
    {
        return _innerStream.Length;
    }
    /*long*/ get Position()
    {
        return _innerStream.Position;
    }
    /*long*/ set Position(value)
    {
        _innerStream.Position  = value;
    }
    /*void*/ Write(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count)
    {
                throw new NotSupportedException();
;
    }
    /*Task<int>*/ WriteAsync(/*ReadOnlySpan<byte>*/ buffer, /*CancellationToken*/ cancellationToken)
    {
        throw new NotImplementedException();
    }
}

class System_Net_Http_Json_TranscodingReadStream extends System_IO_AsyncStream
{
    /*int*/ OverflowBufferSize = Encoding.UTF8.GetMaxByteCount(1);
    /*int*/ MaxByteBufferSize = 4096;
    /*Stream*/ _stream = null;
    /*Decoder*/ _decoder = null;
    /*Encoder*/ _encoder = null;
    /*Span<byte>*/ _byteBuffer = null;
    /*Span<char>*/ _charBuffer = null;
    /*Span<byte>*/ _overflowBuffer = null;
    /*bool*/ _disposed = null;
    constructor(/*Stream*/ input, /*Encoding*/ sourceEncoding)
    {
        super();
        _stream = input;
        // The "count" in the buffer is the size of any content from a previous read.
            // Initialize them to 0 since nothing has been read so far.
            _byteBuffer = new Span_$1(byte, ArrayPool_$1.Shared.Rent(MaxByteBufferSize), 0, { length : 0 });
        /*// Attempt to allocate a char buffer than can tolerate the worst-case scenario for this
            // encoding. This would allow the byte -> char conversion to complete in a single call.
            // The conversion process is tolerant of char buffer that is not large enough to convert all the bytes at once.
            int*/ let maxCharBufferSize = sourceEncoding.GetMaxCharCount(MaxByteBufferSize);
        _charBuffer = new Span_$1(char, ArrayPool_$1.Shared.Rent(maxCharBufferSize), 0, { length : 0 });
        _overflowBuffer = new Span_$1(byte, ArrayPool_$1.Shared.Rent(OverflowBufferSize), 0, { length : 0 });
        _decoder = sourceEncoding.GetDecoder();
        _encoder = Encoding.UTF8.GetEncoder();
    }
    /*bool*/ get CanRead()
    {
        return true;
    }
    /*bool*/ get CanSeek()
    {
        return false;
    }
    /*bool*/ get CanWrite()
    {
        return false;
    }
    /*long*/ get Length()
    {
        return         throw new NotSupportedException();
;
    }
    /*long*/ get Position()
    {
        return         throw new NotSupportedException();
;
    }
    /*long*/ set Position(value)
    {
                throw new NotSupportedException();
;
    }
    /*int*/ get ByteBufferCount()
    {
        return _byteBuffer.Count;
    }
    /*int*/ get CharBufferCount()
    {
        return _charBuffer.Count;
    }
    /*int*/ get OverflowCount()
    {
        return _overflowBuffer.Count;
    }
    /*int*/ Read(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count)
    {
                throw new NotSupportedException();
;
    }
    /*Task<int>*/ ReadAsync(/*Span<byte>*/ buffer, /*CancellationToken*/ cancellationToken)
    {
        return ReadAsyncCore(buffer, cancellationToken);
    }
    /*Task<int>*/ async ReadAsyncCore(/*Span<byte>*/ readBuffer, /*CancellationToken*/ cancellationToken)
    {
        if (readBuffer.Length  == 0)
        {
            return 0;
        }
        if (_overflowBuffer.Count  > 0)
        {
            /*int*/ let bytesToCopy = Math.Min(readBuffer.Length, _overflowBuffer.Count);
            _overflowBuffer.Slice(0, bytesToCopy).CopyTo(readBuffer);
            _overflowBuffer = _overflowBuffer.Slice(bytesToCopy);
            return bytesToCopy;
        }
        /*bool*/ let shouldFlushEncoder = false;
        if (_charBuffer.Count  == 0)
        {
            /*int*/ let bytesRead = await ReadInputChars(cancellationToken);
            shouldFlushEncoder = bytesRead == 0 && _byteBuffer.Count  == 0;
        }
        /*bool*/ let completed = false;
        /*int*/ let charsRead = default;
        /*int*/ let bytesWritten = default;
        if (readBuffer.Count  > OverflowBufferSize || _charBuffer.Count  == 0)
        {
            let $v = { value: set(value){ charsRead = value; } };
            let $v = { value: set(value){ bytesWritten = value; } };
            let $v = { value: set(value){ completed = value; } };
            _encoder.Convert(_charBuffer.Array, _charBuffer.Offset, _charBuffer.Count, readBuffer.Array, readBuffer.Offset, readBuffer.Count, shouldFlushEncoder, $v, $v, $v);
        }
        _charBuffer = _charBuffer.Slice(charsRead);
        if (completed || bytesWritten > 0)
        {
            return bytesWritten;
        }
        let overFlowChars = null;
        let $v = { value: set(value){ overFlowChars = value; } };
        let overflowBytes = null;
        let $v = { value: set(value){ overflowBytes = value; } };
        let $v = { value: set(value){ _ = value; } };
        _encoder.Convert(_charBuffer.Array, _charBuffer.Offset, _charBuffer.Count, _overflowBuffer.Array, 0, _overflowBuffer.Array.Length, shouldFlushEncoder, $v, $v, $v);
        Debug.Assert(overflowBytes > 0 && overFlowChars > 0, "We expect writes to the overflow buffer to always succeed since it is large enough to accommodate at least one char.");
        _charBuffer = _charBuffer.Slice(overFlowChars);
        // readBuffer: [ 0, 0, ], overflowBuffer: [ 7, 13, 34, ]
            // Fill up the readBuffer to capacity, so the result looks like so:
            // readBuffer: [ 7, 13 ], overflowBuffer: [ 34 ]
            Debug.Assert(readBuffer.Count  < overflowBytes);
        _overflowBuffer.Array.AsSpan(0, readBuffer.Count).CopyTo(readBuffer);
        Debug.Assert(_overflowBuffer.Array  != null);
        _overflowBuffer = new Span_$1(byte, _overflowBuffer.Array, readBuffer.Count, overflowBytes - readBuffer.Count);
        Debug.Assert(_overflowBuffer.Count  > 0);
        return readBuffer.Count;
    }
    /*Task<int>*/ async ReadInputChars(/*CancellationToken*/ cancellationToken)
    {
        // If we had left-over bytes from a previous read, move it to the start of the buffer and read content into
            // the segment that follows.
            Debug.Assert(_byteBuffer.Array  != null);
        Array.Copy(_byteBuffer.Array, _byteBuffer.Offset, _byteBuffer.Array, 0, _byteBuffer.Count);
        /*//Buffer.BlockCopy(_byteBuffer.Array, _byteBuffer.Offset, _byteBuffer.Array, 0, _byteBuffer.Count);
            int*/ let offset = _byteBuffer.Count;
        /*int*/ let count = _byteBuffer.Array.Length  - _byteBuffer.Count;
        /*int*/ let bytesRead = await _stream.ReadAsync(_byteBuffer.Array, offset, count, cancellationToken);
        _byteBuffer = new Span_$1(byte, _byteBuffer.Array, 0, offset + bytesRead);
        Debug.Assert(_byteBuffer.Array  != null);
        Debug.Assert(_charBuffer.Array  != null);
        Debug.Assert(_charBuffer.Count  == 0, "We should only expect to read more input chars once all buffered content is read");
        let bytesUsed = null;
        let $v = { value: set(value){ bytesUsed = value; } };
        let charsUsed = null;
        let $v = { value: set(value){ charsUsed = value; } };
        let $v = { value: set(value){ _ = value; } };
        _decoder.Convert(_byteBuffer.Array, _byteBuffer.Offset, _byteBuffer.Count, _charBuffer.Array, 0, _charBuffer.Array.Length, bytesRead == 0, $v, $v, $v);
        // We flush only when the stream is exhausted and there are no pending bytes in the buffer.
            Debug.Assert(bytesRead != 0 || _byteBuffer.Count  - bytesUsed == 0);
        _byteBuffer = _byteBuffer.Slice(bytesUsed);
        _charBuffer = new Span_$1(char, _charBuffer.Array, 0, charsUsed);
        return bytesRead;
    }
    /*void*/ Flush()
    {
                throw new NotSupportedException();
;
    }
    /*long*/ Seek(/*long*/ offset, /*SeekOrigin*/ origin)
    {
                throw new NotSupportedException();
;
    }
    /*void*/ SetLength(/*long*/ value)
    {
                throw new NotSupportedException();
;
    }
    /*void*/ Write(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count)
    {
                throw new NotSupportedException();
;
    }
    /*void*/ Dispose(/*bool*/ disposing)
    {
        if (_disposed)
        {
            _disposed = true;
            /*char[]*/ let charBuffer = _charBuffer.Array;
            Debug.Assert(charBuffer != null);
            _charBuffer = default;
            ArrayPool_$1.Shared.Return(charBuffer);
            /*byte[]*/ let byteBuffer = _byteBuffer.Array;
            Debug.Assert(byteBuffer != null);
            _byteBuffer = default;
            ArrayPool_$1.Shared.Return(byteBuffer);
            /*byte[]*/ let overflowBuffer = _overflowBuffer.Array;
            Debug.Assert(overflowBuffer != null);
            _overflowBuffer = default;
            ArrayPool_$1.Shared.Return(overflowBuffer);
            _stream.Dispose();
        }
    }
    /*Task<int>*/ WriteAsync(/*ReadOnlySpan<byte>*/ buffer, /*CancellationToken*/ cancellationToken)
    {
        throw new NotImplementedException();
    }
}

class System_Net_Http_Json_TranscodingWriteStream extends System_IO_AsyncStream
{
    /*int*/ MaxCharBufferSize = 4096;
    /*int*/ MaxByteBufferSize = 4 * MaxCharBufferSize;
    /*int*/ _maxByteBufferSize = null;
    /*Stream*/ _stream = null;
    /*Decoder*/ _decoder = null;
    /*Encoder*/ _encoder = null;
    /*char[]*/ _charBuffer = null;
    /*int*/ _charsDecoded = null;
    /*bool*/ _disposed = null;
    constructor(/*Stream*/ stream, /*Encoding*/ targetEncoding)
    {
        super();
        _stream = stream;
        _charBuffer = ArrayPool_$1.Shared.Rent(MaxCharBufferSize);
        // Attempt to allocate a byte buffer than can tolerate the worst-case scenario for this
            // encoding. This would allow the char -> byte conversion to complete in a single call.
            // However limit the buffer size to prevent an encoding that has a very poor worst-case scenario.
            _maxByteBufferSize = Math.Min(MaxByteBufferSize, targetEncoding.GetMaxByteCount(MaxCharBufferSize));
        _decoder = Encoding.UTF8.GetDecoder();
        _encoder = targetEncoding.GetEncoder();
    }
    /*bool*/ get CanRead()
    {
        return false;
    }
    /*bool*/ get CanSeek()
    {
        return false;
    }
    /*bool*/ get CanWrite()
    {
        return true;
    }
    /*long*/ get Length()
    {
        return         throw new NotSupportedException();
;
    }
    /*long*/ _backingField_Position = null;
    /*long*/ get Position()
    {
        return _backingField_Position;
    }
    /*long*/ set Position(value)
    {
        _backingField_Position = value;
    }
    /*void*/ Flush()
    {
                throw new NotSupportedException();
;
    }
    /*Task*/ FlushAsync(/*CancellationToken*/ cancellationToken)
    {
        _stream.Flush();
        return Task.CompletedTask;
    }
    /*int*/ Read(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count)
    {
                throw new NotSupportedException();
;
    }
    /*long*/ Seek(/*long*/ offset, /*SeekOrigin*/ origin)
    {
                throw new NotSupportedException();
;
    }
    /*void*/ SetLength(/*long*/ value)
    {
                throw new NotSupportedException();
;
    }
    /*void*/ Write(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count)
    {
                throw new NotSupportedException();
;
    }
    /*Task<int>*/ WriteAsync(/*ReadOnlySpan<byte>*/ buffer, /*CancellationToken*/ cancellationToken)
    {
        return WriteAsyncCore(buffer, cancellationToken);
    }
    /*Task<int>*/ async WriteAsyncCore(/*ReadOnlySpan<byte>*/ bufferSegment, /*CancellationToken*/ cancellationToken)
    {
        /*bool*/ let decoderCompleted = false;
        /*int*/ let len = 0;
        while(decoderCompleted)
        {
            //_decoder.Convert(bufferSegment.Array, bufferSegment.Offset, bufferSegment.Count, _charBuffer, _charsDecoded, _charBuffer.Length - _charsDecoded,
                //    flush: false, out int bytesDecoded, out int charsDecoded, out decoderCompleted);
            let bytesDecoded = null;
            let $v = { value: set(value){ bytesDecoded = value; } };
            let charsDecoded = null;
            let $v = { value: set(value){ charsDecoded = value; } };
            let $v = { value: set(value){ decoderCompleted = value; } };
                _decoder.Convert(bufferSegment.ToArray(), 0, bufferSegment.Length, _charBuffer, _charsDecoded, _charBuffer.Length  - _charsDecoded, false, $v, $v, $v);
            len += bytesDecoded;
            _charsDecoded += charsDecoded;
            bufferSegment = bufferSegment.Slice(bytesDecoded);
            await WriteBufferAsync(cancellationToken);
        }
        return len;
    }
    /*Task*/ async WriteBufferAsync(/*CancellationToken*/ cancellationToken)
    {
        /*bool*/ let encoderCompleted = false;
        /*int*/ let charsWritten = 0;
        /*byte[]*/ let byteBuffer = ArrayPool_$1.Shared.Rent(_maxByteBufferSize);
        while(encoderCompleted && charsWritten < _charsDecoded)
        {
            let charsEncoded = null;
            let $v = { value: set(value){ charsEncoded = value; } };
            let bytesUsed = null;
            let $v = { value: set(value){ bytesUsed = value; } };
            let $v = { value: set(value){ encoderCompleted = value; } };
            _encoder.Convert(_charBuffer, charsWritten, _charsDecoded - charsWritten, byteBuffer, 0, byteBuffer.Length, false, $v, $v, $v);
            await _stream.WriteAsync(byteBuffer, 0, bytesUsed, cancellationToken);
            charsWritten += charsEncoded;
        }
        ArrayPool_$1.Shared.Return(byteBuffer);
        // At this point, we've written all the buffered chars to the underlying Stream.
            _charsDecoded = 0;
    }
    /*void*/ Dispose(/*bool*/ disposing)
    {
        if (_disposed)
        {
            _disposed = true;
            /*char[]*/ let toReturn = _charBuffer;
            _charBuffer = null;
            ArrayPool_$1.Shared.Return(toReturn);
        }
    }
    /*Task*/ async FinalWriteAsync(/*CancellationToken*/ cancellationToken)
    {
        /*// Flush the encoder.
            byte[]*/ let byteBuffer = ArrayPool_$1.Shared.Rent(_maxByteBufferSize);
        /*bool*/ let encoderCompleted = false;
        while(encoderCompleted)
        {
            let $v = { value: set(value){ _ = value; } };
            let bytesUsed = null;
            let $v = { value: set(value){ bytesUsed = value; } };
            let $v = { value: set(value){ encoderCompleted = value; } };
            _encoder.Convert(Array.Empty(char), 0, 0, byteBuffer, 0, byteBuffer.Length, true, $v, $v, $v);
            await _stream.WriteAsync(byteBuffer, 0, bytesUsed, cancellationToken);
        }
        ArrayPool_$1.Shared.Return(byteBuffer);
    }
    /*Task<int>*/ ReadAsync(/*Span<byte>*/ buffer, /*CancellationToken*/ cancellationToken)
    {
        throw new NotImplementedException();
    }
}

const System_Numerics_IParsable$_1 = (T, Base) => class extends Base
{
}

class System_Reflection_AssemblyExtension extends object
{
    constructor()
    {
        super();
    }
    class System_Reflection_AssemblyName extends object
    {
        constructor()
        {
            super();
        }
        /*string*/ _backingField_Name = null;
        /*string*/ get Name()
        {
            return _backingField_Name;
        }
        /*string*/ set Name(value)
        {
            _backingField_Name = value;
        }
    }
    /*AssemblyName*/ GetName(/*Assembly*/ assembly)
    {
        return new AssemblyName()Name = assembly.FullName ;
    }
    /*Stream*/ GetManifestResourceStream(/*Assembly*/ assembly, /*string*/ name)
    {
        return Stream.Null;
    }
}

class System_Reflection_AttributeExtension extends object
{
    constructor()
    {
        super();
    }
    /*IEnumerable<T>*/ GetCustomAttributes(T, /*Type*/ t, /*bool*/ inherit)
    {
        return Enumerable.Cast(T, t.GetCustomAttributes(T, inherit));
    }
    /*IEnumerable<T>*/ GetCustomAttributes(T, /*MethodInfo*/ t, /*bool*/ inherit)
    {
        return Enumerable.Cast(T, t.GetCustomAttributes(T, inherit));
    }
}

const System_Runtime_CompilerServices_ConditionalWeakTable$_2 = (TKey, TValue) => class extends System_Collections_Generic_Dictionary(TKey, TValue)
{
    constructor()
    {
        super();
        TKey = $_TKey;
        TValue = $_TValue;
    }
}

class System_Runtime_CompilerServices_IsExternalInit extends object
{
    constructor()
    {
        super();
    }
}

class System_Runtime_CompilerServices_RequiredMemberAttribute extends System_Attribute
{
    constructor()
    {
        super();
    }
}

class Microsoft_AspNetCore_Components_CompilerServices_RuntimeHelpers extends object
{
    constructor()
    {
        super();
    }
    /*T*/ TypeCheck(T, /*T*/ t)
    {
        return t;
    }
}

class System_Security_Claims_Claim extends object
{
 = 0 = 1 = 2 = 4 = 8 = 16 = 32 = 64 = 128    /*byte[]*/ _userSerializationData = null;
    /*string*/ _issuer = null;
    /*string*/ _originalIssuer = null;
    /*Dictionary<string, string>*/ _properties = null;
    /*ClaimsIdentity*/ _subject = null;
    /*string*/ _type = null;
    /*string*/ _value = null;
    /*string*/ _valueType = null;
    constructor(/*BinaryReader*/ reader)
    {
        super(reader, null);
    }
    constructor(/*BinaryReader*/ reader, /*ClaimsIdentity*/ subject)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(reader);
        _subject = subject;
        /*SerializationMask*/ let mask = SerializationMaskreader.ReadInt32();
        /*int*/ let numPropertiesRead = 1;
        /*int*/ let numPropertiesToRead = reader.ReadInt32();
        _value = reader.ReadString();
        if (mask & SerializationMask.NameClaimType == SerializationMask.NameClaimType)
        {
            _type = ClaimsIdentity.DefaultNameClaimType;
        }
        else if (mask & SerializationMask.RoleClaimType == SerializationMask.RoleClaimType)
        {
            _type = ClaimsIdentity.DefaultRoleClaimType;
        }
        else 
        {
            _type = reader.ReadString();
            numPropertiesRead++;
        }
        if (mask & SerializationMask.StringType == SerializationMask.StringType)
        {
            _valueType = reader.ReadString();
            numPropertiesRead++;
        }
        else 
        {
            _valueType = ClaimValueTypes.String;
        }
        if (mask & SerializationMask.Issuer == SerializationMask.Issuer)
        {
            _issuer = reader.ReadString();
            numPropertiesRead++;
        }
        else 
        {
            _issuer = ClaimsIdentity.DefaultIssuer;
        }
        if (mask & SerializationMask.OriginalIssuerEqualsIssuer == SerializationMask.OriginalIssuerEqualsIssuer)
        {
            _originalIssuer = _issuer;
        }
        else if (mask & SerializationMask.OriginalIssuer == SerializationMask.OriginalIssuer)
        {
            _originalIssuer = reader.ReadString();
            numPropertiesRead++;
        }
        else 
        {
            _originalIssuer = ClaimsIdentity.DefaultIssuer;
        }
        if (mask & SerializationMask.HasProperties == SerializationMask.HasProperties)
        {
            /*int*/ let numProperties = reader.ReadInt32();
            numPropertiesRead++;
            for(/*int*/ let i = 0; i < numProperties; i++)
            {
                Properties.Add(reader.ReadString(), reader.ReadString());
            });
        }
        if (mask & SerializationMask.UserData == SerializationMask.UserData)
        {
            /*int*/ let cb = reader.ReadInt32();
            _userSerializationData = reader.ReadBytes(cb);
            numPropertiesRead++;
        }
        for(/*int*/ let i = numPropertiesRead; i < numPropertiesToRead; i++)
        {
            reader.ReadString();
        });
    }
    constructor(/*string*/ type, /*string*/ value)
    {
        super(type, value, ClaimValueTypes.String, ClaimsIdentity.DefaultIssuer, ClaimsIdentity.DefaultIssuer, ClaimsIdentitynull);
    }
    constructor(/*string*/ type, /*string*/ value, /*string*/ valueType)
    {
        super(type, value, valueType, ClaimsIdentity.DefaultIssuer, ClaimsIdentity.DefaultIssuer, ClaimsIdentitynull);
    }
    constructor(/*string*/ type, /*string*/ value, /*string*/ valueType, /*string*/ issuer)
    {
        super(type, value, valueType, issuer, issuer, ClaimsIdentitynull);
    }
    constructor(/*string*/ type, /*string*/ value, /*string*/ valueType, /*string*/ issuer, /*string*/ originalIssuer)
    {
        super(type, value, valueType, issuer, originalIssuer, ClaimsIdentitynull);
    }
    constructor(/*string*/ type, /*string*/ value, /*string*/ valueType, /*string*/ issuer, /*string*/ originalIssuer, /*ClaimsIdentity*/ subject)
    {
        super(type, value, valueType, issuer, originalIssuer, subject, null, null);
    }
    constructor(/*string*/ type, /*string*/ value, /*string*/ valueType, /*string*/ issuer, /*string*/ originalIssuer, /*ClaimsIdentity*/ subject, /*string*/ propertyKey, /*string*/ propertyValue)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(type);
        ArgumentNullExceptionExtension.ThrowIfNull(value);
        _type = type;
        _value = value;
        _valueType = .IsNullOrEmpty(valueType)ClaimValueTypes.String valueType;
        _issuer = .IsNullOrEmpty(issuer)ClaimsIdentity.DefaultIssuer issuer;
        _originalIssuer = .IsNullOrEmpty(originalIssuer)_issueroriginalIssuer;
        _subject = subject;
        if (propertyKey != null)
        {
            _properties = new Dictionary_$2(string, string);
            _propertiespropertyKey = propertyValue;
        }
    }
    constructor(/*Claim*/ other)
    {
        super(other, other == nullClaimsIdentitynullother._subject);
    }
    constructor(/*Claim*/ other, /*ClaimsIdentity*/ subject)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(other);
        _issuer = other._issuer;
        _originalIssuer = other._originalIssuer;
        _subject = subject;
        _type = other._type;
        _value = other._value;
        _valueType = other._valueType;
        if (other._properties  != null)
        {
            _properties = new Dictionary_$2(string, string, other._properties);
        }
        if (other._userSerializationData  != null)
        {
            _userSerializationData = other._userSerializationData.Clone() as ;
        }
    }
    /*byte[]*/ get CustomSerializationData()
    {
        return _userSerializationData;
    }
    /*string*/ get Issuer()
    {
        return _issuer;
    }
    /*string*/ get OriginalIssuer()
    {
        return _originalIssuer;
    }
    /*IDictionary<string, string>*/ get Properties()
    {
        return _properties = _properties ?? new Dictionary_$2(string, string);
    }
    /*ClaimsIdentity*/ get Subject()
    {
        return _subject;
    }
    /*string*/ get Type()
    {
        return _type;
    }
    /*string*/ get Value()
    {
        return _value;
    }
    /*string*/ get ValueType()
    {
        return _valueType;
    }
    /*Claim*/ Clone()
    {
        return Clone(ClaimsIdentitynull);
    }
    /*Claim*/ Clone(/*ClaimsIdentity*/ identity)
    {
        return new Claim(, identity);
    }
    /*void*/ WriteTo(/*BinaryWriter*/ writer)
    {
        WriteTo(writer, null);
    }
    /*void*/ WriteTo(/*BinaryWriter*/ writer, /*byte[]*/ userData)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(writer);
        /*int*/ let numberOfPropertiesWritten = 1;
        /*SerializationMask*/ let mask = SerializationMask.None;
        if (.Equals(_type, ClaimsIdentity.DefaultNameClaimType))
        {
            mask |= SerializationMask.NameClaimType;
        }
        else if (.Equals(_type, ClaimsIdentity.DefaultRoleClaimType))
        {
            mask |= SerializationMask.RoleClaimType;
        }
        else 
        {
            numberOfPropertiesWritten++;
        }
        if (.Equals(_valueType, ClaimValueTypes.String, StringComparison.Ordinal))
        {
            numberOfPropertiesWritten++;
            mask |= SerializationMask.StringType;
        }
        if (.Equals(_issuer, ClaimsIdentity.DefaultIssuer, StringComparison.Ordinal))
        {
            numberOfPropertiesWritten++;
            mask |= SerializationMask.Issuer;
        }
        if (.Equals(_originalIssuer, _issuer, StringComparison.Ordinal))
        {
            mask |= SerializationMask.OriginalIssuerEqualsIssuer;
        }
        else if (.Equals(_originalIssuer, ClaimsIdentity.DefaultIssuer))
        {
            numberOfPropertiesWritten++;
            mask |= SerializationMask.OriginalIssuer;
        }
        if (_properties != null && _properties.Count  > 0)
        {
            numberOfPropertiesWritten++;
            mask |= SerializationMask.HasProperties;
        }
        if (userData != null && userData.Length  > 0)
        {
            numberOfPropertiesWritten++;
            mask |= SerializationMask.UserData;
        }
        writer.Write(mask);
        writer.Write(numberOfPropertiesWritten);
        writer.Write(_value);
        if (mask & SerializationMask.NameClaimType != SerializationMask.NameClaimType && mask & SerializationMask.RoleClaimType != SerializationMask.RoleClaimType)
        {
            writer.Write(_type);
        }
        if (mask & SerializationMask.StringType == SerializationMask.StringType)
        {
            writer.Write(_valueType);
        }
        if (mask & SerializationMask.Issuer == SerializationMask.Issuer)
        {
            writer.Write(_issuer);
        }
        if (mask & SerializationMask.OriginalIssuer == SerializationMask.OriginalIssuer)
        {
            writer.Write(_originalIssuer);
        }
        if (mask & SerializationMask.HasProperties == SerializationMask.HasProperties)
        {
            writer.Write(_properties.Count);
            BlazorJs.forEach(_properties, function(kvp, $_i)
            {
                writer.Write(kvp.Key);
                writer.Write(kvp.Value);
            });
        }
        if (mask & SerializationMask.UserData == SerializationMask.UserData)
        {
            writer.Write(userData.Length);
            writer.Write(userData);
        }
        writer.Flush();
    }
    /*string*/ ToString()
    {
        return _type + ": " + _value;
    }
}

class System_Security_Claims_ClaimsIdentity extends System_Security_Principal_IIdentity(object)
{
 = 0 = 1 = 2 = 4 = 8 = 16 = 32 = 64 = 128    /*byte[]*/ _userSerializationData = null;
    /*ClaimsIdentity*/ _actor = null;
    /*string*/ _authenticationType = null;
    /*object*/ _bootstrapContext = null;
    /*List<List<Claim>>*/ _externalClaims = null;
    /*string*/ _label = null;
    /*List<Claim>*/ _instanceClaims = new List_$1(Claim);
    /*string*/ _nameClaimType = DefaultNameClaimType;
    /*string*/ _roleClaimType = DefaultRoleClaimType;
    /*string*/ DefaultIssuer = @"LOCAL AUTHORITY";
    /*string*/ DefaultNameClaimType = ClaimTypes.Name;
    /*string*/ DefaultRoleClaimType = ClaimTypes.Role;
    constructor()
    {
        super(IIdentitynull, IEnumerable_$1null, null, null, null);
    }
    constructor(/*IIdentity*/ identity)
    {
        super(identity, IEnumerable_$1null, null, null, null);
    }
    constructor(/*IEnumerable<Claim>*/ claims)
    {
        super(IIdentitynull, claims, null, null, null);
    }
    constructor(/*string*/ authenticationType)
    {
        super(IIdentitynull, IEnumerable_$1null, authenticationType, null, null);
    }
    constructor(/*IEnumerable<Claim>*/ claims, /*string*/ authenticationType)
    {
        super(IIdentitynull, claims, authenticationType, null, null);
    }
    constructor(/*IIdentity*/ identity, /*IEnumerable<Claim>*/ claims)
    {
        super(identity, claims, null, null, null);
    }
    constructor(/*string*/ authenticationType, /*string*/ nameType, /*string*/ roleType)
    {
        super(IIdentitynull, IEnumerable_$1null, authenticationType, nameType, roleType);
    }
    constructor(/*IEnumerable<Claim>*/ claims, /*string*/ authenticationType, /*string*/ nameType, /*string*/ roleType)
    {
        super(IIdentitynull, claims, authenticationType, nameType, roleType);
    }
    constructor(/*IIdentity*/ identity, /*IEnumerable<Claim>*/ claims, /*string*/ authenticationType, /*string*/ nameType, /*string*/ roleType)
    {
        super();
        /*ClaimsIdentity*/ let claimsIdentity = identity as ClaimsIdentity;
        _authenticationType = identity != null && .IsNullOrEmpty(authenticationType)identity.AuthenticationType authenticationType;
        _nameClaimType = .IsNullOrEmpty(nameType)nameTypeclaimsIdentity != nullclaimsIdentity._nameClaimType DefaultNameClaimType;
        _roleClaimType = .IsNullOrEmpty(roleType)roleTypeclaimsIdentity != nullclaimsIdentity._roleClaimType DefaultRoleClaimType;
        if (claimsIdentity != null)
        {
            _label = claimsIdentity._label;
            _bootstrapContext = claimsIdentity._bootstrapContext;
            if (claimsIdentity.Actor  != null)
            {
                if (IsCircular(claimsIdentity.Actor))
                {
                    _actor = claimsIdentity.Actor;
                }
                else 
                {
                    throw new InvalidOperationException("ActorGraphCircular");
                }
            }
            SafeAddClaims(claimsIdentity._instanceClaims);
        }
        else 
        {
            if (identity != null && .IsNullOrEmpty(identity.Name))
            {
                SafeAddClaim(new Claim(_nameClaimType, identity.Name, ClaimValueTypes.String, DefaultIssuer, DefaultIssuer, ));
            }
        }
        if (claims != null)
        {
            SafeAddClaims(claims);
        }
    }
    constructor(/*BinaryReader*/ reader)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(reader);
        Initialize(reader);
    }
    constructor(/*ClaimsIdentity*/ other)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(other);
        if (other._actor  != null)
        {
            _actor = other._actor.Clone();
        }
        _authenticationType = other._authenticationType;
        _bootstrapContext = other._bootstrapContext;
        _label = other._label;
        _nameClaimType = other._nameClaimType;
        _roleClaimType = other._roleClaimType;
        if (other._userSerializationData  != null)
        {
            _userSerializationData = other._userSerializationData.Clone() as ;
        }
        SafeAddClaims(other._instanceClaims);
    }
    /*string*/ get AuthenticationType()
    {
        return _authenticationType;
    }
    /*bool*/ get IsAuthenticated()
    {
        return .IsNullOrEmpty(_authenticationType);
    }
    /*ClaimsIdentity*/ get Actor()
    {
        return _actor;
    }
    /*ClaimsIdentity*/ set Actor(value)
    {
        if (value != null)
        {
            if (IsCircular(value))
            {
                throw new InvalidOperationException("ActorGraphCircular");
            }
        }
        _actor = value;
    }
    /*object*/ get BootstrapContext()
    {
        return _bootstrapContext;
    }
    /*object*/ set BootstrapContext(value)
    {
        _bootstrapContext = value;
    }
    /*IEnumerable<Claim>*/ get Claims()
    {
        if (_externalClaims == null)
        {
            return _instanceClaims;
        }
        return CombinedClaimsIterator();
    }
    /*IEnumerable<Claim>*/ CombinedClaimsIterator()
    {
        for(/*int*/ let i = 0; i < _instanceClaims.Count; i++)
        {
_instanceClaimsi        });
        for(/*int*/ let j = 0; j < _externalClaims.Count; j++)
        {
            if (_externalClaimsj != null)
            {
                BlazorJs.forEach(_externalClaimsj, function(claim, $_i)
                {
claim                });
            }
        });
    }
    /*byte[]*/ get CustomSerializationData()
    {
        return _userSerializationData;
    }
    /*List<List<Claim>>*/ get ExternalClaims()
    {
        return _externalClaims = _externalClaims ?? new List_$1(List<Claim>);
    }
    /*string*/ get Label()
    {
        return _label;
    }
    /*string*/ set Label(value)
    {
        _label = value;
    }
    /*string*/ get Name()
    {
        /*Claim*/ let claim = FindFirst(_nameClaimType);
        if (claim != null)
        {
            return claim.Value;
        }
        return null;
    }
    /*string*/ get NameClaimType()
    {
        return _nameClaimType;
    }
    /*string*/ get RoleClaimType()
    {
        return _roleClaimType;
    }
    /*ClaimsIdentity*/ Clone()
    {
        return new ClaimsIdentity();
    }
    /*void*/ AddClaim(/*Claim*/ claim)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(claim);
        if (.ReferenceEquals(claim.Subject, ))
        {
            _instanceClaims.Add(claim);
        }
        else 
        {
            _instanceClaims.Add(claim.Clone());
        }
    }
    /*void*/ AddClaims(/*IEnumerable<Claim>*/ claims)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(claims);
        BlazorJs.forEach(claims, function(claim, $_i)
        {
            if (claim == null)
            {
            }
            if (.ReferenceEquals(claim.Subject, ))
            {
                _instanceClaims.Add(claim);
            }
            else 
            {
                _instanceClaims.Add(claim.Clone());
            }
        });
    }
    /*bool*/ TryRemoveClaim(/*Claim*/ claim)
    {
        if (claim == null)
        {
            return false;
        }
        /*bool*/ let removed = false;
        for(/*int*/ let i = 0; i < _instanceClaims.Count; i++)
        {
            if (.ReferenceEquals(_instanceClaimsi, claim))
            {
                _instanceClaims.RemoveAt(i);
                removed = true;
                break;
            }
        });
        return removed;
    }
    /*void*/ RemoveClaim(/*Claim*/ claim)
    {
        if (TryRemoveClaim(claim))
        {
            throw new InvalidOperationException("ClaimCannotBeRemoved");
        }
    }
    /*void*/ SafeAddClaims(/*IEnumerable<Claim>*/ claims)
    {
        BlazorJs.forEach(claims, function(claim, $_i)
        {
            if (claim == null)
            if (.ReferenceEquals(claim.Subject, ))
            {
                _instanceClaims.Add(claim);
            }
            else 
            {
                _instanceClaims.Add(claim.Clone());
            }
        });
    }
    /*void*/ SafeAddClaim(/*Claim*/ claim)
    {
        if (claim == null)
        return ;
        if (.ReferenceEquals(claim.Subject, ))
        {
            _instanceClaims.Add(claim);
        }
        else 
        {
            _instanceClaims.Add(claim.Clone());
        }
    }
    /*IEnumerable<Claim>*/ FindAll(/*Predicate<Claim>*/ match)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(match);
        return Core(match);
IEnumerable_$1Predicate_$1        {
            BlazorJs.forEach(Claims, function(claim, $_i)
            {
                if (match2(claim))
                {
claim                }
            });
        }
    }
    /*IEnumerable<Claim>*/ FindAll(/*string*/ type)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(type);
        return Core(type);
IEnumerable_$1        {
            BlazorJs.forEach(Claims, function(claim, $_i)
            {
                if (claim != null)
                {
                    if (.Equals(claim.Type, type2, StringComparison.OrdinalIgnoreCase))
                    {
claim                    }
                }
            });
        }
    }
    /*Claim*/ FindFirst(/*Predicate<Claim>*/ match)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(match);
        BlazorJs.forEach(Claims, function(claim, $_i)
        {
            if (match(claim))
            {
                return claim;
            }
        });
        return null;
    }
    /*Claim*/ FindFirst(/*string*/ type)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(type);
        BlazorJs.forEach(Claims, function(claim, $_i)
        {
            if (claim != null)
            {
                if (.Equals(claim.Type, type, StringComparison.OrdinalIgnoreCase))
                {
                    return claim;
                }
            }
        });
        return null;
    }
    /*bool*/ HasClaim(/*Predicate<Claim>*/ match)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(match);
        BlazorJs.forEach(Claims, function(claim, $_i)
        {
            if (match(claim))
            {
                return true;
            }
        });
        return false;
    }
    /*bool*/ HasClaim(/*string*/ type, /*string*/ value)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(type);
        ArgumentNullExceptionExtension.ThrowIfNull(value);
        BlazorJs.forEach(Claims, function(claim, $_i)
        {
            if (claim != null && .Equals(claim.Type, type, StringComparison.OrdinalIgnoreCase) && .Equals(claim.Value, value, StringComparison.Ordinal))
            {
                return true;
            }
        });
        return false;
    }
    /*void*/ Initialize(/*BinaryReader*/ reader)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(reader);
        /*SerializationMask*/ let mask = SerializationMaskreader.ReadInt32();
        /*int*/ let numPropertiesRead = 0;
        /*int*/ let numPropertiesToRead = reader.ReadInt32();
        if (mask & SerializationMask.AuthenticationType == SerializationMask.AuthenticationType)
        {
            _authenticationType = reader.ReadString();
            numPropertiesRead++;
        }
        if (mask & SerializationMask.BootstrapConext == SerializationMask.BootstrapConext)
        {
            _bootstrapContext = reader.ReadString();
            numPropertiesRead++;
        }
        if (mask & SerializationMask.NameClaimType == SerializationMask.NameClaimType)
        {
            _nameClaimType = reader.ReadString();
            numPropertiesRead++;
        }
        else 
        {
            _nameClaimType = ClaimsIdentity.DefaultNameClaimType;
        }
        if (mask & SerializationMask.RoleClaimType == SerializationMask.RoleClaimType)
        {
            _roleClaimType = reader.ReadString();
            numPropertiesRead++;
        }
        else 
        {
            _roleClaimType = ClaimsIdentity.DefaultRoleClaimType;
        }
        if (mask & SerializationMask.HasLabel == SerializationMask.HasLabel)
        {
            _label = reader.ReadString();
            numPropertiesRead++;
        }
        if (mask & SerializationMask.HasClaims == SerializationMask.HasClaims)
        {
            /*int*/ let numberOfClaims = reader.ReadInt32();
            for(/*int*/ let index = 0; index < numberOfClaims; index++)
            {
                _instanceClaims.Add(CreateClaim(reader));
            });
            numPropertiesRead++;
        }
        if (mask & SerializationMask.Actor == SerializationMask.Actor)
        {
            _actor = new ClaimsIdentity(reader);
            numPropertiesRead++;
        }
        if (mask & SerializationMask.UserData == SerializationMask.UserData)
        {
            /*int*/ let cb = reader.ReadInt32();
            _userSerializationData = reader.ReadBytes(cb);
            numPropertiesRead++;
        }
        for(/*int*/ let i = numPropertiesRead; i < numPropertiesToRead; i++)
        {
            reader.ReadString();
        });
    }
    /*Claim*/ CreateClaim(/*BinaryReader*/ reader)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(reader);
        return new Claim(reader, );
    }
    /*void*/ WriteTo(/*BinaryWriter*/ writer)
    {
        WriteTo(writer, null);
    }
    /*void*/ WriteTo(/*BinaryWriter*/ writer, /*byte[]*/ userData)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(writer);
        /*int*/ let numberOfPropertiesWritten = 0;
        /*var*/ let mask = SerializationMask.None;
        if (_authenticationType != null)
        {
            mask |= SerializationMask.AuthenticationType;
            numberOfPropertiesWritten++;
        }
        if (_bootstrapContext != null)
        {
            if (_bootstrapContext is )
            {
                mask |= SerializationMask.BootstrapConext;
                numberOfPropertiesWritten++;
            }
        }
        if (.Equals(_nameClaimType, ClaimsIdentity.DefaultNameClaimType, StringComparison.Ordinal))
        {
            mask |= SerializationMask.NameClaimType;
            numberOfPropertiesWritten++;
        }
        if (.Equals(_roleClaimType, ClaimsIdentity.DefaultRoleClaimType, StringComparison.Ordinal))
        {
            mask |= SerializationMask.RoleClaimType;
            numberOfPropertiesWritten++;
        }
        if (.IsNullOrWhiteSpace(_label))
        {
            mask |= SerializationMask.HasLabel;
            numberOfPropertiesWritten++;
        }
        if (_instanceClaims.Count  > 0)
        {
            mask |= SerializationMask.HasClaims;
            numberOfPropertiesWritten++;
        }
        if (_actor != null)
        {
            mask |= SerializationMask.Actor;
            numberOfPropertiesWritten++;
        }
        if (userData != null && userData.Length  > 0)
        {
            numberOfPropertiesWritten++;
            mask |= SerializationMask.UserData;
        }
        writer.Write(mask);
        writer.Write(numberOfPropertiesWritten);
        if (mask & SerializationMask.AuthenticationType == SerializationMask.AuthenticationType)
        {
            writer.Write(_authenticationType);
        }
        if (mask & SerializationMask.BootstrapConext == SerializationMask.BootstrapConext)
        {
            writer.Write(_bootstrapContext);
        }
        if (mask & SerializationMask.NameClaimType == SerializationMask.NameClaimType)
        {
            writer.Write(_nameClaimType);
        }
        if (mask & SerializationMask.RoleClaimType == SerializationMask.RoleClaimType)
        {
            writer.Write(_roleClaimType);
        }
        if (mask & SerializationMask.HasLabel == SerializationMask.HasLabel)
        {
            writer.Write(_label);
        }
        if (mask & SerializationMask.HasClaims == SerializationMask.HasClaims)
        {
            writer.Write(_instanceClaims.Count);
            BlazorJs.forEach(_instanceClaims, function(claim, $_i)
            {
                claim.WriteTo(writer);
            });
        }
        if (mask & SerializationMask.Actor == SerializationMask.Actor)
        {
            _actor.WriteTo(writer);
        }
        if (mask & SerializationMask.UserData == SerializationMask.UserData)
        {
            writer.Write(userData.Length);
            writer.Write(userData);
        }
        writer.Flush();
    }
    /*bool*/ IsCircular(/*ClaimsIdentity*/ subject)
    {
        if (ReferenceEquals(, subject))
        {
            return true;
        }
        /*ClaimsIdentity*/ let currSubject = subject;
        while(currSubject.Actor  != null)
        {
            if (ReferenceEquals(, currSubject.Actor))
            {
                return true;
            }
            currSubject = currSubject.Actor;
        }
        return false;
    }
    /*string*/ DebuggerToString()
    {
        /*// DebuggerDisplayAttribute is inherited. Use virtual members instead of private fields to gather data.
            int*/ let claimsCount = 0;
        BlazorJs.forEach(Claims, function(item, $_i)
        {
            claimsCount++;
        });
        /*string*/ let debugText = IsAuthenticated"true""false";
        if (Name != null)
        {
            // The ClaimsIdentity.Name property requires that ClaimsIdentity.NameClaimType is correctly
                // configured to match the name of the logical name claim type of the identity.
                // Because of this, only include name if the ClaimsIdentity.Name property has a value.
                // Not including the name is to avoid developer confusion at seeing "Name = (null)" on an authenticated identity.
                debugText += Name;
        }
        if (claimsCount > 0)
        {
            debugText += claimsCount;
        }
        return debugText;
    }
}

class System_Security_Claims_ClaimsPrincipal extends System_Security_Principal_IPrincipal(object)
{
 = 0 = 1 = 2    /*List<ClaimsIdentity>*/ _identities = new List_$1(ClaimsIdentity);
    /*byte[]*/ _userSerializationData = null;
    /*Func<IEnumerable<ClaimsIdentity>, ClaimsIdentity>*/ s_identitySelector = SelectPrimaryIdentity;
    /*Func<ClaimsPrincipal>*/ s_principalSelector = ClaimsPrincipalSelector;
    /*ClaimsPrincipal*/ SelectClaimsPrincipal()
    {
        return new ClaimsPrincipal();
    }
    /*ClaimsIdentity*/ SelectPrimaryIdentity(/*IEnumerable<ClaimsIdentity>*/ identities)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(identities);
        BlazorJs.forEach(identities, function(identity, $_i)
        {
            if (identity != null)
            {
                return identity;
            }
        });
        return null;
    }
    /*Func<IEnumerable<ClaimsIdentity>, ClaimsIdentity>*/ get PrimaryIdentitySelector()
    {
        return s_identitySelector;
    }
    /*Func<IEnumerable<ClaimsIdentity>, ClaimsIdentity>*/ set PrimaryIdentitySelector(value)
    {
        s_identitySelector = value;
    }
    /*Func<ClaimsPrincipal>*/ get ClaimsPrincipalSelector()
    {
        return s_principalSelector;
    }
    /*Func<ClaimsPrincipal>*/ set ClaimsPrincipalSelector(value)
    {
        s_principalSelector = value;
    }
    constructor()
    {
        super();
    }
    constructor(/*IEnumerable<ClaimsIdentity>*/ identities)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(identities);
        _identities.AddRange(identities);
    }
    constructor(/*IIdentity*/ identity)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(identity);
        if (identity instanceof ClaimsIdentity, ci = identity)
        {
            _identities.Add(ci);
        }
        else 
        {
            _identities.Add(new ClaimsIdentity(identity));
        }
    }
    constructor(/*IPrincipal*/ principal)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(principal);
        /*//
            // If IPrincipal is a ClaimsPrincipal add all of the identities
            // If IPrincipal is not a ClaimsPrincipal, create a new identity from IPrincipal.Identity
            //
            ClaimsPrincipal*/ let cp = principal as ClaimsPrincipal;
        if (null == cp)
        {
            _identities.Add(new ClaimsIdentity(principal.Identity));
        }
        else 
        {
            if (null != cp.Identities)
            {
                _identities.AddRange(cp.Identities);
            }
        }
    }
    constructor(/*BinaryReader*/ reader)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(reader);
        /*SerializationMask*/ let mask = SerializationMaskreader.ReadInt32();
        /*int*/ let numPropertiesToRead = reader.ReadInt32();
        /*int*/ let numPropertiesRead = 0;
        if (mask & SerializationMask.HasIdentities == SerializationMask.HasIdentities)
        {
            numPropertiesRead++;
            /*int*/ let numberOfIdentities = reader.ReadInt32();
            for(/*int*/ let index = 0; index < numberOfIdentities; index)
            {
                // directly add to _identities as that is what we serialized from
                    _identities.Add(CreateClaimsIdentity(reader));
            });
        }
        if (mask & SerializationMask.UserData == SerializationMask.UserData)
        {
            /*int*/ let cb = reader.ReadInt32();
            _userSerializationData = reader.ReadBytes(cb);
            numPropertiesRead++;
        }
        for(/*int*/ let i = numPropertiesRead; i < numPropertiesToRead; i++)
        {
            reader.ReadString();
        });
    }
    /*void*/ AddIdentity(/*ClaimsIdentity*/ identity)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(identity);
        _identities.Add(identity);
    }
    /*void*/ AddIdentities(/*IEnumerable<ClaimsIdentity>*/ identities)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(identities);
        _identities.AddRange(identities);
    }
    /*IEnumerable<Claim>*/ get Claims()
    {
        BlazorJs.forEach(Identities, function(identity, $_i)
        {
            BlazorJs.forEach(identity.Claims, function(claim, $_i)
            {
claim            });
        });
    }
    /*byte[]*/ get CustomSerializationData()
    {
        return _userSerializationData;
    }
    /*ClaimsPrincipal*/ Clone()
    {
        return new ClaimsPrincipal();
    }
    /*ClaimsIdentity*/ CreateClaimsIdentity(/*BinaryReader*/ reader)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(reader);
        return new ClaimsIdentity(reader);
    }
    /*ClaimsPrincipal*/ get Current()
    {
        return s_principalSelectors_principalSelector()SelectClaimsPrincipal();
    }
    /*IEnumerable<Claim>*/ FindAll(/*Predicate<Claim>*/ match)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(match);
        return Core(match);
IEnumerable_$1Predicate_$1        {
            BlazorJs.forEach(Identities, function(identity, $_i)
            {
                if (identity != null)
                {
                    BlazorJs.forEach(identity.FindAll(match2), function(claim, $_i)
                    {
claim                    });
                }
            });
        }
    }
    /*IEnumerable<Claim>*/ FindAll(/*string*/ type)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(type);
        return Core(type);
IEnumerable_$1        {
            BlazorJs.forEach(Identities, function(identity, $_i)
            {
                if (identity != null)
                {
                    BlazorJs.forEach(identity.FindAll(type2), function(claim, $_i)
                    {
claim                    });
                }
            });
        }
    }
    /*Claim*/ FindFirst(/*Predicate<Claim>*/ match)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(match);
        /*Claim*/ let claim = null;
        BlazorJs.forEach(Identities, function(identity, $_i)
        {
            if (identity != null)
            {
                claim = identity.FindFirst(match);
                if (claim != null)
                {
                    return claim;
                }
            }
        });
        return claim;
    }
    /*Claim*/ FindFirst(/*string*/ type)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(type);
        /*Claim*/ let claim = null;
        for(/*int*/ let i = 0; i < _identities.Count; i++)
        {
            if (_identitiesi != null)
            {
                claim = _identitiesi.FindFirst(type);
                if (claim != null)
                {
                    return claim;
                }
            }
        });
        return claim;
    }
    /*bool*/ HasClaim(/*Predicate<Claim>*/ match)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(match);
        for(/*int*/ let i = 0; i < _identities.Count; i++)
        {
            if (_identitiesi != null)
            {
                if (_identitiesi.HasClaim(match))
                {
                    return true;
                }
            }
        });
        return false;
    }
    /*bool*/ HasClaim(/*string*/ type, /*string*/ value)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(type);
        ArgumentNullExceptionExtension.ThrowIfNull(value);
        for(/*int*/ let i = 0; i < _identities.Count; i++)
        {
            if (_identitiesi != null)
            {
                if (_identitiesi.HasClaim(type, value))
                {
                    return true;
                }
            }
        });
        return false;
    }
    /*IEnumerable<ClaimsIdentity>*/ get Identities()
    {
        return _identities;
    }
    /*System.Security.Principal.IIdentity*/ get Identity()
    {
        if (s_identitySelector != null)
        {
            return s_identitySelector(_identities);
        }
        else 
        {
            return SelectPrimaryIdentity(_identities);
        }
    }
    /*bool*/ IsInRole(/*string*/ role)
    {
        for(/*int*/ let i = 0; i < _identities.Count; i++)
        {
            if (_identitiesi != null)
            {
                if (_identitiesi.HasClaim(_identitiesi.RoleClaimType, role))
                {
                    return true;
                }
            }
        });
        return false;
    }
    /*void*/ WriteTo(/*BinaryWriter*/ writer)
    {
        WriteTo(writer, null);
    }
    /*void*/ WriteTo(/*BinaryWriter*/ writer, /*byte[]*/ userData)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(writer);
        /*int*/ let numberOfPropertiesWritten = 0;
        /*var*/ let mask = SerializationMask.None;
        if (_identities.Count  > 0)
        {
            mask |= SerializationMask.HasIdentities;
            numberOfPropertiesWritten++;
        }
        if (userData != null && userData.Length  > 0)
        {
            numberOfPropertiesWritten++;
            mask |= SerializationMask.UserData;
        }
        writer.Write(mask);
        writer.Write(numberOfPropertiesWritten);
        if (mask & SerializationMask.HasIdentities == SerializationMask.HasIdentities)
        {
            writer.Write(_identities.Count);
            BlazorJs.forEach(_identities, function(identity, $_i)
            {
                identity.WriteTo(writer);
            });
        }
        if (mask & SerializationMask.UserData == SerializationMask.UserData)
        {
            writer.Write(userData.Length);
            writer.Write(userData);
        }
        writer.Flush();
    }
}

class System_Security_Claims_ClaimTypes extends object
{
    constructor()
    {
        super();
    }
    /*string*/ ClaimTypeNamespace = "http://schemas.microsoft.com/ws/2008/06/identity/claims";
    /*string*/ AuthenticationInstant = ClaimTypeNamespace + "/authenticationinstant";
    /*string*/ AuthenticationMethod = ClaimTypeNamespace + "/authenticationmethod";
    /*string*/ CookiePath = ClaimTypeNamespace + "/cookiepath";
    /*string*/ DenyOnlyPrimarySid = ClaimTypeNamespace + "/denyonlyprimarysid";
    /*string*/ DenyOnlyPrimaryGroupSid = ClaimTypeNamespace + "/denyonlyprimarygroupsid";
    /*string*/ DenyOnlyWindowsDeviceGroup = ClaimTypeNamespace + "/denyonlywindowsdevicegroup";
    /*string*/ Dsa = ClaimTypeNamespace + "/dsa";
    /*string*/ Expiration = ClaimTypeNamespace + "/expiration";
    /*string*/ Expired = ClaimTypeNamespace + "/expired";
    /*string*/ GroupSid = ClaimTypeNamespace + "/groupsid";
    /*string*/ IsPersistent = ClaimTypeNamespace + "/ispersistent";
    /*string*/ PrimaryGroupSid = ClaimTypeNamespace + "/primarygroupsid";
    /*string*/ PrimarySid = ClaimTypeNamespace + "/primarysid";
    /*string*/ Role = ClaimTypeNamespace + "/role";
    /*string*/ SerialNumber = ClaimTypeNamespace + "/serialnumber";
    /*string*/ UserData = ClaimTypeNamespace + "/userdata";
    /*string*/ Version = ClaimTypeNamespace + "/version";
    /*string*/ WindowsAccountName = ClaimTypeNamespace + "/windowsaccountname";
    /*string*/ WindowsDeviceClaim = ClaimTypeNamespace + "/windowsdeviceclaim";
    /*string*/ WindowsDeviceGroup = ClaimTypeNamespace + "/windowsdevicegroup";
    /*string*/ WindowsUserClaim = ClaimTypeNamespace + "/windowsuserclaim";
    /*string*/ WindowsFqbnVersion = ClaimTypeNamespace + "/windowsfqbnversion";
    /*string*/ WindowsSubAuthority = ClaimTypeNamespace + "/windowssubauthority";
    /*string*/ ClaimType2005Namespace = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims";
    /*string*/ Anonymous = ClaimType2005Namespace + "/anonymous";
    /*string*/ Authentication = ClaimType2005Namespace + "/authentication";
    /*string*/ AuthorizationDecision = ClaimType2005Namespace + "/authorizationdecision";
    /*string*/ Country = ClaimType2005Namespace + "/country";
    /*string*/ DateOfBirth = ClaimType2005Namespace + "/dateofbirth";
    /*string*/ Dns = ClaimType2005Namespace + "/dns";
    /*string*/ DenyOnlySid = ClaimType2005Namespace + "/denyonlysid";
    /*string*/ Email = ClaimType2005Namespace + "/emailaddress";
    /*string*/ Gender = ClaimType2005Namespace + "/gender";
    /*string*/ GivenName = ClaimType2005Namespace + "/givenname";
    /*string*/ Hash = ClaimType2005Namespace + "/hash";
    /*string*/ HomePhone = ClaimType2005Namespace + "/homephone";
    /*string*/ Locality = ClaimType2005Namespace + "/locality";
    /*string*/ MobilePhone = ClaimType2005Namespace + "/mobilephone";
    /*string*/ Name = ClaimType2005Namespace + "/name";
    /*string*/ NameIdentifier = ClaimType2005Namespace + "/nameidentifier";
    /*string*/ OtherPhone = ClaimType2005Namespace + "/otherphone";
    /*string*/ PostalCode = ClaimType2005Namespace + "/postalcode";
    /*string*/ Rsa = ClaimType2005Namespace + "/rsa";
    /*string*/ Sid = ClaimType2005Namespace + "/sid";
    /*string*/ Spn = ClaimType2005Namespace + "/spn";
    /*string*/ StateOrProvince = ClaimType2005Namespace + "/stateorprovince";
    /*string*/ StreetAddress = ClaimType2005Namespace + "/streetaddress";
    /*string*/ Surname = ClaimType2005Namespace + "/surname";
    /*string*/ System = ClaimType2005Namespace + "/system";
    /*string*/ Thumbprint = ClaimType2005Namespace + "/thumbprint";
    /*string*/ Upn = ClaimType2005Namespace + "/upn";
    /*string*/ Uri = ClaimType2005Namespace + "/uri";
    /*string*/ Webpage = ClaimType2005Namespace + "/webpage";
    /*string*/ X500DistinguishedName = ClaimType2005Namespace + "/x500distinguishedname";
    /*string*/ ClaimType2009Namespace = "http://schemas.xmlsoap.org/ws/2009/09/identity/claims";
    /*string*/ Actor = ClaimType2009Namespace + "/actor";
}

class System_Security_Claims_ClaimValueTypes extends object
{
    constructor()
    {
        super();
    }
    /*string*/ XmlSchemaNamespace = "http://www.w3.org/2001/XMLSchema";
    /*string*/ Base64Binary = XmlSchemaNamespace + "#base64Binary";
    /*string*/ Base64Octet = XmlSchemaNamespace + "#base64Octet";
    /*string*/ Boolean = XmlSchemaNamespace + "#boolean";
    /*string*/ Date = XmlSchemaNamespace + "#date";
    /*string*/ DateTime = XmlSchemaNamespace + "#dateTime";
    /*string*/ Double = XmlSchemaNamespace + "#double";
    /*string*/ Fqbn = XmlSchemaNamespace + "#fqbn";
    /*string*/ HexBinary = XmlSchemaNamespace + "#hexBinary";
    /*string*/ Integer = XmlSchemaNamespace + "#integer";
    /*string*/ Integer32 = XmlSchemaNamespace + "#integer32";
    /*string*/ Integer64 = XmlSchemaNamespace + "#integer64";
    /*string*/ Sid = XmlSchemaNamespace + "#sid";
    /*string*/ String = XmlSchemaNamespace + "#string";
    /*string*/ Time = XmlSchemaNamespace + "#time";
    /*string*/ UInteger32 = XmlSchemaNamespace + "#uinteger32";
    /*string*/ UInteger64 = XmlSchemaNamespace + "#uinteger64";
    /*string*/ SoapSchemaNamespace = "http://schemas.xmlsoap.org/";
    /*string*/ DnsName = SoapSchemaNamespace + "claims/dns";
    /*string*/ Email = SoapSchemaNamespace + "ws/2005/05/identity/claims/emailaddress";
    /*string*/ Rsa = SoapSchemaNamespace + "ws/2005/05/identity/claims/rsa";
    /*string*/ UpnName = SoapSchemaNamespace + "claims/UPN";
    /*string*/ XmlSignatureConstantsNamespace = "http://www.w3.org/2000/09/xmldsig#";
    /*string*/ DsaKeyValue = XmlSignatureConstantsNamespace + "DSAKeyValue";
    /*string*/ KeyInfo = XmlSignatureConstantsNamespace + "KeyInfo";
    /*string*/ RsaKeyValue = XmlSignatureConstantsNamespace + "RSAKeyValue";
    /*string*/ XQueryOperatorsNameSpace = "http://www.w3.org/TR/2002/WD-xquery-operators-20020816";
    /*string*/ DaytimeDuration = XQueryOperatorsNameSpace + "#dayTimeDuration";
    /*string*/ YearMonthDuration = XQueryOperatorsNameSpace + "#yearMonthDuration";
    /*string*/ Xacml10Namespace = "urn:oasis:names:tc:xacml:1.0";
    /*string*/ Rfc822Name = Xacml10Namespace + ":data-type:rfc822Name";
    /*string*/ X500Name = Xacml10Namespace + ":data-type:x500Name";
}

class System_Security_Principal_GenericIdentity extends System_Security_Claims_ClaimsIdentity
{
    /*string*/ m_name = null;
    /*string*/ m_type = null;
    constructor(/*string*/ name)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(name);
        m_name = name;
        m_type = "";
        AddNameClaim();
    }
    constructor(/*string*/ name, /*string*/ type)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(name);
        ArgumentNullExceptionExtension.ThrowIfNull(type);
        m_name = name;
        m_type = type;
        AddNameClaim();
    }
    constructor(/*GenericIdentity*/ identity)
    {
        super(identity);
        m_name = identity.m_name;
        m_type = identity.m_type;
    }
    /*ClaimsIdentity*/ Clone()
    {
        return new GenericIdentity();
    }
    /*IEnumerable<Claim>*/ get Claims()
    {
        return super.Claims;
    }
    /*string*/ get Name()
    {
        return m_name;
    }
    /*string*/ get AuthenticationType()
    {
        return m_type;
    }
    /*bool*/ get IsAuthenticated()
    {
        return m_name.Equals("");
    }
    /*void*/ AddNameClaim()
    {
        if (m_name != null)
        {
            super.AddClaim(new Claim(super.NameClaimType, m_name, ClaimValueTypes.String, ClaimsIdentity.DefaultIssuer, ClaimsIdentity.DefaultIssuer, ));
        }
    }
}

class System_Security_Principal_GenericPrincipal extends System_Security_Claims_ClaimsPrincipal
{
    /*IIdentity*/ m_identity = null;
    /*string[]*/ m_roles = null;
    constructor(/*IIdentity*/ identity, /*string[]*/ roles)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(identity);
        m_identity = identity;
        if (roles != null)
        {
            m_roles = roles.Clone();
        }
        else 
        {
            m_roles = null;
        }
        AddIdentityWithRoles(m_identity, m_roles);
    }
    /*void*/ AddIdentityWithRoles(/*IIdentity*/ identity, /*string[]*/ roles)
    {
        if (identity instanceof ClaimsIdentity, claimsIdentity = identity)
        {
            claimsIdentity = claimsIdentity.Clone();
        }
        else 
        {
            claimsIdentity = new ClaimsIdentity(identity);
        }
        if (roles != null && roles.Length  > 0)
        {
            /*List<Claim>*/ let roleClaims = new List_$1(Claim, roles.Length);
            BlazorJs.forEach(roles, function(role, $_i)
            {
                if (.IsNullOrWhiteSpace(role))
                {
                    roleClaims.Add(new Claim(claimsIdentity.RoleClaimType, role, ClaimValueTypes.String, ClaimsIdentity.DefaultIssuer, ClaimsIdentity.DefaultIssuer, claimsIdentity));
                }
            });
            claimsIdentity.ExternalClaims.Add(roleClaims);
        }
        super.AddIdentity(claimsIdentity);
    }
    /*IIdentity*/ get Identity()
    {
        return m_identity;
    }
    /*bool*/ IsInRole(/*string*/ role)
    {
        if (role == null || m_roles == null)
        return false;
        for(/*int*/ let i = 0; i < m_roles.Length; i)
        {
            if (.Equals(m_rolesi, role, StringComparison.OrdinalIgnoreCase))
            return true;
        });
        return super.IsInRole(role);
    }
    /*GenericPrincipal*/ GetDefaultInstance()
    {
        new GenericPrincipal(new GenericIdentity(.Empty), [ .Empty  ]);
    }
}

const System_Security_Principal_IIdentity = (Base) => class extends Base
{
    /*//
        // Summary:
        //     Gets the type of authentication used.
        //
        // Returns:
        //     The type of authentication used to identify the user.
        string*/ _backingField_AuthenticationType = null;
    /*//
        // Summary:
        //     Gets the type of authentication used.
        //
        // Returns:
        //     The type of authentication used to identify the user.
        string*/ get AuthenticationType()
    {
        return _backingField_AuthenticationType;
    }
    /*//
        // Summary:
        //     Gets a value that indicates whether the user has been authenticated.
        //
        // Returns:
        //     true if the user was authenticated; otherwise, false.
        bool*/ _backingField_IsAuthenticated = null;
    /*//
        // Summary:
        //     Gets a value that indicates whether the user has been authenticated.
        //
        // Returns:
        //     true if the user was authenticated; otherwise, false.
        bool*/ get IsAuthenticated()
    {
        return _backingField_IsAuthenticated;
    }
    /*//
        // Summary:
        //     Gets the name of the current user.
        //
        // Returns:
        //     The name of the user on whose behalf the code is running.
        string*/ _backingField_Name = null;
    /*//
        // Summary:
        //     Gets the name of the current user.
        //
        // Returns:
        //     The name of the user on whose behalf the code is running.
        string*/ get Name()
    {
        return _backingField_Name;
    }
}

const System_Security_Principal_IPrincipal = (Base) => class extends Base
{
    /*// Retrieve the identity object
        IIdentity*/ _backingField_Identity = null;
    /*// Retrieve the identity object
        IIdentity*/ get Identity()
    {
        return _backingField_Identity;
    }
}

 = 0 = 1 = 2
 = 0 = 1 = 2 = 3 = 4
class System_Text_Decoder extends object
{
    /*Encoding*/ encoding = null;
    constructor(/*Encoding*/ encoding)
    {
        super();
        .encoding  = encoding;
    }
    /*void*/ Convert(/*byte[]*/ inBytes, /*int*/ byteIndex, /*int*/ byteCount, /*char[]*/ outChars, /*int*/ charIndex, /*int*/ charCount, /*bool*/ flush, /*int*/ bytesUsed, /*int*/ charsUsed, /*bool*/ completed)
    {
        throw new NotImplementedException();
    }
}
class System_Text_Encoder extends object
{
    /*Encoding*/ encoding = null;
    constructor(/*Encoding*/ encoding)
    {
        super();
        .encoding  = encoding;
    }
    /*void*/ Convert(/*char[]*/ inChars, /*int*/ charIndex, /*int*/ charCount, /*byte[]*/ outBytes, /*int*/ byteIndex, /*int*/ byteCount, /*bool*/ flush, /*int*/ charsUsed, /*int*/ bytesUsed, /*bool*/ completed)
    {
        throw new NotImplementedException();
    }
}
class System_Text_EncodingExtensions extends object
{
    constructor()
    {
        super();
    }
    /*Encoder*/ GetEncoder(/*Encoding*/ encoding)
    {
        return new Encoder(encoding);
    }
    /*Decoder*/ GetDecoder(/*Encoding*/ encoding)
    {
        return new Decoder(encoding);
    }
}

class System_Text_Json_Serialization_JsonAttribute extends System_Attribute
{
    constructor()
    {
        super();
    }
}


class System_Text_Json_Serialization_JsonConstructorAttribute extends System_Text_Json_Serialization_JsonAttribute
{
    constructor()
    {
        super();
    }
}

class System_Text_Json_Serialization_JsonConverterAttribute extends System_Text_Json_Serialization_JsonAttribute
{
    constructor(/*Type*/ type)
    {
        super();
    }
}

class System_Text_Json_JsonDocument extends object
{
    constructor(/*object*/ obj)
    {
        super();
        Object = obj;
    }
    /*object*/ _backingField_Object = null;
    /*object*/ get Object()
    {
        return _backingField_Object;
    }
    /*JsonElement*/ get RootElement()
    {
        return new JsonElement(Object);
    }
    /*JsonDocument*/ Parse(/*string*/ json, /*JsonDocumentOptions*/ options)
    {
        /*var*/ let _object = JsonSerializer.Deserialize(object, json);
        return new JsonDocument(_object);
    }
}

class System_Text_Json_JsonDocumentOptions extends object
{
    constructor()
    {
        super();
    }
    /*JsonCommentHandling*/ _backingField_CommentHandling = null;
    /*JsonCommentHandling*/ get CommentHandling()
    {
        return _backingField_CommentHandling;
    }
    /*JsonCommentHandling*/ set CommentHandling(value)
    {
        _backingField_CommentHandling = value;
    }
    /*bool*/ _backingField_AllowTrailingCommas = null;
    /*bool*/ get AllowTrailingCommas()
    {
        return _backingField_AllowTrailingCommas;
    }
    /*bool*/ set AllowTrailingCommas(value)
    {
        _backingField_AllowTrailingCommas = value;
    }
}

class System_Text_Json_JsonElement extends System_ValueType
{
    /*object*/ _backingField_Object = null;
    /*object*/ get Object()
    {
        return _backingField_Object;
    }
    constructor(/*object*/ obj)
    {
        super();
        Object = obj;
    }
    /*bool*/ TryGetProperty(/*string*/ path, /*JsonElement*/ element)
    {
        /*var*/ let o = Objectpath;
        if (o != null)
        {
            element = new JsonElement(o);
            return true;
        }
        element = default;
        return false;
    }
}

class System_Text_Json_Serialization_JsonIgnoreAttribute extends System_Text_Json_Serialization_JsonAttribute
{
    constructor()
    {
        super();
    }
    /*JsonIgnoreCondition*/ _backingField_Condition = null;
    /*JsonIgnoreCondition*/ get Condition()
    {
        return _backingField_Condition;
    }
    /*JsonIgnoreCondition*/ set Condition(value)
    {
        _backingField_Condition = value;
    }
}

 = 0 = 1 = 2 = 3
class System_Text_Json_Serialization_JsonPropertyNameAttribute extends System_Text_Json_Serialization_JsonAttribute
{
    constructor(/*string*/ name)
    {
        super();
        Name = name;
    }
    /*string*/ _backingField_Name = null;
    /*string*/ get Name()
    {
        return _backingField_Name;
    }
}

class System_Text_Json_JsonSerializer extends object
{
    constructor()
    {
        super();
    }
    /*string*/ SerializeImpl(/*object*/ value)
    /*object*/ DeserializeImpl(/*string*/ value)
    /*void*/ DeepCopy(/*object*/ source, /*object*/ destination)
    {
        if (source != null && destination != null)
        {
            /*var*/ let props = .GetOwnPropertyNames(source);
            /*var*/ let properties = destination.GetType().GetProperties();
            for(/*int*/ let i = 0; i < props.Length; i++)
            {
                /*var*/ let value = sourcepropsi;
                if (value != null)
                {
                    /*var*/ let property = properties.SingleOrDefault(function(/**/ p)
                    {
p.Name.Equals(propsi, StringComparison.InvariantCultureIgnoreCase)                    });
                    if (property != null)
                    {
                        /*var*/ let type = H5.Script.TypeOf(value);
                        if (type == "number" || type == "string")
                        {
                            if (type == "string")
                            value = ValueConverter.Convert(value, property.PropertyType);
                            property.SetValue(destination, value);
                        }
                        else if (type == "object")
                        {
                            if (H5.Script.IsArray(value))
                            {
                                /*Type*/ let elementType = property.PropertyType.GetElementType() ?? property.PropertyType.GetGenericArguments()0;
                                /*Array*/ let valueArray = value.As(Array);
                                /*Array*/ let newArray = Array.CreateInstance(elementType, valueArray.Length);
                                for(/*int*/ let ii = 0; ii < valueArray.Length; ii++)
                                {
                                    /*var*/ let obj = Activator.CreateInstance(elementType);
                                    DeepCopy(valueArrayii, obj);
                                    newArrayii = obj;
                                });
                                property.SetValue(destination, newArray);
                            }
                            else 
                            {
                                /*var*/ let newObject = Activator.CreateInstance(property.PropertyType);
                                DeepCopy(value, newObject);
                                property.SetValue(destination, newObject);
                            }
                        }
                    }
                }
            });
        }
    }
    /*object*/ Convert(/*object*/ obj, /*Type*/ type)
    {
        /*var*/ let newObject = Activator.CreateInstance(type);
        DeepCopy(obj, newObject);
        return newObject;
    }
    /*object*/ Convert(/*string*/ json, /*Type*/ type)
    {
        /*var*/ let obj = DeserializeImpl(json);
        /*var*/ let jtype = H5.Script.TypeOf(obj);
        if (obj == null || obj.GetType() == type || jtype == "number" || jtype == "string")
        return json;
        return Convert(obj, type);
    }
    /*T*/ Convert(T, /*string*/ json, { /*Type*/ type = null})
    {
        return TConvert(json, type ?? T);
    }
    /*T*/ Convert(T, /*object*/ obj, { /*Type*/ type = null})
    {
        return TConvert(obj, type ?? T);
    }
    /*Task<string>*/ async AsStringAsync(/*Stream*/ utf8Json, /*CancellationToken*/ cancellationToken)
    {
        /*Span<byte>*/ let span = new Span_$1(byte, utf8Json.Length);
        await utf8Json.ReadAsync(span, cancellationToken);
        return Encoding.UTF8.GetString(span.Array);
    }
    /*string*/ AsString(/*Stream*/ utf8Json)
    {
        /*Span<byte>*/ let span = new Span_$1(byte, utf8Json.Length);
        utf8Json.ReadAsync(span, CancellationToken.None).GetAwaiter().GetResult();
        return Encoding.UTF8.GetString(span.Array);
    }
    /*string*/ AsString(/*ReadOnlySpan<byte>*/ span)
    {
        return Encoding.UTF8.GetString(span.ToArray());
    }
    /*string*/ AsString(/*ReadOnlySpan<char>*/ span)
    {
        return span.AsString();
    }
    /*string*/ SerializeToString(/*object*/ o, /*Type*/ type)
    {
        /*var*/ let str = SerializeImpl(o);
        return str;
    }
    /*void*/ SerializeToStream(/*object*/ o, /*Stream*/ utf8Json, /*Type*/ type)
    {
        /*var*/ let str = SerializeImpl(o);
        /*var*/ let bytes = Encoding.UTF8.GetBytes(str);
        utf8Json.Write(bytes, 0, bytes.Length);
    }
    /*Task*/ async SerializeToStreamAsync(/*object*/ o, /*Stream*/ utf8Json, /*Type*/ type, /*CancellationToken*/ cancellationToken)
    {
        /*var*/ let str = SerializeImpl(o);
        /*var*/ let bytes = Encoding.UTF8.GetBytes(str);
        await utf8Json.WriteAsync(bytes, cancellationToken);
    }
    /*byte[]*/ SerializeToBytes(/*object*/ o, /*Type*/ type)
    {
        /*var*/ let str = SerializeImpl(o);
        return Encoding.UTF8.GetBytes(str);
    }
    /*TValue*/ Deserialize(TValue, /*Stream*/ utf8Json, { /*JsonSerializerOptions*/ options = null})
    {
        return Convert_$1(TValue, AsString(utf8Json));
    }
    /*TValue*/ Deserialize(TValue, /*Stream*/ utf8Json, /*JsonTypeInfo<TValue>*/ jsonTypeInfo)
    {
        return Convert_$1(TValue, AsString(utf8Json));
    }
    /*TValue*/ Deserialize(TValue, /*ReadOnlySpan<byte>*/ utf8Json, { /*JsonSerializerOptions*/ options = null})
    {
        return Convert_$1(TValue, AsString(utf8Json));
    }
    /*TValue*/ Deserialize(TValue, /*ReadOnlySpan<byte>*/ utf8Json, /*JsonTypeInfo<TValue>*/ jsonTypeInfo)
    {
        return Convert_$1(TValue, AsString(utf8Json));
    }
    /*TValue*/ Deserialize(TValue, /*ReadOnlySpan<char>*/ json, { /*JsonSerializerOptions*/ options = null})
    {
        return Convert_$1(TValue, AsString(json));
    }
    /*TValue*/ Deserialize(TValue, /*ReadOnlySpan<char>*/ json, /*JsonTypeInfo<TValue>*/ jsonTypeInfo)
    {
        return Convert_$1(TValue, AsString(json));
    }
    /*TValue*/ Deserialize(TValue, /*string*/ json, { /*JsonSerializerOptions*/ options = null})
    {
        return Convert_$1(TValue, json);
    }
    /*TValue*/ Deserialize(TValue, /*string*/ json, /*JsonTypeInfo<TValue>*/ jsonTypeInfo)
    {
        return Convert_$1(TValue, json);
    }
    /*object*/ Deserialize(/*Stream*/ utf8Json, /*Type*/ returnType, { /*JsonSerializerOptions*/ options = null})
    {
        return Convert(AsString(utf8Json), returnType);
    }
    /*object*/ Deserialize(/*Stream*/ utf8Json, /*Type*/ returnType, /*JsonSerializerContext*/ context)
    {
        return Convert(AsString(utf8Json), returnType);
    }
    /*object*/ Deserialize(/*ReadOnlySpan<byte>*/ utf8Json, /*JsonTypeInfo*/ jsonTypeInfo)
    {
        return Convert(AsString(utf8Json), jsonTypeInfo.Type);
    }
    /*object*/ Deserialize(/*ReadOnlySpan<byte>*/ utf8Json, /*Type*/ returnType, { /*JsonSerializerOptions*/ options = null})
    {
        return Convert(AsString(utf8Json), returnType);
    }
    /*object*/ Deserialize(/*ReadOnlySpan<byte>*/ utf8Json, /*Type*/ returnType, /*JsonSerializerContext*/ context)
    {
        return Convert(AsString(utf8Json), returnType);
    }
    /*object*/ Deserialize(/*ReadOnlySpan<char>*/ json, /*JsonTypeInfo*/ jsonTypeInfo)
    {
        return Convert(AsString(json), jsonTypeInfo.Type);
    }
    /*object*/ Deserialize(/*ReadOnlySpan<char>*/ json, /*Type*/ returnType, { /*JsonSerializerOptions*/ options = null})
    {
        return Convert(AsString(json), returnType);
    }
    /*object*/ Deserialize(/*ReadOnlySpan<char>*/ json, /*Type*/ returnType, /*JsonSerializerContext*/ context)
    {
        return Convert(AsString(json), returnType);
    }
    /*object*/ Deserialize(/*string*/ json, /*JsonTypeInfo*/ jsonTypeInfo)
    {
        return Convert(json, jsonTypeInfo.Type);
    }
    /*object*/ Deserialize(/*string*/ json, /*Type*/ returnType, { /*JsonSerializerOptions*/ options = null})
    {
        return Convert(json, returnType);
    }
    /*object*/ Deserialize(/*string*/ json, /*Type*/ returnType, /*JsonSerializerContext*/ context)
    {
        return Convert(json, returnType);
    }
    /*object*/ Deserialize(/*Stream*/ utf8Json, /*JsonTypeInfo*/ jsonTypeInfo)
    {
        return Convert(AsString(utf8Json), jsonTypeInfo.Type);
    }
    /*Task<TValue>*/ async DeserializeAsync(TValue, /*Stream*/ utf8Json, { /*JsonSerializerOptions*/ options = null, /*CancellationToken*/ cancellationToken = default})
    {
        return Convert_$1(TValue, await AsStringAsync(utf8Json, cancellationToken));
    }
    /*Task<object>*/ async DeserializeAsync(/*Stream*/ utf8Json, /*Type*/ returnType, /*JsonSerializerContext*/ context, { /*CancellationToken*/ cancellationToken = default})
    {
        return Convert(await AsStringAsync(utf8Json, cancellationToken), returnType);
    }
    /*Task<object>*/ async DeserializeAsync(/*Stream*/ utf8Json, /*JsonTypeInfo*/ jsonTypeInfo, { /*CancellationToken*/ cancellationToken = default})
    {
        return Convert(await AsStringAsync(utf8Json, cancellationToken), jsonTypeInfo.Type);
    }
    /*Task<TValue>*/ async DeserializeAsync(TValue, /*Stream*/ utf8Json, /*JsonTypeInfo<TValue>*/ jsonTypeInfo, { /*CancellationToken*/ cancellationToken = default})
    {
        return Convert_$1(TValue, await AsStringAsync(utf8Json, cancellationToken), jsonTypeInfo.Type);
    }
    /*Task<object>*/ async DeserializeAsync(/*Stream*/ utf8Json, /*Type*/ returnType, { /*JsonSerializerOptions*/ options = null, /*CancellationToken*/ cancellationToken = default})
    {
        return Convert(await AsStringAsync(utf8Json, cancellationToken), returnType);
    }
    /*TValue*/ Deserialize(TValue, /*JsonDocument*/ document, { /*JsonSerializerOptions*/ options = null})
    {
        return Convert_$1(TValue, document.Object);
    }
    /*TValue*/ Deserialize(TValue, /*JsonDocument*/ document, /*JsonTypeInfo<TValue>*/ jsonTypeInfo)
    {
        return Convert_$1(TValue, document.Object);
    }
    /*TValue*/ Deserialize(TValue, /*JsonElement*/ element, { /*JsonSerializerOptions*/ options = null})
    {
        return Convert_$1(TValue, element.Object);
    }
    /*TValue*/ Deserialize(TValue, /*JsonElement*/ element, /*JsonTypeInfo<TValue>*/ jsonTypeInfo)
    {
        return Convert_$1(TValue, element.Object);
    }
    /*object*/ Deserialize(/*JsonDocument*/ document, /*Type*/ returnType, { /*JsonSerializerOptions*/ options = null})
    {
        return Convert(document.Object, returnType);
    }
    /*object*/ Deserialize(/*JsonDocument*/ document, /*JsonTypeInfo*/ jsonTypeInfo)
    {
        return Convert(document.Object, jsonTypeInfo.Type);
    }
    /*object*/ Deserialize(/*JsonElement*/ element, /*Type*/ returnType, { /*JsonSerializerOptions*/ options = null})
    {
        return Convert(element.Object, returnType);
    }
    /*object*/ Deserialize(/*JsonElement*/ element, /*Type*/ returnType, /*JsonSerializerContext*/ context)
    {
        return Convert(element.Object, returnType);
    }
    /*object*/ Deserialize(/*JsonElement*/ element, /*JsonTypeInfo*/ jsonTypeInfo)
    {
        return Convert(element.Object, jsonTypeInfo.Type);
    }
    /*object*/ Deserialize(/*JsonDocument*/ document, /*Type*/ returnType, /*JsonSerializerContext*/ context)
    {
        return Convert(document.Object, returnType);
    }
    /*string*/ Serialize(TValue, /*TValue*/ value, { /*JsonSerializerOptions*/ options = null})
    {
        return SerializeToString(value, TValue);
    }
    /*void*/ Serialize(TValue, /*Stream*/ utf8Json, /*TValue*/ value, /*JsonTypeInfo<TValue>*/ jsonTypeInfo)
    {
        SerializeToStream(value, utf8Json, jsonTypeInfo.Type);
    }
    /*void*/ Serialize(TValue, /*Stream*/ utf8Json, /*TValue*/ value, { /*JsonSerializerOptions*/ options = null})
    {
        SerializeToStream(value, utf8Json, TValue);
    }
    /*string*/ Serialize(/*object*/ value, /*Type*/ inputType, /*JsonSerializerContext*/ context)
    {
        return SerializeToString(value, inputType);
    }
    /*string*/ Serialize(/*object*/ value, /*Type*/ inputType, { /*JsonSerializerOptions*/ options = null})
    {
        return SerializeToString(value, inputType);
    }
    /*string*/ Serialize(TValue, /*TValue*/ value, /*JsonTypeInfo<TValue>*/ jsonTypeInfo)
    {
        return SerializeToString(value, jsonTypeInfo.Type);
    }
    /*void*/ Serialize(/*Stream*/ utf8Json, /*object*/ value, /*JsonTypeInfo*/ jsonTypeInfo)
    {
        SerializeToStream(value, utf8Json, jsonTypeInfo.Type);
    }
    /*void*/ Serialize(/*Stream*/ utf8Json, /*object*/ value, /*Type*/ inputType, { /*JsonSerializerOptions*/ options = null})
    {
        SerializeToStream(value, utf8Json, inputType);
    }
    /*void*/ Serialize(/*Stream*/ utf8Json, /*object*/ value, /*Type*/ inputType, /*JsonSerializerContext*/ context)
    {
        SerializeToStream(value, utf8Json, inputType);
    }
    /*string*/ Serialize(/*object*/ value, /*JsonTypeInfo*/ jsonTypeInfo)
    {
        return SerializeToString(value, jsonTypeInfo.Type);
    }
    /*Task*/ SerializeAsync(/*Stream*/ utf8Json, /*object*/ value, /*JsonTypeInfo*/ jsonTypeInfo, { /*CancellationToken*/ cancellationToken = default})
    {
        return SerializeToStreamAsync(value, utf8Json, jsonTypeInfo.Type, cancellationToken);
    }
    /*Task*/ SerializeAsync(/*Stream*/ utf8Json, /*object*/ value, /*Type*/ inputType, { /*JsonSerializerOptions*/ options = null, /*CancellationToken*/ cancellationToken = default})
    {
        return SerializeToStreamAsync(value, utf8Json, inputType, cancellationToken);
    }
    /*Task*/ SerializeAsync(/*Stream*/ utf8Json, /*object*/ value, /*Type*/ inputType, /*JsonSerializerContext*/ context, { /*CancellationToken*/ cancellationToken = default})
    {
        return SerializeToStreamAsync(value, utf8Json, inputType, cancellationToken);
    }
    /*Task*/ SerializeAsync(TValue, /*Stream*/ utf8Json, /*TValue*/ value, { /*JsonSerializerOptions*/ options = null, /*CancellationToken*/ cancellationToken = default})
    {
        return SerializeToStreamAsync(value, utf8Json, TValue, cancellationToken);
    }
    /*Task*/ SerializeAsync(TValue, /*Stream*/ utf8Json, /*TValue*/ value, /*JsonTypeInfo<TValue>*/ jsonTypeInfo, { /*CancellationToken*/ cancellationToken = default})
    {
        return SerializeToStreamAsync(value, utf8Json, jsonTypeInfo.Type, cancellationToken);
    }
    /*byte[]*/ SerializeToUtf8Bytes(TValue, /*TValue*/ value, { /*JsonSerializerOptions*/ options = null})
    {
        return SerializeToBytes(value, TValue);
    }
    /*byte[]*/ SerializeToUtf8Bytes(TValue, /*TValue*/ value, /*JsonTypeInfo<TValue>*/ jsonTypeInfo)
    {
        return SerializeToBytes(value, jsonTypeInfo.Type);
    }
    /*byte[]*/ SerializeToUtf8Bytes(/*object*/ value, /*JsonTypeInfo*/ jsonTypeInfo)
    {
        return SerializeToBytes(value, jsonTypeInfo.Type);
    }
    /*byte[]*/ SerializeToUtf8Bytes(/*object*/ value, /*Type*/ inputType, { /*JsonSerializerOptions*/ options = null})
    {
        return SerializeToBytes(value, inputType);
    }
    /*byte[]*/ SerializeToUtf8Bytes(/*object*/ value, /*Type*/ inputType, /*JsonSerializerContext*/ context)
    {
        return SerializeToBytes(value, inputType);
    }
}

class System_Text_Json_Serialization_JsonSerializerContext extends object
{
    constructor()
    {
        super();
    }
}

class System_Text_Json_JsonSerializerOptions extends object
{
    constructor()
    {
        super();
    }
    /*JsonSerializerOptions*/ Web = new JsonSerializerOptions();
    /*JsonCommentHandling*/ _backingField_ReadCommentHandling = null;
    /*JsonCommentHandling*/ get ReadCommentHandling()
    {
        return _backingField_ReadCommentHandling;
    }
    /*JsonCommentHandling*/ set ReadCommentHandling(value)
    {
        _backingField_ReadCommentHandling = value;
    }
}

class System_Text_Json_Serialization_Metadata_JsonTypeInfo extends object
{
    constructor(/*Type*/ type)
    {
        super();
        Type = type;
    }
    /*Type*/ _backingField_Type = null;
    /*Type*/ get Type()
    {
        return _backingField_Type;
    }
}
const System_Text_Json_Serialization_Metadata_JsonTypeInfo$_1 = (T) => class extends System_Text_Json_Serialization_Metadata_JsonTypeInfo
{
    constructor()
    {
        super(T);
    }
}


class System_Text_Unicode_Utf8 extends object
{
    constructor()
    {
        super();
    }
    /*OperationStatus*/ ToUtf16(/*ReadOnlySpan<byte>*/ source, /*Span<char>*/ destination, /*int*/ bytesRead, /*int*/ charsWritten, { /*bool*/ replaceInvalidSequences = true, /*bool*/ isFinalBlock = true})
    {
        throw new NotImplementedException();
    }
}

class System_Threading_InterlockedExtension extends object
{
    constructor()
    {
        super();
    }
    /*int*/ CompareExchange(/*int*/ location1, /*int*/ value, /*int*/ comparand)
    {
        /*var*/ let old = location1;
        if (location1 == comparand)
        {
            location1 = value;
        }
        return old;
    }
    /*T*/ CompareExchange(T, /*T*/ location1, /*T*/ value, /*T*/ comparand)
    {
        /*var*/ let old = location1;
        if (location1.Equals(comparand))
        {
            location1 = value;
        }
        return old;
    }
}

class System_Threading_SemaphoreSlim extends System_IDisposable(object)
{
    /*int*/ taken = null;
    /*int*/ maxCount = null;
    constructor(/*int*/ initialCount)
    {
        super();
        maxCount = initialCount;
        taken = 0;
    }
    constructor(/*int*/ initialCount, /*int*/ maxCount)
    {
        super();
        taken = 0;
        .maxCount  = maxCount;
    }
    /*int*/ get CurrentCount()
    {
        return maxCount - taken;
    }
    /*void*/ Dispose()
    {
    }
    /*int*/ Release()
    {
        return Release(1);
    }
    /*//
        // Summary:
        //     Releases the System.Threading.SemaphoreSlim object a specified number of times.
        //
        //
        // Parameters:
        //   releaseCount:
        //     The number of times to exit the semaphore.
        //
        // Returns:
        //     The previous count of the System.Threading.SemaphoreSlim.
        //
        // Exceptions:
        //   T:System.ObjectDisposedException:
        //     The current instance has already been disposed.
        //
        //   T:System.ArgumentOutOfRangeException:
        //     releaseCount is less than 1.
        //
        //   T:System.Threading.SemaphoreFullException:
        //     The System.Threading.SemaphoreSlim has already reached its maximum size.
        List<TaskCompletionSource<bool>>*/ blockedWaits = new List_$1(TaskCompletionSource<bool>);
    /*int*/ Release(/*int*/ releaseCount)
    {
        /*//if (releaseCount> tak)
            int*/ let currentCount = CurrentCount;
        while(releaseCount-- > 0)
        {
            if (blockedWaits.Count  > 0)
            {
                /*var*/ let task = blockedWaits.Last();
                blockedWaits.Remove(task);
                task.SetResult(true);
            }
        }
        return currentCount;
    }
    /*void*/ Wait()
    {
        throw new NotImplementedException();
    }
    /*bool*/ Wait(/*int*/ millisecondsTimeout)
    {
        throw new NotImplementedException();
    }
    /*bool*/ Wait(/*int*/ millisecondsTimeout, /*CancellationToken*/ cancellationToken)
    {
        throw new NotImplementedException();
    }
    /*bool*/ Wait(/*TimeSpan*/ timeout)
    {
        throw new NotImplementedException();
    }
    /*bool*/ Wait(/*TimeSpan*/ timeout, /*CancellationToken*/ cancellationToken)
    {
        throw new NotImplementedException();
    }
    /*void*/ Wait(/*CancellationToken*/ cancellationToken)
    {
        throw new NotImplementedException();
    }
    /*Task*/ WaitAsync()
    {
        return WaitAsync(.MaxValue, CancellationToken.None);
    }
    /*Task<bool>*/ WaitAsync(/*int*/ millisecondsTimeout)
    {
        return WaitAsync(millisecondsTimeout, CancellationToken.None);
    }
    /*Task<bool>*/ WaitAsync(/*int*/ millisecondsTimeout, /*CancellationToken*/ cancellationToken)
    {
        if (CurrentCount > 0)
        {
            taken++;
            return Task.FromResult(false);
        }
        /*TaskCompletionSource<bool>*/ let tcs = new TaskCompletionSource_$1(bool);
        blockedWaits.Add(tcs);
        cancellationToken.Register(function()
        {
            blockedWaits.Remove(tcs);
            tcs.TrySetCanceled();
        });
        if (millisecondsTimeout >= 0 && millisecondsTimeout != .MaxValue)
        {
            /*CancellationTokenSource*/ let cts = new CancellationTokenSource();
            cts.Token.Register(function()
            {
                blockedWaits.Remove(tcs);
                tcs.TrySetCanceled();
            });
            cts.CancelAfter(millisecondsTimeout);
        }
        return tcs.Task;
    }
    /*Task*/ WaitAsync(/*CancellationToken*/ cancellationToken)
    {
        return WaitAsync(.MaxValue, cancellationToken);
    }
    /*Task<bool>*/ WaitAsync(/*TimeSpan*/ timeout)
    {
        return WaitAsync(timeout.TotalMilliseconds, CancellationToken.None);
    }
    /*Task<bool>*/ WaitAsync(/*TimeSpan*/ timeout, /*CancellationToken*/ cancellationToken)
    {
        return WaitAsync(timeout.Milliseconds, cancellationToken);
    }
}

class System_Threading_Tasks_TaskCompletionSource extends System_Threading_Tasks_TaskCompletionSource(object)
{
    constructor()
    {
        super();
    }
    /*void*/ TrySetResult()
    {
        TrySetResult(default);
    }
    /*void*/ SetResult()
    {
        SetResult(default);
    }
}

class System_Threading_Tasks_TaskExtensions extends object
{
    constructor()
    {
        super();
    }
    /*void*/ TrySetCanceled(T, /*TaskCompletionSource<T>*/ tcs, /*CancellationToken*/ token)
    {
        tcs.TrySetCanceled();
    }
}

class System_Threading_Tasks_TaskToAsyncResult extends object
{
    constructor()
    {
        super();
    }
    /*IAsyncResult*/ Begin(/*Task*/ task, /*AsyncCallback*/ callback, /*object*/ state)
    {
        if (task)
        {
            throw new ArgumentNullException(nameof(task));
        }
        return new TaskAsyncResult(task, state, callback);
    }
    /*void*/ End(/*IAsyncResult*/ asyncResult)
    {
        Unwrap(asyncResult).GetAwaiter().GetResult();
    }
    /*TResult*/ End(TResult, /*IAsyncResult*/ asyncResult)
    {
        Unwrap_$1(TResult, asyncResult).GetAwaiter().GetResult();
    }
    /*Task*/ Unwrap(/*IAsyncResult*/ asyncResult)
    {
        if (asyncResult)
        {
            throw new ArgumentNullException(nameof(asyncResult));
        }
        if (asyncResult as TaskAsyncResult_task instanceof Task)
        {
            throw new ArgumentException(null, nameof(asyncResult));
        }
        return task;
    }
    /*Task<TResult>*/ Unwrap(TResult, /*IAsyncResult*/ asyncResult)
    {
        if (asyncResult)
        {
            throw new ArgumentNullException(nameof(asyncResult));
        }
        if (asyncResult as TaskAsyncResult_task instanceof Task_$1)
        {
            throw new ArgumentException(null, nameof(asyncResult));
        }
        return task;
    }
    class System_Threading_Tasks_TaskAsyncResult extends System_IAsyncResult(object)
    {
        /*Task*/ _task = null;
        /*AsyncCallback*/ _callback = null;
        constructor(/*Task*/ task, /*object*/ state, /*AsyncCallback*/ callback)
        {
            super();
            _task = task;
            AsyncState = state;
            if (task.IsCompleted)
            {
                // The task has already completed.  Treat this as synchronous completion.
                    // Invoke the callback; no need to store it.
                    CompletedSynchronously = true;
                callbackInvoke();
            }
            else if (callback)
            {
                // Asynchronous completion, and we have a callback; schedule it. We use OnCompleted rather than ContinueWith in
                    // order to avoid running synchronously if the task has already completed by the time we get here but still run
                    // synchronously as part of the task's completion if the task completes after (the more common case).
                    _callback = callback;
                _task.GetAwaiter().OnCompleted(function()
                {
                    return _callback.Invoke();
                });
            }
        }
        /*object*/ _backingField_AsyncState = null;
        /*object*/ get AsyncState()
        {
            return _backingField_AsyncState;
        }
        /*bool*/ _backingField_CompletedSynchronously = null;
        /*bool*/ get CompletedSynchronously()
        {
            return _backingField_CompletedSynchronously;
        }
        /*bool*/ get IsCompleted()
        {
            return _task.IsCompleted;
        }
    }
}

class System_Threading_Tasks_ValueTask extends System_Threading_Tasks_Task
{
    /*Task*/ task = null;
    constructor(/*Task*/ task)
    {
        super(null);
        .task  = task;
    }
    /*Task*/ AsTask()
    {
        task ?? ;
    }
    constructor(/*Action*/ action)
    {
        super(action);
    }
    constructor(/*Action<object>*/ action, /*object*/ state)
    {
        super(action, state);
    }
    /*ValueTask*/ get CompletedTask()
    {
        return new ValueTask(Task.CompletedTask);
    }
    /*ValueTask<T>*/ FromResult(T, /*T*/ t)
    {
        new ValueTask_$1(T, Task.FromResult(T, t));
    }
}
const System_Threading_Tasks_ValueTask$_1 = (TResult) => class extends System_Threading_Tasks_Task(TResult)
{
    /*Task<TResult>*/ task = null;
    constructor(/*Task<TResult>*/ task)
    {
        super(null);
        .task  = task;
    }
    constructor(/*Func<TResult>*/ function)
    {
        super(function);
    }
    constructor(/*Func<object, TResult>*/ function, /*object*/ state)
    {
        super(function, state);
    }
    /*TResult*/ get Result()
    {
        return task != nulltask.Result super.Result;
    }
    /*Task<TResult>*/ AsTask()
    {
        task ?? ;
    }
    /*Task*/ ContinueWith(/*Action<Task<TResult>>*/ continuationAction)
    {
        taskContinueWith(continuationAction) ?? super.ContinueWith(continuationAction);
    }
    /*Task<TNewResult>*/ ContinueWith(TNewResult, /*Func<Task<TResult>, TNewResult>*/ continuationFunction)
    {
        taskContinueWith(continuationFunction) ?? super.ContinueWith(continuationFunction);
    }
    /*TaskAwaiter<TResult>*/ GetAwaiter()
    {
        taskGetAwaiter() ?? super.GetAwaiter();
    }
    /*void*/ SetResult(/*TResult*/ result)
    {
        if (task != null)
        task.SetResult(result);
        else 
        super.SetResult(result);
    }
}

class System_Web_HttpUtility extends object
{
    constructor()
    {
        super();
    }
    /*string*/ UrlEncode(/*string*/ uri)
    /*NameValueCollection*/ ParseQueryString(/*string*/ query)
    {
        /*Span<Range>*/ let ranges = new Span_$1(Range, 50);
        /*var*/ let span = query.AsSpan().Trim('?');
        /*int*/ let len = span.Split(ranges, '&');
        /*NameValueCollection*/ let collection = new NameValueCollection();
        for(/*int*/ let i = 0; i < len; i++)
        {
            /*var*/ let kv = spanrangesi;
            /*Span<Range>*/ let innerRanges = new Span_$1(Range, 2);
            /*var*/ let ilen = kv.Split(innerRanges, '=');
            /*string*/ let value = null;
            /*string*/ let key = kvinnerRanges0;
            if (ilen > 1)
            {
                value = kvinnerRanges0;
            }
            collection.Add(key, value);
        });
        return collection;
    }
}


class BlazorJs_Core_Components_LiteRouting_LiteRouter extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
    }
    /*NavigationManager*/ _backingField_Navigation = null;
    /*NavigationManager*/ get Navigation()
    {
        return _backingField_Navigation;
    }
    /*NavigationManager*/ set Navigation(value)
    {
        _backingField_Navigation = value;
    }
    /*Type*/ _backingField_DefaultLayout = null;
    /*Type*/ get DefaultLayout()
    {
        return _backingField_DefaultLayout;
    }
    /*Type*/ set DefaultLayout(value)
    {
        _backingField_DefaultLayout = value;
    }
    /*RenderFragment*/ _backingField_NotFound = null;
    /*RenderFragment*/ get NotFound()
    {
        return _backingField_NotFound;
    }
    /*RenderFragment*/ set NotFound(value)
    {
        _backingField_NotFound = value;
    }
    /*int*/ routeIndexSequenceNumber = null;
    /*RouteRegistration*/ route = null;
    /*object*/ routeParameter = null;
    /*void*/ RefreshRoute({ /*string*/ location = null})
    {
        routeParameter = null;
        let $v = { value: set(value){ routeIndexSequenceNumber = value; } };
        let $v = { value: set(value){ routeParameter = value; } };
        route = RouteTableFactory.Match(location ?? document.location.pathname  + document.location.search, $v, $v);
    }
    /*RenderFragment*/ RenderLayout(/*Type*/ layoutType, /*RenderFragment*/ body)
    {
        return function(/**/ frame, /**/ key)
        {
            frame.Component(layoutType, function(/**/ component)
            {
                {
                    ILayoutComponentcomponent.Body  = body;
                }
            }, { sequenceNumber : Utility.LiteRouter_Layout_SequenceNumber });
        };
    }
    /*RenderFragment*/ Found()
    {
        /*RenderFragment*/ let pageContent = function(/**/ frame, /**/ key)
        {
            frame.Component(route.PageType, function(/**/ component)
            {
                {
                    if (route.ParameterSetter  != null && routeParameter != null)
                    {
                        BlazorJs.forEach(Object.GetOwnPropertyNames(routeParameter), function(name, $_i)
                        {
                            route.ParameterSetter(component, name, routeParametername);
                        });
                    }
                }
            }, { sequenceNumber : Utility.LiteRouter_Page_SequenceNumber  + routeIndexSequenceNumber });
        };
        /*var*/ let layout = route.Layout  ?? DefaultLayout;
        if (layout != null)
        {
            return RenderLayout(layout, pageContent);
        }
        return pageContent;
    }
    /*void*/ OnInitialized()
    {
        RefreshRoute();
        Navigation.LocationChanged  += Navigation_OnLocationChanged;
        super.OnInitialized();
    }
    /*void*/ Dispose()
    {
        Navigation.LocationChanged  -= Navigation_OnLocationChanged;
        super.Dispose();
    }
    /*void*/ Navigation_OnLocationChanged(/*object*/ sender, /*LocationChangedEventArgs*/ e)
    {
        RefreshRoute(e.Location);
        StateHasChanged();
    }
}


class Microsoft_AspNetCore_Components_RenderTree_Renderer extends object
{
    constructor()
    {
        super();
    }
    /*ResourceAssetCollection*/ _backingField_Assets = null;
    /*ResourceAssetCollection*/ get Assets()
    {
        return _backingField_Assets;
    }
    /*Dispatcher*/ _backingField_Dispatcher = null;
    /*Dispatcher*/ get Dispatcher()
    {
        return _backingField_Dispatcher;
    }
    /*bool*/ get Disposed()
    {
        return false;
    }
    /*IComponentRenderMode*/ GetComponentRenderMode(/*IComponent*/ component)
    {
        null;
    }
    /*IComponentRenderMode*/ GetComponentRenderMode(/*int*/ componentId)
    {
        null;
    }
    /*RendererInfo*/ _backingField_RendererInfo = null;
    /*RendererInfo*/ get RendererInfo()
    {
        return _backingField_RendererInfo;
    }
    /*void*/ HandleException(/*Exception*/ exception)
    {
    }
}

class Microsoft_AspNetCore_Components_Sections_SectionContent extends System_IDisposable(Microsoft_AspNetCore_Components_IComponent(Microsoft_AspNetCore_Components_ComponentBase))
{
    constructor()
    {
        super();
    }
    /*object*/ _registeredIdentifier = null;
    /*bool?*/ _registeredIsDefaultContent = null;
    /*SectionRegistry*/ _registry = default;
    /*string*/ _backingField_SectionName = null;
    /*string*/ get SectionName()
    {
        return _backingField_SectionName;
    }
    /*string*/ set SectionName(value)
    {
        _backingField_SectionName = value;
    }
    /*object*/ _backingField_SectionId = null;
    /*object*/ get SectionId()
    {
        return _backingField_SectionId;
    }
    /*object*/ set SectionId(value)
    {
        _backingField_SectionId = value;
    }
    /*bool*/ _backingField_IsDefaultContent = null;
    /*bool*/ get IsDefaultContent()
    {
        return _backingField_IsDefaultContent;
    }
    /*bool*/ set IsDefaultContent(value)
    {
        _backingField_IsDefaultContent = value;
    }
    /*RenderFragment*/ _backingField_ChildContent = null;
    /*RenderFragment*/ get ChildContent()
    {
        return _backingField_ChildContent;
    }
    /*RenderFragment*/ set ChildContent(value)
    {
        _backingField_ChildContent = value;
    }
    /*void*/ Attach(/*RenderHandle*/ renderHandle)
    {
        _registry = renderHandle.Dispatcher.SectionRegistry;
    }
    /*Task*/ SetParametersAsync(/*ParameterView*/ parameters)
    {
        // We are not using parameters.SetParameterProperties(this)
            // because IsDefaultContent is internal property and not a parameter
            SetParameterValues(parameters);
        /*object*/ let identifier;
        if (SectionName != null && SectionId != null)
        {
            throw new InvalidOperationException(nameof(SectionContent)nameof(SectionName)nameof(SectionId));
        }
        else if (SectionName != null)
        {
            identifier = SectionName;
        }
        else if (SectionId != null)
        {
            identifier = SectionId;
        }
        else 
        {
            throw new InvalidOperationException(nameof(SectionContent)nameof(SectionName)nameof(SectionId));
        }
        if (.Equals(identifier, _registeredIdentifier) || IsDefaultContent != _registeredIsDefaultContent)
        {
            if (_registeredIdentifier != null)
            {
                _registry.RemoveProvider(_registeredIdentifier, );
            }
            _registry.AddProvider(identifier, , IsDefaultContent);
            _registeredIdentifier = identifier;
            _registeredIsDefaultContent = IsDefaultContent;
        }
        _registry.NotifyContentProviderChanged(identifier, );
        return Task.CompletedTask;
    }
    /*void*/ SetParameterValues(/*ParameterView*/ parameters)
    {
        BlazorJs.forEach(parameters, function(param, $_i)
        {
            switch(param.Name)
            {
                case nameof(SectionContent.SectionName):
                {
                    SectionName = param.Value;
                    break;
                }
                case nameof(SectionContent.SectionId):
                {
                    SectionId = param.Value;
                    break;
                }
                case nameof(SectionContent.IsDefaultContent):
                {
                    IsDefaultContent = param.Value;
                    break;
                }
                case nameof(SectionContent.ChildContent):
                {
                    ChildContent = RenderFragmentparam.Value;
                    break;
                }
                default:                {
                    throw new ArgumentException(param.Name);
                }
            }
        });
    }
    /*void*/ Dispose()
    {
        if (_registeredIdentifier != null)
        {
            _registry.RemoveProvider(_registeredIdentifier, );
        }
        super.Dispose();
    }
}

class Microsoft_AspNetCore_Components_Sections_SectionOutlet extends Microsoft_AspNetCore_Components_IComponent(object)
{
    constructor()
    {
        super();
    }
    /*RenderFragment*/ _emptyRenderFragment = function(/**/ _, /**/ __)
    {
    };
    /*object*/ _subscribedIdentifier = null;
    /*RenderHandle*/ _renderHandle = null;
    /*SectionRegistry*/ _registry = default;
    /*SectionContent*/ _currentContentProvider = null;
    /*string*/ _backingField_SectionName = null;
    /*string*/ get SectionName()
    {
        return _backingField_SectionName;
    }
    /*string*/ set SectionName(value)
    {
        _backingField_SectionName = value;
    }
    /*object*/ _backingField_SectionId = null;
    /*object*/ get SectionId()
    {
        return _backingField_SectionId;
    }
    /*object*/ set SectionId(value)
    {
        _backingField_SectionId = value;
    }
    /*IComponent*/ get CurrentLogicalParent()
    {
        return _currentContentProvider;
    }
    /*void*/ Attach(/*RenderHandle*/ renderHandle)
    {
        _renderHandle = renderHandle;
        _registry = _renderHandle.Dispatcher.SectionRegistry;
    }
    /*Task*/ SetParametersAsync(/*ParameterView*/ parameters)
    {
        parameters.SetParameterProperties();
        /*object*/ let identifier;
        if (SectionName != null && SectionId != null)
        {
            throw new InvalidOperationException(nameof(SectionOutlet)nameof(SectionName)nameof(SectionId));
        }
        else if (SectionName != null)
        {
            identifier = SectionName;
        }
        else if (SectionId != null)
        {
            identifier = SectionId;
        }
        else 
        {
            throw new InvalidOperationException(nameof(SectionOutlet)nameof(SectionName)nameof(SectionId));
        }
        if (.Equals(identifier, _subscribedIdentifier))
        {
            if (_subscribedIdentifier != null)
            {
                _registry.Unsubscribe(_subscribedIdentifier);
            }
            _registry.Subscribe(identifier, );
            _subscribedIdentifier = identifier;
        }
        RenderContent();
        return Task.CompletedTask;
    }
    /*void*/ ContentUpdated(/*SectionContent*/ provider)
    {
        _currentContentProvider = provider;
        RenderContent();
    }
    /*void*/ RenderContent()
    {
        if (_renderHandle.IsRendererDisposed)
        {
            return ;
        }
        _renderHandle.Render(BuildRenderTree);
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ frame, /*object*/ key)
    {
        /*var*/ let fragment = _currentContentProviderChildContent ?? _emptyRenderFragment;
        fragment(frame, key);
    }
    /*void*/ Dispose()
    {
        if (_subscribedIdentifier != null)
        {
            _registry.Unsubscribe(_subscribedIdentifier);
        }
    }
}

class Microsoft_AspNetCore_Components_Sections_SectionRegistry extends object
{
    constructor()
    {
        super();
    }
    /*Dictionary<object, SectionOutlet>*/ _subscribersByIdentifier = new Dictionary_$2(object, SectionOutlet);
    /*Dictionary<object, List<SectionContent>>*/ _providersByIdentifier = new Dictionary_$2(object, List<SectionContent>);
    /*void*/ AddProvider(/*object*/ identifier, /*SectionContent*/ provider, /*bool*/ isDefaultProvider)
    {
        let providers = null;
        let $v = { value: set(value){ providers = value; } };
        if (_providersByIdentifier.TryGetValue(identifier, $v))
        {
            providers = new List_$1(SectionContent);
            _providersByIdentifier.Add(identifier, providers);
        }
        if (isDefaultProvider)
        {
            providers.Insert(0, provider);
        }
        else 
        {
            providers.Add(provider);
        }
    }
    /*void*/ RemoveProvider(/*object*/ identifier, /*SectionContent*/ provider)
    {
        let providers = null;
        let $v = { value: set(value){ providers = value; } };
        if (_providersByIdentifier.TryGetValue(identifier, $v))
        {
            throw new InvalidOperationException(identifier);
        }
        /*var*/ let index = providers.LastIndexOf(provider);
        if (index < 0)
        {
            throw new InvalidOperationException(identifier);
        }
        providers.RemoveAt(index);
        if (index == providers.Count)
        {
            /*// We just removed the most recently added provider, meaning we need to change
                // the current content to that of second most recently added provider.
                var*/ let contentProvider = GetCurrentProviderContentOrDefault(providers);
            NotifyContentChangedForSubscriber(identifier, contentProvider);
        }
    }
    /*void*/ Subscribe(/*object*/ identifier, /*SectionOutlet*/ subscriber)
    {
        if (_subscribersByIdentifier.ContainsKey(identifier))
        {
            throw new InvalidOperationException(identifier);
        }
        /*// Notify the new subscriber with any existing content.
            var*/ let provider = GetCurrentProviderContentOrDefault(identifier);
        subscriber.ContentUpdated(provider);
        _subscribersByIdentifier.Add(identifier, subscriber);
    }
    /*void*/ Unsubscribe(/*object*/ identifier)
    {
        if (_subscribersByIdentifier.Remove(identifier))
        {
            throw new InvalidOperationException(identifier);
        }
    }
    /*void*/ NotifyContentProviderChanged(/*object*/ identifier, /*SectionContent*/ provider)
    {
        let providers = null;
        let $v = { value: set(value){ providers = value; } };
        if (_providersByIdentifier.TryGetValue(identifier, $v))
        {
            throw new InvalidOperationException(identifier);
        }
        if (providers.Count  != 0 && providersproviders.Count  - 1 == provider)
        {
            NotifyContentChangedForSubscriber(identifier, provider);
        }
    }
    /*SectionContent*/ GetCurrentProviderContentOrDefault(/*List<SectionContent>*/ providers)
    {
        providers.Count  != 0providersproviders.Count  - 1null;
    }
    /*SectionContent*/ GetCurrentProviderContentOrDefault(/*object*/ identifier)
    {
        let existingList = null;
        let $v = { value: set(value){ existingList = value; } };
        _providersByIdentifier.TryGetValue(identifier, $v)GetCurrentProviderContentOrDefault(existingList)null;
    }
    /*void*/ NotifyContentChangedForSubscriber(/*object*/ identifier, /*SectionContent*/ provider)
    {
        let subscriber = null;
        let $v = { value: set(value){ subscriber = value; } };
        if (_subscribersByIdentifier.TryGetValue(identifier, $v))
        {
            subscriber.ContentUpdated(provider);
        }
    }
}

class Microsoft_AspNetCore_Components_Forms_BrowserFile extends Microsoft_AspNetCore_Components_Forms_IBrowserFile(object)
{
    constructor()
    {
        super();
    }
    /*long*/ _size = null;
    /*InputFile*/ _backingField_Owner = null;
    /*InputFile*/ get Owner()
    {
        return _backingField_Owner;
    }
    /*InputFile*/ set Owner(value)
    {
        _backingField_Owner = value;
    }
    /*int*/ _backingField_Id = null;
    /*int*/ get Id()
    {
        return _backingField_Id;
    }
    /*int*/ set Id(value)
    {
        _backingField_Id = value;
    }
    /*string*/ _backingField_Name = null;
    /*string*/ get Name()
    {
        return _backingField_Name;
    }
    /*string*/ set Name(value)
    {
        _backingField_Name = value;
    }
    /*DateTimeOffset*/ _backingField_LastModified = null;
    /*DateTimeOffset*/ get LastModified()
    {
        return _backingField_LastModified;
    }
    /*DateTimeOffset*/ set LastModified(value)
    {
        _backingField_LastModified = value;
    }
    /*long*/ get Size()
    {
        return _size;
    }
    /*long*/ set Size(value)
    {
        if (value < 0)
        {
            throw new ArgumentOutOfRangeException(nameof(Size), value);
        }
        _size = value;
    }
    /*string*/ _backingField_ContentType = null;
    /*string*/ get ContentType()
    {
        return _backingField_ContentType;
    }
    /*string*/ set ContentType(value)
    {
        _backingField_ContentType = value;
    }
    /*string*/ _backingField_RelativePath = null;
    /*string*/ get RelativePath()
    {
        return _backingField_RelativePath;
    }
    /*string*/ set RelativePath(value)
    {
        _backingField_RelativePath = value;
    }
    /*Stream*/ OpenReadStream({ /*long*/ maxAllowedSize = 512000, /*CancellationToken*/ cancellationToken = default})
    {
        if (Size > maxAllowedSize)
        {
            throw new IOException(SizemaxAllowedSize);
        }
        return Owner.OpenReadStream(, maxAllowedSize, cancellationToken);
    }
}

class Microsoft_AspNetCore_Components_Forms_BrowserFileExtensions extends object
{
    constructor()
    {
        super();
    }
    /*Task<IBrowserFile>*/ RequestImageFileAsync(/*IBrowserFile*/ browserFile, /*string*/ format, /*int*/ maxWidth, /*int*/ maxHeight)
    {
        if (browserFile instanceof BrowserFile, browserFileInternal = browserFile)
        {
            return browserFileInternal.Owner.ConvertToImageFileAsync(browserFileInternal, format, maxWidth, maxHeight);
        }
        throw new InvalidOperationException(IBrowserFile);
    }
}

class Microsoft_AspNetCore_Components_Forms_BrowserFileStream extends System_IO_AsyncStream
{
    /*long*/ _position = null;
    /*HTMLInputElement*/ _inputFileElement = null;
    /*BrowserFile*/ _file = null;
    /*long*/ _maxAllowedSize = null;
    /*CancellationTokenSource*/ _openReadStreamCts = null;
    /*bool*/ _isDisposed = null;
    /*CancellationTokenSource*/ _copyFileDataCts = null;
    constructor(/*HTMLInputElement*/ inputFileElement, /*BrowserFile*/ file, /*long*/ maxAllowedSize, /*CancellationToken*/ cancellationToken)
    {
        super();
        //_jsRuntime = jsRuntime;
            _inputFileElement = inputFileElement;
        _file = file;
        _maxAllowedSize = maxAllowedSize;
        _openReadStreamCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
    }
    /*bool*/ get CanRead()
    {
        return true;
    }
    /*bool*/ get CanSeek()
    {
        return false;
    }
    /*bool*/ get CanWrite()
    {
        return false;
    }
    /*long*/ get Length()
    {
        return _file.Size;
    }
    /*long*/ get Position()
    {
        return _position;
    }
    /*long*/ set Position(value)
    {
                throw new NotSupportedException();
;
    }
    /*void*/ Flush()
    {
                throw new NotSupportedException();
;
    }
    /*int*/ Read(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count)
    {
                throw new NotSupportedException("Synchronous reads are not supported.");
;
    }
    /*long*/ Seek(/*long*/ offset, /*SeekOrigin*/ origin)
    {
                throw new NotSupportedException();
;
    }
    /*void*/ SetLength(/*long*/ value)
    {
                throw new NotSupportedException();
;
    }
    /*Task<int>*/ WriteAsync(/*ReadOnlySpan<byte>*/ buffer, /*CancellationToken*/ cancellationToken)
    {
        throw new NotImplementedException();
    }
    /*Task<int>*/ async ReadAsync(/*Span<byte>*/ buffer, { /*CancellationToken*/ cancellationToken = default})
    {
        /*var*/ let bytesAvailableToRead = Length - Position;
        /*var*/ let maxBytesToRead = Math.Min(bytesAvailableToRead, buffer.Length);
        if (maxBytesToRead <= 0)
        {
            return 0;
        }
        /*var*/ let bytesRead = await CopyFileDataIntoBuffer(buffer.Slice(0, maxBytesToRead), cancellationToken);
        _position += bytesRead;
        return bytesRead;
    }
    /*Task<int>*/ async CopyFileDataIntoBuffer(/*Span<byte>*/ destination, /*CancellationToken*/ cancellationToken)
    {
        /*var*/ let blob = await Task.FromPromise(Blob[], InputFileInterop.ReadFileData(_inputFileElement, _file.Id).As(IPromise), null)0;
        /*var*/ let reader = H5.Script.Write(FileReader, "new FileReader()");
        reader.readAsArrayBuffer(blob);
        destination.CopyFrom(reader.result.As(byte[]));
        return blob.size;
    }
    /*void*/ Dispose(/*bool*/ disposing)
    {
        if (_isDisposed)
        {
            return ;
        }
        _openReadStreamCts.Cancel();
        _copyFileDataCtsCancel();
        //// If the browser connection is still live, notify the JS side that it's free to release the Blob
            //// and reclaim the memory. If the browser connection is already gone, there's no way for the
            //// notification to get through, but we don't want to fail the .NET-side disposal process for this.
            //try
            //{
            //    _ = _jsStreamReference?.DisposeAsync().Preserve();
            //}
            //catch
            //{
            //}

            _isDisposed = true;
        super.Dispose(disposing);
    }
}

const Microsoft_AspNetCore_Components_Forms_IBrowserFile = (Base) => class extends Base
{
    /*/// <summary>
        /// Gets the name of the file as specified by the browser.
        /// </summary>
        string*/ _backingField_Name = null;
    /*/// <summary>
        /// Gets the name of the file as specified by the browser.
        /// </summary>
        string*/ get Name()
    {
        return _backingField_Name;
    }
    /*/// <summary>
        /// Gets the last modified date as specified by the browser.
        /// </summary>
        DateTimeOffset*/ _backingField_LastModified = null;
    /*/// <summary>
        /// Gets the last modified date as specified by the browser.
        /// </summary>
        DateTimeOffset*/ get LastModified()
    {
        return _backingField_LastModified;
    }
    /*/// <summary>
        /// Gets the size of the file in bytes as specified by the browser.
        /// </summary>
        long*/ _backingField_Size = null;
    /*/// <summary>
        /// Gets the size of the file in bytes as specified by the browser.
        /// </summary>
        long*/ get Size()
    {
        return _backingField_Size;
    }
    /*/// <summary>
        /// Gets the MIME type of the file as specified by the browser.
        /// </summary>
        string*/ _backingField_ContentType = null;
    /*/// <summary>
        /// Gets the MIME type of the file as specified by the browser.
        /// </summary>
        string*/ get ContentType()
    {
        return _backingField_ContentType;
    }
}

const Microsoft_AspNetCore_Components_Forms_IInputFileJsCallbacks = (Base) => class extends Base
{
}

class Microsoft_AspNetCore_Components_Forms_InputFileChangeEventArgs extends System_EventArgs
{
    /*IReadOnlyList<IBrowserFile>*/ _files = null;
    constructor(/*IReadOnlyList<IBrowserFile>*/ files)
    {
        super();
        _files = files ??         throw new ArgumentNullException(nameof(files));
;
    }
    /*int*/ get FileCount()
    {
        return _files.Count;
    }
    /*IBrowserFile*/ get File()
    {
        switch(_files.Count)
        {
            case 0:
            {
                throw new InvalidOperationException("No file was supplied.");
            }
            case 1:
            {
                return _files0;
            }
            default:            {
                throw new InvalidOperationException(nameof(GetMultipleFiles));
            }
        }
    }
    /*IReadOnlyList<IBrowserFile>*/ GetMultipleFiles({ /*int*/ maximumFileCount = 10})
    {
        if (_files.Count  > maximumFileCount)
        {
            throw new InvalidOperationException(maximumFileCount_files.Count);
        }
        return _files;
    }
}

class Microsoft_AspNetCore_Components_Forms_InputFileInterop extends object
{
    constructor()
    {
        super();
    }
    /*void*/ Init(/*IInputFileJsCallbacks*/ callbackWrapper, /*HTMLInputElement*/ elem)
    {
        elem"_blazorInputFileNextFileId" = 0;
        elem.addEventListener("click", function()
        {
            // Permits replacing an existing file with a new one of the same file name.
                elem.value  = "";
        });
        elem.addEventListener("change", function()
        {
            // Reduce to purely serializable data, plus an index by ID.
                elem"_blazorFilesById" = new ();
            /*var*/ let fileList = elem.files.Select(function(/**/ file)
            {
                {
                    /*var*/ let id = elem"_blazorInputFileNextFileId".As(int);
                    id++;
                    elem"_blazorInputFileNextFileId" = id;
                    /*var*/ let result = new BrowserFile()Id = idLastModified = DateTimeOffset.Parse(new Date(file.lastModified).toISOString())Name = file.nameSize = file.sizeContentType = file.type;
                    result"blob" = file;
                    elem"_blazorFilesById"result.Id.ToString() = result;
                    return result;
                }
            }).ToArray();
            callbackWrapper.NotifyChange(fileList);
        });
    }
    /*BrowserFile*/ GetFileById(/*HTMLInputElement*/ elem, /*int*/ fileId)
    {
        /*var*/ let file = elem"_blazorFilesById"fileId.ToString().As(BrowserFile);
        if (file == null)
        {
            throw new Exception(fileId);
        }
        return file;
    }
    /*Promise<Blob>*/ ReadFileData(/*HTMLInputElement*/ elem, /*int*/ fileId)
    {
        /*var*/ let file = GetFileById(elem, fileId);
        return file"blob".As(Promise<Blob>);
    }
    /*Task<BrowserFile>*/ async ToImageFile(/*HTMLInputElement*/ elem, /*int*/ fileId, /*string*/ format, /*int*/ maxWidth, /*int*/ maxHeight)
    {
        /*var*/ let originalFile = GetFileById(elem, fileId);
        /*TaskCompletionSource<HTMLImageElement>*/ let tcs = new TaskCompletionSource_$1(HTMLImageElement);
        /*var*/ let originalFileImage = H5.Script.Write(object, "new Image()").As(HTMLImageElement);
        originalFileImage"onload" = Actionfunction()
        {
            URL.revokeObjectURL(originalFileImage.src);
            tcs.SetResult(originalFileImage);
        };
        originalFileImage"onerror" = Actionfunction()
        {
            originalFileImage.onerror  = null;
            URL.revokeObjectURL(originalFileImage.src);
        };
        originalFileImage"src" = URL.createObjectURL(originalFile"blob");
        /*HTMLImageElement*/ let loadedImage = await tcs.Task;
        /*//HTMLImageElement loadedImage = new Promise((Action<HTMLImageElement> resolve) =>
            //{
            //    var originalFileImage = H5.Script.Write<object>("new Image()").As<HTMLImageElement>();
            //    originalFileImage["onload"] = () =>
            //    {
            //        URL.revokeObjectURL(originalFileImage.src);
            //        resolve(originalFileImage);
            //    };
            //    originalFileImage["onerror"] = () =>
            //    {
            //        originalFileImage.onerror = null;
            //        URL.revokeObjectURL(originalFileImage.src);
            //    };
            //    originalFileImage["src"] = URL.createObjectURL(originalFile["blob"]);
            //});

            TaskCompletionSource<Blob>*/ let tcs2 = new TaskCompletionSource_$1(Blob);
        /*var*/ let desiredWidthRatio = H5.Core.es5.Math.min(1, maxWidth / loadedImage.width);
        /*var*/ let desiredHeightRatio = H5.Core.es5.Math.min(1, maxHeight / loadedImage.height);
        /*var*/ let chosenSizeRatio = H5.Core.es5.Math.min(desiredWidthRatio, desiredHeightRatio);
        /*var*/ let canvas = document.createElement("canvas").As(HTMLCanvasElement);
        canvas.width  = H5.Core.es5.Math.round(loadedImage.width  * chosenSizeRatio).As(uint);
        canvas.height  = H5.Core.es5.Math.round(loadedImage.height  * chosenSizeRatio).As(uint);
        canvas.getContext("2d").As(CanvasRenderingContext2D)drawImage(loadedImage, 0, 0, canvas.width, canvas.height);
        canvas.toBlob(function(/**/ blob)
        {
            tcs2.SetResult(blob);
        }, format);
        /*var*/ let resizedImageBlob = await tcs2.Task;
        /*//var resizedImageBlob = new Promise((Action<BlobCallback> resolve) =>
            //{
            //    var desiredWidthRatio = Math.min(1, maxWidth / loadedImage.width);
            //    var desiredHeightRatio = Math.min(1, maxHeight / loadedImage.height);
            //    var chosenSizeRatio = Math.min(desiredWidthRatio, desiredHeightRatio);

            //    var canvas = document.createElement("canvas").As<HTMLCanvasElement>();
            //    canvas.width = Math.round(loadedImage.width * chosenSizeRatio);
            //    canvas.height = Math.round(loadedImage.height * chosenSizeRatio);
            //    canvas.getContext("2d").As<CanvasRenderingContext2D>()?.drawImage(loadedImage, 0, 0, canvas.width, canvas.height);
            //    canvas.toBlob(resolve, format);
            //});

            var*/ let id = elem"_blazorInputFileNextFileId".As(int);
        id++;
        elem"_blazorInputFileNextFileId" = id;
        /*var*/ let result = new BrowserFile()Id = idLastModified = originalFile.LastModifiedName = originalFile.NameSize = resizedImageBlobsize ?? 0ContentType = format;
        result"blob" = resizedImageBlob ?? originalFile"blob";
        elem"_blazorFilesById"result.Id.ToString() = result;
        return result;
    }
}



class Microsoft_AspNetCore_Components_Forms_Mapping_EditContextFormMappingExtensions extends object
{
    constructor()
    {
        super();
    }
    /*object*/ _key = new ();
    /*IDisposable*/ EnableFormMappingContextExtensions(/*EditContext*/ context, /*FormMappingContext*/ mappingContext)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(context, nameof(context));
        ArgumentNullExceptionExtension.ThrowIfNull(mappingContext, nameof(mappingContext));
        context.Properties_key = mappingContext;
        return new MappingContextEventSubscriptions(context, mappingContext);
    }
    /*string*/ GetAttemptedValue(/*EditContext*/ context, /*string*/ fieldName)
    {
        ArgumentNullExceptionExtension.ThrowIfNull(context, nameof(context));
        ArgumentNullExceptionExtension.ThrowIfNull(fieldName, nameof(fieldName));
        let result = null;
        let $v = { value: set(value){ result = value; } };
        if (context.Properties.TryGetValue(_key, $v) && result instanceof FormMappingContext, mappingContext = result)
        {
            return mappingContext.GetAttemptedValue(fieldName);
        }
        return null;
    }
    class Microsoft_AspNetCore_Components_Forms_Mapping_MappingContextEventSubscriptions extends System_IDisposable(object)
    {
        /*EditContext*/ _editContext = null;
        /*FormMappingContext*/ _mappingContext = null;
        /*ValidationMessageStore*/ _messages = null;
        /*bool*/ _hasmessages = null;
        constructor(/*EditContext*/ editContext, /*FormMappingContext*/ mappingContext)
        {
            super();
            _editContext = editContext;
            _mappingContext = mappingContext;
            _editContext.OnValidationRequested  += OnValidationRequested;
        }
        /*void*/ OnValidationRequested(/*object*/ sender, /*ValidationRequestedEventArgs*/ e)
        {
            if (_messages != null)
            {
                return ;
            }
            _messages = new ValidationMessageStore(_editContext);
            /*var*/ let adddedMessages = false;
            BlazorJs.forEach(_mappingContext.GetAllErrors(), function(error, $_i)
            {
                /*var*/ let owner = error.Container;
                /*var*/ let key = error.Name;
                /*var*/ let errors = error.ErrorMessages;
                /*FieldIdentifier*/ let fieldIdentifier;
                fieldIdentifier = new FieldIdentifier(owner ?? _editContext.Model, key);
                BlazorJs.forEach(errors, function(errorMessage, $_i)
                {
                    adddedMessages = true;
                    // TODO: We need to support localizing the error message.
                        _messages.Add(fieldIdentifier, errorMessage.ToString(CultureInfo.CurrentCulture));
                    _hasmessages = true;
                });
            });
            if (adddedMessages)
            {
                // There were mapping errors, notify.
                    _editContext.NotifyValidationStateChanged();
            }
        }
        /*void*/ Dispose()
        {
            _messagesClear();
            _editContext.OnValidationRequested  -= OnValidationRequested;
            if (_hasmessages)
            {
                _editContext.NotifyValidationStateChanged();
            }
        }
    }
}

class Microsoft_AspNetCore_Components_Forms_FormMappingContext extends object
{
    /*Dictionary<string, FormMappingError>*/ _errors = null;
    /*List<KeyValuePair<string, FormMappingError>>*/ _pendingErrors = null;
    /*Dictionary<string, Dictionary<string, FormMappingError>>*/ _errorsByFormName = null;
    constructor(/*string*/ mappingScopeName)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(mappingScopeName);
        MappingScopeName = mappingScopeName;
    }
    /*string*/ _backingField_MappingScopeName = null;
    /*string*/ get MappingScopeName()
    {
        return _backingField_MappingScopeName;
    }
    /*FormMappingError*/ GetErrors(/*string*/ key)
    {
        let mappingError = null;
        let $v = { value: set(value){ mappingError = value; } };
        _errorsTryGetValue(key, $v) == truemappingErrornull;
    }
    /*FormMappingError*/ GetErrors(/*string*/ formName, /*string*/ key)
    {
        let formErrors = null;
        let $v = { value: set(value){ formErrors = value; } };
        let mappingError = null;
        let $v = { value: set(value){ mappingError = value; } };
        _errorsByFormNameTryGetValue(formName, $v) == true && formErrors.TryGetValue(key, $v) == truemappingErrornull;
    }
    /*IEnumerable<FormMappingError>*/ GetAllErrors()
    {
        return GetAllErrorsCore(_errors);
    }
    /*IEnumerable<FormMappingError>*/ GetAllErrorsCore(/*Dictionary<string, FormMappingError>*/ errors)
    {
        if (errors == null)
        {
            return Array.Empty(FormMappingError);
        }
        return errors.Values;
    }
    /*IEnumerable<FormMappingError>*/ GetAllErrors(/*string*/ formName)
    {
        let formErrors = null;
        let $v = { value: set(value){ formErrors = value; } };
        return _errorsByFormNameTryGetValue(formName, $v) == trueGetAllErrorsCore(formErrors)Array.Empty(FormMappingError);
    }
    /*string*/ GetAttemptedValue(/*string*/ key)
    {
        let mappingError = null;
        let $v = { value: set(value){ mappingError = value; } };
        _errorsTryGetValue(key, $v) == truemappingError.AttemptedValue null;
    }
    /*string*/ GetAttemptedValue(/*string*/ formName, /*string*/ key)
    {
        let formErrors = null;
        let $v = { value: set(value){ formErrors = value; } };
        let mappingError = null;
        let $v = { value: set(value){ mappingError = value; } };
        _errorsByFormNameTryGetValue(formName, $v) == true && formErrors.TryGetValue(key, $v)mappingError.AttemptedValue null;
    }
    /*void*/ AddError(/*string*/ key, /*FormattableString*/ error, /*string*/ attemptedValue)
    {
        _errors = _errors ?? new Dictionary_$2(string, FormMappingError);
        let $v = { value: set(value){ _pendingErrors = value; } };
        AddErrorCore(_errors, key, error, attemptedValue, $v);
    }
    /*void*/ AddErrorCore(/*Dictionary<string, FormMappingError>*/ errors, /*string*/ key, /*FormattableString*/ error, /*string*/ attemptedValue, /*List<KeyValuePair<string, FormMappingError>>*/ pendingErrors)
    {
        let mappingError = null;
        let $v = { value: set(value){ mappingError = value; } };
        if (errors.TryGetValue(key, $v))
        {
            mappingError = new FormMappingError(key, new List_$1(FormattableString)error, attemptedValue);
            errors.Add(key, mappingError);
            pendingErrors = pendingErrors ?? new List_$1(KeyValuePair<string, FormMappingError>);
            pendingErrors.Add(new KeyValuePair_$2(string, FormMappingError, key, mappingError));
        }
        else 
        {
            mappingError.AddError(error);
        }
    }
    /*void*/ AddError(/*string*/ formName, /*string*/ key, /*FormattableString*/ error, /*string*/ attemptedValue)
    {
        _errorsByFormName = _errorsByFormName ?? new Dictionary_$2(string, Dictionary<string, FormMappingError>);
        let formErrors = null;
        let $v = { value: set(value){ formErrors = value; } };
        if (_errorsByFormName.TryGetValue(formName, $v))
        {
            formErrors = new Dictionary_$2(string, FormMappingError);
            _errorsByFormName.Add(formName, formErrors);
        }
        let $v = { value: set(value){ _pendingErrors = value; } };
        AddErrorCore(formErrors, key, error, attemptedValue, $v);
    }
    /*void*/ AttachParentValue(/*string*/ key, /*object*/ value)
    {
        if (_pendingErrors == null)
        {
            return ;
        }
        for(/*var*/ let i = 0; i < _pendingErrors.Count; i++)
        {
            var = _pendingErrorsi;
            if (errorKey.StartsWith(key, StringComparison.Ordinal))
            {
                throw new InvalidOperationException(errorKeykey);
            }
            error.Container  = value;
        });
        _pendingErrors.Clear();
    }
    /*void*/ SetErrors(/*string*/ formName, /*FormMappingContext*/ childContext)
    {
        let formErrors = null;
        let $v = { value: set(value){ formErrors = value; } };
        if (_errorsByFormName == null || _errorsByFormName.TryGetValue(formName, $v))
        {
            return ;
        }
        childContext._errors  = formErrors;
    }
}

class Microsoft_AspNetCore_Components_Forms_Mapping_FormMappingError extends object
{
    /*char[]*/ Separators = [ '.''[' ];
    /*List<FormattableString>*/ _errorMessages = null;
    constructor(/*string*/ path, /*List<FormattableString>*/ errorMessages, /*string*/ attemptedValue)
    {
        super();
        _errorMessages = errorMessages;
        AttemptedValue = attemptedValue;
        Path = path;
        Name = GetName(Path);
    }
    /*object*/ _backingField_Container = null;
    /*object*/ get Container()
    {
        return _backingField_Container;
    }
    /*object*/ set Container(value)
    {
        _backingField_Container = value;
    }
    /*string*/ _backingField_Name = null;
    /*string*/ get Name()
    {
        return _backingField_Name;
    }
    /*string*/ _backingField_Path = null;
    /*string*/ get Path()
    {
        return _backingField_Path;
    }
    /*IReadOnlyList<FormattableString>*/ get ErrorMessages()
    {
        return _errorMessages;
    }
    /*string*/ _backingField_AttemptedValue = null;
    /*string*/ get AttemptedValue()
    {
        return _backingField_AttemptedValue;
    }
    /*string*/ GetName(/*string*/ path)
    {
        /*var*/ let errorKey = path;
        /*var*/ let lastSeparatorIndex = path.LastIndexOfAny(Separators);
        if (lastSeparatorIndex >= 0)
        {
            if (pathlastSeparatorIndex == '[')
            {
                /*var*/ let closingBracket = path.IndexOf(']', lastSeparatorIndex);
                // content within brackets
                    errorKey = path.AsSpan()new SystemRange(lastSeparatorIndex + 1, closingBracket);
            }
            else 
            {
                errorKey = path.AsSpan()new SystemRange(lastSeparatorIndex + 1, 1);
            }
        }
        return errorKey;
    }
    /*void*/ AddError(/*FormattableString*/ error)
    {
        _errorMessages.Add(error);
    }
}


class Microsoft_AspNetCore_Components_Forms_Mapping_FormMappingValidator extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
    }
    /*IDisposable*/ _subscriptions = null;
    /*EditContext*/ _originalEditContext = null;
    /*EditContext*/ _backingField_CurrentEditContext = null;
    /*EditContext*/ get CurrentEditContext()
    {
        return _backingField_CurrentEditContext;
    }
    /*EditContext*/ set CurrentEditContext(value)
    {
        _backingField_CurrentEditContext = value;
    }
    /*FormMappingContext*/ _backingField_MappingContext = null;
    /*FormMappingContext*/ get MappingContext()
    {
        return _backingField_MappingContext;
    }
    /*FormMappingContext*/ set MappingContext(value)
    {
        _backingField_MappingContext = value;
    }
    /*void*/ OnInitialized()
    {
        if (CurrentEditContext == null)
        {
            throw new InvalidOperationException(nameof(FormMappingValidator) + nameof(EditContext));
        }
        if (MappingContext == null)
        {
            return ;
        }
        _subscriptions = CurrentEditContext.EnableFormMappingContextExtensions(MappingContext);
        _originalEditContext = CurrentEditContext;
    }
    /*void*/ OnParametersSet()
    {
        if (MappingContext == null)
        {
            return ;
        }
        if (CurrentEditContext != _originalEditContext)
        {
            throw new InvalidOperationException(GetType() + nameof(EditContext));
        }
    }
    /*void*/ Dispose()
    {
        super.Dispose();
        _subscriptionsDispose();
        _subscriptions = null;
    }
}

class Microsoft_AspNetCore_Components_Forms_Mapping_FormValueMappingContext extends object
{
    /*bool*/ _resultSet = null;
    constructor(/*string*/ acceptMappingScopeName, /*string*/ acceptFormName, /*Type*/ valueType, /*string*/ parameterName)
    {
        super();
        ArgumentNullExceptionExtension.ThrowIfNull(acceptMappingScopeName, nameof(acceptMappingScopeName));
        ArgumentNullExceptionExtension.ThrowIfNull(valueType, nameof(valueType));
        ArgumentNullExceptionExtension.ThrowIfNull(parameterName, nameof(parameterName));
        AcceptMappingScopeName = acceptMappingScopeName;
        AcceptFormName = acceptFormName;
        ParameterName = parameterName;
        ValueType = valueType;
    }
    /*string*/ _backingField_AcceptMappingScopeName = null;
    /*string*/ get AcceptMappingScopeName()
    {
        return _backingField_AcceptMappingScopeName;
    }
    /*string*/ _backingField_AcceptFormName = null;
    /*string*/ get AcceptFormName()
    {
        return _backingField_AcceptFormName;
    }
    /*string*/ _backingField_ParameterName = null;
    /*string*/ get ParameterName()
    {
        return _backingField_ParameterName;
    }
    /*Type*/ _backingField_ValueType = null;
    /*Type*/ get ValueType()
    {
        return _backingField_ValueType;
    }
    /*Action<string, FormattableString, string>*/ _backingField_OnError = null;
    /*Action<string, FormattableString, string>*/ get OnError()
    {
        return _backingField_OnError;
    }
    /*Action<string, FormattableString, string>*/ set OnError(value)
    {
        _backingField_OnError = value;
    }
    /*Action<string, object>*/ _backingField_MapErrorToContainer = null;
    /*Action<string, object>*/ get MapErrorToContainer()
    {
        return _backingField_MapErrorToContainer;
    }
    /*Action<string, object>*/ set MapErrorToContainer(value)
    {
        _backingField_MapErrorToContainer = value;
    }
    /*object*/ _backingField_Result = null;
    /*object*/ get Result()
    {
        return _backingField_Result;
    }
    /*object*/ set Result(value)
    {
        _backingField_Result = value;
    }
    /*void*/ SetResult(/*object*/ result)
    {
        if (_resultSet)
        {
            throw new InvalidOperationException(Result);
        }
        _resultSet = true;
        Result = result;
    }
}

const Microsoft_AspNetCore_Components_Forms_Mapping_IFormValueMapper = (Base) => class extends Base
{
}



class Microsoft_JSInterop_Implementation_JSInProcessObjectReference extends System_IDisposable(Microsoft_JSInterop_IJSObjectReference(Microsoft_JSInterop_IJSInProcessObjectReference(Microsoft_JSInterop_Implementation_JSObjectReference)))
{
    /*JSInProcessRuntime*/ _jsRuntime = null;
    constructor(/*JSInProcessRuntime*/ jsRuntime, /*long*/ id)
    {
        super(jsRuntime, id);
        _jsRuntime = jsRuntime;
    }
    /*TValue*/ Invoke(TValue, /*string*/ identifier, /*object[]*/ args)
    {
        ThrowIfDisposed();
        return _jsRuntime.Invoke(TValue, identifier, Id, JSCallType.FunctionCall, args);
    }
    /*IJSInProcessObjectReference*/ InvokeNew(/*string*/ identifier, /*object[]*/ args)
    {
        ThrowIfDisposed();
        return _jsRuntime.Invoke(IJSInProcessObjectReference, identifier, Id, JSCallType.NewCall, args);
    }
    /*TValue*/ GetValue(TValue, /*string*/ identifier)
    {
        ThrowIfDisposed();
        return _jsRuntime.Invoke(TValue, identifier, Id, JSCallType.GetValue);
    }
    /*void*/ SetValue(TValue, /*string*/ identifier, /*TValue*/ value)
    {
        ThrowIfDisposed();
        _jsRuntime.Invoke(TValue, identifier, Id, JSCallType.SetValue, value);
    }
    /*void*/ Dispose()
    {
        if (Disposed)
        {
            Disposed = true;
            DisposeJSObjectReferenceById(Id);
        }
    }
    /*void*/ DisposeJSObjectReferenceById(/*long*/ id)
    {
    }
}

class Microsoft_JSInterop_Implementation_JSObjectReference extends System_IDisposable(Microsoft_JSInterop_IJSObjectReference(object))
{
    /*JSRuntime*/ _jsRuntime = null;
    /*bool*/ _backingField_Disposed = null;
    /*bool*/ get Disposed()
    {
        return _backingField_Disposed;
    }
    /*bool*/ set Disposed(value)
    {
        _backingField_Disposed = value;
    }
    /*long*/ _backingField_Id = null;
    /*long*/ get Id()
    {
        return _backingField_Id;
    }
    constructor(/*JSRuntime*/ jsRuntime, /*long*/ id)
    {
        super();
        _jsRuntime = jsRuntime;
        Id = id;
    }
    /*Task<TValue>*/ InvokeAsync(TValue, /*string*/ identifier, /*object[]*/ args)
    {
        ThrowIfDisposed();
        return _jsRuntime.InvokeAsync(TValue, Id, identifier, JSCallType.FunctionCall, args);
    }
    /*Task<TValue>*/ InvokeAsync(TValue, /*string*/ identifier, /*CancellationToken*/ cancellationToken, /*object[]*/ args)
    {
        ThrowIfDisposed();
        return _jsRuntime.InvokeAsync(TValue, Id, identifier, JSCallType.FunctionCall, cancellationToken, args);
    }
    /*Task<IJSObjectReference>*/ InvokeNewAsync(/*string*/ identifier, /*object[]*/ args)
    {
        ThrowIfDisposed();
        return _jsRuntime.InvokeAsync(IJSObjectReference, Id, identifier, JSCallType.NewCall, args);
    }
    /*Task<IJSObjectReference>*/ InvokeNewAsync(/*string*/ identifier, /*CancellationToken*/ cancellationToken, /*object[]*/ args)
    {
        ThrowIfDisposed();
        return _jsRuntime.InvokeAsync(IJSObjectReference, Id, identifier, JSCallType.NewCall, cancellationToken, args);
    }
    /*Task<TValue>*/ GetValueAsync(TValue, /*string*/ identifier)
    {
        ThrowIfDisposed();
        return _jsRuntime.InvokeAsync(TValue, Id, identifier, JSCallType.GetValue, null);
    }
    /*Task<TValue>*/ GetValueAsync(TValue, /*string*/ identifier, /*CancellationToken*/ cancellationToken)
    {
        ThrowIfDisposed();
        return _jsRuntime.InvokeAsync(TValue, Id, identifier, JSCallType.GetValue, null);
    }
    /*Task*/ async SetValueAsync(TValue, /*string*/ identifier, /*TValue*/ value)
    {
        ThrowIfDisposed();
        await _jsRuntime.InvokeAsync(TValue, Id, identifier, JSCallType.SetValue, [ value ]);
    }
    /*Task*/ async SetValueAsync(TValue, /*string*/ identifier, /*TValue*/ value, /*CancellationToken*/ cancellationToken)
    {
        ThrowIfDisposed();
        await _jsRuntime.InvokeAsync(TValue, Id, identifier, JSCallType.SetValue, [ value ]);
    }
    /*void*/ async Dispose()
    {
        if (Disposed)
        {
            Disposed = true;
            await _jsRuntime.InvokeVoidAsync("DotNet.disposeJSObjectReferenceById", Id);
        }
    }
    /*void*/ ThrowIfDisposed()
    {
        if (Disposed)
        throw new ObjectDisposedException("disposed");
    }
}


class Microsoft_JSInterop_Implementation_JSStreamReference extends System_IDisposable(Microsoft_JSInterop_IJSStreamReference(Microsoft_JSInterop_Implementation_JSObjectReference))
{
    /*JSRuntime*/ _jsRuntime = null;
    /*long*/ _backingField_Length = null;
    /*long*/ get Length()
    {
        return _backingField_Length;
    }
    constructor(/*JSRuntime*/ jsRuntime, /*long*/ id, /*long*/ totalLength)
    {
        super(jsRuntime, id);
        if (totalLength <= 0)
        {
            throw new ArgumentOutOfRangeException(nameof(totalLength), totalLength, "Length must be a positive value.");
        }
        _jsRuntime = jsRuntime;
        Length = totalLength;
    }
    /*Task<Stream>*/ async OpenReadStreamAsync(/*long*/ maxAllowedSize, /*CancellationToken*/ cancellationToken)
    {
        if (Length > maxAllowedSize)
        {
            throw new ArgumentOutOfRangeException(nameof(maxAllowedSize), LengthmaxAllowedSize);
        }
        return await _jsRuntime.ReadJSDataAsStreamAsync(, Length, cancellationToken);
    }
}


class Microsoft_JSInterop_Infrastructure_DotNetDispatcher extends object
{
    constructor()
    {
        super();
    }
    /*string*/ DisposeDotNetObjectReferenceMethodName = "__Dispose";
    /*ConcurrentDictionary<AssemblyKey, IReadOnlyDictionary<string, (MethodInfo, Type[])>>*/ _cachedMethodsByAssembly = new ConcurrentDictionary_$2(AssemblyKey, IReadOnlyDictionary<string, (MethodInfo, Type[])>);
    /*ConcurrentDictionary<Type, IReadOnlyDictionary<string, (MethodInfo, Type[])>>*/ _cachedMethodsByType = new ConcurrentDictionary_$2(Type, IReadOnlyDictionary<string, (MethodInfo, Type[])>);
    /*ConcurrentDictionary<Type, Func<object, Task>>*/ _cachedConvertToTaskByType = new ConcurrentDictionary_$2(Type, Func<object, Task>);
    /*MethodInfo*/ _taskConverterMethodInfo = DotNetDispatcher.GetMethod(nameof(CreateValueTaskConverter), BindingFlags.NonPublic  | BindingFlags.Static);
    /*string*/ Invoke(/*JSRuntime*/ jsRuntime, /*DotNetInvocationInfo*/ invocationInfo, /*string*/ argsJson)
    {
        /*// This method doesn't need [JSInvokable] because the platform is responsible for having
            // some way to dispatch calls here. The logic inside here is the thing that checks whether
            // the targeted method has [JSInvokable]. It is not itself subject to that restriction,
            // because there would be nobody to police that. This method *is* the police.
            IDotNetObjectReference*/ let targetInstance = default;
        if (invocationInfo.DotNetObjectId  != default)
        {
            targetInstance = jsRuntime.GetObjectReference(invocationInfo.DotNetObjectId);
        }
        /*var*/ let syncResult = InvokeSynchronously(jsRuntime, invocationInfo, targetInstance, argsJson);
        if (syncResult == null)
        {
            return null;
        }
        return JsonSerializer.Serialize(syncResult, jsRuntime.JsonSerializerOptions);
    }
    /*void*/ BeginInvokeDotNet(/*JSRuntime*/ jsRuntime, /*DotNetInvocationInfo*/ invocationInfo, /*string*/ argsJson)
    {
        /*// This method doesn't need [JSInvokable] because the platform is responsible for having
            // some way to dispatch calls here. The logic inside here is the thing that checks whether
            // the targeted method has [JSInvokable]. It is not itself subject to that restriction,
            // because there would be nobody to police that. This method *is* the police.
            // Using ExceptionDispatchInfo here throughout because we want to always preserve
            // original stack traces.
            var*/ let callId = invocationInfo.CallId;
        /*object*/ let syncResult = null;
        /*//ExceptionDispatchInfo? syncException = null;
            Exception*/ let syncException = null;
        /*IDotNetObjectReference*/ let targetInstance = null;
        {
            if (invocationInfo.DotNetObjectId  != default)
            {
                targetInstance = jsRuntime.GetObjectReference(invocationInfo.DotNetObjectId);
            }
            syncResult = InvokeSynchronously(jsRuntime, invocationInfo, targetInstance, argsJson);
        }
Exception        {
            syncException = ex;
        }
        if (callId == null)
        {
            return ;
        }
        else if (syncException != null)
        {
            // Threw synchronously, let's respond.
                jsRuntime.EndInvokeDotNet(invocationInfo, new DotNetInvocationResult(syncException/*.SourceException*/, "InvocationFailure"));
        }
        else if (syncResult instanceof Task, task = syncResult)
        {
            // Returned a task - we need to continue that task and then report an exception
                // or return the value.
                task.ContinueWith(function(/**/ t)
            {
EndInvokeDotNetAfterTask(t, jsRuntime, invocationInfo)            });
        }
        else if (syncResult instanceof Task, TaskResult = syncResult)
        {
            TaskResult.ContinueWith(function(/**/ t)
            {
EndInvokeDotNetAfterTask(t, jsRuntime, invocationInfo)            });
        }
        else if (syncResult != null && syncResult.GetType().IsGenericType
 && syncResult.GetType().GetGenericTypeDefinition() == Task_$1)
        {
            /*// It's a Task<T>. We'll coerce it to a Task so that we can attach a continuation.
                var*/ let innerTask = GetTaskByType(syncResultGetType().GetGenericArguments()0, syncResult);
            innerTask.ContinueWith(function(/**/ t)
            {
EndInvokeDotNetAfterTask(t, jsRuntime, invocationInfo)            });
        }
        else 
        {
            /*var*/ let syncResultJson = JsonSerializer.Serialize(syncResult, jsRuntime.JsonSerializerOptions);
            /*var*/ let dispatchResult = new DotNetInvocationResult(syncResultJson);
            jsRuntime.EndInvokeDotNet(invocationInfo, dispatchResult);
        }
    }
    /*void*/ EndInvokeDotNetAfterTask(/*Task*/ task, /*JSRuntime*/ jsRuntime, /*DotNetInvocationInfo*/ invocationInfo)
    {
        if (task.Exception  != null)
        {
            /*var*/ let exceptionDispatchInfo = task.Exception.GetBaseException();
            /*var*/ let dispatchResult = new DotNetInvocationResult(exceptionDispatchInfo/*.SourceException*/, "InvocationFailure");
            jsRuntime.EndInvokeDotNet(invocationInfo, dispatchResult);
        }
        /*var*/ let result = TaskGenericsUtil.GetTaskResult(task);
        /*var*/ let resultJson = JsonSerializer.Serialize(result, jsRuntime.JsonSerializerOptions);
        jsRuntime.EndInvokeDotNet(invocationInfo, new DotNetInvocationResult(resultJson));
    }
    /*object*/ InvokeSynchronously(/*JSRuntime*/ jsRuntime, /*DotNetInvocationInfo*/ callInfo, /*IDotNetObjectReference*/ objectReference, /*string*/ argsJson)
    {
        /*var*/ let assemblyName = callInfo.AssemblyName;
        /*var*/ let methodIdentifier = callInfo.MethodIdentifier;
        /*AssemblyKey*/ let assemblyKey;
        /*MethodInfo*/ let methodInfo;
        /*Type[]*/ let parameterTypes;
        if (objectReference)
        {
            assemblyKey = new AssemblyKey(assemblyName);
            methodInfoparameterTypes = GetCachedMethodInfo(assemblyKey, methodIdentifier);
        }
        else 
        {
            if (assemblyName != null)
            {
                throw new ArgumentException(nameof(assemblyName)assemblyName);
            }
            if (.Equals(DisposeDotNetObjectReferenceMethodName, methodIdentifier, StringComparison.Ordinal))
            {
                // The client executed dotNetObjectReference.dispose(). Dispose the reference and exit.
                    objectReference.Dispose();
                return default;
            }
            methodInfoparameterTypes = GetCachedMethodInfo(objectReference, methodIdentifier);
        }
        /*var*/ let suppliedArgs = ParseArguments(jsRuntime, methodIdentifier, argsJson, parameterTypes);
        {
            return methodInfo.Invoke(objectReferenceValue, suppliedArgs);
        }
TargetInvocationException        {
            if (tie.InnerException  != null)
            {
                throw tie.InnerException;
            }
            throw ;
        }
        {
            // We require the invoked method to retrieve any pending byte arrays synchronously. If we didn't,
                // we wouldn't be able to have overlapping async calls. As a way to enforce this, we clear the
                // pending byte arrays synchronously after the call. This also helps because the recipient isn't
                // required to consume all the pending byte arrays, since it's legal for the JS data model to contain
                // more data than the .NET data model (like overposting)
                jsRuntime.ByteArraysToBeRevived.Clear();
        }
    }
    /*object[]*/ ParseArguments(/*JSRuntime*/ jsRuntime, /*string*/ methodIdentifier, /*string*/ arguments, /*Type[]*/ parameterTypes)
    {
        if (parameterTypes.Length  == 0)
        {
            return Array.Empty(object);
        }
        /*var*/ let count = Encoding.UTF8.GetByteCount(arguments);
        {
            /*var*/ let datas = JsonSerializer.DeserializeImpl(arguments).As(object[]);
            /*var*/ let suppliedArgs = new Array(parameterTypes.Length);
            /*var*/ let index = 0;
            while(index < parameterTypes.Length)
            {
                /*var*/ let parameterType = parameterTypesindex;
                suppliedArgsindex = JsonSerializer.Convert(datasindex, parameterType);
                index++;
            }
            if (index < parameterTypes.Length)
            {
                throw new ArgumentException(methodIdentifierparameterTypes.Lengthindex);
            }
            return suppliedArgs;
        }
        {
        }
    }
    /*void*/ EndInvokeJS(/*JSRuntime*/ jsRuntime, /*string*/ arguments)
    {
        /*var*/ let data = JsonSerializer.DeserializeImpl(arguments).As(object[]);
        /*var*/ let taskId = data0.As(long);
        /*var*/ let success = data1.As(bool);
        jsRuntime.EndInvokeJS(taskId, success, data2);
    }
    /*void*/ ReceiveByteArray(/*JSRuntime*/ jsRuntime, /*int*/ id, /*byte[]*/ data)
    {
        jsRuntime.ReceiveByteArray(id, data);
    }
    /*(MethodInfo, Type[])*/ GetCachedMethodInfo(/*AssemblyKey*/ assemblyKey, /*string*/ methodIdentifier)
    {
        ArgumentExceptionExtension.ThrowIfNullOrWhiteSpace(assemblyKey.AssemblyName);
        ArgumentExceptionExtension.ThrowIfNullOrWhiteSpace(methodIdentifier);
        /*var*/ let assemblyMethods = _cachedMethodsByAssembly.GetOrAdd(assemblyKey, ScanAssemblyForCallableMethods);
        let result = null;
        let $v = { value: set(value){ result = value; } };
        if (assemblyMethods.TryGetValue(methodIdentifier, $v))
        {
            return result;
        }
        else 
        {
            throw new ArgumentException(assemblyKey.AssemblyNamenameof(JSInvokableAttribute)methodIdentifier);
        }
    }
    /*Task*/ GetTaskByType(/*Type*/ type, /*object*/ obj)
    {
        /*var*/ let converterDelegate = _cachedConvertToTaskByType.GetOrAdd(type, function(/*Type*/ t, /*MethodInfo*/ taskConverterMethodInfo)
        {
            return Func_$2taskConverterMethodInfo.MakeGenericMethod(t).CreateDelegate/*<Func<object, Task>>*/();
        }, _taskConverterMethodInfo);
        return converterDelegate.Invoke(obj);
    }
    /*Task*/ CreateValueTaskConverter(T, /*object*/ result)
    {
        Task_$1result;
    }
    /*(MethodInfo methodInfo, Type[] parameterTypes)*/ GetCachedMethodInfo(/*IDotNetObjectReference*/ objectReference, /*string*/ methodIdentifier)
    {
        /*var*/ let type = objectReference.Value.GetType();
        /*// Suppressed with "pragma warning disable" in addition to WarningSuppressions.xml so ILLink Roslyn Anayzer doesn't report the warning.
#pragma warning disable IL2111 // Method with parameters or return value with `DynamicallyAccessedMembersAttribute` is accessed via reflection. Trimmer can't guarantee availability of the requirements of the method.
            var*/ let assemblyMethods = _cachedMethodsByType.GetOrAdd(type, ScanTypeForCallableMethods);
        let result = null;
        let $v = { value: set(value){ result = value; } };
        if (assemblyMethods.TryGetValue(methodIdentifier, $v))
        {
            return result;
        }
        else 
        {
            throw new ArgumentException(type.Namenameof(JSInvokableAttribute)methodIdentifier);
        }
Dictionary_$2Type        {
            /*var*/ let iresult = new Dictionary_$2(string, (MethodInfo, Type[]), StringComparer.Ordinal);
            BlazorJs.forEach(itype.GetMethods(BindingFlags.Instance  | BindingFlags.Public), function(method, $_i)
            {
                if (method.ContainsGenericParameters  || method.IsDefined(JSInvokableAttribute, { inherit : false }))
                {
                }
                BlazorJs.forEach(method.GetCustomAttributes(JSInvokableAttribute, false), function(attr, $_i)
                {
                    /*var*/ let identifier = attr.Identifier  ?? method.Name;
                    /*var*/ let parameterTypes = GetParameterTypes(method);
                    if (iresult.ContainsKey(identifier))
                    {
                        throw new InvalidOperationException(itype.Name + identifier + "type must have different identifiers. You can pass a custom identifier as a parameter to " + );
                    }
                    iresult.Add(identifier, methodparameterTypes);
                });
            });
            return iresult;
        }
    }
    /*Dictionary<string, (MethodInfo, Type[])>*/ ScanAssemblyForCallableMethods(/*AssemblyKey*/ assemblyKey)
    {
        /*// TODO: Consider looking first for assembly-level attributes (i.e., if there are any,
            // only use those) to avoid scanning, especially for framework assemblies.
            var*/ let result = new Dictionary_$2(string, (MethodInfo, Type[]), StringComparer.Ordinal);
        /*var*/ let exportedTypes = GetRequiredLoadedAssembly(assemblyKey).GetTypes();
        BlazorJs.forEach(exportedTypes, function(type, $_i)
        {
            BlazorJs.forEach(type.GetMethods(BindingFlags.Public  | BindingFlags.Static), function(method, $_i)
            {
                if (method.ContainsGenericParameters  || method.IsDefined(JSInvokableAttribute, { inherit : false }))
                {
                }
                BlazorJs.forEach(method.GetCustomAttributes(JSInvokableAttribute, false), function(attr, $_i)
                {
                    /*var*/ let identifier = attr.Identifier  ?? method.Name;
                    /*var*/ let parameterTypes = GetParameterTypes(method);
                    if (result.ContainsKey(identifier))
                    {
                        throw new InvalidOperationException(assemblyKey.AssemblyName + identifier +  + );
                    }
                    result.Add(identifier, methodparameterTypes);
                });
            });
        });
        return result;
    }
    /*Type[]*/ GetParameterTypes(/*MethodInfo*/ method)
    {
        /*var*/ let parameters = method.GetParameters();
        if (parameters.Length  == 0)
        {
            return Array.Empty(Type);
        }
        /*var*/ let parameterTypes = new Array(parameters.Length);
        for(/*var*/ let i = 0; i < parameters.Length; i++)
        {
            parameterTypesi = parametersi.ParameterType;
        });
        return parameterTypes;
    }
    /*Assembly*/ GetRequiredLoadedAssembly(/*AssemblyKey*/ assemblyKey)
    {
        /*// We don't want to load assemblies on demand here, because we don't necessarily trust
            // "assemblyName" to be something the developer intended to load. So only pick from the
            // set of already-loaded assemblies.
            // In some edge cases this might force developers to explicitly call something on the
            // target assembly (from .NET) before they can invoke its allowed methods from JS.

            // Using the last to workaround https://github.com/dotnet/arcade/issues/2816.
            // In most ordinary scenarios, we wouldn't have two instances of the same Assembly in the AppDomain
            // so this doesn't change the outcome.
            Assembly*/ let assembly = null;
        BlazorJs.forEach(AppDomain.CurrentDomain.GetAssemblies(), function(a, $_i)
        {
            if (new AssemblyKey(a).Equals(assemblyKey))
            {
                assembly = a;
            }
        });
        return assembly ??         throw new ArgumentException(assemblyKey.AssemblyName);
;
    }
    class Microsoft_JSInterop_Infrastructure_MetadataUpdateHandler extends object
    {
        constructor()
        {
            super();
        }
        /*void*/ ClearCache(/*Type[]*/ _)
        {
            _cachedMethodsByAssembly.Clear();
            _cachedMethodsByType.Clear();
            _cachedConvertToTaskByType.Clear();
        }
    }
    class Microsoft_JSInterop_Infrastructure_AssemblyKey extends H5_IH5Class(System_IEquatable<Microsoft_JSInterop_Infrastructure_DotNetDispatcher_AssemblyKey>(System_ValueType))
    {
        constructor(/*Assembly*/ assembly)
        {
            super();
            Assembly = assembly;
            AssemblyName = assembly.GetName().Name;
        }
        constructor(/*string*/ assemblyName)
        {
            super();
            Assembly = null;
            AssemblyName = assemblyName;
        }
        /*Assembly*/ _backingField_Assembly = null;
        /*Assembly*/ get Assembly()
        {
            return _backingField_Assembly;
        }
        /*string*/ _backingField_AssemblyName = null;
        /*string*/ get AssemblyName()
        {
            return _backingField_AssemblyName;
        }
        /*bool*/ Equals(/*AssemblyKey*/ other)
        {
            if (Assembly != null && other.Assembly  != null)
            {
                return Assembly == other.Assembly;
            }
            return AssemblyName.Equals(other.AssemblyName, StringComparison.Ordinal);
        }
        /*int*/ GetHashCode()
        {
            StringComparer.Ordinal.GetHashCode(AssemblyName);
        }
    }
}

class Microsoft_JSInterop_Infrastructure_DotNetInvocationInfo extends System_ValueType
{
    constructor(/*string*/ assemblyName, /*string*/ methodIdentifier, /*long*/ dotNetObjectId, /*string*/ callId)
    {
        super();
        CallId = callId;
        AssemblyName = assemblyName;
        MethodIdentifier = methodIdentifier;
        DotNetObjectId = dotNetObjectId;
    }
    /*string*/ _backingField_AssemblyName = null;
    /*string*/ get AssemblyName()
    {
        return _backingField_AssemblyName;
    }
    /*string*/ _backingField_MethodIdentifier = null;
    /*string*/ get MethodIdentifier()
    {
        return _backingField_MethodIdentifier;
    }
    /*long*/ _backingField_DotNetObjectId = null;
    /*long*/ get DotNetObjectId()
    {
        return _backingField_DotNetObjectId;
    }
    /*string*/ _backingField_CallId = null;
    /*string*/ get CallId()
    {
        return _backingField_CallId;
    }
}

class Microsoft_JSInterop_Infrastructure_DotNetInvocationResult extends System_ValueType
{
    constructor(/*Exception*/ exception, /*string*/ errorKind)
    {
        super();
        ResultJson = default;
        Exception = exception ??         throw new ArgumentNullException(nameof(exception));
;
        ErrorKind = errorKind;
        Success = false;
    }
    constructor(/*string*/ resultJson)
    {
        super();
        ResultJson = resultJson;
        Exception = default;
        ErrorKind = default;
        Success = true;
    }
    /*Exception*/ _backingField_Exception = null;
    /*Exception*/ get Exception()
    {
        return _backingField_Exception;
    }
    /*string*/ _backingField_ErrorKind = null;
    /*string*/ get ErrorKind()
    {
        return _backingField_ErrorKind;
    }
    /*string*/ _backingField_ResultJson = null;
    /*string*/ get ResultJson()
    {
        return _backingField_ResultJson;
    }
    /*bool*/ _backingField_Success = null;
    /*bool*/ get Success()
    {
        return _backingField_Success;
    }
}




const Microsoft_JSInterop_Infrastructure_IDotNetObjectReference = (Base) => class extends Base
{
    /*object*/ _backingField_Value = null;
    /*object*/ get Value()
    {
        return _backingField_Value;
    }
}

const Microsoft_JSInterop_Infrastructure_IJSVoidResult = (Base) => class extends Base
{
}

 = 1 = 2 = 3 = 4
class Microsoft_JSInterop_Infrastructure_JSInvocationInfo extends System_ValueType
{
    constructor()
    {
        super();
    }
    /*string*/ _argsJson = null;
    /*long*/ _backingField_AsyncHandle = null;
    /*long*/ get AsyncHandle()
    {
        return _backingField_AsyncHandle;
    }
    /*long*/ set AsyncHandle(value)
    {
        _backingField_AsyncHandle = value;
    }
    /*long*/ _backingField_TargetInstanceId = null;
    /*long*/ get TargetInstanceId()
    {
        return _backingField_TargetInstanceId;
    }
    /*long*/ set TargetInstanceId(value)
    {
        _backingField_TargetInstanceId = value;
    }
    /*string*/ _backingField_Identifier = null;
    /*string*/ get Identifier()
    {
        return _backingField_Identifier;
    }
    /*string*/ set Identifier(value)
    {
        _backingField_Identifier = value;
    }
    /*JSCallType*/ _backingField_CallType = null;
    /*JSCallType*/ get CallType()
    {
        return _backingField_CallType;
    }
    /*JSCallType*/ set CallType(value)
    {
        _backingField_CallType = value;
    }
    /*JSCallResultType*/ _backingField_ResultType = null;
    /*JSCallResultType*/ get ResultType()
    {
        return _backingField_ResultType;
    }
    /*JSCallResultType*/ set ResultType(value)
    {
        _backingField_ResultType = value;
    }
    /*string*/ get ArgsJson()
    {
        return _argsJson ?? "[]";
    }
    /*string*/ set ArgsJson(value)
    {
        _argsJson = value;
    }
}



class Microsoft_JSInterop_Infrastructure_TaskGenericsUtil extends object
{
    constructor()
    {
        super();
    }
    /*ConcurrentDictionary<Type, ITaskResultGetter>*/ _cachedResultGetters = new ConcurrentDictionary_$2(Type, ITaskResultGetter);
    /*ConcurrentDictionary<Type, ITcsResultSetter>*/ _cachedResultSetters = new ConcurrentDictionary_$2(Type, ITcsResultSetter);
    /*void*/ SetTaskCompletionSourceResult(/*object*/ taskCompletionSource, /*object*/ result)
    {
        CreateResultSetter(taskCompletionSource).SetResult(taskCompletionSource, result);
    }
    /*void*/ SetTaskCompletionSourceException(/*object*/ taskCompletionSource, /*Exception*/ exception)
    {
        CreateResultSetter(taskCompletionSource).SetException(taskCompletionSource, exception);
    }
    /*Type*/ GetTaskCompletionSourceResultType(/*object*/ taskCompletionSource)
    {
        CreateResultSetter(taskCompletionSource).ResultType;
    }
    /*object*/ GetTaskResult(/*Task*/ task)
    {
        /*var*/ let getter = _cachedResultGetters.GetOrAdd(task.GetType(), function(/**/ taskInstanceType)
        {
            {
                /*var*/ let resultType = GetTaskResultType(taskInstanceType);
                return resultType == nullnew VoidTaskResultGetter()ITaskResultGetterActivator.CreateInstance(TaskResultGetter_$1.MakeGenericType(resultType));
            }
        });
        return getter.GetResult(task);
    }
    /*Type*/ GetTaskResultType(/*Type*/ taskType)
    {
        while(taskType != Task && taskType.IsGenericType  || taskType.GetGenericTypeDefinition() != Task_$1)
        {
            taskType = taskType.BaseType
 ??             throw new ArgumentException(taskType.FullNameTask.FullName);
;
        }
        return taskType.IsGenericType
taskType.GetGenericArguments()0null;
    }
    const Microsoft_JSInterop_Infrastructure_ITcsResultSetter = (Base) => class extends Base
    {
        /*Type*/ _backingField_ResultType = null;
        /*Type*/ get ResultType()
        {
            return _backingField_ResultType;
        }
    }
    const Microsoft_JSInterop_Infrastructure_ITaskResultGetter = (Base) => class extends Base
    {
    }
    const Microsoft_JSInterop_Infrastructure_TaskResultGetter$_1 = (T) => class extends Microsoft_JSInterop_Infrastructure_TaskGenericsUtil_ITaskResultGetter(object)
    {
        constructor()
        {
            super();
            T = $_T;
        }
        /*object*/ GetResult(/*Task*/ task)
        {
            Task_$1task.Result;
        }
    }
    class Microsoft_JSInterop_Infrastructure_VoidTaskResultGetter extends Microsoft_JSInterop_Infrastructure_TaskGenericsUtil_ITaskResultGetter(object)
    {
        constructor()
        {
            super();
        }
        /*object*/ GetResult(/*Task*/ task)
        {
            task.Wait();
            return null;
        }
    }
    const Microsoft_JSInterop_Infrastructure_TcsResultSetter$_1 = (T) => class extends Microsoft_JSInterop_Infrastructure_TaskGenericsUtil_ITcsResultSetter(object)
    {
        constructor()
        {
            super();
            T = $_T;
        }
        /*Type*/ get ResultType()
        {
            return T;
        }
        /*void*/ SetResult(/*object*/ tcs, /*object*/ result)
        {
            /*var*/ let typedTcs = TaskCompletionSource_$1tcs;
            /*// If necessary, attempt a cast
                var*/ let typedResult = result instanceof T, resultT = resultresultTresult == null && T.IsGenericType  && T.GetGenericTypeDefinition() == Nullable_$1TTConvert.ChangeType(result, T, CultureInfo.InvariantCulture);
            typedTcs.SetResult(typedResult);
        }
        /*void*/ SetException(/*object*/ tcs, /*Exception*/ exception)
        {
            /*var*/ let typedTcs = TaskCompletionSource_$1tcs;
            typedTcs.SetException(exception);
        }
    }
    /*ITcsResultSetter*/ CreateResultSetter(/*object*/ taskCompletionSource)
    {
        return _cachedResultSetters.GetOrAdd(taskCompletionSource.GetType(), function(/**/ tcsType)
        {
            {
                /*var*/ let resultType = tcsType.GetGenericArguments()0;
                return ITcsResultSetterActivator.CreateInstance(TcsResultSetter_$1.MakeGenericType(resultType));
            }
        });
    }
}

class System_ComponentModel_DataAnnotations_Schema_ColumnAttribute extends System_Attribute
{
    /*string*/ _name = null;
    /*string*/ _typeName = null;
    /*int*/ _order = 1;
    constructor()
    {
        super();
    }
    constructor(/*string*/ name)
    {
        super();
        if (.IsNullOrWhiteSpace(name))
        {
            throw new ArgumentException("ArgumentIsNullOrWhitespace", nameof(name));
        }
        _name = name;
    }
    /*string*/ get Name()
    {
        return _name;
    }
    /*int*/ get Order()
    {
        return _order;
    }
    /*int*/ set Order(value)
    {
        if (value < 0)
        {
            throw new ArgumentOutOfRangeException("value");
        }
        _order = value;
    }
    /*string*/ get TypeName()
    {
        return _typeName;
    }
    /*string*/ set TypeName(value)
    {
        if (.IsNullOrWhiteSpace(value))
        {
            throw new ArgumentException("ArgumentIsNullOrWhitespace", nameof(value));
        }
        _typeName = value;
    }
}

class System_ComponentModel_DataAnnotations_Schema_ComplexTypeAttribute extends System_Attribute
{
    constructor()
    {
        super();
    }
}

class System_ComponentModel_DataAnnotations_Schema_DatabaseGeneratedAttribute extends System_Attribute
{
    constructor(/*DatabaseGeneratedOption*/ databaseGeneratedOption)
    {
        super();
        if (Enum.IsDefined(DatabaseGeneratedOption, databaseGeneratedOption))
        {
            throw new ArgumentOutOfRangeException("databaseGeneratedOption");
        }
        DatabaseGeneratedOption = databaseGeneratedOption;
    }
    /*DatabaseGeneratedOption*/ _backingField_DatabaseGeneratedOption = null;
    /*DatabaseGeneratedOption*/ get DatabaseGeneratedOption()
    {
        return _backingField_DatabaseGeneratedOption;
    }
    /*DatabaseGeneratedOption*/ set DatabaseGeneratedOption(value)
    {
        _backingField_DatabaseGeneratedOption = value;
    }
}


class System_ComponentModel_DataAnnotations_Schema_ForeignKeyAttribute extends System_Attribute
{
    /*string*/ _name = null;
    constructor(/*string*/ name)
    {
        super();
        if (.IsNullOrWhiteSpace(name))
        {
            throw new ArgumentException("ArgumentIsNullOrWhitespace", nameof(name));
        }
        _name = name;
    }
    /*string*/ get Name()
    {
        return _name;
    }
}

class System_ComponentModel_DataAnnotations_Schema_InversePropertyAttribute extends System_Attribute
{
    /*string*/ _property = null;
    constructor(/*string*/ property)
    {
        super();
        if (.IsNullOrWhiteSpace(property))
        {
            throw new ArgumentException("ArgumentIsNullOrWhitespace", nameof(property));
        }
        _property = property;
    }
    /*string*/ get Property()
    {
        return _property;
    }
}

class System_ComponentModel_DataAnnotations_Schema_NotMappedAttribute extends System_Attribute
{
    constructor()
    {
        super();
    }
}

class System_ComponentModel_DataAnnotations_Schema_TableAttribute extends System_Attribute
{
    /*string*/ _name = null;
    /*string*/ _schema = null;
    constructor(/*string*/ name)
    {
        super();
        if (.IsNullOrWhiteSpace(name))
        {
            throw new ArgumentException("ArgumentIsNullOrWhitespace", nameof(name));
        }
        _name = name;
    }
    /*string*/ get Name()
    {
        return _name;
    }
    /*string*/ get Schema()
    {
        return _schema;
    }
    /*string*/ set Schema(value)
    {
        if (.IsNullOrWhiteSpace(value))
        {
            throw new ArgumentException("ArgumentIsNullOrWhitespace", nameof(value));
        }
        _schema = value;
    }
}

class System_Net_Http_BrowserHttpContent extends System_Net_Http_HttpContent
{
    /*byte[]*/ _data = null;
    /*int*/ _length = 1;
    /*Response*/ _response = null;
    constructor(/*Response*/ response)
    {
        super();
        _response = response;
    }
    /*Task<byte[]>*/ async GetResponseData(/*CancellationToken*/ cancellationToken)
    {
        if (_data != null)
        {
            return _data;
        }
        /*ArrayBuffer*/ let buffer = await Task.FromPromise(ArrayBuffer[], _response.arrayBuffer().As(IPromise), null)0;
        _length = buffer.byteLength;
        _data = new Array(_length);
        return new Uint8Array(buffer).As(byte[]);
    }
    /*Task<Stream>*/ async CreateContentReadStreamAsync()
    {
        /*byte[]*/ let data = await GetResponseData(CancellationToken.None);
        return new MemoryStream(data, { writable : false });
    }
    /*Task*/ SerializeToStreamAsync(/*Stream*/ stream)
    {
        SerializeToStreamAsync(stream, CancellationToken.None);
    }
    /*Task*/ async SerializeToStreamAsync(/*Stream*/ stream, /*CancellationToken*/ cancellationToken)
    {
        if (stream == null)
        throw new ArgumentNullException(nameof(stream));
        /*byte[]*/ let data = await GetResponseData(cancellationToken);
        await stream.WriteAsync(data, cancellationToken);
    }
    /*bool*/ TryComputeLength(/*long*/ length)
    {
        if (_length != 1)
        {
            length = _length;
            return true;
        }
        length = 0;
        return false;
    }
}


class System_Net_Http_BrowserHttpHandler extends System_Net_Http_HttpMessageHandler
{
    constructor()
    {
        super();
    }
    /*bool*/ _allowAutoRedirect = true;
    /*bool*/ _isAllowAutoRedirectTouched = null;
    /*bool*/ get AllowAutoRedirect()
    {
        return _allowAutoRedirect;
    }
    /*bool*/ set AllowAutoRedirect(value)
    {
        _allowAutoRedirect = value;
        _isAllowAutoRedirectTouched = true;
    }
    /*bool*/ SupportsAutomaticDecompression = false;
    /*bool*/ SupportsProxy = false;
    /*bool*/ SupportsRedirectConfiguration = true;
    /*Dictionary<string, object>*/ _properties = null;
    /*IDictionary<string, object>*/ get Properties()
    {
        return _properties = _properties ?? new Dictionary_$2(string, object);
    }
    /*HttpResponseMessage*/ Send(/*HttpRequestMessage*/ request, /*CancellationToken*/ cancellationToken)
    {
        throw new InvalidOperationException();
    }
    /*Request*/ CreateFetchRequest(/*HttpRequestMessage*/ mrequest)
    {
        /*int*/ let headerCount = mrequest.Headers.Count  + mrequest.ContentHeaders.Count  ?? 0;
        /*var*/ let headerNames = new List_$1(string, headerCount);
        /*var*/ let headerValues = new List_$1(string, headerCount);
        BlazorJs.forEach(mrequest.Headers, function(header, $_i)
        {
            BlazorJs.forEach(header.Value, function(value, $_i)
            {
                headerNames.Add(header.Key);
                headerValues.Add(value);
            });
        });
        if (mrequest.Content  != null)
        {
            BlazorJs.forEach(mrequest.Content.Headers, function(header, $_i)
            {
                BlazorJs.forEach(header.Value, function(value, $_i)
                {
                    headerNames.Add(header.Key);
                    headerValues.Add(value);
                });
            });
        }
        /*var*/ let stream = mrequest.ContentReadAsStream();
        /*byte[]*/ let bts = stream != nullnew Array(stream.Length)null;
        streamRead(bts, 0, bts.Length);
        /*var*/ let init = new RequestInit()method = mrequest.Method.Method;
        if (headerNames.Count  > 0)
        {
            init.headers  = HeadersInit.Create(headerNames.ToArray()headerValues.ToArray());
        }
        if (bts != null)
        {
            init.body  = Int8Array.from(ArrayLike_$1bts);
        }
        return new Request(mrequest.RequestUri.ToString(), init);
    }
    /*HttpResponseMessage*/ ConvertResponse(/*HttpRequestMessage*/ mrequest, /*Response*/ mresponse)
    {
        {
            /*string*/ let responseType = mresponse.type;
            /*int*/ let status = mresponse.status;
            /*HttpResponseMessage*/ let responseMessage = new HttpResponseMessage(HttpStatusCodestatus);
            responseMessage.RequestMessage  = mrequest;
            if (responseType == "opaqueredirect")
            {
                // Here we will set the ReasonPhrase so that it can be evaluated later.
                    // We do not have a status code but this will signal some type of what happened
                    // after interrogating the status code for success or not i.e. IsSuccessStatusCode
                    //
                    // https://developer.mozilla.org/en-US/docs/Web/API/Response/type
                    // opaqueredirect: The fetch request was made with redirect: "manual".
                    // The Response's status is 0, headers are empty, body is null and trailer is empty.
                    responseMessage.SetReasonPhraseWithoutValidation(responseType);
            }
            /*bool*/ let streamingResponseEnabled = false;
            //if (BrowserHttpInterop.SupportsStreamingResponse())
                //{
                //    _request.Options.TryGetValue(EnableStreamingResponse, out streamingResponseEnabled);
                //}

                responseMessage.Content  = streamingResponseEnablednew StreamContent(new BrowserHttpReadStream(mresponse))HttpContentnew BrowserHttpContent(mresponse);
            mresponse.headers.forEach(function()
            {
            });
            return responseMessage;
        }
    }
    /*Task<HttpResponseMessage>*/ async SendAsync(/*HttpRequestMessage*/ request, /*CancellationToken*/ cancellationToken)
    {
        /*bool?*/ let allowAutoRedirect = _isAllowAutoRedirectTouchedAllowAutoRedirectnull;
        if (request == null)
        throw new ArgumentNullException(nameof(request));
        if (request.RequestUri  == null)
        throw new ArgumentNullException(nameof(request.RequestUri));
        /*//JSObject httpController = BrowserHttpInterop.CreateController();
            //CancellationTokenRegistration abortRegistration = cancellationToken.Register(static s =>
            //{
            //    JSObject _httpController = (JSObject)s!;

            //    if (!_httpController.IsDisposed)
            //    {
            //        BrowserHttpInterop.Abort(_httpController);
            //    }
            //}, httpController);


            //_jsController = httpController;
            //_abortRegistration = abortRegistration;

            var*/ let uri = request.RequestUri.ToString();
        //bool hasFetchOptions = request.Options.TryGetValue(FetchOptions, out IDictionary<string, object> fetchOptions);
            //int optionCount = 1 + (allowAutoRedirect.HasValue ? 1 : 0) + (hasFetchOptions && fetchOptions != null ? fetchOptions.Count : 0);
            //int optionIndex = 0;

            //// note there could be more values for each header name and so this is just name count

            //_optionNames = new string[optionCount];
            //_optionValues = new object[optionCount];

            //_optionNames[optionIndex] = "method";
            //_optionValues[optionIndex] = request.Method.Method;
            //optionIndex++;
            //if (allowAutoRedirect.HasValue)
            //{
            //    _optionNames[optionIndex] = "redirect";
            //    _optionValues[optionIndex] = allowAutoRedirect.Value ? "follow" : "manual";
            //    optionIndex++;
            //}

            //if (hasFetchOptions && fetchOptions != null)
            //{
            //    foreach (KeyValuePair<string, object> item in fetchOptions)
            //    {
            //        _optionNames[optionIndex] = item.Key;
            //        _optionValues[optionIndex] = item.Value;
            //        optionIndex++;
            //    }
            //}

            CancellationHelper.ThrowIfCancellationRequested(cancellationToken);
        {
            /*var*/ let promise = fetch(CreateFetchRequest(request));
            /*var*/ let response = await Task.FromPromise(Response[], promise.As(IPromise), null);
            return ConvertResponse(request, response0);
        }
        {
            //writeStream?.Dispose();
                Dispose();
        }
    }
    /*void*/ ThrowIfDisposed()
    {
    }
}

class System_Net_Http_BrowserHttpReadStream extends System_IO_Stream
{
    /*Response*/ _response = null;
    constructor(/*Response*/ response)
    {
        super();
        _response = response;
    }
    /*int*/ Read(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count)
    {
        return 0;
    }
    /*bool*/ get CanRead()
    {
        return true;
    }
    /*bool*/ get CanSeek()
    {
        return false;
    }
    /*bool*/ get CanWrite()
    {
        return false;
    }
    /*void*/ Flush()
    {
    }
    /*long*/ get Position()
    {
        return         throw new NotSupportedException();
;
    }
    /*long*/ set Position(value)
    {
                throw new NotSupportedException();
;
    }
    /*long*/ get Length()
    {
        return         throw new NotSupportedException();
;
    }
    /*long*/ Seek(/*long*/ offset, /*SeekOrigin*/ origin)
    {
        throw new NotSupportedException();
    }
    /*void*/ SetLength(/*long*/ value)
    {
        throw new NotSupportedException();
    }
    /*void*/ Write(/*byte[]*/ buffer, /*int*/ offset, /*int*/ count)
    {
        throw new NotSupportedException();
    }
}


class System_Net_Http_Headers_AltSvcHeaderParser extends System_Net_Http_Headers_BaseHeaderParser
{
    /*long*/ DefaultMaxAgeTicks = 24 * TimeSpan.TicksPerHour;
    /*AltSvcHeaderParser*/ _backingField_Parser = null;
    /*AltSvcHeaderParser*/ get Parser()
    {
        return _backingField_Parser;
    }
    constructor()
    {
        super(supportsMultipleValues : true);
    }
    /*int*/ GetParsedValueLength(/*string*/ value, /*int*/ startIndex, /*object*/ storeValue, /*object*/ parsedValue)
    {
        Debug.Assert(startIndex >= 0);
        Debug.Assert(startIndex < value.Length);
        if (.IsNullOrEmpty(value))
        {
            parsedValue = null;
            return 0;
        }
        /*int*/ let idx = startIndex;
        let alpnProtocolName = null;
        let $v = { value: set(value){ alpnProtocolName = value; } };
        let alpnProtocolNameLength = null;
        let $v = { value: set(value){ alpnProtocolNameLength = value; } };
        if (TryReadPercentEncodedAlpnProtocolName(value, idx, $v, $v))
        {
            parsedValue = null;
            return 0;
        }
        idx += alpnProtocolNameLength;
        if (alpnProtocolName == "clear")
        {
            if (idx != value.Length)
            {
                // Clear has no parameters and should be the only Alt-Svc value present, so there should be nothing after it.
                    parsedValue = null;
                return 0;
            }
            parsedValue = AltSvcHeaderValue.Clear;
            return idx - startIndex;
        }
        if (idx + 1 >= value.Length  || valueidx++ != '=')
        {
            parsedValue = null;
            return 0;
        }
        let altAuthorityHost = null;
        let $v = { value: set(value){ altAuthorityHost = value; } };
        let altAuthorityPort = null;
        let $v = { value: set(value){ altAuthorityPort = value; } };
        let altAuthorityLength = null;
        let $v = { value: set(value){ altAuthorityLength = value; } };
        if (TryReadQuotedAltAuthority(value, idx, $v, $v, $v))
        {
            parsedValue = null;
            return 0;
        }
        idx += altAuthorityLength;
        /*// Parse parameters: *( OWS ";" OWS parameter )
            int?*/ let maxAge = null;
        /*bool*/ let persist = false;
        while(idx < value.Length)
        {
            while(idx < value.Length  && IsOptionalWhiteSpace(valueidx))
            {
idx            }
            if (idx == value.Length)
            {
                parsedValue = null;
                return 0;
            }
            /*char*/ let ch = valueidx;
            if (ch == ',')
            {
                break;
            }
            if (ch != ';')
            {
                // Expecting parameters starting with semicolon; fail out.
                    parsedValue = null;
                return 0;
            }
            idx;
            while(idx < value.Length  && IsOptionalWhiteSpace(valueidx))
            {
idx            }
            /*// Get the parameter key length.
                int*/ let tokenLength = HttpRuleParser.GetTokenLength(value, idx);
            if (tokenLength == 0)
            {
                parsedValue = null;
                return 0;
            }
            if (idx + tokenLength >= value.Length  || valueidx + tokenLength != '=')
            {
                parsedValue = null;
                return 0;
            }
            if (tokenLength == 2 && valueidx == 'm' && valueidx + 1 == 'a')
            {
                // Parse "ma" (Max Age).
                    idx += 3;
                let maxAgeTmp = null;
                let $v = { value: set(value){ maxAgeTmp = value; } };
                let parameterLength = null;
                let $v = { value: set(value){ parameterLength = value; } };
                if (TryReadTokenOrQuotedInt32(value, idx, $v, $v))
                {
                    parsedValue = null;
                    return 0;
                }
                if (maxAge == null)
                {
                    maxAge = maxAgeTmp;
                }
                else 
                {
                    // RFC makes it unclear what to do if a duplicate parameter is found. For now, take the minimum.
                        maxAge = Math.Min(maxAge.GetValueOrDefault(), maxAgeTmp);
                }
                idx += parameterLength;
            }
            else if (value.AsSpan(idx).StartsWith("persist="))
            {
                idx += 8;
                let persistInt = null;
                let $v = { value: set(value){ persistInt = value; } };
                let parameterLength = null;
                let $v = { value: set(value){ parameterLength = value; } };
                if (TryReadTokenOrQuotedInt32(value, idx, $v, $v))
                {
                    persist = persistInt == 1;
                }
                let $v = { value: set(value){ parameterLength = value; } };
                else if (TrySkipTokenOrQuoted(value, idx, $v))
                {
                    // Cold path: unsupported value, just skip the parameter.
                        parsedValue = null;
                    return 0;
                }
                idx += parameterLength;
            }
            else 
            {
                // Some unknown parameter. Skip it.
                    idx += tokenLength + 1;
                let parameterLength = null;
                let $v = { value: set(value){ parameterLength = value; } };
                if (TrySkipTokenOrQuoted(value, idx, $v))
                {
                    parsedValue = null;
                    return 0;
                }
                idx += parameterLength;
            }
        }
        /*// If no "ma" parameter present, use the default.
            TimeSpan*/ let maxAgeTimeSpan = TimeSpan.FromTicks(maxAge * TimeSpan.TicksPerSecond  ?? DefaultMaxAgeTicks);
        parsedValue = new AltSvcHeaderValue(alpnProtocolName, altAuthorityHost, altAuthorityPort, maxAgeTimeSpan, persist);
        return idx - startIndex;
    }
    /*bool*/ IsOptionalWhiteSpace(/*char*/ ch)
    {
        return ch == ' ' || ch == '\t';
    }
    /*bool*/ TryReadPercentEncodedAlpnProtocolName(/*string*/ value, /*int*/ startIndex, /*string*/ result, /*int*/ readLength)
    {
        /*int*/ let tokenLength = HttpRuleParser.GetTokenLength(value, startIndex);
        if (tokenLength == 0)
        {
            result = null;
            readLength = 0;
            return false;
        }
        /*ReadOnlySpan<char>*/ let span = value.AsSpan(startIndex, tokenLength);
        readLength = tokenLength;
        switch(span.Length)
        {
2span.IsEqual("h3")            {
                result = "h3";
                return true;
            }
2span.IsEqual("h2")            {
                result = "h2";
                return true;
            }
3span.IsEqual("h2c")            {
                result = "h2c";
                readLength = 3;
                return true;
            }
5span.IsEqual("clear")            {
                result = "clear";
                return true;
            }
10span.StartsWith("http%2F1.")            {
                /*char*/ let ch = span9;
                if (ch == '1')
                {
                    result = "http/1.1";
                    return true;
                }
                if (ch == '0')
                {
                    result = "http/1.0";
                    return true;
                }
                break;
            }
        }
        let $v = { value: set(value){ result = value; } };
        return TryReadUnknownPercentEncodedAlpnProtocolName(span, $v);
    }
    /*bool*/ TryReadUnknownPercentEncodedAlpnProtocolName(/*ReadOnlySpan<char>*/ value, /*string*/ result)
    {
        /*int*/ let idx = value.IndexOf('%');
        if (idx < 0)
        {
            result = value.ToString();
            return true;
        }
        /*var*/ let builder = new StringBuilder(value.Length);
        do        {
            if (idx != 0)
            {
                builder.Append(value.Slice(0, idx));
            }
            let hi = null;
            let $v = { value: set(value){ hi = value; } };
            let lo = null;
            let $v = { value: set(value){ lo = value; } };
            if (value.Length  - idx < 3 || TryReadAlpnHexDigit(value1, $v) || TryReadAlpnHexDigit(value2, $v))
            {
                //builder.Dispose();
                    result = null;
                return false;
            }
            builder.Append(hi << 8 | lo);
            value = value.Slice(idx + 3);
            idx = value.IndexOf('%');
        } while(idx != 1);
        if (value.Length  != 0)
        {
            builder.Append(value);
        }
        result = builder.ToString();
        return true;
    }
    /*bool*/ TryReadAlpnHexDigit(/*char*/ ch, /*int*/ nibble)
    {
        /*int*/ let result = ch >= '0' && ch < '9'ch - '0'ch >= 'A' && ch <= 'F'ch - 'A' + 100xFF;
        if (result == 0xFF)
        {
            nibble = 0;
            return false;
        }
        nibble = result;
        return true;
    }
    /*bool*/ TryReadQuotedAltAuthority(/*string*/ value, /*int*/ startIndex, /*string*/ host, /*int*/ port, /*int*/ readLength)
    {
        let quotedLength = null;
        let $v = { value: set(value){ quotedLength = value; } };
        if (HttpRuleParser.GetQuotedStringLength(value, startIndex, $v) != HttpParseResult.Parsed)
        {
parseError        }
        Debug.Assert(valuestartIndex == '"' && valuestartIndex + quotedLength - 1 == '"', nameof(HttpRuleParser.GetQuotedStringLength)nameof(HttpParseResult.NotParsed));
        /*ReadOnlySpan<char>*/ let quoted = value.AsSpan(startIndex + 1, quotedLength - 2);
        /*int*/ let idx = quoted.IndexOf(':');
        if (idx == 1)
        {
parseError        }
        let $v = { value: set(value){ port = value; } };
        if (TryReadQuotedInt32Value(quoted.Slice(idx + 1), $v))
        {
parseError        }
        if (idx == 0)
        {
            host = null;
        }
        let $v = { value: set(value){ host = value; } };
        else if (TryReadQuotedValue(quoted.Slice(0, idx), $v))
        {
parseError        }
        readLength = quotedLength;
        return true;
        host = null;
        port = 0;
        readLength = 0;
        return false;
    }
    /*bool*/ TryReadQuotedValue(/*ReadOnlySpan<char>*/ value, /*string*/ result)
    {
        /*int*/ let idx = value.IndexOf('\\');
        if (idx == 1)
        {
            // Hostnames shouldn't require quoted pairs, so this should be the hot path.
                result = value.Length  != 0value.ToString()null;
            return true;
        }
        /*var*/ let builder = new StringBuilder();
        do        {
            if (idx + 1 == value.Length)
            {
                // quoted-pair requires two characters: the quote, and the quoted character.
                    //builder.Dispose();
                    result = null;
                return false;
            }
            if (idx != 0)
            {
                builder.Append(value.Slice(0, idx));
            }
            builder.Append(valueidx + 1);
            value = value.Slice(idx + 2);
            idx = value.IndexOf('\\');
        } while(idx != 1);
        if (value.Length  != 0)
        {
            builder.Append(value);
        }
        result = builder.ToString();
        return true;
    }
    /*bool*/ TryReadTokenOrQuotedInt32(/*string*/ value, /*int*/ startIndex, /*int*/ result, /*int*/ readLength)
    {
        if (startIndex >= value.Length)
        {
            result = 0;
            readLength = 0;
            return false;
        }
        /*int*/ let tokenLength = HttpRuleParser.GetTokenLength(value, startIndex);
        if (tokenLength > 0)
        {
            // No reason for integers to be quoted, so this should be the hot path.
                readLength = tokenLength;
            let $v = { value: set(value){ result = value; } };
            return HeaderUtilities.TryParseInt32(value, startIndex, tokenLength, $v);
        }
        let quotedLength = null;
        let $v = { value: set(value){ quotedLength = value; } };
        if (HttpRuleParser.GetQuotedStringLength(value, startIndex, $v) == HttpParseResult.Parsed)
        {
            readLength = quotedLength;
            let $v = { value: set(value){ result = value; } };
            return TryReadQuotedInt32Value(value.AsSpan(1, quotedLength - 2), $v);
        }
        result = 0;
        readLength = 0;
        return false;
    }
    /*bool*/ TryReadQuotedInt32Value(/*ReadOnlySpan<char>*/ value, /*int*/ result)
    {
        if (value.Length  == 0)
        {
            result = 0;
            return false;
        }
        /*int*/ let port = 0;
        BlazorJs.forEach(value, function(ch, $_i)
        {
            if (ch == '\\')
            if (.IsDigit(ch))
            {
                result = 0;
                return false;
            }
            /*long*/ let portTmp = port * 10L + ch - '0';
            if (portTmp > .MaxValue)
            {
                result = 0;
                return false;
            }
            port = portTmp;
        });
        result = port;
        return true;
    }
    /*bool*/ TrySkipTokenOrQuoted(/*string*/ value, /*int*/ startIndex, /*int*/ readLength)
    {
        if (startIndex >= value.Length)
        {
            readLength = 0;
            return false;
        }
        /*int*/ let tokenLength = HttpRuleParser.GetTokenLength(value, startIndex);
        if (tokenLength > 0)
        {
            readLength = tokenLength;
            return true;
        }
        let quotedLength = null;
        let $v = { value: set(value){ quotedLength = value; } };
        if (HttpRuleParser.GetQuotedStringLength(value, startIndex, $v) == HttpParseResult.Parsed)
        {
            readLength = quotedLength;
            return true;
        }
        readLength = 0;
        return false;
    }
}

class System_Net_Http_Headers_AltSvcHeaderValue extends object
{
    /*AltSvcHeaderValue*/ _backingField_Clear = null;
    /*AltSvcHeaderValue*/ get Clear()
    {
        return _backingField_Clear;
    }
    constructor(/*string*/ alpnProtocolName, /*string*/ host, /*int*/ port, /*TimeSpan*/ maxAge, /*bool*/ persist)
    {
        super();
        AlpnProtocolName = alpnProtocolName;
        Host = host;
        Port = port;
        MaxAge = maxAge;
        Persist = persist;
    }
    /*string*/ _backingField_AlpnProtocolName = null;
    /*string*/ get AlpnProtocolName()
    {
        return _backingField_AlpnProtocolName;
    }
    /*string*/ _backingField_Host = null;
    /*string*/ get Host()
    {
        return _backingField_Host;
    }
    /*int*/ _backingField_Port = null;
    /*int*/ get Port()
    {
        return _backingField_Port;
    }
    /*TimeSpan*/ _backingField_MaxAge = null;
    /*TimeSpan*/ get MaxAge()
    {
        return _backingField_MaxAge;
    }
    /*bool*/ _backingField_Persist = null;
    /*bool*/ get Persist()
    {
        return _backingField_Persist;
    }
    /*string*/ ToString()
    {
        /*var*/ let sb = new StringBuilder();
        sb.Append(AlpnProtocolName);
        sb.Append("=\"");
        if (Host != null)
        {
            sb.Append(Host);
        }
        sb.Append(':');
        //sb.AppendSpanFormattable((uint)Port);
            sb.Append(Port);
        sb.Append('"');
        if (MaxAge != TimeSpan.FromTicks(AltSvcHeaderParser.DefaultMaxAgeTicks))
        {
            sb.Append("; ma=");
            sb.Append(MaxAge.Ticks  / TimeSpan.TicksPerSecond);
        }
        if (Persist)
        {
            sb.Append("; persist=1");
        }
        return sb.ToString();
    }
}

class System_Net_Http_Headers_AuthenticationHeaderValue extends H5_IH5Class(System_ICloneable(object))
{
    /*string*/ _scheme = null;
    /*string*/ _parameter = null;
    /*string*/ get Scheme()
    {
        return _scheme;
    }
    /*string*/ get Parameter()
    {
        return _parameter;
    }
    constructor(/*string*/ scheme)
    {
        super(scheme, null);
    }
    constructor(/*string*/ scheme, /*string*/ parameter)
    {
        super();
        HeaderUtilities.CheckValidToken(scheme);
        HttpHeaders.CheckContainsNewLine(parameter);
        _scheme = scheme;
        _parameter = parameter;
    }
    constructor(/*AuthenticationHeaderValue*/ source)
    {
        super();
        Debug.Assert(source != null);
        _scheme = source._scheme;
        _parameter = source._parameter;
    }
    /*string*/ ToString()
    {
        if (.IsNullOrEmpty(_parameter))
        {
            return _scheme;
        }
        return _scheme + " " + _parameter;
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        /*AuthenticationHeaderValue*/ let other = obj as AuthenticationHeaderValue;
        if (other == null)
        {
            return false;
        }
        if (.IsNullOrEmpty(_parameter) && .IsNullOrEmpty(other._parameter))
        {
            return .Equals(_scheme, other._scheme, StringComparison.OrdinalIgnoreCase);
        }
        else 
        {
            return .Equals(_scheme, other._scheme, StringComparison.OrdinalIgnoreCase) && .Equals(_parameter, other._parameter, StringComparison.Ordinal);
        }
    }
    /*int*/ GetHashCode()
    {
        /*int*/ let result = StringComparer.OrdinalIgnoreCase.GetHashCode(_scheme);
        if (.IsNullOrEmpty(_parameter))
        {
            result ^= _parameter.GetHashCode();
        }
        return result;
    }
    /*AuthenticationHeaderValue*/ Parse(/*string*/ input)
    {
        /*int*/ let index = 0;
        let $v = { value: set(value){ index = value; } };
        return AuthenticationHeaderValueGenericHeaderParser.SingleValueAuthenticationParser.ParseValue(input, null, $v);
    }
    /*bool*/ TryParse(/*string*/ input, /*AuthenticationHeaderValue*/ parsedValue)
    {
        /*int*/ let index = 0;
        parsedValue = null;
        let $v = { value: set(value){ index = value; } };
        let output = null;
        let $v = { value: set(value){ output = value; } };
        if (GenericHeaderParser.SingleValueAuthenticationParser.TryParseValue(input, null, $v, $v))
        {
            parsedValue = AuthenticationHeaderValueoutput;
            return true;
        }
        return false;
    }
    /*int*/ GetAuthenticationLength(/*string*/ input, /*int*/ startIndex, /*object*/ parsedValue)
    {
        Debug.Assert(startIndex >= 0);
        parsedValue = null;
        if (.IsNullOrEmpty(input) || startIndex >= input.Length || HttpRuleParser.ContainsNewLine(input, startIndex))
        {
            return 0;
        }
        /*// Parse the scheme string: <scheme> in '<scheme> <parameter>'
            int*/ let schemeLength = HttpRuleParser.GetTokenLength(input, startIndex);
        if (schemeLength == 0)
        {
            return 0;
        }
        /*string*/ let targetScheme = null;
        switch(schemeLength)
        {
            case 5:
            {
                targetScheme = "Basic";
                break;
            }
            case 6:
            {
                targetScheme = "Digest";
                break;
            }
            case 4:
            {
                targetScheme = "NTLM";
                break;
            }
            case 9:
            {
                targetScheme = "Negotiate";
                break;
            }
        }
        /*//string scheme = targetScheme != null && string.CompareOrdinal(input, startIndex, targetScheme, 0, schemeLength) == 0 ?
            //    targetScheme :
            //    input.Substring(startIndex, schemeLength);
            string*/ let scheme = targetScheme != null && .Compare(input, startIndex, targetScheme, 0, schemeLength) == 0targetSchemeinput.Substring(startIndex, schemeLength);
        /*int*/ let current = startIndex + schemeLength;
        /*int*/ let whitespaceLength = HttpRuleParser.GetWhitespaceLength(input, current);
        current += whitespaceLength;
        if (current == input.Length || inputcurrent == ',')
        {
            // If we only have a scheme followed by whitespace, we're done.
                parsedValue = new AuthenticationHeaderValue(scheme);
            return current - startIndex;
        }
        if (whitespaceLength == 0)
        {
            return 0;
        }
        /*// If we get here, we have a <scheme> followed by a whitespace. Now we expect the following:
            // '<scheme> <blob>[,<name>=<value>]*[, <otherscheme>...]*': <blob> potentially contains one
            // or more '=' characters, optionally followed by additional name/value pairs, optionally followed by
            // other schemes. <blob> may be a quoted string.
            // We look at the value after ',': if it is <token>=<value> then we have a parameter for <scheme>.
            // If we have either a <token>-only or <token><whitespace><blob> then we have another scheme.
            int*/ let parameterStartIndex = current;
        /*int*/ let parameterEndIndex = current;
        let $v = { value: set(value){ current = value; } };
        let $v = { value: set(value){ parameterEndIndex = value; } };
        if (TrySkipFirstBlob(input, $v, $v))
        {
            return 0;
        }
        if (current < input.Length)
        {
            let $v = { value: set(value){ current = value; } };
            let $v = { value: set(value){ parameterEndIndex = value; } };
            if (TryGetParametersEndIndex(input, $v, $v))
            {
                return 0;
            }
        }
        /*string*/ let parameter = input.Substring(parameterStartIndex, parameterEndIndex - parameterStartIndex + 1);
        parsedValue = new AuthenticationHeaderValue(scheme, parameter);
        return current - startIndex;
    }
    /*bool*/ TrySkipFirstBlob(/*string*/ input, /*int*/ current, /*int*/ parameterEndIndex)
    {
        while(current < input.Length && inputcurrent != ',')
        {
            if (inputcurrent == '"')
            {
                /*int*/ let quotedStringLength;
                let $v = { value: set(value){ quotedStringLength = value; } };
                if (HttpRuleParser.GetQuotedStringLength(input, current, $v) != HttpParseResult.Parsed)
                {
                    return false;
                }
                current += quotedStringLength;
                parameterEndIndex = current - 1;
            }
            else 
            {
                /*int*/ let whitespaceLength = HttpRuleParser.GetWhitespaceLength(input, current);
                if (whitespaceLength == 0)
                {
                    parameterEndIndex = current;
                    current++;
                }
                else 
                {
                    current += whitespaceLength;
                }
            }
        }
        return true;
    }
    /*bool*/ TryGetParametersEndIndex(/*string*/ input, /*int*/ parseEndIndex, /*int*/ parameterEndIndex)
    {
        Debug.Assert(parseEndIndex < input.Length, "Expected string to have at least 1 char");
        Debug.Assert(inputparseEndIndex == ',');
        /*int*/ let current = parseEndIndex;
        do        {
            current++;
            let $v = { value: set(value){ _ = value; } };
            current = HeaderUtilities.GetNextNonEmptyOrWhitespaceIndex(input, current, true, $v);
            if (current == input.Length)
            {
                return true;
            }
            /*// Now we have to determine if after ',' we have a list of <name>=<value> pairs that are part of
                // the auth scheme parameters OR if we have another auth scheme. Either way, after ',' we expect a
                // valid token that is either the <name> in a <name>=<value> pair OR <scheme> of another scheme.
                int*/ let tokenLength = HttpRuleParser.GetTokenLength(input, current);
            if (tokenLength == 0)
            {
                return false;
            }
            current += tokenLength;
            current += HttpRuleParser.GetWhitespaceLength(input, current);
            if (current == input.Length || inputcurrent != '=')
            {
                return true;
            }
            current++;
            current += HttpRuleParser.GetWhitespaceLength(input, current);
            /*int*/ let valueLength = NameValueHeaderValue.GetValueLength(input, current);
            if (valueLength == 0)
            {
                return false;
            }
            // Update parameter end index, since we just parsed a valid <name>=<value> pair that is part of the
                // parameters string.
                current += valueLength;
            parameterEndIndex = current - 1;
            current += HttpRuleParser.GetWhitespaceLength(input, current);
            parseEndIndex = current;
        } while(current < input.Length && inputcurrent == ',');
        return true;
    }
    /*object*/ Clone()
    {
        return new AuthenticationHeaderValue();
    }
}

class System_Net_Http_Headers_BaseHeaderParser extends System_Net_Http_Headers_HttpHeaderParser
{
    constructor(/*bool*/ supportsMultipleValues)
    {
        super(supportsMultipleValues);
    }
    /*bool*/ TryParseValue(/*string*/ value, /*object*/ storeValue, /*int*/ index, /*object*/ parsedValue)
    {
        parsedValue = null;
        if (.IsNullOrEmpty(value) || index == value.Length)
        {
            return SupportsMultipleValues;
        }
        /*bool*/ let separatorFound;
        let $v = { value: set(value){             out separatorFound = value; } };
        /*int*/ let current = HeaderUtilities.GetNextNonEmptyOrWhitespaceIndex(value, index, SupportsMultipleValues, $v);
        if (separatorFound && SupportsMultipleValues)
        {
            return false;
        }
        if (current == value.Length)
        {
            if (SupportsMultipleValues)
            {
                index = current;
            }
            return SupportsMultipleValues;
        }
        let result = null;
        let $v = { value: set(value){ result = value; } };
        /*int*/ let length = GetParsedValueLength(value, current, storeValue, $v);
        if (length == 0)
        {
            return false;
        }
        current += length;
        let $v = { value: set(value){             out separatorFound = value; } };
        current = HeaderUtilities.GetNextNonEmptyOrWhitespaceIndex(value, current, SupportsMultipleValues, $v);
        if (separatorFound && SupportsMultipleValues || separatorFound && current < value.Length)
        {
            return false;
        }
        index = current;
        parsedValue = result;
        return true;
    }
}

class System_Net_Http_Headers_ByteArrayHeaderParser extends System_Net_Http_Headers_HttpHeaderParser
{
    /*ByteArrayHeaderParser*/ Parser = new ByteArrayHeaderParser();
    constructor()
    {
        super(false);
    }
    /*string*/ ToString(/*object*/ value)
    {
        Debug.Assert(value is );
        return Convert.ToBase64String(value);
    }
    /*bool*/ TryParseValue(/*string*/ value, /*object*/ storeValue, /*int*/ index, /*object*/ parsedValue)
    {
        parsedValue = null;
        if (.IsNullOrEmpty(value) || index == value.Length)
        {
            return false;
        }
        /*string*/ let base64String = value;
        if (index > 0)
        {
            base64String = value.Substring(index);
        }
        {
            parsedValue = Convert.FromBase64String(base64String);
            index = value.Length;
            return true;
        }
FormatException        {
        }
        return false;
    }
}

class System_Net_Http_Headers_CacheControlHeaderParser extends System_Net_Http_Headers_BaseHeaderParser
{
    /*CacheControlHeaderParser*/ Parser = new CacheControlHeaderParser();
    constructor()
    {
        super(true);
    }
    /*int*/ GetParsedValueLength(/*string*/ value, /*int*/ startIndex, /*object*/ storeValue, /*object*/ parsedValue)
    {
        /*CacheControlHeaderValue*/ let temp = null;
        /*bool*/ let isInvalidValue = true;
        if (storeValue instanceof List_$1, list = storeValue)
        {
            BlazorJs.forEach(list, function(item, $_i)
            {
                if (item is HttpHeadersInvalidValue)
                {
                    isInvalidValue = false;
                    temp = item as CacheControlHeaderValue;
                    break;
                }
            });
        }
        else 
        {
            if (storeValue is HttpHeadersInvalidValue)
            {
                isInvalidValue = false;
                temp = storeValue as CacheControlHeaderValue;
            }
        }
        Debug.Assert(isInvalidValue || storeValue == null || temp != null, "'storeValue' is not of type CacheControlHeaderValue");
        let $v = { value: set(value){ temp = value; } };
        /*int*/ let resultLength = CacheControlHeaderValue.GetCacheControlLength(value, startIndex, temp, $v);
        parsedValue = temp;
        return resultLength;
    }
}

class System_Net_Http_Headers_CacheControlHeaderValue extends H5_IH5Class(System_ICloneable(object))
{
    /*string*/ maxAgeString = "max-age";
    /*string*/ maxStaleString = "max-stale";
    /*string*/ minFreshString = "min-fresh";
    /*string*/ mustRevalidateString = "must-revalidate";
    /*string*/ noCacheString = "no-cache";
    /*string*/ noStoreString = "no-store";
    /*string*/ noTransformString = "no-transform";
    /*string*/ onlyIfCachedString = "only-if-cached";
    /*string*/ privateString = "private";
    /*string*/ proxyRevalidateString = "proxy-revalidate";
    /*string*/ publicString = "public";
    /*string*/ sharedMaxAgeString = "s-maxage";
    /*GenericHeaderParser*/ s_nameValueListParser = GenericHeaderParser.MultipleValueNameValueParser;
 = 0 = 1 << 0 = 1 << 1 = 1 << 2 = 1 << 3 = 1 << 4 = 1 << 5 = 1 << 6 = 1 << 7 = 1 << 8 = 1 << 9 = 1 << 10 = 1 << 11 = 1 << 12    /*Flags*/ _flags = null;
    /*TokenObjectCollection*/ _noCacheHeaders = null;
    /*TimeSpan*/ _maxAge = null;
    /*TimeSpan*/ _sharedMaxAge = null;
    /*TimeSpan*/ _maxStaleLimit = null;
    /*TimeSpan*/ _minFresh = null;
    /*TokenObjectCollection*/ _privateHeaders = null;
    /*UnvalidatedObjectCollection<NameValueHeaderValue>*/ _extensions = null;
    /*void*/ SetTimeSpan(/*TimeSpan*/ fieldRef, /*Flags*/ flag, /*TimeSpan?*/ value)
    {
        fieldRef = value.GetValueOrDefault();
        SetFlag(flag, value.HasValue);
    }
    /*void*/ SetFlag(/*Flags*/ flag, /*bool*/ value)
    {
        Debug.Assert(Flags == );
        if (value)
        {
            _flags |= flag;
        }
        else 
        {
            _flags &= flag;
        }
    }
    /*bool*/ get NoCache()
    {
        return _flags & Flags.NoCache != 0;
    }
    /*bool*/ set NoCache(value)
    {
        SetFlag(Flags.NoCache, value);
    }
    /*ICollection<string>*/ get NoCacheHeaders()
    {
        return _noCacheHeaders = _noCacheHeaders ?? new TokenObjectCollection();
    }
    /*bool*/ get NoStore()
    {
        return _flags & Flags.NoStore != 0;
    }
    /*bool*/ set NoStore(value)
    {
        SetFlag(Flags.NoStore, value);
    }
    /*TimeSpan?*/ get MaxAge()
    {
        return _flags & Flags.MaxAgeHasValue == 0TimeSpannull_maxAge;
    }
    /*TimeSpan?*/ set MaxAge(value)
    {
        let $v = { value: set(value){ _maxAge = value; } };
        SetTimeSpan($v, Flags.MaxAgeHasValue, value);
    }
    /*TimeSpan?*/ get SharedMaxAge()
    {
        return _flags & Flags.SharedMaxAgeHasValue == 0TimeSpannull_sharedMaxAge;
    }
    /*TimeSpan?*/ set SharedMaxAge(value)
    {
        let $v = { value: set(value){ _sharedMaxAge = value; } };
        SetTimeSpan($v, Flags.SharedMaxAgeHasValue, value);
    }
    /*bool*/ get MaxStale()
    {
        return _flags & Flags.MaxStale != 0;
    }
    /*bool*/ set MaxStale(value)
    {
        SetFlag(Flags.MaxStale, value);
    }
    /*TimeSpan?*/ get MaxStaleLimit()
    {
        return _flags & Flags.MaxStaleLimitHasValue == 0TimeSpannull_maxStaleLimit;
    }
    /*TimeSpan?*/ set MaxStaleLimit(value)
    {
        let $v = { value: set(value){ _maxStaleLimit = value; } };
        SetTimeSpan($v, Flags.MaxStaleLimitHasValue, value);
    }
    /*TimeSpan?*/ get MinFresh()
    {
        return _flags & Flags.MinFreshHasValue == 0TimeSpannull_minFresh;
    }
    /*TimeSpan?*/ set MinFresh(value)
    {
        let $v = { value: set(value){ _minFresh = value; } };
        SetTimeSpan($v, Flags.MinFreshHasValue, value);
    }
    /*bool*/ get NoTransform()
    {
        return _flags & Flags.NoTransform != 0;
    }
    /*bool*/ set NoTransform(value)
    {
        SetFlag(Flags.NoTransform, value);
    }
    /*bool*/ get OnlyIfCached()
    {
        return _flags & Flags.OnlyIfCached != 0;
    }
    /*bool*/ set OnlyIfCached(value)
    {
        SetFlag(Flags.OnlyIfCached, value);
    }
    /*bool*/ get Public()
    {
        return _flags & Flags.Public != 0;
    }
    /*bool*/ set Public(value)
    {
        SetFlag(Flags.Public, value);
    }
    /*bool*/ get Private()
    {
        return _flags & Flags.Private != 0;
    }
    /*bool*/ set Private(value)
    {
        SetFlag(Flags.Private, value);
    }
    /*ICollection<string>*/ get PrivateHeaders()
    {
        return _privateHeaders = _privateHeaders ?? new TokenObjectCollection();
    }
    /*bool*/ get MustRevalidate()
    {
        return _flags & Flags.MustRevalidate != 0;
    }
    /*bool*/ set MustRevalidate(value)
    {
        SetFlag(Flags.MustRevalidate, value);
    }
    /*bool*/ get ProxyRevalidate()
    {
        return _flags & Flags.ProxyRevalidate != 0;
    }
    /*bool*/ set ProxyRevalidate(value)
    {
        SetFlag(Flags.ProxyRevalidate, value);
    }
    /*ICollection<NameValueHeaderValue>*/ get Extensions()
    {
        return _extensions = _extensions ?? new UnvalidatedObjectCollection_$1(NameValueHeaderValue);
    }
    constructor()
    {
        super();
    }
    constructor(/*CacheControlHeaderValue*/ source)
    {
        super();
        Debug.Assert(source != null);
        _flags = source._flags;
        _maxAge = source._maxAge;
        _sharedMaxAge = source._sharedMaxAge;
        _maxStaleLimit = source._maxStaleLimit;
        _minFresh = source._minFresh;
        if (source._noCacheHeaders  != null)
        {
            BlazorJs.forEach(source._noCacheHeaders, function(noCacheHeader, $_i)
            {
                NoCacheHeaders.Add(noCacheHeader);
            });
        }
        if (source._privateHeaders  != null)
        {
            BlazorJs.forEach(source._privateHeaders, function(privateHeader, $_i)
            {
                PrivateHeaders.Add(privateHeader);
            });
        }
        _extensions = source._extensions.Clone();
    }
    /*string*/ ToString()
    {
        /*StringBuilder*/ let sb = new StringBuilder();
        AppendValueIfRequired(sb, NoStore, noStoreString);
        AppendValueIfRequired(sb, NoTransform, noTransformString);
        AppendValueIfRequired(sb, OnlyIfCached, onlyIfCachedString);
        AppendValueIfRequired(sb, Public, publicString);
        AppendValueIfRequired(sb, MustRevalidate, mustRevalidateString);
        AppendValueIfRequired(sb, ProxyRevalidate, proxyRevalidateString);
        if (NoCache)
        {
            AppendValueWithSeparatorIfRequired(sb, noCacheString);
            if (_noCacheHeaders != null && _noCacheHeaders.Count  > 0)
            {
                sb.Append("=\"");
                AppendValues(sb, _noCacheHeaders);
                sb.Append('\"');
            }
        }
        if (_flags & Flags.MaxAgeHasValue != 0)
        {
            AppendValueWithSeparatorIfRequired(sb, maxAgeString);
            sb.Append('=');
            /*int*/ let maxAge = _maxAge.TotalSeconds;
            if (maxAge >= 0)
            {
                sb.Append(maxAge);
            }
            else 
            {
                // In the corner case where the value is negative, ensure it uses
                    // the invariant's negative sign rather than the current culture's.
                    //sb.Append(NumberFormatInfo.InvariantInfo, $"{maxAge}");
                    sb.Append(maxAge);
            }
        }
        if (_flags & Flags.SharedMaxAgeHasValue != 0)
        {
            AppendValueWithSeparatorIfRequired(sb, sharedMaxAgeString);
            sb.Append('=');
            /*int*/ let sharedMaxAge = _sharedMaxAge.TotalSeconds;
            if (sharedMaxAge >= 0)
            {
                sb.Append(sharedMaxAge);
            }
            else 
            {
                // In the corner case where the value is negative, ensure it uses
                    // the invariant's negative sign rather than the current culture's.
                    //sb.Append(NumberFormatInfo.InvariantInfo, $"{sharedMaxAge}");
                    sb.Append(sharedMaxAge);
            }
        }
        if (MaxStale)
        {
            AppendValueWithSeparatorIfRequired(sb, maxStaleString);
            if (_flags & Flags.MaxStaleLimitHasValue != 0)
            {
                sb.Append('=');
                /*int*/ let maxStaleLimit = _maxStaleLimit.TotalSeconds;
                if (maxStaleLimit >= 0)
                {
                    sb.Append(maxStaleLimit);
                }
                else 
                {
                    // In the corner case where the value is negative, ensure it uses
                        // the invariant's negative sign rather than the current culture's.
                        //sb.Append(NumberFormatInfo.InvariantInfo, $"{maxStaleLimit}");
                        sb.Append(maxStaleLimit);
                }
            }
        }
        if (_flags & Flags.MinFreshHasValue != 0)
        {
            AppendValueWithSeparatorIfRequired(sb, minFreshString);
            sb.Append('=');
            /*int*/ let minFresh = _minFresh.TotalSeconds;
            if (minFresh >= 0)
            {
                sb.Append(minFresh);
            }
            else 
            {
                // In the corner case where the value is negative, ensure it uses
                    // the invariant's negative sign rather than the current culture's.
                    //sb.Append(NumberFormatInfo.InvariantInfo, $"{minFresh}");
                    sb.Append(minFresh);
            }
        }
        if (Private)
        {
            AppendValueWithSeparatorIfRequired(sb, privateString);
            if (_privateHeaders != null && _privateHeaders.Count  > 0)
            {
                sb.Append("=\"");
                AppendValues(sb, _privateHeaders);
                sb.Append('\"');
            }
        }
        NameValueHeaderValue.ToString(_extensions, ',', false, sb);
        return sb.ToString();
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        obj instanceof CacheControlHeaderValue, other = obj && _flags == other._flags  && _maxAge == other._maxAge  && _sharedMaxAge == other._sharedMaxAge  && _maxStaleLimit == other._maxStaleLimit  && _minFresh == other._minFresh  && HeaderUtilities.AreEqualCollections(_noCacheHeaders, other._noCacheHeaders, StringComparer.OrdinalIgnoreCase) && HeaderUtilities.AreEqualCollections(_privateHeaders, other._privateHeaders, StringComparer.OrdinalIgnoreCase) && HeaderUtilities.AreEqualCollections(_extensions, other._extensions);
    }
    /*int*/ GetHashCode()
    {
        HashCode.Combine(_flags, _maxAge, _sharedMaxAge, _maxStaleLimit, _minFresh, _noCacheHeaders0_noCacheHeaders.GetHashCode(StringComparer.OrdinalIgnoreCase), _privateHeaders0_privateHeaders.GetHashCode(StringComparer.OrdinalIgnoreCase), NameValueHeaderValue.GetHashCode(_extensions));
    }
    /*CacheControlHeaderValue*/ Parse(/*string*/ input)
    {
        /*int*/ let index = 0;
        let $v = { value: set(value){ index = value; } };
        return CacheControlHeaderValueCacheControlHeaderParser.Parser.ParseValue(input, null, $v) ?? new CacheControlHeaderValue();
    }
    /*bool*/ TryParse(/*string*/ input, /*CacheControlHeaderValue*/ parsedValue)
    {
        /*int*/ let index = 0;
        parsedValue = null;
        let $v = { value: set(value){ index = value; } };
        let output = null;
        let $v = { value: set(value){ output = value; } };
        if (CacheControlHeaderParser.Parser.TryParseValue(input, null, $v, $v))
        {
            parsedValue = CacheControlHeaderValueoutput ?? new CacheControlHeaderValue();
            return true;
        }
        return false;
    }
    /*int*/ GetCacheControlLength(/*string*/ input, /*int*/ startIndex, /*CacheControlHeaderValue*/ storeValue, /*CacheControlHeaderValue*/ parsedValue)
    {
        Debug.Assert(startIndex >= 0);
        parsedValue = null;
        if (.IsNullOrEmpty(input) || startIndex >= input.Length)
        {
            return 0;
        }
        /*// Cache-Control header consists of a list of name/value pairs, where the value is optional. So use an
            // instance of NameValueHeaderParser to parse the string.
            int*/ let current = startIndex;
        /*List<NameValueHeaderValue>*/ let nameValueList = new List_$1(NameValueHeaderValue);
        while(current < input.Length)
        {
            let $v = { value: set(value){ current = value; } };
            let nameValue = null;
            let $v = { value: set(value){ nameValue = value; } };
            if (s_nameValueListParser.TryParseValue(input, null, $v, $v))
            {
                return 0;
            }
            Debug.Assert(nameValue);
            nameValueList.Add(NameValueHeaderValuenameValue);
        }
        /*// If we get here, we were able to successfully parse the string as list of name/value pairs. Now analyze
            // the name/value pairs.
            // Cache-Control is a header supporting lists of values. However, expose the header as an instance of
            // CacheControlHeaderValue. So if we already have an instance of CacheControlHeaderValue, add the values
            // from this string to the existing instances.
            CacheControlHeaderValue*/ let result = storeValue ?? new CacheControlHeaderValue();
        if (TrySetCacheControlValues(result, nameValueList))
        {
            return 0;
        }
        if (storeValue == null)
        {
            parsedValue = result;
        }
        return input.Length  - startIndex;
    }
    /*bool*/ TrySetCacheControlValues(/*CacheControlHeaderValue*/ cc, /*List<NameValueHeaderValue>*/ nameValueList)
    {
        BlazorJs.forEach(nameValueList, function(nameValue, $_i)
        {
            /*string*/ let name = nameValue.Name.ToLower();
            /*//string name = nameValue.Name.ToLowerInvariant();
                string*/ let value = nameValue.Value;
            /*Flags*/ let flagsToSet = Flags.None;
            /*bool*/ let success = value;
            switch(name)
            {
                case noCacheString:
                {
                    flagsToSet = Flags.NoCache;
                    let $v = { value: set(value){ cc._noCacheHeaders = value; } };
                    success = TrySetOptionalTokenList(nameValue, $v);
                    break;
                }
                case noStoreString:
                {
                    flagsToSet = Flags.NoStore;
                    break;
                }
                case maxAgeString:
                {
                    flagsToSet = Flags.MaxAgeHasValue;
                    let $v = { value: set(value){ cc._maxAge = value; } };
                    success = TrySetTimeSpan(value, $v);
                    break;
                }
                case maxStaleString:
                {
                    flagsToSet = Flags.MaxStale;
                    let $v = { value: set(value){ cc._maxStaleLimit = value; } };
                    if (TrySetTimeSpan(value, $v))
                    {
                        success = true;
                        flagsToSet = Flags.MaxStale  | Flags.MaxStaleLimitHasValue;
                    }
                    break;
                }
                case minFreshString:
                {
                    flagsToSet = Flags.MinFreshHasValue;
                    let $v = { value: set(value){ cc._minFresh = value; } };
                    success = TrySetTimeSpan(value, $v);
                    break;
                }
                case noTransformString:
                {
                    flagsToSet = Flags.NoTransform;
                    break;
                }
                case onlyIfCachedString:
                {
                    flagsToSet = Flags.OnlyIfCached;
                    break;
                }
                case publicString:
                {
                    flagsToSet = Flags.Public;
                    break;
                }
                case privateString:
                {
                    flagsToSet = Flags.Private;
                    let $v = { value: set(value){ cc._privateHeaders = value; } };
                    success = TrySetOptionalTokenList(nameValue, $v);
                    break;
                }
                case mustRevalidateString:
                {
                    flagsToSet = Flags.MustRevalidate;
                    break;
                }
                case proxyRevalidateString:
                {
                    flagsToSet = Flags.ProxyRevalidate;
                    break;
                }
                case sharedMaxAgeString:
                {
                    flagsToSet = Flags.SharedMaxAgeHasValue;
                    let $v = { value: set(value){ cc._sharedMaxAge = value; } };
                    success = TrySetTimeSpan(value, $v);
                    break;
                }
                default:                {
                    success = true;
                    cc.Extensions.Add(nameValue);
                    break;
                }
            }
            if (success)
            {
                cc._flags  |= flagsToSet;
            }
            else 
            {
                return false;
            }
        });
        return true;
    }
    /*bool*/ TrySetOptionalTokenList(/*NameValueHeaderValue*/ nameValue, /*TokenObjectCollection*/ destination)
    {
        Debug.Assert(nameValue != null);
        if (nameValue.Value  == null)
        {
            return true;
        }
        /*// We need the string to be at least 3 chars long: 2x quotes and at least 1 character. Also make sure we
            // have a quoted string. Note that NameValueHeaderValue will never have leading/trailing whitespace.
            string*/ let valueString = nameValue.Value;
        if (valueString.Length  < 3 || valueString.StartsWith("\"") || valueString.EndsWith("\""))
        {
            return false;
        }
        /*// We have a quoted string. Now verify that the string contains a list of valid tokens separated by ','.
            int*/ let current = 1;
        /*int*/ let maxLength = valueString.Length  - 1;
        /*int*/ let originalValueCount = destination == null0destination.Count;
        while(current < maxLength)
        {
            let $v = { value: set(value){                 out _ = value; } };
            current = HeaderUtilities.GetNextNonEmptyOrWhitespaceIndex(valueString, current, true, $v);
            if (current == maxLength)
            {
                break;
            }
            /*int*/ let tokenLength = HttpRuleParser.GetTokenLength(valueString, current);
            if (tokenLength == 0)
            {
                return false;
            }
            destination = destination ?? new TokenObjectCollection();
            destination.Add(valueString.Substring(current, tokenLength));
            current += tokenLength;
        }
        if (destination != null && destination.Count  > originalValueCount)
        {
            return true;
        }
        return false;
    }
    /*bool*/ TrySetTimeSpan(/*string*/ value, /*TimeSpan*/ timeSpan)
    {
        let seconds = null;
        let $v = { value: set(value){ seconds = value; } };
        if (value || HeaderUtilities.TryParseInt32(value, $v))
        {
            return false;
        }
        timeSpan = new TimeSpan(0, 0, seconds);
        return true;
    }
    /*void*/ AppendValueIfRequired(/*StringBuilder*/ sb, /*bool*/ appendValue, /*string*/ value)
    {
        if (appendValue)
        {
            AppendValueWithSeparatorIfRequired(sb, value);
        }
    }
    /*void*/ AppendValueWithSeparatorIfRequired(/*StringBuilder*/ sb, /*string*/ value)
    {
        if (sb.Length  > 0)
        {
            sb.Append(", ");
        }
        sb.Append(value);
    }
    /*void*/ AppendValues(/*StringBuilder*/ sb, /*TokenObjectCollection*/ values)
    {
        /*bool*/ let first = true;
        BlazorJs.forEach(values, function(value, $_i)
        {
            if (first)
            {
                first = false;
            }
            else 
            {
                sb.Append(", ");
            }
            sb.Append(value);
        });
    }
    /*object*/ Clone()
    {
        return new CacheControlHeaderValue();
    }
    class System_Net_Http_Headers_TokenObjectCollection extends System_Net_Http_Headers_ObjectCollection(string)
    {
        constructor()
        {
            super();
        }
        /*void*/ Validate(/*string*/ item)
        {
            HeaderUtilities.CheckValidToken(item);
        }
        /*int*/ GetHashCode(/*StringComparer*/ comparer)
        {
            /*int*/ let hashcode = 0;
            BlazorJs.forEach(, function(value, $_i)
            {
                hashcode ^= comparer.GetHashCode(value);
            });
            return hashcode;
        }
    }
}

class System_Net_Http_Headers_ContentDispositionHeaderValue extends H5_IH5Class(System_ICloneable(object))
{
    /*string*/ fileName = "filename";
    /*string*/ name = "name";
    /*string*/ fileNameStar = "filename*";
    /*string*/ creationDate = "creation-date";
    /*string*/ modificationDate = "modification-date";
    /*string*/ readDate = "read-date";
    /*string*/ size = "size";
    /*UnvalidatedObjectCollection<NameValueHeaderValue>*/ _parameters = null;
    /*string*/ _dispositionType = null;
    /*string*/ get DispositionType()
    {
        return _dispositionType;
    }
    /*string*/ set DispositionType(value)
    {
        HeaderUtilities.CheckValidToken(value);
        _dispositionType = value;
    }
    /*ICollection<NameValueHeaderValue>*/ get Parameters()
    {
        return _parameters = _parameters ?? new UnvalidatedObjectCollection_$1(NameValueHeaderValue);
    }
    /*string*/ get Name()
    {
        return GetName(name);
    }
    /*string*/ set Name(value)
    {
        SetName(name, value);
    }
    /*string*/ get FileName()
    {
        return GetName(fileName);
    }
    /*string*/ set FileName(value)
    {
        SetName(fileName, value);
    }
    /*string*/ get FileNameStar()
    {
        return GetName(fileNameStar);
    }
    /*string*/ set FileNameStar(value)
    {
        SetName(fileNameStar, value);
    }
    /*DateTimeOffset?*/ get CreationDate()
    {
        return GetDate(creationDate);
    }
    /*DateTimeOffset?*/ set CreationDate(value)
    {
        SetDate(creationDate, value);
    }
    /*DateTimeOffset?*/ get ModificationDate()
    {
        return GetDate(modificationDate);
    }
    /*DateTimeOffset?*/ set ModificationDate(value)
    {
        SetDate(modificationDate, value);
    }
    /*DateTimeOffset?*/ get ReadDate()
    {
        return GetDate(readDate);
    }
    /*DateTimeOffset?*/ set ReadDate(value)
    {
        SetDate(readDate, value);
    }
    /*long?*/ get Size()
    {
        /*NameValueHeaderValue*/ let sizeParameter = NameValueHeaderValue.Find(_parameters, size);
        /*ulong*/ let value;
        if (sizeParameter != null)
        {
            /*string*/ let sizeString = sizeParameter.Value;
            let $v = { value: set(value){ value = value; } };
            if (.TryParse(sizeString, $v))
            {
                return value;
            }
        }
        return null;
    }
    /*long?*/ set Size(value)
    {
        /*NameValueHeaderValue*/ let sizeParameter = NameValueHeaderValue.Find(_parameters, size);
        if (value == null)
        {
            if (sizeParameter != null)
            {
                _parameters.Remove(sizeParameter);
            }
        }
        else 
        {
            if (value.GetValueOrDefault() < 0)
            {
                throw new ArgumentOutOfRangeException();
            }
            if (sizeParameter != null)
            {
                sizeParameter.Value  = value.Value.ToString();
            }
            else 
            {
                /*string*/ let sizeString = value.Value.ToString();
                Parameters.Add(new NameValueHeaderValue(size, sizeString));
            }
        }
    }
    constructor()
    {
        super();
    }
    constructor(/*ContentDispositionHeaderValue*/ source)
    {
        super();
        Debug.Assert(source != null);
        _dispositionType = source._dispositionType;
        _parameters = source._parameters.Clone();
    }
    constructor(/*string*/ dispositionType)
    {
        super();
        HeaderUtilities.CheckValidToken(dispositionType);
        _dispositionType = dispositionType;
    }
    /*string*/ ToString()
    {
        /*StringBuilder*/ let sb = new StringBuilder();
        sb.Append(_dispositionType);
        NameValueHeaderValue.ToString(_parameters, ';', true, sb);
        return sb.ToString();
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        /*ContentDispositionHeaderValue*/ let other = obj as ContentDispositionHeaderValue;
        if (other == null)
        {
            return false;
        }
        return .Equals(_dispositionType, other._dispositionType, StringComparison.OrdinalIgnoreCase) && HeaderUtilities.AreEqualCollections(_parameters, other._parameters);
    }
    /*int*/ GetHashCode()
    {
        return StringComparer.OrdinalIgnoreCase.GetHashCode(_dispositionType) ^ NameValueHeaderValue.GetHashCode(_parameters);
    }
    /*// Implement ICloneable explicitly to allow derived types to "override" the implementation.
        object*/ Clone()
    {
        return new ContentDispositionHeaderValue();
    }
    /*ContentDispositionHeaderValue*/ Parse(/*string*/ input)
    {
        /*int*/ let index = 0;
        let $v = { value: set(value){ index = value; } };
        return ContentDispositionHeaderValueGenericHeaderParser.ContentDispositionParser.ParseValue(input, null, $v);
    }
    /*bool*/ TryParse(/*string*/ input, /*ContentDispositionHeaderValue*/ parsedValue)
    {
        /*int*/ let index = 0;
        parsedValue = null;
        let $v = { value: set(value){ index = value; } };
        let output = null;
        let $v = { value: set(value){ output = value; } };
        if (GenericHeaderParser.ContentDispositionParser.TryParseValue(input, null, $v, $v))
        {
            parsedValue = ContentDispositionHeaderValueoutput;
            return true;
        }
        return false;
    }
    /*int*/ GetDispositionTypeLength(/*string*/ input, /*int*/ startIndex, /*object*/ parsedValue)
    {
        Debug.Assert(startIndex >= 0);
        parsedValue = null;
        if (.IsNullOrEmpty(input) || startIndex >= input.Length)
        {
            return 0;
        }
        /*// Caller must remove leading whitespace. If not, we'll return 0.
            string*/ let dispositionType;
        let $v = { value: set(value){ dispositionType = value; } };
        /*int*/ let dispositionTypeLength = GetDispositionTypeExpressionLength(input, startIndex, $v);
        if (dispositionTypeLength == 0)
        {
            return 0;
        }
        /*int*/ let current = startIndex + dispositionTypeLength;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        /*ContentDispositionHeaderValue*/ let contentDispositionHeader = new ContentDispositionHeaderValue();
        contentDispositionHeader._dispositionType  = dispositionType;
        if (current < input.Length && inputcurrent == ';')
        {
            current++;
            /*int*/ let parameterLength = NameValueHeaderValue.GetNameValueListLength(input, current, ';', UnvalidatedObjectCollection_$1contentDispositionHeader.Parameters);
            if (parameterLength == 0)
            {
                return 0;
            }
            parsedValue = contentDispositionHeader;
            return current + parameterLength - startIndex;
        }
        // We have a ContentDisposition header without parameters.
            parsedValue = contentDispositionHeader;
        return current - startIndex;
    }
    /*int*/ GetDispositionTypeExpressionLength(/*string*/ input, /*int*/ startIndex, /*string*/ dispositionType)
    {
        Debug.Assert(input != null && input.Length  > 0 && startIndex < input.Length);
        // This method just parses the disposition type string, it does not parse parameters.
            dispositionType = null;
        /*// Parse the disposition type, i.e. <dispositiontype> in content-disposition string
            // "<dispositiontype>; param1=value1; param2=value2".
            int*/ let typeLength = HttpRuleParser.GetTokenLength(input, startIndex);
        if (typeLength == 0)
        {
            return 0;
        }
        dispositionType = input.Substring(startIndex, typeLength);
        return typeLength;
    }
    /*DateTimeOffset?*/ GetDate(/*string*/ parameter)
    {
        /*NameValueHeaderValue*/ let dateParameter = NameValueHeaderValue.Find(_parameters, parameter);
        /*DateTimeOffset*/ let date;
        if (dateParameter != null)
        {
            /*ReadOnlySpan<char>*/ let dateString = dateParameter.Value.AsSpan();
            if (IsQuoted(dateString))
            {
                dateString = dateString.Slice(1, dateString.Length  - 2);
            }
            let $v = { value: set(value){ date = value; } };
            if (DateTimeOffset.TryParse(dateString, $v))
            {
                return date;
            }
        }
        return null;
    }
    /*void*/ SetDate(/*string*/ parameter, /*DateTimeOffset?*/ date)
    {
        /*NameValueHeaderValue*/ let dateParameter = NameValueHeaderValue.Find(_parameters, parameter);
        if (date == null)
        {
            if (dateParameter != null)
            {
                _parameters.Remove(dateParameter);
            }
        }
        else 
        {
            /*// Must always be quoted.
                string*/ let dateString = date.GetValueOrDefault();
            if (dateParameter != null)
            {
                dateParameter.Value  = dateString;
            }
            else 
            {
                Parameters.Add(new NameValueHeaderValue(parameter, dateString));
            }
        }
    }
    /*string*/ GetName(/*string*/ parameter)
    {
        /*NameValueHeaderValue*/ let nameParameter = NameValueHeaderValue.Find(_parameters, parameter);
        if (nameParameter != null)
        {
            /*string*/ let result;
            if (parameter.EndsWith("*"))
            {
                Debug.Assert(nameParameter.Value  != null);
                let $v = { value: set(value){ result = value; } };
                if (TryDecode5987(nameParameter.Value, $v))
                {
                    return result;
                }
                return null;
            }
            let $v = { value: set(value){ result = value; } };
            if (TryDecodeMime(nameParameter.Value, $v))
            {
                return result;
            }
            return nameParameter.Value;
        }
        return null;
    }
    /*void*/ SetName(/*string*/ parameter, /*string*/ value)
    {
        /*NameValueHeaderValue*/ let nameParameter = NameValueHeaderValue.Find(_parameters, parameter);
        if (.IsNullOrEmpty(value))
        {
            if (nameParameter != null)
            {
                _parameters.Remove(nameParameter);
            }
        }
        else 
        {
            /*string*/ let processedValue;
            if (parameter.EndsWith("*"))
            {
                processedValue = HeaderUtilities.Encode5987(value);
            }
            else 
            {
                processedValue = EncodeAndQuoteMime(value);
            }
            if (nameParameter != null)
            {
                nameParameter.Value  = processedValue;
            }
            else 
            {
                Parameters.Add(new NameValueHeaderValue(parameter, processedValue));
            }
        }
    }
    /*string*/ EncodeAndQuoteMime(/*string*/ input)
    {
        /*string*/ let result = input;
        /*bool*/ let needsQuotes = false;
        if (IsQuoted(result.AsSpan()))
        {
            result = result.Substring(1, result.Length  - 2);
            needsQuotes = true;
        }
        if (result.Contains("\""))
        {
            throw new ArgumentException("net_http_headers_invalid_value");
        }
        else if (Ascii.IsValid(result))
        {
            needsQuotes = true;
            result = EncodeMime(result);
        }
        else if (needsQuotes && HttpRuleParser.GetTokenLength(result, 0) != result.Length)
        {
            needsQuotes = true;
        }
        if (needsQuotes)
        {
            // Re-add quotes "value".
                result = "\"" + result + "\"";
        }
        return result;
    }
    /*bool*/ IsQuoted(/*ReadOnlySpan<char>*/ value)
    {
        return value.Length  > 1 && value0 == '"' && valuevalue.Length  - 1 == '"';
    }
    /*string*/ EncodeMime(/*string*/ input)
    {
        /*byte[]*/ let buffer = Encoding.UTF8.GetBytes(input);
        /*string*/ let encodedName = Convert.ToBase64String(buffer);
        return "=?utf-8?B?" + encodedName + "?=";
    }
    /*bool*/ TryDecodeMime(/*string*/ input, /*string*/ output)
    {
        Debug.Assert(input != null);
        output = null;
        /*string*/ let processedInput = input;
        if (IsQuoted(processedInput.AsSpan()) || processedInput.Length  < 10)
        {
            return false;
        }
        /*Span<Range>*/ let parts = new Span_$1(Range, new Array(6));
        /*ReadOnlySpan<char>*/ let processedInputSpan = processedInput.AsSpan();
        if (processedInputSpan.Split(parts, '?') != 5 || processedInputSpanparts0.IsEqual("\"=") || processedInputSpanparts0.IsEqual("=\"") || processedInputSpanparts2.IsEqual("b", StringComparison.OrdinalIgnoreCase))
        {
            return false;
        }
        {
            /*Encoding*/ let encoding = Encoding.GetEncoding(processedInput.AsSpan()parts1);
            /*byte[]*/ let bytes = Convert.FromBase64String(processedInput.AsSpan()parts3);
            output = encoding.GetString(bytes, 0, bytes.Length);
            return true;
        }
ArgumentException        {
        }
FormatException        {
        }
        return false;
    }
    /*bool*/ TryDecode5987(/*string*/ input, /*string*/ output)
    {
        output = null;
        /*int*/ let quoteIndex = input.IndexOf('\'');
        if (quoteIndex == 1)
        {
            return false;
        }
        /*int*/ let lastQuoteIndex = input.LastIndexOf('\'');
        if (quoteIndex == lastQuoteIndex || input.IndexOf('\'', quoteIndex + 1) != lastQuoteIndex)
        {
            return false;
        }
        /*string*/ let encodingString = input.Substring(0, quoteIndex);
        /*string*/ let dataString = input.Substring(lastQuoteIndex + 1);
        /*StringBuilder*/ let decoded = new StringBuilder();
        {
            /*Encoding*/ let encoding = Encoding.GetEncoding(encodingString);
            /*byte[]*/ let unescapedBytes = new Array(dataString.Length);
            /*int*/ let unescapedBytesCount = 0;
            for(/*int*/ let index = 0; index < dataString.Length; index++)
            {
                if (UriExtension.IsHexEncoding(dataString, index))
                {
                    // Unescape and cache bytes, multi-byte characters must be decoded all at once.
                    let $v = { value: set(value){ index = value; } };
                        unescapedBytesunescapedBytesCount++ = UriExtension.HexUnescape(dataString, $v);
                    index--;
                }
                else 
                {
                    if (unescapedBytesCount > 0)
                    {
                        // Decode any previously cached bytes.
                            decoded.Append(encoding.GetString(unescapedBytes, 0, unescapedBytesCount));
                        unescapedBytesCount = 0;
                    }
                    decoded.Append(dataStringindex);
                }
            });
            if (unescapedBytesCount > 0)
            {
                // Decode any previously cached bytes.
                    decoded.Append(encoding.GetString(unescapedBytes, 0, unescapedBytesCount));
            }
        }
ArgumentException        {
            return false;
        }
        output = decoded.ToString();
        return true;
    }
}

class System_Net_Http_Headers_ContentRangeHeaderValue extends H5_IH5Class(System_ICloneable(object))
{
    /*string*/ _unit = null;
    /*long*/ _from = null;
    /*long*/ _to = null;
    /*long*/ _length = null;
    /*string*/ get Unit()
    {
        return _unit;
    }
    /*string*/ set Unit(value)
    {
        HeaderUtilities.CheckValidToken(value);
        _unit = value;
    }
    /*long?*/ get From()
    {
        return HasRange_fromnull;
    }
    /*long?*/ get To()
    {
        return HasRange_tonull;
    }
    /*long?*/ get Length()
    {
        return HasLength_lengthnull;
    }
    /*bool*/ get HasLength()
    {
        return _length >= 0;
    }
    /*bool*/ get HasRange()
    {
        return _from >= 0;
    }
    constructor(/*long*/ from, /*long*/ to, /*long*/ length)
    {
        super();
        if (length < 0)
        throw new ArgumentOutOfRangeException(nameof(length));
        if (to < 0)
        throw new ArgumentOutOfRangeException(nameof(to));
        if (from < 0)
        throw new ArgumentOutOfRangeException(nameof(from));
        if (from > to)
        throw new ArgumentOutOfRangeException(nameof(from));
        if (to > length)
        throw new ArgumentOutOfRangeException(nameof(to));
        _from = from;
        _to = to;
        _length = length;
        _unit = HeaderUtilities.BytesUnit;
    }
    constructor(/*long*/ length)
    {
        super();
        if (length < 0)
        throw new ArgumentOutOfRangeException(nameof(length));
        _length = length;
        _unit = HeaderUtilities.BytesUnit;
        _from = 1;
    }
    constructor(/*long*/ from, /*long*/ to)
    {
        super();
        if (to < 0)
        throw new ArgumentOutOfRangeException(nameof(to));
        if (from < 0)
        throw new ArgumentOutOfRangeException(nameof(from));
        if (from > to)
        throw new ArgumentOutOfRangeException(nameof(from));
        _from = from;
        _to = to;
        _unit = HeaderUtilities.BytesUnit;
        _length = 1;
    }
    constructor()
    {
        super();
        _from = 1;
        _length = 1;
    }
    constructor(/*ContentRangeHeaderValue*/ source)
    {
        super();
        Debug.Assert(source != null);
        _from = source._from;
        _to = source._to;
        _length = source._length;
        _unit = source._unit;
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        obj instanceof ContentRangeHeaderValue, other = obj && _from == other._from  && _to == other._to  && _length == other._length  && .Equals(_unit, other._unit, StringComparison.OrdinalIgnoreCase);
    }
    /*int*/ GetHashCode()
    {
        HashCode.Combine(StringComparer.OrdinalIgnoreCase.GetHashCode(_unit), _from, _to, _length);
    }
    /*string*/ ToString()
    {
        /*var*/ let sb = new StringBuilder(256);
        sb.Append(_unit);
        sb.Append(' ');
        if (HasRange)
        {
            sb.Append(_from);
            sb.Append('-');
            sb.Append(_to);
        }
        else 
        {
            sb.Append('*');
        }
        sb.Append('/');
        if (HasLength)
        {
            sb.Append(_length);
        }
        else 
        {
            sb.Append('*');
        }
        return sb.ToString();
    }
    /*ContentRangeHeaderValue*/ Parse(/*string*/ input)
    {
        /*int*/ let index = 0;
        let $v = { value: set(value){ index = value; } };
        return ContentRangeHeaderValueGenericHeaderParser.ContentRangeParser.ParseValue(input, null, $v);
    }
    /*bool*/ TryParse(/*string*/ input, /*ContentRangeHeaderValue*/ parsedValue)
    {
        /*int*/ let index = 0;
        parsedValue = null;
        let $v = { value: set(value){ index = value; } };
        let output = null;
        let $v = { value: set(value){ output = value; } };
        if (GenericHeaderParser.ContentRangeParser.TryParseValue(input, null, $v, $v))
        {
            parsedValue = ContentRangeHeaderValueoutput;
            return true;
        }
        return false;
    }
    /*int*/ GetContentRangeLength(/*string*/ input, /*int*/ startIndex, /*object*/ parsedValue)
    {
        Debug.Assert(startIndex >= 0);
        parsedValue = null;
        if (.IsNullOrEmpty(input) || startIndex >= input.Length)
        {
            return 0;
        }
        /*// Parse the unit string: <unit> in '<unit> <from>-<to>/<length>'
            int*/ let unitLength = HttpRuleParser.GetTokenLength(input, startIndex);
        if (unitLength == 0)
        {
            return 0;
        }
        /*string*/ let unit = input.Substring(startIndex, unitLength);
        /*int*/ let current = startIndex + unitLength;
        /*int*/ let separatorLength = HttpRuleParser.GetWhitespaceLength(input, current);
        if (separatorLength == 0)
        {
            return 0;
        }
        current += separatorLength;
        if (current == input.Length)
        {
            return 0;
        }
        /*// Read range values <from> and <to> in '<unit> <from>-<to>/<length>'
            int*/ let fromStartIndex = current;
        /*int*/ let fromLength;
        /*int*/ let toStartIndex;
        /*int*/ let toLength;
        let $v = { value: set(value){ current = value; } };
        let $v = { value: set(value){ fromLength = value; } };
        let $v = { value: set(value){ toStartIndex = value; } };
        let $v = { value: set(value){ toLength = value; } };
        if (TryGetRangeLength(input, $v, $v, $v, $v))
        {
            return 0;
        }
        if (current == input.Length || inputcurrent != '/')
        {
            return 0;
        }
        current++;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        if (current == input.Length)
        {
            return 0;
        }
        /*// We may not have a length (e.g. 'bytes 1-2/*'). But if we do, parse the length now.
            int*/ let lengthStartIndex = current;
        /*int*/ let lengthLength;
        let $v = { value: set(value){ current = value; } };
        let $v = { value: set(value){ lengthLength = value; } };
        if (TryGetLengthLength(input, $v, $v))
        {
            return 0;
        }
        let $v = { value: set(value){ parsedValue = value; } };
        if (TryCreateContentRange(input, unit, fromStartIndex, fromLength, toStartIndex, toLength, lengthStartIndex, lengthLength, $v))
        {
            return 0;
        }
        return current - startIndex;
    }
    /*bool*/ TryGetLengthLength(/*string*/ input, /*int*/ current, /*int*/ lengthLength)
    {
        lengthLength = 0;
        if (inputcurrent == '*')
        {
            current++;
        }
        else 
        {
            // Parse length value: <length> in '<unit> <from>-<to>/<length>'
                lengthLength = HttpRuleParser.GetNumberLength(input, current, false);
            if (lengthLength == 0 || lengthLength > HttpRuleParser.MaxInt64Digits)
            {
                return false;
            }
            current += lengthLength;
        }
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        return true;
    }
    /*bool*/ TryGetRangeLength(/*string*/ input, /*int*/ current, /*int*/ fromLength, /*int*/ toStartIndex, /*int*/ toLength)
    {
        fromLength = 0;
        toStartIndex = 0;
        toLength = 0;
        if (inputcurrent == '*')
        {
            current++;
        }
        else 
        {
            // Parse first range value: <from> in '<unit> <from>-<to>/<length>'
                fromLength = HttpRuleParser.GetNumberLength(input, current, false);
            if (fromLength == 0 || fromLength > HttpRuleParser.MaxInt64Digits)
            {
                return false;
            }
            current += fromLength;
            current += HttpRuleParser.GetWhitespaceLength(input, current);
            if (current == input.Length || inputcurrent != '-')
            {
                return false;
            }
            current++;
            current += HttpRuleParser.GetWhitespaceLength(input, current);
            if (current == input.Length)
            {
                return false;
            }
            // Parse second range value: <to> in '<unit> <from>-<to>/<length>'
                toStartIndex = current;
            toLength = HttpRuleParser.GetNumberLength(input, current, false);
            if (toLength == 0 || toLength > HttpRuleParser.MaxInt64Digits)
            {
                return false;
            }
            current += toLength;
        }
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        return true;
    }
    /*bool*/ TryCreateContentRange(/*string*/ input, /*string*/ unit, /*int*/ fromStartIndex, /*int*/ fromLength, /*int*/ toStartIndex, /*int*/ toLength, /*int*/ lengthStartIndex, /*int*/ lengthLength, /*object*/ parsedValue)
    {
        parsedValue = null;
        /*long*/ let from = 0;
        let $v = { value: set(value){ from = value; } };
        if (fromLength > 0 && HeaderUtilities.TryParseInt64(input, fromStartIndex, fromLength, $v))
        {
            return false;
        }
        /*long*/ let to = 0;
        let $v = { value: set(value){ to = value; } };
        if (toLength > 0 && HeaderUtilities.TryParseInt64(input, toStartIndex, toLength, $v))
        {
            return false;
        }
        if (fromLength > 0 && toLength > 0 && from > to)
        {
            return false;
        }
        /*long*/ let length = 0;
        let $v = { value: set(value){ length = value; } };
        if (lengthLength > 0 && HeaderUtilities.TryParseInt64(input, lengthStartIndex, lengthLength, $v))
        {
            return false;
        }
        if (toLength > 0 && lengthLength > 0 && to >= length)
        {
            return false;
        }
        /*ContentRangeHeaderValue*/ let result = new ContentRangeHeaderValue();
        result._unit  = unit;
        if (fromLength > 0)
        {
            result._from  = from;
            result._to  = to;
        }
        if (lengthLength > 0)
        {
            result._length  = length;
        }
        parsedValue = result;
        return true;
    }
    /*object*/ Clone()
    {
        return new ContentRangeHeaderValue();
    }
}

class System_Net_Http_Headers_CookieHeaderParser extends System_Net_Http_Headers_HttpHeaderParser
{
    /*CookieHeaderParser*/ Parser = new CookieHeaderParser();
    constructor()
    {
        super(true, "; ");
    }
    /*bool*/ TryParseValue(/*string*/ value, /*object*/ storeValue, /*int*/ index, /*object*/ parsedValue)
    {
        if (.IsNullOrEmpty(value) || index == value.Length)
        {
            parsedValue = null;
            return false;
        }
        parsedValue = value;
        index = value.Length;
        return true;
    }
}

class System_Net_Http_Headers_DateHeaderParser extends System_Net_Http_Headers_HttpHeaderParser
{
    /*DateHeaderParser*/ Parser = new DateHeaderParser();
    constructor()
    {
        super(false);
    }
    /*string*/ ToString(/*object*/ value)
    {
        Debug.Assert(value is DateTimeOffset);
        return DateTimeOffsetvalue.ToString("r");
    }
    /*bool*/ TryParseValue(/*string*/ value, /*object*/ storeValue, /*int*/ index, /*object*/ parsedValue)
    {
        parsedValue = null;
        if (.IsNullOrEmpty(value) || index == value.Length)
        {
            return false;
        }
        /*ReadOnlySpan<char>*/ let dateString = value.AsSpan();
        if (index > 0)
        {
            dateString = value.AsSpan(index);
        }
        /*DateTimeOffset*/ let date;
        let $v = { value: set(value){ date = value; } };
        if (DateTimeOffset.TryParse(dateString, $v))
        {
            return false;
        }
        index = value.Length;
        parsedValue = date;
        return true;
    }
}

class System_Net_Http_Headers_EntityTagHeaderValue extends H5_IH5Class(System_ICloneable(object))
{
    /*string*/ _backingField_Tag = null;
    /*string*/ get Tag()
    {
        return _backingField_Tag;
    }
    /*string*/ set Tag(value)
    {
        _backingField_Tag = value;
    }
    /*bool*/ _backingField_IsWeak = null;
    /*bool*/ get IsWeak()
    {
        return _backingField_IsWeak;
    }
    /*bool*/ set IsWeak(value)
    {
        _backingField_IsWeak = value;
    }
    /*EntityTagHeaderValue*/ _backingField_Any = null;
    /*EntityTagHeaderValue*/ get Any()
    {
        return _backingField_Any;
    }
    constructor(/*string*/ tag, /*bool*/ isWeak, /*bool*/ _)
    {
        super();
        #if DEBUG
            // This constructor should only be used with already validated values.
            // "*" is a special case that can only be created via the static Any property.
            if (tag != "*")
            {
                new EntityTagHeaderValue(tag, isWeak);
            }
#endif
            Tag = tag;
        IsWeak = isWeak;
    }
    constructor(/*string*/ tag)
    {
        super(tag, false);
    }
    constructor(/*string*/ tag, /*bool*/ isWeak)
    {
        super();
        HeaderUtilities.CheckValidQuotedString(tag);
        Tag = tag;
        IsWeak = isWeak;
    }
    constructor(/*EntityTagHeaderValue*/ source)
    {
        super();
        Debug.Assert(source != null);
        Tag = source.Tag;
        IsWeak = source.IsWeak;
    }
    /*string*/ ToString()
    {
        IsWeakTagTag;
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        obj instanceof EntityTagHeaderValue, other = obj && IsWeak == other.IsWeak  && .Equals(Tag, other.Tag, StringComparison.Ordinal);
    }
    /*int*/ GetHashCode()
    {
        HashCode.Combine(Tag, IsWeak);
    }
    /*EntityTagHeaderValue*/ Parse(/*string*/ input)
    {
        /*int*/ let index = 0;
        let $v = { value: set(value){ index = value; } };
        return EntityTagHeaderValueGenericHeaderParser.SingleValueEntityTagParser.ParseValue(input, null, $v);
    }
    /*bool*/ TryParse(/*string*/ input, /*EntityTagHeaderValue*/ parsedValue)
    {
        /*int*/ let index = 0;
        parsedValue = null;
        let $v = { value: set(value){ index = value; } };
        let output = null;
        let $v = { value: set(value){ output = value; } };
        if (GenericHeaderParser.SingleValueEntityTagParser.TryParseValue(input, null, $v, $v))
        {
            parsedValue = EntityTagHeaderValueoutput;
            return true;
        }
        return false;
    }
    /*int*/ GetEntityTagLength(/*string*/ input, /*int*/ startIndex, /*EntityTagHeaderValue*/ parsedValue)
    {
        Debug.Assert(startIndex >= 0);
        parsedValue = null;
        if (.IsNullOrEmpty(input) || startIndex >= input.Length)
        {
            return 0;
        }
        /*// Caller must remove leading whitespace. If not, we'll return 0.
            bool*/ let isWeak = false;
        /*int*/ let current = startIndex;
        /*char*/ let firstChar = inputstartIndex;
        if (firstChar == '*')
        {
            // We have '*' value, indicating "any" ETag.
                parsedValue = Any;
            current++;
        }
        else 
        {
            if (firstChar == 'W' || firstChar == 'w')
            {
                current++;
                if (current + 2 >= input.Length || inputcurrent != '/')
                {
                    return 0;
                }
                isWeak = true;
                current++;
                current += HttpRuleParser.GetWhitespaceLength(input, current);
            }
            let tagLength = null;
            let $v = { value: set(value){ tagLength = value; } };
            if (current == input.Length  || HttpRuleParser.GetQuotedStringLength(input, current, $v) != HttpParseResult.Parsed)
            {
                return 0;
            }
            // Most of the time we'll have strong ETags without leading/trailing whitespace.
                Debug.Assert(tagLength != input.Length  || startIndex == 0 && isWeak);
            parsedValue = new EntityTagHeaderValue(input.Substring(current, tagLength), isWeak, false);
            current += tagLength;
        }
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        return current - startIndex;
    }
    /*object*/ Clone()
    {
        ReferenceEquals(, Any)Anynew EntityTagHeaderValue();
    }
}

class System_Net_Http_Headers_GenericHeaderParser extends System_Net_Http_Headers_BaseHeaderParser
{
    /*GenericHeaderParser*/ HostParser = new GenericHeaderParser(false, ParseHost/*, StringComparer.OrdinalIgnoreCase*/);
    /*GenericHeaderParser*/ TokenListParser = new GenericHeaderParser(true, ParseTokenList/*, StringComparer.OrdinalIgnoreCase*/);
    /*GenericHeaderParser*/ SingleValueNameValueWithParametersParser = new GenericHeaderParser(false, NameValueWithParametersHeaderValue.GetNameValueWithParametersLength);
    /*GenericHeaderParser*/ MultipleValueNameValueWithParametersParser = new GenericHeaderParser(true, NameValueWithParametersHeaderValue.GetNameValueWithParametersLength);
    /*GenericHeaderParser*/ SingleValueNameValueParser = new GenericHeaderParser(false, ParseNameValue);
    /*GenericHeaderParser*/ MultipleValueNameValueParser = new GenericHeaderParser(true, ParseNameValue);
    /*GenericHeaderParser*/ SingleValueParserWithoutValidation = new GenericHeaderParser(false, ParseWithoutValidation);
    /*GenericHeaderParser*/ SingleValueProductParser = new GenericHeaderParser(false, ParseProduct);
    /*GenericHeaderParser*/ MultipleValueProductParser = new GenericHeaderParser(true, ParseProduct);
    /*GenericHeaderParser*/ RangeConditionParser = new GenericHeaderParser(false, RangeConditionHeaderValue.GetRangeConditionLength);
    /*GenericHeaderParser*/ SingleValueAuthenticationParser = new GenericHeaderParser(false, AuthenticationHeaderValue.GetAuthenticationLength);
    /*GenericHeaderParser*/ MultipleValueAuthenticationParser = new GenericHeaderParser(true, AuthenticationHeaderValue.GetAuthenticationLength);
    /*GenericHeaderParser*/ RangeParser = new GenericHeaderParser(false, RangeHeaderValue.GetRangeLength);
    /*GenericHeaderParser*/ RetryConditionParser = new GenericHeaderParser(false, RetryConditionHeaderValue.GetRetryConditionLength);
    /*GenericHeaderParser*/ ContentRangeParser = new GenericHeaderParser(false, ContentRangeHeaderValue.GetContentRangeLength);
    /*GenericHeaderParser*/ ContentDispositionParser = new GenericHeaderParser(false, ContentDispositionHeaderValue.GetDispositionTypeLength);
    /*GenericHeaderParser*/ SingleValueStringWithQualityParser = new GenericHeaderParser(false, StringWithQualityHeaderValue.GetStringWithQualityLength);
    /*GenericHeaderParser*/ MultipleValueStringWithQualityParser = new GenericHeaderParser(true, StringWithQualityHeaderValue.GetStringWithQualityLength);
    /*GenericHeaderParser*/ SingleValueEntityTagParser = new GenericHeaderParser(false, ParseSingleEntityTag);
    /*GenericHeaderParser*/ MultipleValueEntityTagParser = new GenericHeaderParser(true, ParseMultipleEntityTags);
    /*GenericHeaderParser*/ SingleValueViaParser = new GenericHeaderParser(false, ViaHeaderValue.GetViaLength);
    /*GenericHeaderParser*/ MultipleValueViaParser = new GenericHeaderParser(true, ViaHeaderValue.GetViaLength);
    /*GenericHeaderParser*/ SingleValueWarningParser = new GenericHeaderParser(false, WarningHeaderValue.GetWarningLength);
    /*GenericHeaderParser*/ MultipleValueWarningParser = new GenericHeaderParser(true, WarningHeaderValue.GetWarningLength);
    /*GetParsedValueLengthDelegate*/ _getParsedValueLength = null;
    /*IEqualityComparer*/ _comparer = null;
    /*IEqualityComparer*/ get Comparer()
    {
        return _comparer;
    }
    constructor(/*bool*/ supportsMultipleValues, /*GetParsedValueLengthDelegate*/ getParsedValueLength)
    {
        super(supportsMultipleValues, getParsedValueLength, null);
    }
    constructor(/*bool*/ supportsMultipleValues, /*GetParsedValueLengthDelegate*/ getParsedValueLength, /*IEqualityComparer*/ comparer)
    {
        super(supportsMultipleValues);
        Debug.Assert(getParsedValueLength != null);
        _getParsedValueLength = getParsedValueLength;
        _comparer = comparer;
    }
    /*int*/ GetParsedValueLength(/*string*/ value, /*int*/ startIndex, /*object*/ storeValue, /*object*/ parsedValue)
    {
        let $v = { value: set(value){ parsedValue = value; } };
        return _getParsedValueLength(value, startIndex, $v);
    }
    /*int*/ ParseNameValue(/*string*/ value, /*int*/ startIndex, /*object*/ parsedValue)
    {
        let temp = null;
        let $v = { value: set(value){ temp = value; } };
        /*int*/ let resultLength = NameValueHeaderValue.GetNameValueLength(value, startIndex, $v);
        parsedValue = temp;
        return resultLength;
    }
    /*int*/ ParseProduct(/*string*/ value, /*int*/ startIndex, /*object*/ parsedValue)
    {
        let temp = null;
        let $v = { value: set(value){ temp = value; } };
        /*int*/ let resultLength = ProductHeaderValue.GetProductLength(value, startIndex, $v);
        parsedValue = temp;
        return resultLength;
    }
    /*int*/ ParseSingleEntityTag(/*string*/ value, /*int*/ startIndex, /*object*/ parsedValue)
    {
        parsedValue = null;
        let temp = null;
        let $v = { value: set(value){ temp = value; } };
        /*int*/ let resultLength = EntityTagHeaderValue.GetEntityTagLength(value, startIndex, $v);
        if (temp == EntityTagHeaderValue.Any)
        {
            return 0;
        }
        parsedValue = temp;
        return resultLength;
    }
    /*int*/ ParseMultipleEntityTags(/*string*/ value, /*int*/ startIndex, /*object*/ parsedValue)
    {
        let temp = null;
        let $v = { value: set(value){ temp = value; } };
        /*int*/ let resultLength = EntityTagHeaderValue.GetEntityTagLength(value, startIndex, $v);
        parsedValue = temp;
        return resultLength;
    }
    /*int*/ ParseWithoutValidation(/*string*/ value, /*int*/ startIndex, /*object*/ parsedValue)
    {
        if (HttpRuleParser.ContainsNewLine(value, startIndex))
        {
            parsedValue = null;
            return 0;
        }
        /*string*/ let result = value.Substring(startIndex);
        parsedValue = result;
        return result.Length;
    }
    /*int*/ ParseHost(/*string*/ value, /*int*/ startIndex, /*object*/ parsedValue)
    {
        /*int*/ let hostLength = HttpRuleParser.GetHostLength(value, startIndex, false);
        parsedValue = value.Substring(startIndex, hostLength);
        return hostLength;
    }
    /*int*/ ParseTokenList(/*string*/ value, /*int*/ startIndex, /*object*/ parsedValue)
    {
        /*int*/ let resultLength = HttpRuleParser.GetTokenLength(value, startIndex);
        parsedValue = value.Substring(startIndex, resultLength);
        return resultLength;
    }
}

class System_Net_Http_Headers_HeaderDescriptor extends H5_IH5Class(System_IEquatable<System_Net_Http_Headers_HeaderDescriptor>(System_ValueType))
{
    /*object*/ _descriptor = null;
    constructor(/*KnownHeader*/ knownHeader)
    {
        super();
        _descriptor = knownHeader;
    }
    constructor(/*string*/ headerName, /*bool*/ customHeader)
    {
        super();
        Debug.Assert(customHeader || KnownHeaders.TryGetKnownHeader(headerName), nameof(KnownHeader)headerName);
        _descriptor = headerName;
    }
    /*string*/ get Name()
    {
        return _descriptor instanceof KnownHeader, header = _descriptorheader.Name _descriptor as ;
    }
    /*HttpHeaderParser*/ get Parser()
    {
        return _descriptor as KnownHeaderParser;
    }
    /*HttpHeaderType*/ get HeaderType()
    {
        return _descriptor instanceof KnownHeader, knownHeader = _descriptorknownHeader.HeaderType HttpHeaderType.Custom;
    }
    /*KnownHeader*/ get KnownHeader()
    {
        return _descriptor as KnownHeader;
    }
    /*bool*/ Equals(/*KnownHeader*/ other)
    {
        ReferenceEquals(_descriptor, other);
    }
    /*bool*/ Equals(/*HeaderDescriptor*/ other)
    {
        if (_descriptor instanceof , headerName = _descriptor)
        {
            return .Equals(headerName, other._descriptor  as , StringComparison.OrdinalIgnoreCase);
        }
        else 
        {
            return ReferenceEquals(_descriptor, other._descriptor);
        }
    }
    /*int*/ GetHashCode()
    {
        _descriptor instanceof KnownHeader, knownHeader = _descriptorknownHeader.GetHashCode()StringComparer.OrdinalIgnoreCase.GetHashCode(_descriptor);
    }
    /*bool*/ Equals(/*object*/ obj)
    {
                throw new InvalidOperationException();
;
    }
    /*bool*/ TryGet(/*string*/ headerName, /*HeaderDescriptor*/ descriptor)
    {
        Debug.Assert(.IsNullOrEmpty(headerName));
        /*KnownHeader*/ let knownHeader = KnownHeaders.TryGetKnownHeader(headerName);
        if (knownHeader != null)
        {
            descriptor = new HeaderDescriptor(knownHeader);
            return true;
        }
        if (HttpRuleParser.IsToken(headerName.AsSpan()))
        {
            descriptor = HeaderDescriptor;
            return false;
        }
        descriptor = new HeaderDescriptor(headerName);
        return true;
    }
    /*bool*/ TryGet(/*ReadOnlySpan<byte>*/ headerName, /*HeaderDescriptor*/ descriptor)
    {
        Debug.Assert(headerName.Length  > 0);
        /*KnownHeader*/ let knownHeader = KnownHeaders.TryGetKnownHeader(headerName);
        if (knownHeader != null)
        {
            descriptor = new HeaderDescriptor(knownHeader);
            return true;
        }
        if (HttpRuleParser.IsToken(headerName))
        {
            descriptor = HeaderDescriptor;
            return false;
        }
        descriptor = new HeaderDescriptor(HttpRuleParser.GetTokenString(headerName));
        return true;
    }
    /*bool*/ TryGetStaticQPackHeader(/*int*/ index, /*HeaderDescriptor*/ descriptor, /*string*/ knownValue)
    {
        Debug.Assert(index >= 0);
        /*// Micro-opt: store field to variable to prevent Length re-read and use unsigned to avoid bounds check.
            (HeaderDescriptor descriptor, string value)[]*/ let qpackStaticTable = QPackStaticTable.HeaderLookup;
        Debug.Assert(qpackStaticTable.Length  == 99);
        /*uint*/ let uindex = index;
        if (uindex < qpackStaticTable.Length)
        {
            descriptorknownValue = qpackStaticTableuindex;
            return true;
        }
        else 
        {
            descriptor = default;
            knownValue = null;
            return false;
        }
    }
    /*HeaderDescriptor*/ AsCustomHeader()
    {
        Debug.Assert(_descriptor is KnownHeader);
        Debug.Assert(HeaderType != HttpHeaderType.Custom);
        return new HeaderDescriptor(Name, { customHeader : true });
    }
    /*string*/ GetHeaderValue(/*ReadOnlySpan<byte>*/ headerValue, /*Encoding*/ valueEncoding)
    {
        if (headerValue.Length  == 0)
        {
            return .Empty;
        }
        if (_descriptor instanceof KnownHeader, knownHeader = _descriptor)
        {
            if (knownHeader.KnownValues  instanceof )
            {
                for(/*int*/ let i = 0; i < knownValues.Length; i++)
                {
                    if (Ascii.Equals(headerValue, knownValuesi))
                    {
                        return knownValuesi;
                    }
                });
            }
            if (knownHeader == KnownHeaders.ContentType)
            {
                /*string*/ let contentType = GetKnownContentType(headerValue);
                if (contentType != null)
                {
                    return contentType;
                }
            }
            else if (knownHeader == KnownHeaders.Location)
            {
                let decoded = null;
                let $v = { value: set(value){ decoded = value; } };
                if (valueEncoding && TryDecodeUtf8(headerValue, $v))
                {
                    return decoded;
                }
            }
        }
        return valueEncoding ?? HttpRuleParser.DefaultHttpEncoding.GetString(headerValue.ToArray());
    }
    /*string*/ GetKnownContentType(/*ReadOnlySpan<byte>*/ contentTypeValue)
    {
        /*string*/ let candidate = null;
        switch(contentTypeValue.Length)
        {
            case 8:
            {
                switch(contentTypeValue7)
                {
                    case 'l':
                    {
                        candidate = "text/xml";
                        break;
                    }
                    case 's':
                    {
                        candidate = "text/css";
                        break;
                    }
                    case 'v':
                    {
                        candidate = "text/csv";
                        break;
                    }
                }
                break;
            }
            case 9:
            {
                switch(contentTypeValue6)
                {
                    case 'g':
                    {
                        candidate = "image/gif";
                        break;
                    }
                    case 'p':
                    {
                        candidate = "image/png";
                        break;
                    }
                    case 't':
                    {
                        candidate = "text/html";
                        break;
                    }
                }
                break;
            }
            case 10:
            {
                switch(contentTypeValue0)
                {
                    case 't':
                    {
                        candidate = "text/plain";
                        break;
                    }
                    case 'i':
                    {
                        candidate = "image/jpeg";
                        break;
                    }
                }
                break;
            }
            case 15:
            {
                switch(contentTypeValue12)
                {
                    case 'p':
                    {
                        candidate = "application/pdf";
                        break;
                    }
                    case 'x':
                    {
                        candidate = "application/xml";
                        break;
                    }
                    case 'z':
                    {
                        candidate = "application/zip";
                        break;
                    }
                }
                break;
            }
            case 16:
            {
                switch(contentTypeValue12)
                {
                    case 'g':
                    {
                        candidate = "application/grpc";
                        break;
                    }
                    case 'j':
                    {
                        candidate = "application/json";
                        break;
                    }
                }
                break;
            }
            case 19:
            {
                candidate = "multipart/form-data";
                break;
            }
            case 22:
            {
                candidate = "application/javascript";
                break;
            }
            case 24:
            {
                switch(contentTypeValue19)
                {
                    case 't':
                    {
                        candidate = "application/octet-stream";
                        break;
                    }
                    case 'u':
                    {
                        candidate = "text/html; charset=utf-8";
                        break;
                    }
                    case 'U':
                    {
                        candidate = "text/html; charset=UTF-8";
                        break;
                    }
                }
                break;
            }
            case 25:
            {
                candidate = "text/plain; charset=utf-8";
                break;
            }
            case 31:
            {
                candidate = "application/json; charset=utf-8";
                break;
            }
            case 33:
            {
                candidate = "application/x-www-form-urlencoded";
                break;
            }
        }
        Debug.Assert(candidate || candidate.Length  == contentTypeValue.Length);
        return candidate != null && Ascii.Equals(contentTypeValue, candidate)candidatenull;
    }
    /*bool*/ TryDecodeUtf8(/*ReadOnlySpan<byte>*/ input, /*string*/ decoded)
    {
        /*char[]*/ let rented = ArrayPool_$1.Shared.Rent(input.Length);
        {
            let $v = { value: set(value){ _ = value; } };
            let charsWritten = null;
            let $v = { value: set(value){ charsWritten = value; } };
            if (Utf8.ToUtf16(input, rented, $v, $v, { replaceInvalidSequences : false }) == OperationStatus.Done)
            {
                decoded = new (rented, 0, charsWritten);
                return true;
            }
        }
        {
            ArrayPool_$1.Shared.Return(rented);
        }
        decoded = null;
        return false;
    }
    /*string*/ get Separator()
    {
        return ParserSeparator ?? HttpHeaderParser.DefaultSeparator;
    }
    /*byte[]*/ get SeparatorBytes()
    {
        return ParserSeparatorBytes ?? HttpHeaderParser.DefaultSeparatorBytes;
    }
}

class System_Net_Http_Headers_HeaderStringValues extends H5_IH5Class(System_Collections_IEnumerable(System_Collections_Generic_IEnumerable<string>(System_Collections_Generic_IReadOnlyCollection<string>(System_ValueType))))
{
    /*HeaderDescriptor*/ _header = null;
    /*object*/ _value = null;
    constructor(/*HeaderDescriptor*/ descriptor, /*string*/ value)
    {
        super();
        _header = descriptor;
        _value = value;
    }
    constructor(/*HeaderDescriptor*/ descriptor, /*string[]*/ values)
    {
        super();
        _header = descriptor;
        _value = values;
    }
    /*int*/ get Count()
    {
        switch(_value)
        {
            {
                return 1;
            }
            {
                return ss.Length;
            }
        }
        return 0;
    }
    /*string*/ ToString()
    {
        switch(_value)
        {
            {
                return value;
            }
            {
                return .Join(_header.Separator, values);
            }
        }
        return .Empty;
    }
    /*Enumerator*/ GetEnumerator()
    {
        new Enumerator(_value);
    }
    /*/// <inheritdoc/>
        IEnumerator<string>*/ GetEnumerator()
    {
        GetEnumerator();
    }
    /*/// <inheritdoc/>
        IEnumerator*/ GetEnumerator()
    {
        GetEnumerator();
    }
    class System_Net_Http_Headers_Enumerator extends System_Collections_IEnumerator(System_IDisposable(System_Collections_Generic_IEnumerator<string>(System_ValueType)))
    {
        /*string[]*/ _values = null;
        /*string*/ _current = null;
        /*int*/ _index = null;
        constructor(/*object*/ value)
        {
            super();
            if (value instanceof , s = value)
            {
                _values = null;
                _current = s;
            }
            else 
            {
                _values = value as ;
                _current = null;
            }
            _index = 0;
        }
        /*bool*/ MoveNext()
        {
            /*int*/ let index = _index;
            if (index < 0)
            {
                return false;
            }
            /*string[]*/ let values = _values;
            if (values != null)
            {
                if (index < values.Length)
                {
                    _index = index + 1;
                    _current = valuesindex;
                    return true;
                }
                _index = 1;
                return false;
            }
            _index = 1;
            return _current != null;
        }
        /*string*/ get Current()
        {
            return _current;
        }
        /*/// <inheritdoc/>
            object*/ get Current()
        {
            return Current;
        }
        /*void*/ Dispose()
        {
        }
        /*/// <inheritdoc/>
            void*/ Reset()
        {
                        throw new NotSupportedException();
;
        }
    }
}

class System_Net_Http_Headers_HeaderUtilities extends object
{
    constructor()
    {
        super();
    }
    /*string*/ qualityName = "q";
    /*string*/ ConnectionClose = "close";
    /*TransferCodingHeaderValue*/ TransferEncodingChunked = new TransferCodingHeaderValue("chunked");
    /*NameValueWithParametersHeaderValue*/ ExpectContinue = new NameValueWithParametersHeaderValue("100-continue");
    /*string*/ BytesUnit = "bytes";
    /*string*/ s_rfc5987AttrBytes = "!#$&+-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ^_`abcdefghijklmnopqrstuvwxyz|~";
    /*void*/ SetQuality(/*UnvalidatedObjectCollection<NameValueHeaderValue>*/ parameters, /*double?*/ value)
    {
        Debug.Assert(parameters != null);
        /*NameValueHeaderValue*/ let qualityParameter = NameValueHeaderValue.Find(parameters, qualityName);
        if (value.HasValue)
        {
            /*// Note that even if we check the value here, we can't prevent a user from adding an invalid quality
                // value using Parameters.Add(). Even if we would prevent the user from adding an invalid value
                // using Parameters.Add() they could always add invalid values using HttpHeaders.AddWithoutValidation().
                // So this check is really for convenience to show users that they're trying to add an invalid
                // value.
                double*/ let d = value.GetValueOrDefault();
            if (d < 0 || d > 1)
            throw new ArgumentOutOfRangeException();
            /*string*/ let qualityString = d.ToString("0.0##", NumberFormatInfo.InvariantInfo);
            if (qualityParameter != null)
            {
                qualityParameter.Value  = qualityString;
            }
            else 
            {
                parameters.Add(new NameValueHeaderValue(qualityName, qualityString));
            }
        }
        else 
        {
            if (qualityParameter != null)
            {
                parameters.Remove(qualityParameter);
            }
        }
    }
    /*string*/ Encode5987(/*string*/ input)
    {
        /*var*/ let builder = new StringBuilder(256);
        /*byte[]*/ let utf8bytes = ArrayPool_$1.Shared.Rent(Encoding.UTF8.GetMaxByteCount(input.Length));
        /*int*/ let utf8length = Encoding.UTF8.GetBytes(input, 0, input.Length, utf8bytes, 0);
        builder.Append("utf-8\'\'");
        /*ReadOnlySpan<byte>*/ let utf8 = utf8bytes.AsReadOnlySpan(0, utf8length);
        do        {
            /*int*/ let length = utf8.IndexOfAnyExcept(Encoding.ASCII.GetBytes(s_rfc5987AttrBytes));
            if (length < 0)
            {
                length = utf8.Length;
            }
            BlazorJs.forEach(utf8.Slice(0, length), function(b, $_i)
            {
                builder.Append(b);
            });
            //Encoding.ASCII.GetChars(utf8.Slice(0, length), builder.AppendSpan(length));
                utf8 = utf8.Slice(length);
            if (utf8.IsEmpty)
            {
                break;
            }
            length = utf8.IndexOfAny(Encoding.ASCII.GetBytes(s_rfc5987AttrBytes));
            if (length < 0)
            {
                length = utf8.Length;
            }
            BlazorJs.forEach(utf8.Slice(0, length), function(b, $_i)
            {
                let $v = { value: set(value){ builder = value; } };
                AddHexEscaped(b, $v);
            });
            utf8 = utf8.Slice(length);
        } while(utf8.IsEmpty);
        ArrayPool_$1.Shared.Return(utf8bytes);
        return builder.ToString();
    }
    /*void*/ AddHexEscaped(/*byte*/ c, /*StringBuilder*/ destination)
    {
        destination.Append('%');
        destination.Append(HexConverter.ToCharUpper(c >> 4));
        destination.Append(HexConverter.ToCharUpper(c));
    }
    /*double?*/ GetQuality(/*UnvalidatedObjectCollection<NameValueHeaderValue>*/ parameters)
    {
        Debug.Assert(parameters != null);
        /*NameValueHeaderValue*/ let qualityParameter = NameValueHeaderValue.Find(parameters, qualityName);
        if (qualityParameter != null)
        {
            /*// Note that the RFC requires decimal '.' regardless of the culture. I.e. using ',' as decimal
                // separator is considered invalid (even if the current culture would allow it).
                double*/ let qualityValue;
            let $v = { value: set(value){ qualityValue = value; } };
            if (.TryParse(qualityParameter.Value, $v))
            {
                return qualityValue;
            }
        }
        return null;
    }
    /*void*/ CheckValidToken(/*string*/ value, { /*string*/ parameterName = null})
    {
        if (.IsNullOrEmpty(value))
        throw new ArgumentException(nameof(value));
        if (HttpRuleParser.IsToken(value.AsSpan()))
        {
            throw new FormatException("net_http_headers_invalid_value");
        }
    }
    /*void*/ CheckValidComment(/*string*/ value, { /*string*/ parameterName = null})
    {
        if (.IsNullOrEmpty(value))
        throw new ArgumentException(nameof(value));
        let length = null;
        let $v = { value: set(value){ length = value; } };
        if (HttpRuleParser.GetCommentLength(value, 0, $v) != HttpParseResult.Parsed || length != value.Length)
        {
            throw new FormatException("net_http_headers_invalid_value");
        }
    }
    /*void*/ CheckValidQuotedString(/*string*/ value, { /*string*/ parameterName = null})
    {
        if (.IsNullOrEmpty(value))
        throw new ArgumentException(nameof(value));
        let length = null;
        let $v = { value: set(value){ length = value; } };
        if (HttpRuleParser.GetQuotedStringLength(value, 0, $v) != HttpParseResult.Parsed || length != value.Length)
        {
            throw new FormatException("net_http_headers_invalid_value");
        }
    }
    /*bool*/ AreEqualCollections(T, /*ObjectCollection<T>*/ x, /*ObjectCollection<T>*/ y)
    {
        return AreEqualCollections(x, y, null);
    }
    /*bool*/ AreEqualCollections(T, /*ObjectCollection<T>*/ x, /*ObjectCollection<T>*/ y, /*IEqualityComparer<T>*/ comparer)
    {
        if (x == null)
        {
            return y == null || y.Count  == 0;
        }
        if (y == null)
        {
            return x.Count  == 0;
        }
        if (x.Count  != y.Count)
        {
            return false;
        }
        if (x.Count  == 0)
        {
            return true;
        }
        /*// We have two unordered lists. So comparison is an O(n*m) operation which is expensive. Usually
            // headers have 1-2 parameters (if any), so this comparison shouldn't be too expensive.
            bool[]*/ let alreadyFound = new Array(x.Count);
        /*int*/ let i = 0;
        BlazorJs.forEach(x, function(xItem, $_i)
        {
            Debug.Assert(xItem != null);
            i = 0;
            /*bool*/ let found = false;
            BlazorJs.forEach(y, function(yItem, $_i)
            {
                if (alreadyFoundi)
                {
                    if (comparer == null && xItem.Equals(yItem) || comparer != null && comparer.Equals(xItem, yItem))
                    {
                        alreadyFoundi = true;
                        found = true;
                        break;
                    }
                }
                i++;
            });
            if (found)
            {
                return false;
            }
        });
        // Since we never re-use a "found" value in 'y', we expect 'alreadyFound' to have all fields set to 'true'.
            // Otherwise the two collections can't be equal and we should not get here.
            Debug.Assert(Array.TrueForAll(alreadyFound, function(/**/ value)
        {
value        }), "Expected all values in 'alreadyFound' to be true since collections are considered equal.");
        return true;
    }
    /*int*/ GetNextNonEmptyOrWhitespaceIndex(/*string*/ input, /*int*/ startIndex, /*bool*/ skipEmptyValues, /*bool*/ separatorFound)
    {
        Debug.Assert(input != null);
        Debug.Assert(startIndex <= input.Length);
        separatorFound = false;
        /*int*/ let current = startIndex + HttpRuleParser.GetWhitespaceLength(input, startIndex);
        if (current == input.Length || inputcurrent != ',')
        {
            return current;
        }
        // If we have a separator, skip the separator and all following whitespace. If we support
            // empty values, continue until the current character is neither a separator nor a whitespace.
            separatorFound = true;
        current++;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        if (skipEmptyValues)
        {
            while(current < input.Length && inputcurrent == ',')
            {
                current++;
                current += HttpRuleParser.GetWhitespaceLength(input, current);
            }
        }
        return current;
    }
    /*DateTimeOffset?*/ GetDateTimeOffsetValue(/*HeaderDescriptor*/ descriptor, /*HttpHeaders*/ store, { /*DateTimeOffset?*/ defaultValue = null})
    {
        Debug.Assert(store != null);
        /*object*/ let storedValue = store.GetSingleParsedValue(descriptor);
        if (storedValue != null)
        {
            return DateTimeOffsetstoredValue;
        }
        else if (defaultValue != null && store.Contains(descriptor))
        {
            return defaultValue;
        }
        return null;
    }
    /*TimeSpan?*/ GetTimeSpanValue(/*HeaderDescriptor*/ descriptor, /*HttpHeaders*/ store)
    {
        Debug.Assert(store != null);
        /*object*/ let storedValue = store.GetSingleParsedValue(descriptor);
        if (storedValue != null)
        {
            return TimeSpanstoredValue;
        }
        return null;
    }
    /*bool*/ TryParseInt32(/*string*/ value, /*int*/ result)
    {
        let $v = { value: set(value){ result = value; } };
        .TryParse(value, $v);
    }
    /*bool*/ TryParseInt32(/*string*/ value, /*int*/ offset, /*int*/ length, /*int*/ result)
    {
        if (offset < 0 || length < 0 || offset > value.Length  - length)
        {
            result = 0;
            return false;
        }
        let $v = { value: set(value){ result = value; } };
        return .TryParse(value.AsSpan(offset, length), $v);
    }
    /*bool*/ TryParseInt64(/*string*/ value, /*int*/ offset, /*int*/ length, /*long*/ result)
    {
        if (offset < 0 || length < 0 || offset > value.Length  - length)
        {
            result = 0;
            return false;
        }
        let $v = { value: set(value){ result = value; } };
        return .TryParse(value.AsSpan(offset, length), $v);
    }
    /*void*/ DumpHeaders(/*StringBuilder*/ sb, /*HttpHeaders[]*/ headers)
    {
        // Appends all headers as string similar to:
            // {
            //    HeaderName1: Value1
            //    HeaderName1: Value2
            //    HeaderName2: Value1
            //    ...
            // }
            sb.AppendLine("{");
        for(/*int*/ let i = 0; i < headers.Length; i++)
        {
            if (headersi instanceof HttpHeaders)
            {
                BlazorJs.forEach(hh.NonValidated, function(header, $_i)
                {
                    BlazorJs.forEach(header.Value, function(headerValue, $_i)
                    {
                        sb.Append("  ");
                        sb.Append(header.Key);
                        sb.Append(": ");
                        sb.AppendLine(headerValue);
                    });
                });
            }
        });
        sb.Append('}');
    }
    /*UnvalidatedObjectCollection<NameValueHeaderValue>*/ Clone(/*UnvalidatedObjectCollection<NameValueHeaderValue>*/ source)
    {
        if (source == null)
        return null;
        /*var*/ let copy = new UnvalidatedObjectCollection_$1(NameValueHeaderValue);
        BlazorJs.forEach(source, function(item, $_i)
        {
            copy.Add(new NameValueHeaderValue(item));
        });
        return copy;
    }
}

class System_Net_Http_Headers_HttpContentHeaders extends System_Net_Http_Headers_HttpHeaders
{
    /*HttpContent*/ _parent = null;
    /*bool*/ _contentLengthSet = null;
    /*HttpHeaderValueCollection<string>*/ _allow = null;
    /*HttpHeaderValueCollection<string>*/ _contentEncoding = null;
    /*HttpHeaderValueCollection<string>*/ _contentLanguage = null;
    /*ICollection<string>*/ get Allow()
    {
        return _allow = _allow ?? new HttpHeaderValueCollection_$1(string, KnownHeaders.Allow.Descriptor, );
    }
    /*ContentDispositionHeaderValue*/ get ContentDisposition()
    {
        return ContentDispositionHeaderValueGetSingleParsedValue(KnownHeaders.ContentDisposition.Descriptor);
    }
    /*ContentDispositionHeaderValue*/ set ContentDisposition(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.ContentDisposition.Descriptor, value);
    }
    /*ICollection<string>*/ get ContentEncoding()
    {
        return _contentEncoding = _contentEncoding ?? new HttpHeaderValueCollection_$1(string, KnownHeaders.ContentEncoding.Descriptor, );
    }
    /*ICollection<string>*/ get ContentLanguage()
    {
        return _contentLanguage = _contentLanguage ?? new HttpHeaderValueCollection_$1(string, KnownHeaders.ContentLanguage.Descriptor, );
    }
    /*long?*/ get ContentLength()
    {
        /*// 'Content-Length' can only hold one value. So either we get 'null' back or a boxed long value.
                object*/ let storedValue = GetSingleParsedValue(KnownHeaders.ContentLength.Descriptor);
        if (_contentLengthSet && storedValue == null)
        {
            /*// If we don't have a value for Content-Length in the store, try to let the content calculate
                    // it's length. If the content object is able to calculate the length, we'll store it in the
                    // store.
                    long?*/ let calculatedLength = _parent.GetComputedOrBufferLength();
            if (calculatedLength != null)
            {
                SetParsedValue(KnownHeaders.ContentLength.Descriptor, calculatedLength.Value);
            }
            return calculatedLength;
        }
        if (storedValue == null)
        {
            return null;
        }
        else 
        {
            return storedValue;
        }
    }
    /*long?*/ set ContentLength(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.ContentLength.Descriptor, value);
        _contentLengthSet = true;
    }
    /*Uri*/ get ContentLocation()
    {
        return UriGetSingleParsedValue(KnownHeaders.ContentLocation.Descriptor);
    }
    /*Uri*/ set ContentLocation(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.ContentLocation.Descriptor, value);
    }
    /*byte[]*/ get ContentMD5()
    {
        return GetSingleParsedValue(KnownHeaders.ContentMD5.Descriptor);
    }
    /*byte[]*/ set ContentMD5(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.ContentMD5.Descriptor, value);
    }
    /*ContentRangeHeaderValue*/ get ContentRange()
    {
        return ContentRangeHeaderValueGetSingleParsedValue(KnownHeaders.ContentRange.Descriptor);
    }
    /*ContentRangeHeaderValue*/ set ContentRange(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.ContentRange.Descriptor, value);
    }
    /*MediaTypeHeaderValue*/ get ContentType()
    {
        return MediaTypeHeaderValueGetSingleParsedValue(KnownHeaders.ContentType.Descriptor);
    }
    /*MediaTypeHeaderValue*/ set ContentType(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.ContentType.Descriptor, value);
    }
    /*DateTimeOffset?*/ get Expires()
    {
        return HeaderUtilities.GetDateTimeOffsetValue(KnownHeaders.Expires.Descriptor, , DateTimeOffset.MinValue);
    }
    /*DateTimeOffset?*/ set Expires(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.Expires.Descriptor, value);
    }
    /*DateTimeOffset?*/ get LastModified()
    {
        return HeaderUtilities.GetDateTimeOffsetValue(KnownHeaders.LastModified.Descriptor, );
    }
    /*DateTimeOffset?*/ set LastModified(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.LastModified.Descriptor, value);
    }
    constructor(/*HttpContent*/ parent)
    {
        super(HttpHeaderType.Content  | HttpHeaderType.Custom, HttpHeaderType.None);
        _parent = parent;
    }
}

class System_Net_Http_Headers_HttpGeneralHeaders extends object
{
    /*HttpHeaderValueCollection<string>*/ _connection = null;
    /*HttpHeaderValueCollection<string>*/ _trailer = null;
    /*HttpHeaderValueCollection<TransferCodingHeaderValue>*/ _transferEncoding = null;
    /*HttpHeaderValueCollection<ProductHeaderValue>*/ _upgrade = null;
    /*HttpHeaderValueCollection<ViaHeaderValue>*/ _via = null;
    /*HttpHeaderValueCollection<WarningHeaderValue>*/ _warning = null;
    /*HttpHeaderValueCollection<NameValueHeaderValue>*/ _pragma = null;
    /*HttpHeaders*/ _parent = null;
    /*bool*/ _transferEncodingChunkedSet = null;
    /*bool*/ _connectionCloseSet = null;
    /*CacheControlHeaderValue*/ get CacheControl()
    {
        return CacheControlHeaderValue_parent.GetSingleParsedValue(KnownHeaders.CacheControl.Descriptor);
    }
    /*CacheControlHeaderValue*/ set CacheControl(value)
    {
        _parent.SetOrRemoveParsedValue(KnownHeaders.CacheControl.Descriptor, value);
    }
    /*bool?*/ get ConnectionClose()
    {
        return GetConnectionClose(_parent, );
    }
    /*bool?*/ set ConnectionClose(value)
    {
        if (value == true)
        {
            _connectionCloseSet = true;
            if (_parent.ContainsParsedValue(KnownHeaders.Connection.Descriptor, HeaderUtilities.ConnectionClose))
            {
                _parent.AddParsedValue(KnownHeaders.Connection.Descriptor, HeaderUtilities.ConnectionClose);
            }
        }
        else 
        {
            _connectionCloseSet = value != null;
            // We intentionally ignore the return value. It's OK if "close" wasn't in the store.
                    _parent.RemoveParsedValue(KnownHeaders.Connection.Descriptor, HeaderUtilities.ConnectionClose);
        }
    }
    /*bool?*/ GetConnectionClose(/*HttpHeaders*/ parent, /*HttpGeneralHeaders*/ headers)
    {
        if (parent.ContainsParsedValue(KnownHeaders.Connection.Descriptor, HeaderUtilities.ConnectionClose))
        {
            return true;
        }
        if (headers != null && headers._connectionCloseSet)
        {
            return false;
        }
        return null;
    }
    /*DateTimeOffset?*/ get Date()
    {
        return HeaderUtilities.GetDateTimeOffsetValue(KnownHeaders.Date.Descriptor, _parent);
    }
    /*DateTimeOffset?*/ set Date(value)
    {
        _parent.SetOrRemoveParsedValue(KnownHeaders.Date.Descriptor, value);
    }
    /*HttpHeaderValueCollection<NameValueHeaderValue>*/ get Pragma()
    {
        return _pragma = _pragma ?? new HttpHeaderValueCollection_$1(NameValueHeaderValue, KnownHeaders.Pragma.Descriptor, _parent);
    }
    /*HttpHeaderValueCollection<string>*/ get Trailer()
    {
        return _trailer = _trailer ?? new HttpHeaderValueCollection_$1(string, KnownHeaders.Trailer.Descriptor, _parent);
    }
    /*bool?*/ GetTransferEncodingChunked(/*HttpHeaders*/ parent, /*HttpGeneralHeaders*/ headers)
    {
        let value = null;
        let $v = { value: set(value){ value = value; } };
        if (parent.TryGetHeaderValue(KnownHeaders.TransferEncoding.Descriptor, $v))
        {
            if (value.Value  instanceof  && stringValue.Equals("chunked", StringComparison.OrdinalIgnoreCase))
            {
                return true;
            }
            if (parent.ContainsParsedValue(KnownHeaders.TransferEncoding.Descriptor, HeaderUtilities.TransferEncodingChunked))
            {
                return true;
            }
        }
        if (headers != null && headers._transferEncodingChunkedSet)
        {
            return false;
        }
        return null;
    }
    /*bool?*/ get TransferEncodingChunked()
    {
        return GetTransferEncodingChunked(_parent, );
    }
    /*bool?*/ set TransferEncodingChunked(value)
    {
        if (value == true)
        {
            _transferEncodingChunkedSet = true;
            if (_parent.ContainsParsedValue(KnownHeaders.TransferEncoding.Descriptor, HeaderUtilities.TransferEncodingChunked))
            {
                _parent.AddParsedValue(KnownHeaders.TransferEncoding.Descriptor, HeaderUtilities.TransferEncodingChunked);
            }
        }
        else 
        {
            _transferEncodingChunkedSet = value != null;
            // We intentionally ignore the return value. It's OK if "chunked" wasn't in the store.
                    _parent.RemoveParsedValue(KnownHeaders.TransferEncoding.Descriptor, HeaderUtilities.TransferEncodingChunked);
        }
    }
    /*HttpHeaderValueCollection<ProductHeaderValue>*/ get Upgrade()
    {
        return _upgrade = _upgrade ?? new HttpHeaderValueCollection_$1(ProductHeaderValue, KnownHeaders.Upgrade.Descriptor, _parent);
    }
    /*HttpHeaderValueCollection<ViaHeaderValue>*/ get Via()
    {
        return _via = _via ?? new HttpHeaderValueCollection_$1(ViaHeaderValue, KnownHeaders.Via.Descriptor, _parent);
    }
    /*HttpHeaderValueCollection<WarningHeaderValue>*/ get Warning()
    {
        return _warning = _warning ?? new HttpHeaderValueCollection_$1(WarningHeaderValue, KnownHeaders.Warning.Descriptor, _parent);
    }
    /*HttpHeaderValueCollection<string>*/ get Connection()
    {
        return _connection = _connection ?? new HttpHeaderValueCollection_$1(string, KnownHeaders.Connection.Descriptor, _parent);
    }
    /*HttpHeaderValueCollection<TransferCodingHeaderValue>*/ get TransferEncoding()
    {
        return _transferEncoding = _transferEncoding ?? new HttpHeaderValueCollection_$1(TransferCodingHeaderValue, KnownHeaders.TransferEncoding.Descriptor, _parent);
    }
    constructor(/*HttpHeaders*/ parent)
    {
        super();
        Debug.Assert(parent != null);
        _parent = parent;
    }
    /*void*/ AddSpecialsFrom(/*HttpGeneralHeaders*/ sourceHeaders)
    {
        /*// Copy special values, but do not overwrite
            bool?*/ let chunked = TransferEncodingChunked;
        if (chunked.HasValue)
        {
            TransferEncodingChunked = sourceHeaders.TransferEncodingChunked;
        }
        /*bool?*/ let close = ConnectionClose;
        if (close.HasValue)
        {
            ConnectionClose = sourceHeaders.ConnectionClose;
        }
    }
}

class System_Net_Http_Headers_HttpHeaderParser extends object
{
    /*string*/ DefaultSeparator = ", ";
    /*byte[]*/ DefaultSeparatorBytes = [ ','' ' ];
    /*bool*/ _backingField_SupportsMultipleValues = null;
    /*bool*/ get SupportsMultipleValues()
    {
        return _backingField_SupportsMultipleValues;
    }
    /*string*/ _backingField_Separator = null;
    /*string*/ get Separator()
    {
        return _backingField_Separator;
    }
    /*byte[]*/ _backingField_SeparatorBytes = null;
    /*byte[]*/ get SeparatorBytes()
    {
        return _backingField_SeparatorBytes;
    }
    /*IEqualityComparer*/ get Comparer()
    {
        return null;
    }
    constructor(/*bool*/ supportsMultipleValues)
    {
        super();
        SupportsMultipleValues = supportsMultipleValues;
        Separator = DefaultSeparator;
        SeparatorBytes = DefaultSeparatorBytes;
    }
    constructor(/*bool*/ supportsMultipleValues, /*string*/ separator)
    {
        super(supportsMultipleValues);
        Debug.Assert(.IsNullOrEmpty(separator));
        Debug.Assert(Ascii.IsValid(separator));
        if (supportsMultipleValues)
        {
            Separator = separator;
            SeparatorBytes = Encoding.ASCII.GetBytes(separator);
        }
    }
    /*object*/ ParseValue(/*string*/ value, /*object*/ storeValue, /*int*/ index)
    {
        // Index may be value.Length (e.g. both 0). This may be allowed for some headers (e.g. Accept but not
            // allowed by others (e.g. Content-Length). The parser has to decide if this is valid or not.
            Debug.Assert(value == null || index >= 0 && index <= value.Length);
        let $v = { value: set(value){ index = value; } };
        let result = null;
        let $v = { value: set(value){ result = value; } };
        if (TryParseValue(value, storeValue, $v, $v))
        {
            throw new FormatException("net_http_headers_invalid_value");
        }
        return result;
    }
    /*string*/ ToString(/*object*/ value)
    {
        Debug.Assert(value != null);
        return value.ToString();
    }
}

class System_Net_Http_Headers_HeaderEntry extends object
{
    /*HeaderDescriptor*/ Key = null;
    /*object*/ Value = null;
    constructor()
    {
        super();
    }
    constructor(/*HeaderDescriptor*/ key, /*object*/ value)
    {
        super();
        Key = key;
        Value = value;
    }
}
class System_Net_Http_Headers_HttpHeaders extends H5_IH5Class(System_Collections_IEnumerable(System_Collections_Generic_IEnumerable<System_Collections_Generic_KeyValuePair<string, System_Collections_Generic_IEnumerable<string>>>(object)))
{
    /*object*/ _headerStore = null;
    /*int*/ _count = null;
    /*HttpHeaderType*/ _allowedHeaderTypes = null;
    /*HttpHeaderType*/ _treatAsCustomHeaderTypes = null;
    constructor()
    {
        super(HttpHeaderType.All, HttpHeaderType.None);
    }
    constructor(/*HttpHeaderType*/ allowedHeaderTypes, /*HttpHeaderType*/ treatAsCustomHeaderTypes)
    {
        super();
        // Should be no overlap
            Debug.Assert(allowedHeaderTypes & treatAsCustomHeaderTypes == 0);
        _allowedHeaderTypes = allowedHeaderTypes & HttpHeaderType.NonTrailing;
        _treatAsCustomHeaderTypes = treatAsCustomHeaderTypes & HttpHeaderType.NonTrailing;
    }
    /*HttpHeadersNonValidated*/ get NonValidated()
    {
        return new HttpHeadersNonValidated();
    }
    /*void*/ Add(/*string*/ name, /*string*/ value)
    {
        Add(GetHeaderDescriptor(name), value);
    }
    /*void*/ Add(/*HeaderDescriptor*/ descriptor, /*string*/ value)
    {
        // We don't use GetOrCreateHeaderInfo() here, since this would create a new header in the store. If parsing
            // the value then throws, we would have to remove the header from the store again. So just get a
            // HeaderStoreItemInfo object and try to parse the value. If it works, we'll add the header.
        let info = null;
        let $v = { value: set(value){ info = value; } };
        let addToStore = null;
        let $v = { value: set(value){ addToStore = value; } };
            PrepareHeaderInfoForAdd(descriptor, $v, $v);
        ParseAndAddValue(descriptor, info, value);
        if (addToStore && info.ParsedAndInvalidValues  != null)
        {
            info.AssertContainsNoInvalidValues();
            Debug.Assert(Contains(descriptor));
            AddEntryToStore(new HeaderEntry(descriptor, info));
        }
    }
    /*void*/ Add(/*string*/ name, /*IEnumerable<string>*/ values)
    {
        Add(GetHeaderDescriptor(name), values);
    }
    /*void*/ Add(/*HeaderDescriptor*/ descriptor, /*IEnumerable<string>*/ values)
    {
        if (values == null)
        throw new ArgumentNullException(nameof(values));
        let info = null;
        let $v = { value: set(value){ info = value; } };
        let addToStore = null;
        let $v = { value: set(value){ addToStore = value; } };
        PrepareHeaderInfoForAdd(descriptor, $v, $v);
        {
            BlazorJs.forEach(values, function(value, $_i)
            {
                ParseAndAddValue(descriptor, info, value);
            });
        }
        {
            if (addToStore && info.ParsedAndInvalidValues  != null)
            {
                info.AssertContainsNoInvalidValues();
                Debug.Assert(Contains(descriptor));
                AddEntryToStore(new HeaderEntry(descriptor, info));
            }
        }
    }
    /*bool*/ TryAddWithoutValidation(/*string*/ name, /*string*/ value)
    {
        let descriptor = null;
        let $v = { value: set(value){ descriptor = value; } };
        TryGetHeaderDescriptor(name, $v) && TryAddWithoutValidation(descriptor, value);
    }
    /*bool*/ TryAddWithoutValidation(/*HeaderDescriptor*/ descriptor, /*string*/ value)
    {
        // Normalize null values to be empty values, which are allowed. If the user adds multiple
            // null/empty values, all of them are added to the collection. This will result in delimiter-only
            // values, e.g. adding two null-strings (or empty, or whitespace-only) results in "My-Header: ,".
            value = value ?? .Empty;
        /*var*/ let storeValueRef = GetValueRefOrAddDefault(descriptor);
        /*object*/ let currentValue = storeValueRef.Value;
        if (currentValue)
        {
            storeValueRef.Value  = value;
        }
        else 
        {
            if (currentValue instanceof HeaderStoreItemInfo, info = currentValue)
            {
                // The header store contained a single raw string value, so promote it
                    // to being a HeaderStoreItemInfo and add to it.
                    Debug.Assert(currentValue is );
                storeValueRef.Value  = info = new HeaderStoreItemInfo()RawValue = currentValue;
            }
            AddRawValue(info, value);
        }
        return true;
    }
    /*bool*/ TryAddWithoutValidation(/*string*/ name, /*IEnumerable<string>*/ values)
    {
        let descriptor = null;
        let $v = { value: set(value){ descriptor = value; } };
        TryGetHeaderDescriptor(name, $v) && TryAddWithoutValidation(descriptor, values);
    }
    /*bool*/ TryAddWithoutValidation(/*HeaderDescriptor*/ descriptor, /*IEnumerable<string>*/ values)
    {
        if (values == null)
        throw new ArgumentNullException(nameof(values));
        if (values instanceof IList_$1, valuesList = values)
        {
            /*int*/ let count = valuesList.Count;
            if (count > 0)
            {
                /*// The store value is either a string (a single unparsed value) or a HeaderStoreItemInfo.
                    // The RawValue on HeaderStoreItemInfo can likewise be either a single string or a List<string>.
                    var*/ let storeValueRef = GetValueRefOrAddDefault(descriptor);
                /*object*/ let storeValue = storeValueRef.Value;
                if (storeValue || count > 1)
                {
                    if (storeValue instanceof HeaderStoreItemInfo, info = storeValue)
                    {
                        storeValueRef.Value  = info = new HeaderStoreItemInfo()RawValue = storeValue;
                    }
                    /*object*/ let rawValue = info.RawValue;
                    if (rawValue instanceof List_$1, rawValues = rawValue)
                    {
                        info.RawValue  = rawValues = new List_$1(string);
                        if (rawValue != null)
                        {
                            //rawValues.EnsureCapacity(count + 1);
                                rawValues.Add(rawValue);
                        }
                    }
                    for(/*int*/ let i = 0; i < count; i++)
                    {
                        rawValues.Add(valuesListi ?? .Empty);
                    });
                }
                else 
                {
                    // We're adding a single value to a new header entry. We can store the unparsed value as-is.
                        storeValueRef.Value  = valuesList0 ?? .Empty;
                }
            }
        }
        else 
        {
            BlazorJs.forEach(values, function(value, $_i)
            {
                TryAddWithoutValidation(descriptor, value ?? .Empty);
            });
        }
        return true;
    }
    /*IEnumerable<string>*/ GetValues(/*string*/ name)
    {
        GetValues(GetHeaderDescriptor(name));
    }
    /*IEnumerable<string>*/ GetValues(/*HeaderDescriptor*/ descriptor)
    {
        let values = null;
        let $v = { value: set(value){ values = value; } };
        if (TryGetValues(descriptor, $v))
        {
            return values;
        }
        throw new InvalidOperationException("net_http_headers_not_found");
    }
    /*bool*/ TryGetValues(/*string*/ name, /*IEnumerable<string>*/ values)
    {
        let descriptor = null;
        let $v = { value: set(value){ descriptor = value; } };
        if (TryGetHeaderDescriptor(name, $v))
        {
            let $v = { value: set(value){ values = value; } };
            return TryGetValues(descriptor, $v);
        }
        values = null;
        return false;
    }
    /*bool*/ TryGetValues(/*HeaderDescriptor*/ descriptor, /*IEnumerable<string>*/ values)
    {
        let info = null;
        let $v = { value: set(value){ info = value; } };
        if (TryGetAndParseHeaderInfo(descriptor, $v))
        {
            values = GetStoreValuesAsStringArray(descriptor, info);
            return true;
        }
        values = null;
        return false;
    }
    /*bool*/ Contains(/*string*/ name)
    {
        Contains(GetHeaderDescriptor(name));
    }
    /*string*/ ToString()
    {
        /*// Return all headers as string similar to:
            // HeaderName1: Value1, Value2
            // HeaderName2: Value1
            // ...
            var*/ let vsb = new StringBuilder(512);
        BlazorJs.forEach(GetEntries(), function(entry, $_i)
        {
            vsb.Append(entry.Key.Name);
            vsb.Append(": ");
            let singleValue = null;
            let $v = { value: set(value){ singleValue = value; } };
            let multiValue = null;
            let $v = { value: set(value){ multiValue = value; } };
            GetStoreValuesAsStringOrStringArray(entry.Key, entry.Value, $v, $v);
            Debug.Assert(singleValue ^ multiValue);
            if (singleValue)
            {
                vsb.Append(singleValue);
            }
            else 
            {
                /*// Note that if we get multiple values for a header that doesn't support multiple values, we'll
                    // just separate the values using a comma (default separator).
                    string*/ let separator = entry.Key.Separator;
                Debug.Assert(multiValue && multiValue.Length  > 0);
                vsb.Append(multiValue0);
                for(/*int*/ let i = 1; i < multiValue.Length; i++)
                {
                    vsb.Append(separator);
                    vsb.Append(multiValuei);
                });
            }
            vsb.Append(Environment.NewLine);
        });
        return vsb.ToString();
    }
    /*string*/ GetHeaderString(/*HeaderDescriptor*/ descriptor)
    {
        let info = null;
        let $v = { value: set(value){ info = value; } };
        if (TryGetHeaderValue(descriptor, $v))
        {
            let singleValue = null;
            let $v = { value: set(value){ singleValue = value; } };
            let multiValue = null;
            let $v = { value: set(value){ multiValue = value; } };
            GetStoreValuesAsStringOrStringArray(descriptor, info, $v, $v);
            Debug.Assert(singleValue ^ multiValue);
            if (singleValue)
            {
                return singleValue;
            }
            return .Join(descriptor.Separator, multiValue);
        }
        return .Empty;
    }
    /*IEnumerator<KeyValuePair<string, IEnumerable<string>>>*/ GetEnumerator()
    {
        _count == 0IEnumerable_$1Array.Empty(KeyValuePair<string, IEnumerable<string>>).GetEnumerator()GetEnumeratorCore();
    }
    /*IEnumerator<KeyValuePair<string, IEnumerable<string>>>*/ GetEnumeratorCore()
    {
        /*HeaderEntry[]*/ let entries = GetEntriesArray();
        Debug.Assert(_count != 0 && entries, "Caller should have validated the collection is not empty");
        for(/*int*/ let i = 0; i < _count; i++)
        {
            /*HeaderEntry*/ let entry = entriesi;
            if (entry.Value  instanceof HeaderStoreItemInfo)
            {
                /*// To retain consistent semantics, we need to upgrade a raw string to a HeaderStoreItemInfo
                    // during enumeration so that we can parse the raw value in order to a) return
                    // the correct set of parsed values, and b) update the instance for subsequent enumerations
                    // to reflect that parsing.
                    //#nullable disable // https://github.com/dotnet/roslyn/issues/73928
                    var*/ let storeValueRef = EntriesAreLiveViewentriesiDictionary_$2_headerStore.GetValueOrDefault(entry.Key);
                //: ref CollectionsMarshal.GetValueRefOrNullRef((Dictionary<HeaderDescriptor, object>)_headerStore, entry.Key);
                    info = ReplaceWithHeaderStoreItemInfo(storeValueRef, entry.Value);
            }
            // Make sure we parse all raw values before returning the result. Note that this has to be
                // done before we calculate the array length (next line): A raw value may contain a list of
                // values.
                ParseRawHeaderValues(entry.Key, info);
            /*string[]*/ let values = GetStoreValuesAsStringArray(entry.Key, info);
new KeyValuePair_$2(string, IEnumerable<string>, entry.Key.Name, values)        });
    }
    /*#endregion
        #region IEnumerable Members
        Collections.IEnumerator*/ GetEnumerator()
    {
        GetEnumerator();
    }
    /*void*/ AddParsedValue(/*HeaderDescriptor*/ descriptor, /*object*/ value)
    {
        Debug.Assert(value != null);
        Debug.Assert(descriptor.Parser  != null, "Can't add parsed value if there is no parser available.");
        /*HeaderStoreItemInfo*/ let info = GetOrCreateHeaderInfo(descriptor);
        // If the current header has only one value, we can't add another value. The strongly typed property
            // must not call AddParsedValue(), but SetParsedValue(). E.g. for headers like 'Date', 'Host'.
            Debug.Assert(descriptor.Parser.SupportsMultipleValues, descriptor.Name);
        AddParsedValue(info, value);
    }
    /*void*/ SetParsedValue(/*HeaderDescriptor*/ descriptor, /*object*/ value)
    {
        Debug.Assert(value != null);
        Debug.Assert(descriptor.Parser  != null, "Can't add parsed value if there is no parser available.");
        /*// This method will first clear all values. This is used e.g. when setting the 'Date' or 'Host' header.
            // i.e. headers not supporting collections.
            HeaderStoreItemInfo*/ let info = GetOrCreateHeaderInfo(descriptor);
        info.ParsedAndInvalidValues  = null;
        info.RawValue  = null;
        AddParsedValue(info, value);
    }
    /*void*/ SetOrRemoveParsedValue(/*HeaderDescriptor*/ descriptor, /*object*/ value)
    {
        if (value == null)
        {
            Remove(descriptor);
        }
        else 
        {
            SetParsedValue(descriptor, value);
        }
    }
    /*bool*/ Remove(/*string*/ name)
    {
        Remove(GetHeaderDescriptor(name));
    }
    /*bool*/ RemoveParsedValue(/*HeaderDescriptor*/ descriptor, /*object*/ value)
    {
        Debug.Assert(value != null);
        let info = null;
        let $v = { value: set(value){ info = value; } };
        if (TryGetAndParseHeaderInfo(descriptor, $v))
        {
            Debug.Assert(descriptor.Parser  != null, "Can't add parsed value if there is no parser available.");
            Debug.Assert(descriptor.Parser.SupportsMultipleValues, "This method should not be used for single-value headers. Use Remove(string) instead.");
            /*// If there is no entry, just return.
                var*/ let parsedValue = info.ParsedAndInvalidValues;
            if (parsedValue == null)
            {
                return false;
            }
            /*bool*/ let result = false;
            /*IEqualityComparer*/ let comparer = descriptor.Parser.Comparer;
            /*List<object>*/ let parsedValues = parsedValue as List_$1;
            if (parsedValues == null)
            {
                if (parsedValue is InvalidValue)
                {
                    Debug.Assert(parsedValue.GetType() == value.GetType(), "Stored value does not have the same type as 'value'.");
                    if (AreEqual(value, parsedValue, comparer))
                    {
                        info.ParsedAndInvalidValues  = null;
                        result = true;
                    }
                }
            }
            else 
            {
                BlazorJs.forEach(parsedValues, function(item, $_i)
                {
                    if (item is InvalidValue)
                    {
                        Debug.Assert(item.GetType() == value.GetType(), "One of the stored values does not have the same type as 'value'.");
                        if (AreEqual(value, item, comparer))
                        {
                            // Remove 'item' rather than 'value', since the 'comparer' may consider two values
                                // equal even though the default obj.Equals() may not (e.g. if 'comparer' does
                                // case-insensitive comparison for strings, but string.Equals() is case-sensitive).
                                result = parsedValues.Remove(item);
                            break;
                        }
                    }
                });
                if (parsedValues.Count  == 0)
                {
                    info.AssertContainsNoInvalidValues();
                    info.ParsedAndInvalidValues  = null;
                }
            }
            if (info.IsEmpty)
            {
                /*bool*/ let headerRemoved = Remove(descriptor);
                Debug.Assert(headerRemoved, descriptor.Name);
            }
            return result;
        }
        return false;
    }
    /*bool*/ ContainsParsedValue(/*HeaderDescriptor*/ descriptor, /*object*/ value)
    {
        Debug.Assert(value != null);
        let info = null;
        let $v = { value: set(value){ info = value; } };
        if (TryGetAndParseHeaderInfo(descriptor, $v))
        {
            Debug.Assert(descriptor.Parser  != null, "Can't add parsed value if there is no parser available.");
            Debug.Assert(descriptor.Parser.SupportsMultipleValues, "This method should not be used for single-value headers. Use equality comparer instead.");
            /*// If there is no entry, just return.
                var*/ let parsedValue = info.ParsedAndInvalidValues;
            if (parsedValue == null)
            {
                return false;
            }
            /*List<object>*/ let parsedValues = parsedValue as List_$1;
            /*IEqualityComparer*/ let comparer = descriptor.Parser.Comparer;
            if (parsedValues == null)
            {
                if (parsedValue is InvalidValue)
                {
                    Debug.Assert(parsedValue.GetType() == value.GetType(), "Stored value does not have the same type as 'value'.");
                    return AreEqual(value, parsedValue, comparer);
                }
            }
            else 
            {
                BlazorJs.forEach(parsedValues, function(item, $_i)
                {
                    if (item is InvalidValue)
                    {
                        Debug.Assert(item.GetType() == value.GetType(), "One of the stored values does not have the same type as 'value'.");
                        if (AreEqual(value, item, comparer))
                        {
                            return true;
                        }
                    }
                });
                return false;
            }
        }
        return false;
    }
    /*void*/ AddHeaders(/*HttpHeaders*/ sourceHeaders)
    {
        Debug.Assert(sourceHeaders != null);
        Debug.Assert(GetType() == sourceHeaders.GetType(), "Can only copy headers from an instance of the same type.");
        if (_count == 0 && sourceHeaders._headerStore  instanceof HeaderEntry)
        {
            // If the target collection is empty, we don't have to search for existing values
                _count = sourceHeaders._count;
            if (_headerStore instanceof HeaderEntry, entries = _headerStore || entries.Length  < _count)
            {
                entries = new Array(sourceEntries.Length);
                _headerStore = entries;
            }
            for(/*int*/ let i = 0; i < _count && i < sourceEntries.Length; i++)
            {
                /*HeaderEntry*/ let entry = sourceEntriesi;
                if (entry.Value  instanceof HeaderStoreItemInfo)
                {
                    entry.Value  = CloneHeaderInfo(entry.Key, info);
                }
                entriesi = entry;
            });
        }
        else 
        {
            BlazorJs.forEach(sourceHeaders.GetEntries(), function(entry, $_i)
            {
                /*var*/ let storeValueRef = GetValueRefOrAddDefault(entry.Key);
                if (storeValueRef)
                {
                    /*object*/ let sourceValue = entry.Value;
                    if (sourceValue instanceof HeaderStoreItemInfo, info = sourceValue)
                    {
                        storeValueRef.Value  = CloneHeaderInfo(entry.Key, info);
                    }
                    else 
                    {
                        Debug.Assert(sourceValue is );
                        storeValueRef.Value  = sourceValue;
                    }
                }
            });
        }
    }
    /*HeaderStoreItemInfo*/ CloneHeaderInfo(/*HeaderDescriptor*/ descriptor, /*HeaderStoreItemInfo*/ sourceInfo)
    {
sourceInfo        {
            /*var*/ let destinationInfo = new HeaderStoreItemInfo()// Always copy raw values
                    RawValue = CloneStringHeaderInfoValues(sourceInfo.RawValue);
            if (descriptor.Parser  == null)
            {
                sourceInfo.AssertContainsNoInvalidValues();
                destinationInfo.ParsedAndInvalidValues  = CloneStringHeaderInfoValues(sourceInfo.ParsedAndInvalidValues);
            }
            else 
            {
                if (sourceInfo.ParsedAndInvalidValues  != null)
                {
                    /*List<object>*/ let sourceValues = sourceInfo.ParsedAndInvalidValues  as List_$1;
                    if (sourceValues == null)
                    {
                        CloneAndAddValue(destinationInfo, sourceInfo.ParsedAndInvalidValues);
                    }
                    else 
                    {
                        BlazorJs.forEach(sourceValues, function(item, $_i)
                        {
                            CloneAndAddValue(destinationInfo, item);
                        });
                    }
                }
            }
            return destinationInfo;
        }
    }
    /*void*/ CloneAndAddValue(/*HeaderStoreItemInfo*/ destinationInfo, /*object*/ source)
    {
        if (source instanceof ICloneable, cloneableValue = source)
        {
            Debug.Assert(source is InvalidValue);
            AddParsedValue(destinationInfo, cloneableValue.Clone());
        }
        else 
        {
            // If it doesn't implement ICloneable, it's a value type or an immutable type like String/Uri.
                AddParsedValue(destinationInfo, source);
        }
    }
    /*object*/ CloneStringHeaderInfoValues(/*object*/ source)
    {
        if (source == null)
        {
            return null;
        }
        /*List<object>*/ let sourceValues = source as List_$1;
        if (sourceValues == null)
        {
            return source;
        }
        else 
        {
            return new List_$1(object, sourceValues);
        }
    }
    /*HeaderStoreItemInfo*/ GetOrCreateHeaderInfo(/*HeaderDescriptor*/ descriptor)
    {
        let info = null;
        let $v = { value: set(value){ info = value; } };
        if (TryGetAndParseHeaderInfo(descriptor, $v))
        {
            return info;
        }
        else 
        {
            return CreateAndAddHeaderToStore(descriptor);
        }
    }
    /*HeaderStoreItemInfo*/ CreateAndAddHeaderToStore(/*HeaderDescriptor*/ descriptor)
    {
        Debug.Assert(Contains(descriptor));
        /*// If we don't have the header in the store yet, add it now.
            HeaderStoreItemInfo*/ let result = new HeaderStoreItemInfo();
        // If the descriptor header type is in _treatAsCustomHeaderTypes, it must be converted to a custom header before calling this method
            Debug.Assert(descriptor.HeaderType  & _treatAsCustomHeaderTypes == 0);
        AddEntryToStore(new HeaderEntry(descriptor, result));
        return result;
    }
    /*bool*/ TryGetHeaderValue(/*HeaderDescriptor*/ descriptor, /*HeaderEntry*/ value)
    {
        /*//ref object storeValueRef = ref GetValueRefOrNullRef(descriptor);
            var*/ let storeValueRef = GetValueRefOrNullRef(descriptor);
        if (storeValueRef == null)
        {
            value = null;
            return false;
        }
        else 
        {
            value = storeValueRef;
            return true;
        }
    }
    /*bool*/ TryGetAndParseHeaderInfo(/*HeaderDescriptor*/ key, /*HeaderStoreItemInfo*/ info)
    {
        /*var*/ let storeValueRef = GetValueRefOrNullRef(key);
        if (storeValueRef == null)
        {
            /*object*/ let value = storeValueRef.Value;
            info = value instanceof HeaderStoreItemInfo, hsi = valuehsiReplaceWithHeaderStoreItemInfo(storeValueRef, value);
            ParseRawHeaderValues(key, info);
            return true;
        }
        info = null;
        return false;
    }
    /*HeaderStoreItemInfo*/ ReplaceWithHeaderStoreItemInfo(/*HeaderEntry*/ storeValueRef, /*object*/ value)
    {
        Debug.Assert(value is );
        /*var*/ let info = new HeaderStoreItemInfo()RawValue = value;
        let $v = { value: set(value){ storeValueRef.Value = value; } };
        /*object*/ let previousValue = InterlockedExtension.CompareExchange($v, info, value);
        if (ReferenceEquals(previousValue, value))
        {
            return info;
        }
        return HeaderStoreItemInfopreviousValue;
    }
    /*void*/ ParseRawHeaderValues(/*HeaderDescriptor*/ descriptor, /*HeaderStoreItemInfo*/ info)
    {
info        {
            Debug.Assert(info.IsEmpty);
            if (info.RawValue  != null)
            {
                if (info.RawValue  instanceof List_$1)
                {
                    BlazorJs.forEach(rawValues, function(rawValue, $_i)
                    {
                        ParseSingleRawHeaderValue(info, descriptor, rawValue);
                    });
                }
                else 
                {
                    /*string*/ let rawValue = info.RawValue  as ;
                    Debug.Assert(rawValue);
                    ParseSingleRawHeaderValue(info, descriptor, rawValue);
                }
                // At this point all values are either in info.ParsedValue, info.InvalidValue. Reset RawValue.
                    Debug.Assert(info.ParsedAndInvalidValues );
                info.RawValue  = null;
            }
        }
    }
    /*void*/ ParseSingleRawHeaderValue(/*HeaderStoreItemInfo*/ info, /*HeaderDescriptor*/ descriptor, /*string*/ rawValue)
    {
        if (descriptor.Parser  == null)
        {
            if (HttpRuleParser.ContainsNewLine(rawValue))
            {
                //if (NetEventSource.Log.IsEnabled()) NetEventSource.Error(null, SR.Format(SR.net_http_log_headers_no_newlines, descriptor.Name, rawValue));
                    AddInvalidValue(info, rawValue);
            }
            else 
            {
                AddParsedValue(info, rawValue);
            }
        }
        else 
        {
            if (TryParseAndAddRawHeaderValue(descriptor, info, rawValue, true))
            {
            }
        }
    }
    /*bool*/ TryParseAndAddValue(/*HeaderDescriptor*/ descriptor, /*string*/ value)
    {
        /*// We don't use GetOrCreateHeaderInfo() here, since this would create a new header in the store. If parsing
            // the value then throws, we would have to remove the header from the store again. So just get a
            // HeaderStoreItemInfo object and try to parse the value. If it works, we'll add the header.
            HeaderStoreItemInfo*/ let info;
        /*bool*/ let addToStore;
        let $v = { value: set(value){ info = value; } };
        let $v = { value: set(value){ addToStore = value; } };
        PrepareHeaderInfoForAdd(descriptor, $v, $v);
        /*bool*/ let result = TryParseAndAddRawHeaderValue(descriptor, info, value, false);
        if (result && addToStore && info.ParsedAndInvalidValues  != null)
        {
            info.AssertContainsNoInvalidValues();
            // If we get here, then the value could be parsed correctly. If we created a new HeaderStoreItemInfo, add
                // it to the store if we added at least one value.
                Debug.Assert(Contains(descriptor));
            AddEntryToStore(new HeaderEntry(descriptor, info));
        }
        return result;
    }
    /*bool*/ TryParseAndAddRawHeaderValue(/*HeaderDescriptor*/ descriptor, /*HeaderStoreItemInfo*/ info, /*string*/ value, /*bool*/ addWhenInvalid)
    {
        Debug.Assert(info != null);
        Debug.Assert(descriptor.Parser  != null);
        if (info.CanAddParsedValue(descriptor.Parser))
        {
            if (addWhenInvalid)
            {
                AddInvalidValue(info, value ?? .Empty);
            }
            return false;
        }
        /*int*/ let index = 0;
        let $v = { value: set(value){ index = value; } };
        let parsedValue = null;
        let $v = { value: set(value){ parsedValue = value; } };
        if (descriptor.Parser.TryParseValue(value, info.ParsedAndInvalidValues, $v, $v))
        {
            if (value == null || index == value.Length)
            {
                if (parsedValue != null)
                {
                    AddParsedValue(info, parsedValue);
                }
                else if (addWhenInvalid && info.ParsedAndInvalidValues )
                {
                    AddInvalidValue(info, value ?? .Empty);
                }
                return true;
            }
            Debug.Assert(index < value.Length, "Parser must return an index value within the string length.");
            /*// If we successfully parsed a value, but there are more left to read, store the results in a temp
                // list. Only when all values are parsed successfully write the list to the store.
                List<object>*/ let parsedValues = new List_$1(object);
            if (parsedValue != null)
            {
                parsedValues.Add(parsedValue);
            }
            while(index < value.Length)
            {
                let $v = { value: set(value){ index = value; } };
                let $v = { value: set(value){ parsedValue = value; } };
                if (descriptor.Parser.TryParseValue(value, info.ParsedAndInvalidValues, $v, $v))
                {
                    if (parsedValue != null)
                    {
                        parsedValues.Add(parsedValue);
                    }
                }
                else 
                {
                    if (addWhenInvalid)
                    {
                        AddInvalidValue(info, value);
                    }
                    return false;
                }
            }
            BlazorJs.forEach(parsedValues, function(item, $_i)
            {
                AddParsedValue(info, item);
            });
            if (parsedValues.Count  == 0 && addWhenInvalid && info.ParsedAndInvalidValues )
            {
                AddInvalidValue(info, value);
            }
            return true;
        }
        Debug.Assert(value != null);
        if (addWhenInvalid)
        {
            AddInvalidValue(info, value ?? .Empty);
        }
        return false;
    }
    /*void*/ AddParsedValue(/*HeaderStoreItemInfo*/ info, /*object*/ value)
    {
        Debug.Assert(value is List_$1, "Header value types must not derive from List<object> since this type is used internally to store " + "lists of values. So we would not be able to distinguish between a single value and a list of values.");
        let $v = { value: set(value){ info.ParsedAndInvalidValues = value; } };
        AddValueToStoreValue_$1(object, value, $v);
    }
    /*void*/ AddInvalidValue(/*HeaderStoreItemInfo*/ info, /*string*/ value)
    {
        let $v = { value: set(value){ info.ParsedAndInvalidValues = value; } };
        AddValueToStoreValue_$1(object, new InvalidValue(value), $v);
    }
    /*void*/ AddRawValue(/*HeaderStoreItemInfo*/ info, /*string*/ value)
    {
        let $v = { value: set(value){ info.RawValue = value; } };
        AddValueToStoreValue_$1(string, value, $v);
    }
    /*void*/ AddValueToStoreValue(T, /*T*/ value, /*object*/ currentStoreValue)
    {
        if (currentStoreValue == null)
        {
            currentStoreValue = value;
        }
        else 
        {
            /*List<T>*/ let storeValues = currentStoreValue as List_$1;
            if (storeValues == null)
            {
                storeValues = new List_$1(T, 2);
                Debug.Assert(currentStoreValue is T);
                storeValues.Add(TcurrentStoreValue);
                currentStoreValue = storeValues;
            }
            Debug.Assert(value is T);
            storeValues.Add(Tvalue);
        }
    }
    /*object*/ GetSingleParsedValue(/*HeaderDescriptor*/ descriptor)
    {
        let info = null;
        let $v = { value: set(value){ info = value; } };
        if (TryGetAndParseHeaderInfo(descriptor, $v))
        {
            return null;
        }
        return info.GetSingleParsedValue();
    }
    /*object*/ GetParsedAndInvalidValues(/*HeaderDescriptor*/ descriptor)
    {
        let info = null;
        let $v = { value: set(value){ info = value; } };
        if (TryGetAndParseHeaderInfo(descriptor, $v))
        {
            return null;
        }
        return info.ParsedAndInvalidValues;
    }
    /*bool*/ IsAllowedHeaderName(/*HeaderDescriptor*/ descriptor)
    {
        true;
    }
    /*void*/ PrepareHeaderInfoForAdd(/*HeaderDescriptor*/ descriptor, /*HeaderStoreItemInfo*/ info, /*bool*/ addToStore)
    {
        if (IsAllowedHeaderName(descriptor))
        {
            throw new InvalidOperationException("net_http_headers_not_allowed_header_name");
        }
        addToStore = false;
        let $v = { value: set(value){ info = value; } };
        if (TryGetAndParseHeaderInfo(descriptor, $v))
        {
            info = new HeaderStoreItemInfo();
            addToStore = true;
        }
    }
    /*void*/ ParseAndAddValue(/*HeaderDescriptor*/ descriptor, /*HeaderStoreItemInfo*/ info, /*string*/ value)
    {
        Debug.Assert(info != null);
        if (descriptor.Parser  == null)
        {
            // If we don't have a parser for the header, we consider the value valid if it doesn't contains
                // newline characters. We add the values as "parsed value". Note that we allow empty values.
                CheckContainsNewLine(value);
            AddParsedValue(info, value ?? .Empty);
            return ;
        }
        if (info.CanAddParsedValue(descriptor.Parser))
        {
            throw new FormatException("net_http_headers_single_value_header");
        }
        /*int*/ let index = 0;
        let $v = { value: set(value){ index = value; } };
        /*object*/ let parsedValue = descriptor.Parser.ParseValue(value, info.ParsedAndInvalidValues, $v);
        if (value == null || index == value.Length)
        {
            if (parsedValue != null)
            {
                AddParsedValue(info, parsedValue);
            }
            return ;
        }
        Debug.Assert(index < value.Length, "Parser must return an index value within the string length.");
        /*// If we successfully parsed a value, but there are more left to read, store the results in a temp
            // list. Only when all values are parsed successfully write the list to the store.
            List<object>*/ let parsedValues = new List_$1(object);
        if (parsedValue != null)
        {
            parsedValues.Add(parsedValue);
        }
        while(index < value.Length)
        {
            let $v = { value: set(value){ index = value; } };
            parsedValue = descriptor.Parser.ParseValue(value, info.ParsedAndInvalidValues, $v);
            if (parsedValue != null)
            {
                parsedValues.Add(parsedValue);
            }
        }
        BlazorJs.forEach(parsedValues, function(item, $_i)
        {
            AddParsedValue(info, item);
        });
    }
    /*HeaderDescriptor*/ GetHeaderDescriptor(/*string*/ name)
    {
        if (.IsNullOrEmpty(name))
        throw new ArgumentException(nameof(name));
        let descriptor = null;
        let $v = { value: set(value){ descriptor = value; } };
        if (HeaderDescriptor.TryGet(name, $v))
        {
            throw new FormatException("net_http_headers_invalid_header_name");
        }
        if (descriptor.HeaderType  & _allowedHeaderTypes != 0)
        {
            return descriptor;
        }
        else if (descriptor.HeaderType  & _treatAsCustomHeaderTypes != 0)
        {
            return descriptor.AsCustomHeader();
        }
        throw new InvalidOperationException("net_http_headers_not_allowed_header_name");
    }
    /*bool*/ TryGetHeaderDescriptor(/*string*/ name, /*HeaderDescriptor*/ descriptor)
    {
        if (.IsNullOrEmpty(name))
        {
            descriptor = default;
            return false;
        }
        let $v = { value: set(value){ descriptor = value; } };
        if (HeaderDescriptor.TryGet(name, $v))
        {
            /*HttpHeaderType*/ let headerType = descriptor.HeaderType;
            if (headerType & _allowedHeaderTypes != 0)
            {
                return true;
            }
            if (headerType & _treatAsCustomHeaderTypes != 0)
            {
                descriptor = descriptor.AsCustomHeader();
                return true;
            }
        }
        return false;
    }
    /*void*/ CheckContainsNewLine(/*string*/ value)
    {
        if (value == null)
        {
            return ;
        }
        if (HttpRuleParser.ContainsNewLine(value))
        {
            throw new FormatException("net_http_headers_no_newlines");
        }
    }
    /*string[]*/ GetStoreValuesAsStringArray(/*HeaderDescriptor*/ descriptor, /*HeaderStoreItemInfo*/ info)
    {
        let singleValue = null;
        let $v = { value: set(value){ singleValue = value; } };
        let multiValue = null;
        let $v = { value: set(value){ multiValue = value; } };
        GetStoreValuesAsStringOrStringArray(descriptor, info, $v, $v);
        Debug.Assert(singleValue ^ multiValue);
        return multiValue ?? singleValue;
    }
    /*void*/ GetStoreValuesAsStringOrStringArray(/*HeaderDescriptor*/ descriptor, /*object*/ sourceValues, /*string*/ singleValue, /*string[]*/ multiValue)
    {
        /*HeaderStoreItemInfo*/ let info = sourceValues as HeaderStoreItemInfo;
        if (info)
        {
            /*HeaderEntry*/ let entry = HeaderEntrysourceValues;
            Debug.Assert(entry.Value  is );
            singleValue = entry.Value;
            multiValue = null;
            return ;
        }
info        {
            /*int*/ let length = GetValueCount(info);
            /*Span<string>*/ let values;
            singleValue = null;
            if (length == 1)
            {
                multiValue = null;
                values = new Span_$1(string, singleValue);
            }
            else 
            {
                Debug.Assert(length > 1, "The header should have been removed when it became empty");
                values = multiValue = new Array(length);
            }
            /*int*/ let currentIndex = 0;
            let $v = { value: set(value){ currentIndex = value; } };
            ReadStoreValues_$1(object, values, info.ParsedAndInvalidValues, descriptor.Parser, $v);
            let $v = { value: set(value){ currentIndex = value; } };
            ReadStoreValues_$1(string, values, info.RawValue, null, $v);
            Debug.Assert(currentIndex == length);
        }
    }
    /*int*/ GetStoreValuesIntoStringArray(/*HeaderDescriptor*/ descriptor, /*object*/ sourceValues, /*string[]*/ values)
    {
        values = values ?? Array.Empty(string);
        /*HeaderStoreItemInfo*/ let info = sourceValues as HeaderStoreItemInfo;
        if (info)
        {
            Debug.Assert(sourceValues is );
            if (values.Length  == 0)
            {
                values = new Array(1);
            }
            values0 = sourceValues;
            return 1;
        }
info        {
            /*int*/ let length = GetValueCount(info);
            Debug.Assert(length > 0);
            if (values.Length  < length)
            {
                values = new Array(length);
            }
            /*int*/ let currentIndex = 0;
            let $v = { value: set(value){ currentIndex = value; } };
            ReadStoreValues_$1(object, values, info.ParsedAndInvalidValues, descriptor.Parser, $v);
            let $v = { value: set(value){ currentIndex = value; } };
            ReadStoreValues_$1(string, values, info.RawValue, null, $v);
            Debug.Assert(currentIndex == length);
            return length;
        }
    }
    /*int*/ CountObj(T, /*object*/ valueStore)
    {
        valueStore0valueStore instanceof List_$1, list = valueStorelist.Count 1;
    }
    /*int*/ GetValueCount(/*HeaderStoreItemInfo*/ info)
    {
        Debug.Assert(info != null);
        return CountObj_$1(object, info.ParsedAndInvalidValues) + CountObj_$1(string, info.RawValue);
    }
    /*void*/ ReadStoreValues(T, /*Span<string>*/ values, /*object*/ storeValue, /*HttpHeaderParser*/ parser, /*int*/ currentIndex)
    {
        if (storeValue != null)
        {
            /*List<T>*/ let storeValues = storeValue as List_$1;
            if (storeValues == null)
            {
                valuescurrentIndex = parser == null || storeValue is InvalidValuestoreValue.ToString()parser.ToString(storeValue);
                currentIndex++;
            }
            else 
            {
                BlazorJs.forEach(storeValues, function(item, $_i)
                {
                    Debug.Assert(item != null);
                    valuescurrentIndex = parser == null || item is InvalidValueitem.ToString()parser.ToString(item);
                    currentIndex++;
                });
            }
        }
    }
    /*bool*/ AreEqual(/*object*/ value, /*object*/ storeValue, /*IEqualityComparer*/ comparer)
    {
        Debug.Assert(value != null);
        if (comparer != null)
        {
            return comparer.Equals(value, storeValue);
        }
        return value.Equals(storeValue);
    }
    class System_Net_Http_Headers_InvalidValue extends object
    {
        /*string*/ _value = null;
        constructor(/*string*/ value)
        {
            super();
            Debug.Assert(value);
            _value = value;
        }
        /*string*/ ToString()
        {
            _value;
        }
    }
    class System_Net_Http_Headers_HeaderStoreItemInfo extends object
    {
        constructor()
        {
            super();
        }
        /*object*/ RawValue = null;
        /*object*/ ParsedAndInvalidValues = null;
        /*bool*/ CanAddParsedValue(/*HttpHeaderParser*/ parser)
        {
            Debug.Assert(parser != null, "There should be no reason to call CanAddValue if there is no parser for the current header.");
            return parser.SupportsMultipleValues  || ParsedAndInvalidValues;
        }
        /*void*/ AssertContainsNoInvalidValues()
        {
            if (ParsedAndInvalidValues)
            {
                if (ParsedAndInvalidValues instanceof List_$1, list = ParsedAndInvalidValues)
                {
                    BlazorJs.forEach(list, function(item, $_i)
                    {
                        Debug.Assert(item is InvalidValue);
                    });
                }
                else 
                {
                    Debug.Assert(ParsedAndInvalidValues is InvalidValue);
                }
            }
        }
        /*object*/ GetSingleParsedValue()
        {
            if (ParsedAndInvalidValues)
            {
                if (ParsedAndInvalidValues instanceof List_$1, list = ParsedAndInvalidValues)
                {
                    AssertContainsSingleParsedValue(list);
                    BlazorJs.forEach(list, function(item, $_i)
                    {
                        if (item is InvalidValue)
                        {
                            return item;
                        }
                    });
                }
                else 
                {
                    if (ParsedAndInvalidValues is InvalidValue)
                    {
                        return ParsedAndInvalidValues;
                    }
                }
            }
            return null;
        }
        /*void*/ AssertContainsSingleParsedValue(/*List<object>*/ list)
        {
            /*int*/ let count = 0;
            BlazorJs.forEach(list, function(item, $_i)
            {
                if (item is InvalidValue)
                {
                    count++;
                }
            });
            Debug.Assert(count == 1, "Only a single parsed value should be stored for this parser");
        }
        /*bool*/ get IsEmpty()
        {
            return RawValue == null && ParsedAndInvalidValues == null;
        }
    }
    /*int*/ InitialCapacity = 4;
    /*int*/ ArrayThreshold = 64;
    /*HeaderEntry[]*/ GetEntriesArray()
    {
        /*object*/ let store = _headerStore;
        if (store)
        {
            return null;
        }
        else if (store instanceof HeaderEntry, entries = store)
        {
            return entries;
        }
        else 
        {
            return GetEntriesFromDictionary();
        }
HeaderEntry        {
            /*var*/ let dictionary = Dictionary_$2_headerStore;
            /*var*/ let entries = new Array(dictionary.Count);
            /*int*/ let i = 0;
            BlazorJs.forEach(dictionary, function(entry, $_i)
            {
                entriesi++ = new HeaderEntry()Key = entry.KeyValue = entry.Value
;
            });
            return entries;
        }
    }
    /*ReadOnlySpan<HeaderEntry>*/ GetEntries()
    {
        return new ReadOnlySpan_$1(HeaderEntry, GetEntriesArray(), 0, _count);
    }
    /*int*/ get Count()
    {
        return _count;
    }
    /*bool*/ get EntriesAreLiveView()
    {
        return _headerStore is HeaderEntry;
    }
    /*HeaderEntry*/ GetValueRefOrNullRef(/*HeaderDescriptor*/ key)
    {
        /*HeaderEntry*/ let valueRef = null;
        /*object*/ let store = _headerStore;
        if (store instanceof HeaderEntry, entries = store)
        {
            for(/*int*/ let i = 0; i < _count && i < entries.Length; i++)
            {
                if (key.Equals(entriesi.Key))
                {
                    valueRef = entriesi;
                    break;
                }
            });
        }
        else if (store)
        {
            valueRef = Dictionary_$2store.GetValueOrDefault(key);
        }
        return valueRef;
    }
    /*HeaderEntry*/ GetValueRefOrAddDefault(/*HeaderDescriptor*/ key)
    {
        /*object*/ let store = _headerStore;
        if (store instanceof HeaderEntry, entries = store)
        {
            for(/*int*/ let i = 0; i < _count && i < entries.Length; i++)
            {
                if (key.Equals(entriesi.Key))
                {
                    return entriesi;
                }
            });
            /*int*/ let count = _count;
            _count++;
            if (count < entries.Length)
            {
                entriescount.Key  = key;
                return entriescount;
            }
            return GrowEntriesAndAddDefault(key);
        }
        else if (store)
        {
            _count++;
            entries = new Array(InitialCapacity);
            _headerStore = entries;
            /*HeaderEntry*/ let firstEntry = entries0;
            firstEntry.Key  = key;
            return firstEntry;
        }
        else 
        {
            return DictionaryGetValueRefOrAddDefault(key);
        }
HeaderEntryHeaderDescriptor        {
            /*var*/ let mentries = HeaderEntry_headerStore;
            if (mentries.Length  == ArrayThreshold)
            {
                return ConvertToDictionaryAndAddDefault(mkey);
            }
            else 
            {
                let $v = { value: set(value){ mentries = value; } };
                Array.Resize($v, mentries.Length  << 1);
                _headerStore = mentries;
                /*HeaderEntry*/ let firstNewEntry = mentriesmentries.Length  >> 1;
                firstNewEntry.Key  = mkey;
                return firstNewEntry;
            }
        }
HeaderEntryHeaderDescriptor        {
            /*var*/ let mentries = HeaderEntry_headerStore;
            /*var*/ let dictionary = new Dictionary_$2(HeaderDescriptor, HeaderEntry, ArrayThreshold);
            _headerStore = dictionary;
            BlazorJs.forEach(mentries, function(entry, $_i)
            {
                dictionary.Add(entry.Key, entry);
            });
            Debug.Assert(dictionary.Count  == _count - 1);
            let value = null;
            let $v = { value: set(value){ value = value; } };
            if (dictionary.TryGetValue(mkey, $v))
            {
                value = new HeaderEntry()Key = mkey;
                dictionarymkey = value;
            }
            return value;
        }
HeaderEntryHeaderDescriptor        {
            /*var*/ let dictionary = Dictionary_$2_headerStore;
            let value = null;
            let $v = { value: set(value){ value = value; } };
            if (dictionary.TryGetValue(mkey, $v))
            {
                value = new HeaderEntry()Key = mkey;
                dictionarymkey = value;
            }
            if (value.Value )
            {
                _count++;
            }
            return value;
        }
    }
    /*void*/ AddEntryToStore(/*HeaderEntry*/ entry)
    {
        Debug.Assert(Contains(entry.Key));
        if (_headerStore instanceof HeaderEntry, entries = _headerStore)
        {
            /*int*/ let count = _count;
            if (count < entries.Length)
            {
                entriescount = entry;
                _count++;
                return ;
            }
        }
        /*var*/ let val = GetValueRefOrAddDefault(entry.Key);
        if (val != null)
        val.Value  = entry.Value;
    }
    /*bool*/ Contains(/*HeaderDescriptor*/ key)
    {
        return GetValueRefOrNullRef(key) != null;
    }
    /*void*/ Clear()
    {
        if (_headerStore instanceof HeaderEntry, entries = _headerStore)
        {
            Array.Clear(entries, 0, _count);
        }
        else 
        {
            _headerStore = null;
        }
        _count = 0;
    }
    /*bool*/ Remove(/*HeaderDescriptor*/ key)
    {
        /*bool*/ let removed = false;
        /*object*/ let store = _headerStore;
        if (store instanceof HeaderEntry, entries = store)
        {
            for(/*int*/ let i = 0; i < _count && i < entries.Length; i++)
            {
                if (key.Equals(entriesi.Key))
                {
                    while(i + 1 < _count && i + 1 < entries.Length)
                    {
                        entriesi = entriesi + 1;
                        i++;
                    }
                    entriesi = default;
                    removed = true;
                    break;
                }
            });
        }
        else if (store)
        {
            removed = Dictionary_$2store.Remove(key);
        }
        if (removed)
        {
            _count--;
        }
        return removed;
    }
}

class System_Net_Http_Headers_HttpHeadersNonValidated extends H5_IH5Class(System_Collections_IEnumerable(System_Collections_Generic_IEnumerable<System_Collections_Generic_KeyValuePair<string, System_Net_Http_Headers_HeaderStringValues>>(System_Collections_Generic_IReadOnlyCollection<System_Collections_Generic_KeyValuePair<string, System_Net_Http_Headers_HeaderStringValues>>(System_Collections_Generic_IReadOnlyDictionary<string, System_Net_Http_Headers_HeaderStringValues>(System_ValueType)))))
{
    /*HttpHeaders*/ _headers = null;
    constructor(/*HttpHeaders*/ headers)
    {
        super();
    }
    /*int*/ get Count()
    {
        return _headersCount ?? 0;
    }
    /*bool*/ Contains(/*string*/ headerName)
    {
        let descriptor = null;
        let $v = { value: set(value){ descriptor = value; } };
        _headers instanceof HttpHeaders, headers = _headers && headers.TryGetHeaderDescriptor(headerName, $v) && headers.Contains(descriptor);
    }
HeaderStringValues    {
        let values = null;
        let $v = { value: set(value){ values = value; } };
        if (TryGetValues(headerName, $v))
        {
            return values;
        }
        throw new KeyNotFoundException("net_http_headers_not_found");
    }
    /*/// <inheritdoc/>
        bool*/ ContainsKey(/*string*/ key)
    {
        Contains(key);
    }
    /*bool*/ TryGetValues(/*string*/ headerName, /*HeaderStringValues*/ values)
    {
        let descriptor = null;
        let $v = { value: set(value){ descriptor = value; } };
        let info = null;
        let $v = { value: set(value){ info = value; } };
        if (_headers instanceof HttpHeaders, headers = _headers && headers.TryGetHeaderDescriptor(headerName, $v) && headers.TryGetHeaderValue(descriptor, $v))
        {
            let singleValue = null;
            let $v = { value: set(value){ singleValue = value; } };
            let multiValue = null;
            let $v = { value: set(value){ multiValue = value; } };
            HttpHeaders.GetStoreValuesAsStringOrStringArray(descriptor, info, $v, $v);
            Debug.Assert(singleValue ^ multiValue);
            values = singleValuenew HeaderStringValues(descriptor, singleValue)new HeaderStringValues(descriptor, multiValue);
            return true;
        }
        values = default;
        return false;
    }
    /*/// <inheritdoc/>
        bool*/ TryGetValue(/*string*/ key, /*HeaderStringValues*/ value)
    {
        let $v = { value: set(value){ value = value; } };
        TryGetValues(key, $v);
    }
    /*Enumerator*/ GetEnumerator()
    {
        _headers instanceof HttpHeaders, headers = _headers && headers.GetEntriesArray() instanceof HeaderEntrynew Enumerator(entries, headers.Count)default;
    }
    /*/// <inheritdoc/>
        IEnumerator<KeyValuePair<string, HeaderStringValues>>*/ GetEnumerator()
    {
        GetEnumerator();
    }
    /*/// <inheritdoc/>
        IEnumerator*/ GetEnumerator()
    {
        GetEnumerator();
    }
    /*/// <inheritdoc/>
        IEnumerable<string>*/ get Keys()
    {
        BlazorJs.forEach(, function(header, $_i)
        {
header.Key        });
    }
    /*/// <inheritdoc/>
        IEnumerable<HeaderStringValues>*/ get Values()
    {
        BlazorJs.forEach(, function(header, $_i)
        {
header.Value        });
    }
    class System_Net_Http_Headers_Enumerator extends System_Collections_IEnumerator(System_IDisposable(System_Collections_Generic_IEnumerator<System_Collections_Generic_KeyValuePair<string, System_Net_Http_Headers_HeaderStringValues>>(System_ValueType)))
    {
        /*HeaderEntry[]*/ _entries = null;
        /*int*/ _numberOfEntries = null;
        /*int*/ _index = null;
        /*KeyValuePair<string, HeaderStringValues>*/ _current = null;
        constructor(/*HeaderEntry[]*/ entries, /*int*/ numberOfEntries)
        {
            super();
            _entries = entries;
            _numberOfEntries = numberOfEntries;
            _index = 0;
            _current = default;
        }
        /*bool*/ MoveNext()
        {
            /*int*/ let index = _index;
            if (_entries instanceof HeaderEntry, entries = _entries && index < _numberOfEntries && index < entries.Length)
            {
                /*HeaderEntry*/ let entry = entriesindex;
                _index++;
                let singleValue = null;
                let $v = { value: set(value){ singleValue = value; } };
                let multiValue = null;
                let $v = { value: set(value){ multiValue = value; } };
                HttpHeaders.GetStoreValuesAsStringOrStringArray(entry.Key, entry.Value, $v, $v);
                Debug.Assert(singleValue ^ multiValue);
                _current = new KeyValuePair_$2(string, HeaderStringValues, entry.Key.Name, singleValuenew HeaderStringValues(entry.Key, singleValue)new HeaderStringValues(entry.Key, multiValue));
                return true;
            }
            _current = default;
            return false;
        }
        /*KeyValuePair<string, HeaderStringValues>*/ get Current()
        {
            return _current;
        }
        /*/// <inheritdoc/>
            object*/ get Current()
        {
            return _current;
        }
        /*void*/ Dispose()
        {
        }
        /*/// <inheritdoc/>
            void*/ Reset()
        {
                        throw new NotSupportedException();
;
        }
    }
}

 = 0b1 = 0b10 = 0b100 = 0b1000 = 0b10000 = 0b100000 = 0b111111 = 0
const System_Net_Http_Headers_HttpHeaderValueCollection$_1 = (T) => class extends H5_IH5Class(System_Collections_IEnumerable(System_Collections_Generic_IEnumerable<T>(System_Collections_Generic_ICollection<T>(object))))
{
T    /*HeaderDescriptor*/ _descriptor = null;
    /*HttpHeaders*/ _store = null;
    /*int*/ get Count()
    {
        return GetCount();
    }
    /*bool*/ get IsReadOnly()
    {
        return false;
    }
    constructor(/*HeaderDescriptor*/ descriptor, /*HttpHeaders*/ store)
    {
        super();
        _store = store;
        _descriptor = descriptor;
    }
    /*void*/ Add(/*T*/ item)
    {
        CheckValue(item);
        _store.AddParsedValue(_descriptor, item);
    }
    /*void*/ ParseAdd(/*string*/ input)
    {
        _store.Add(_descriptor, input);
    }
    /*bool*/ TryParseAdd(/*string*/ input)
    {
        return _store.TryParseAndAddValue(_descriptor, input);
    }
    /*void*/ Clear()
    {
        _store.Remove(_descriptor);
    }
    /*bool*/ Contains(/*T*/ item)
    {
        CheckValue(item);
        return _store.ContainsParsedValue(_descriptor, item);
    }
    /*void*/ CopyTo(/*T[]*/ array, /*int*/ arrayIndex)
    {
        if (array == null)
        throw new ArgumentNullException(nameof(array));
        if (arrayIndex < 0 || arrayIndex > array.Length)
        {
            throw new ArgumentOutOfRangeException(nameof(arrayIndex));
        }
        /*//// Allow arrayIndex == array.Length in case our own collection is empty
            //ArgumentOutOfRangeException.ThrowIfNegative(arrayIndex);
            //ArgumentOutOfRangeException.ThrowIfGreaterThan(arrayIndex, array.Length);

            object*/ let storeValue = _store.GetParsedAndInvalidValues(_descriptor);
        if (storeValue == null)
        {
            return ;
        }
        /*List<object>*/ let storeValues = storeValue as List_$1;
        if (storeValues == null)
        {
            if (storeValue is HttpHeadersInvalidValue)
            {
                Debug.Assert(storeValue is T);
                if (arrayIndex == array.Length)
                {
                    throw new ArgumentException("net_http_copyto_array_too_small");
                }
                arrayarrayIndex = TstoreValue;
            }
        }
        else 
        {
            BlazorJs.forEach(storeValues, function(item, $_i)
            {
                if (item is HttpHeadersInvalidValue)
                {
                    Debug.Assert(item is T);
                    if (arrayIndex == array.Length)
                    {
                        throw new ArgumentException("net_http_copyto_array_too_small");
                    }
                    arrayarrayIndex++ = Titem;
                }
            });
        }
    }
    /*bool*/ Remove(/*T*/ item)
    {
        CheckValue(item);
        return _store.RemoveParsedValue(_descriptor, item);
    }
    /*IEnumerator<T>*/ GetEnumerator()
    {
        /*object*/ let storeValue = _store.GetParsedAndInvalidValues(_descriptor);
        return storeValue || storeValue is HttpHeadersInvalidValueIEnumerable_$1Array.Empty(T).GetEnumerator()Iterate(storeValue);
IEnumerator_$1        {
            if (mstoreValue instanceof List_$1, storeValues = mstoreValue)
            {
                BlazorJs.forEach(storeValues, function(item, $_i)
                {
                    if (item is HttpHeadersInvalidValue)
                    {
                    }
                    Debug.Assert(item is T);
Titem                });
            }
            else 
            {
                Debug.Assert(mstoreValue is T);
TmstoreValue            }
        }
    }
    /*#endregion

        #region IEnumerable Members

        Collections.IEnumerator*/ GetEnumerator()
    {
        return GetEnumerator();
    }
    /*string*/ ToString()
    {
        return _store.GetHeaderString(_descriptor);
    }
    /*void*/ CheckValue(/*T*/ item)
    {
        if (item == null)
        throw new ArgumentNullException(nameof(item));
        if (_descriptor.Parser  == GenericHeaderParser.TokenListParser)
        {
            // The collection expects valid HTTP tokens, which are typed as string.
                // Unlike other parsed values (which are always valid by construction),
                // we can't assume the provided string is a valid token. So validate it before we use it.
                Debug.Assert(T == );
            HeaderUtilities.CheckValidToken(item, nameof(item));
        }
    }
    /*int*/ GetCount()
    {
        /*// This is an O(n) operation.

            object*/ let storeValue = _store.GetParsedAndInvalidValues(_descriptor);
        if (storeValue == null)
        {
            return 0;
        }
        /*List<object>*/ let storeValues = storeValue as List_$1;
        if (storeValues == null)
        {
            if (storeValue is HttpHeadersInvalidValue)
            {
                return 1;
            }
            return 0;
        }
        else 
        {
            /*int*/ let count = 0;
            BlazorJs.forEach(storeValues, function(item, $_i)
            {
                if (item is HttpHeadersInvalidValue)
                {
                    count++;
                }
            });
            return count;
        }
    }
}

class System_Net_Http_Headers_HttpRequestHeaders extends System_Net_Http_Headers_HttpHeaders
{
    /*int*/ AcceptSlot = 0;
    /*int*/ AcceptCharsetSlot = 1;
    /*int*/ AcceptEncodingSlot = 2;
    /*int*/ AcceptLanguageSlot = 3;
    /*int*/ IfMatchSlot = 4;
    /*int*/ IfNoneMatchSlot = 5;
    /*int*/ TransferEncodingSlot = 6;
    /*int*/ UserAgentSlot = 7;
    /*int*/ ExpectSlot = 8;
    /*int*/ ProtocolSlot = 9;
    /*int*/ NumCollectionsSlots = 10;
    /*object[]*/ _specialCollectionsSlots = null;
    /*HttpGeneralHeaders*/ _generalHeaders = null;
    /*bool*/ _expectContinueSet = null;
    /*T*/ GetSpecializedCollection(T, /*int*/ slot, /*Func<HttpRequestHeaders, T>*/ creationFunc)
    {
        // 8 properties each lazily allocate a collection to store the value(s) for that property.
            // Rather than having a field for each of these, store them untyped in an array that's lazily
            // allocated.  Then we only pay for the 64 bytes for those fields when any is actually accessed.
            _specialCollectionsSlots = _specialCollectionsSlots ?? new Array(NumCollectionsSlots);
        return T_specialCollectionsSlotsslot = _specialCollectionsSlotsslot ?? creationFunc();
    }
    /*HttpHeaderValueCollection<MediaTypeWithQualityHeaderValue>*/ get Accept()
    {
        return GetSpecializedCollection(AcceptSlot, function(/**/ thisRef)
        {
new HttpHeaderValueCollection_$1(MediaTypeWithQualityHeaderValue, KnownHeaders.Accept.Descriptor, thisRef)        });
    }
    /*HttpHeaderValueCollection<StringWithQualityHeaderValue>*/ get AcceptCharset()
    {
        return GetSpecializedCollection(AcceptCharsetSlot, function(/**/ thisRef)
        {
new HttpHeaderValueCollection_$1(StringWithQualityHeaderValue, KnownHeaders.AcceptCharset.Descriptor, thisRef)        });
    }
    /*HttpHeaderValueCollection<StringWithQualityHeaderValue>*/ get AcceptEncoding()
    {
        return GetSpecializedCollection(AcceptEncodingSlot, function(/**/ thisRef)
        {
new HttpHeaderValueCollection_$1(StringWithQualityHeaderValue, KnownHeaders.AcceptEncoding.Descriptor, thisRef)        });
    }
    /*HttpHeaderValueCollection<StringWithQualityHeaderValue>*/ get AcceptLanguage()
    {
        return GetSpecializedCollection(AcceptLanguageSlot, function(/**/ thisRef)
        {
new HttpHeaderValueCollection_$1(StringWithQualityHeaderValue, KnownHeaders.AcceptLanguage.Descriptor, thisRef)        });
    }
    /*AuthenticationHeaderValue*/ get Authorization()
    {
        return AuthenticationHeaderValueGetSingleParsedValue(KnownHeaders.Authorization.Descriptor);
    }
    /*AuthenticationHeaderValue*/ set Authorization(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.Authorization.Descriptor, value);
    }
    /*bool?*/ get ExpectContinue()
    {
        if (ContainsParsedValue(KnownHeaders.Expect.Descriptor, HeaderUtilities.ExpectContinue))
        {
            return true;
        }
        if (_expectContinueSet)
        {
            return false;
        }
        return null;
    }
    /*bool?*/ set ExpectContinue(value)
    {
        if (value == true)
        {
            _expectContinueSet = true;
            if (ContainsParsedValue(KnownHeaders.Expect.Descriptor, HeaderUtilities.ExpectContinue))
            {
                AddParsedValue(KnownHeaders.Expect.Descriptor, HeaderUtilities.ExpectContinue);
            }
        }
        else 
        {
            _expectContinueSet = value != null;
            // We intentionally ignore the return value. It's OK if "100-continue" wasn't in the store.
                    RemoveParsedValue(KnownHeaders.Expect.Descriptor, HeaderUtilities.ExpectContinue);
        }
    }
    /*string*/ get From()
    {
        return GetSingleParsedValue(KnownHeaders.From.Descriptor);
    }
    /*string*/ set From(value)
    {
        if (value == .Empty)
        {
            value = null;
        }
        CheckContainsNewLine(value);
        SetOrRemoveParsedValue(KnownHeaders.From.Descriptor, value);
    }
    /*string*/ get Host()
    {
        return GetSingleParsedValue(KnownHeaders.Host.Descriptor);
    }
    /*string*/ set Host(value)
    {
        if (value == .Empty)
        {
            value = null;
        }
        if (value != null && HttpRuleParser.GetHostLength(value, 0, false) != value.Length)
        {
            throw new FormatException("net_http_headers_invalid_host_header");
        }
        SetOrRemoveParsedValue(KnownHeaders.Host.Descriptor, value);
    }
    /*HttpHeaderValueCollection<EntityTagHeaderValue>*/ get IfMatch()
    {
        return GetSpecializedCollection(IfMatchSlot, function(/**/ thisRef)
        {
new HttpHeaderValueCollection_$1(EntityTagHeaderValue, KnownHeaders.IfMatch.Descriptor, thisRef)        });
    }
    /*DateTimeOffset?*/ get IfModifiedSince()
    {
        return HeaderUtilities.GetDateTimeOffsetValue(KnownHeaders.IfModifiedSince.Descriptor, );
    }
    /*DateTimeOffset?*/ set IfModifiedSince(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.IfModifiedSince.Descriptor, value);
    }
    /*HttpHeaderValueCollection<EntityTagHeaderValue>*/ get IfNoneMatch()
    {
        return GetSpecializedCollection(IfNoneMatchSlot, function(/**/ thisRef)
        {
new HttpHeaderValueCollection_$1(EntityTagHeaderValue, KnownHeaders.IfNoneMatch.Descriptor, thisRef)        });
    }
    /*RangeConditionHeaderValue*/ get IfRange()
    {
        return RangeConditionHeaderValueGetSingleParsedValue(KnownHeaders.IfRange.Descriptor);
    }
    /*RangeConditionHeaderValue*/ set IfRange(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.IfRange.Descriptor, value);
    }
    /*DateTimeOffset?*/ get IfUnmodifiedSince()
    {
        return HeaderUtilities.GetDateTimeOffsetValue(KnownHeaders.IfUnmodifiedSince.Descriptor, );
    }
    /*DateTimeOffset?*/ set IfUnmodifiedSince(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.IfUnmodifiedSince.Descriptor, value);
    }
    /*int?*/ get MaxForwards()
    {
        /*object*/ let storedValue = GetSingleParsedValue(KnownHeaders.MaxForwards.Descriptor);
        if (storedValue != null)
        {
            return storedValue;
        }
        return null;
    }
    /*int?*/ set MaxForwards(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.MaxForwards.Descriptor, value);
    }
    /*string*/ get Protocol()
    {
        return _specialCollectionsSlotsnull_specialCollectionsSlotsProtocolSlot;
    }
    /*string*/ set Protocol(value)
    {
        CheckContainsNewLine(value);
        _specialCollectionsSlots = _specialCollectionsSlots ?? new Array(NumCollectionsSlots);
        _specialCollectionsSlotsProtocolSlot = value;
    }
    /*AuthenticationHeaderValue*/ get ProxyAuthorization()
    {
        return AuthenticationHeaderValueGetSingleParsedValue(KnownHeaders.ProxyAuthorization.Descriptor);
    }
    /*AuthenticationHeaderValue*/ set ProxyAuthorization(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.ProxyAuthorization.Descriptor, value);
    }
    /*RangeHeaderValue*/ get Range()
    {
        return RangeHeaderValueGetSingleParsedValue(KnownHeaders.Range.Descriptor);
    }
    /*RangeHeaderValue*/ set Range(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.Range.Descriptor, value);
    }
    /*Uri*/ get Referrer()
    {
        return UriGetSingleParsedValue(KnownHeaders.Referer.Descriptor);
    }
    /*Uri*/ set Referrer(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.Referer.Descriptor, value);
    }
    /*HttpHeaderValueCollection<TransferCodingWithQualityHeaderValue>*/ get TE()
    {
        return GetSpecializedCollection(TransferEncodingSlot, function(/**/ thisRef)
        {
new HttpHeaderValueCollection_$1(TransferCodingWithQualityHeaderValue, KnownHeaders.TE.Descriptor, thisRef)        });
    }
    /*HttpHeaderValueCollection<ProductInfoHeaderValue>*/ get UserAgent()
    {
        return GetSpecializedCollection(UserAgentSlot, function(/**/ thisRef)
        {
new HttpHeaderValueCollection_$1(ProductInfoHeaderValue, KnownHeaders.UserAgent.Descriptor, thisRef)        });
    }
    /*HttpHeaderValueCollection<NameValueWithParametersHeaderValue>*/ get Expect()
    {
        return GetSpecializedCollection(ExpectSlot, function(/**/ thisRef)
        {
new HttpHeaderValueCollection_$1(NameValueWithParametersHeaderValue, KnownHeaders.Expect.Descriptor, thisRef)        });
    }
    /*CacheControlHeaderValue*/ get CacheControl()
    {
        return GeneralHeaders.CacheControl;
    }
    /*CacheControlHeaderValue*/ set CacheControl(value)
    {
        GeneralHeaders.CacheControl  = value;
    }
    /*HttpHeaderValueCollection<string>*/ get Connection()
    {
        return GeneralHeaders.Connection;
    }
    /*bool?*/ get ConnectionClose()
    {
        return HttpGeneralHeaders.GetConnectionClose(, _generalHeaders);
    }
    /*bool?*/ set ConnectionClose(value)
    {
        GeneralHeaders.ConnectionClose  = value;
    }
    /*DateTimeOffset?*/ get Date()
    {
        return GeneralHeaders.Date;
    }
    /*DateTimeOffset?*/ set Date(value)
    {
        GeneralHeaders.Date  = value;
    }
    /*HttpHeaderValueCollection<NameValueHeaderValue>*/ get Pragma()
    {
        return GeneralHeaders.Pragma;
    }
    /*HttpHeaderValueCollection<string>*/ get Trailer()
    {
        return GeneralHeaders.Trailer;
    }
    /*HttpHeaderValueCollection<TransferCodingHeaderValue>*/ get TransferEncoding()
    {
        return GeneralHeaders.TransferEncoding;
    }
    /*bool?*/ get TransferEncodingChunked()
    {
        return HttpGeneralHeaders.GetTransferEncodingChunked(, _generalHeaders);
    }
    /*bool?*/ set TransferEncodingChunked(value)
    {
        GeneralHeaders.TransferEncodingChunked  = value;
    }
    /*HttpHeaderValueCollection<ProductHeaderValue>*/ get Upgrade()
    {
        return GeneralHeaders.Upgrade;
    }
    /*HttpHeaderValueCollection<ViaHeaderValue>*/ get Via()
    {
        return GeneralHeaders.Via;
    }
    /*HttpHeaderValueCollection<WarningHeaderValue>*/ get Warning()
    {
        return GeneralHeaders.Warning;
    }
    constructor()
    {
        super(HttpHeaderType.General  | HttpHeaderType.Request  | HttpHeaderType.Custom, HttpHeaderType.Response);
    }
    /*void*/ AddHeaders(/*HttpHeaders*/ sourceHeaders)
    {
        super.AddHeaders(sourceHeaders);
        /*HttpRequestHeaders*/ let sourceRequestHeaders = sourceHeaders as HttpRequestHeaders;
        Debug.Assert(sourceRequestHeaders != null);
        if (sourceRequestHeaders._generalHeaders  != null)
        {
            GeneralHeaders.AddSpecialsFrom(sourceRequestHeaders._generalHeaders);
        }
        /*bool?*/ let expectContinue = ExpectContinue;
        if (expectContinue.HasValue)
        {
            ExpectContinue = sourceRequestHeaders.ExpectContinue;
        }
    }
    /*HttpGeneralHeaders*/ get GeneralHeaders()
    {
        return _generalHeaders = _generalHeaders ?? new HttpGeneralHeaders();
    }
}

class System_Net_Http_Headers_HttpResponseHeaders extends System_Net_Http_Headers_HttpHeaders
{
    /*int*/ AcceptRangesSlot = 0;
    /*int*/ ProxyAuthenticateSlot = 1;
    /*int*/ ServerSlot = 2;
    /*int*/ VarySlot = 3;
    /*int*/ WwwAuthenticateSlot = 4;
    /*int*/ NumCollectionsSlots = 5;
    /*object[]*/ _specialCollectionsSlots = null;
    /*HttpGeneralHeaders*/ _generalHeaders = null;
    /*bool*/ _containsTrailingHeaders = null;
    /*T*/ GetSpecializedCollection(T, /*int*/ slot, /*Func<HttpResponseHeaders, T>*/ creationFunc)
    {
        /*// 5 properties each lazily allocate a collection to store the value(s) for that property.
            // Rather than having a field for each of these, store them untyped in an array that's lazily
            // allocated.  Then we only pay for the 45 bytes for those fields when any is actually accessed.
            object[]*/ let collections = _specialCollectionsSlots = _specialCollectionsSlots ?? new Array(NumCollectionsSlots);
        return Tcollectionsslot = collectionsslot ?? creationFunc();
    }
    /*HttpHeaderValueCollection<string>*/ get AcceptRanges()
    {
        return GetSpecializedCollection(AcceptRangesSlot, function(/**/ thisRef)
        {
new HttpHeaderValueCollection_$1(string, KnownHeaders.AcceptRanges.Descriptor, thisRef)        });
    }
    /*TimeSpan?*/ get Age()
    {
        return HeaderUtilities.GetTimeSpanValue(KnownHeaders.Age.Descriptor, );
    }
    /*TimeSpan?*/ set Age(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.Age.Descriptor, value);
    }
    /*EntityTagHeaderValue*/ get ETag()
    {
        return EntityTagHeaderValueGetSingleParsedValue(KnownHeaders.ETag.Descriptor);
    }
    /*EntityTagHeaderValue*/ set ETag(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.ETag.Descriptor, value);
    }
    /*Uri*/ get Location()
    {
        return UriGetSingleParsedValue(KnownHeaders.Location.Descriptor);
    }
    /*Uri*/ set Location(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.Location.Descriptor, value);
    }
    /*HttpHeaderValueCollection<AuthenticationHeaderValue>*/ get ProxyAuthenticate()
    {
        return GetSpecializedCollection(ProxyAuthenticateSlot, function(/**/ thisRef)
        {
new HttpHeaderValueCollection_$1(AuthenticationHeaderValue, KnownHeaders.ProxyAuthenticate.Descriptor, thisRef)        });
    }
    /*RetryConditionHeaderValue*/ get RetryAfter()
    {
        return RetryConditionHeaderValueGetSingleParsedValue(KnownHeaders.RetryAfter.Descriptor);
    }
    /*RetryConditionHeaderValue*/ set RetryAfter(value)
    {
        SetOrRemoveParsedValue(KnownHeaders.RetryAfter.Descriptor, value);
    }
    /*HttpHeaderValueCollection<ProductInfoHeaderValue>*/ get Server()
    {
        return GetSpecializedCollection(ServerSlot, function(/**/ thisRef)
        {
new HttpHeaderValueCollection_$1(ProductInfoHeaderValue, KnownHeaders.Server.Descriptor, thisRef)        });
    }
    /*HttpHeaderValueCollection<string>*/ get Vary()
    {
        return GetSpecializedCollection(VarySlot, function(/**/ thisRef)
        {
new HttpHeaderValueCollection_$1(string, KnownHeaders.Vary.Descriptor, thisRef)        });
    }
    /*HttpHeaderValueCollection<AuthenticationHeaderValue>*/ get WwwAuthenticate()
    {
        return GetSpecializedCollection(WwwAuthenticateSlot, function(/**/ thisRef)
        {
new HttpHeaderValueCollection_$1(AuthenticationHeaderValue, KnownHeaders.WWWAuthenticate.Descriptor, thisRef)        });
    }
    /*CacheControlHeaderValue*/ get CacheControl()
    {
        return GeneralHeaders.CacheControl;
    }
    /*CacheControlHeaderValue*/ set CacheControl(value)
    {
        GeneralHeaders.CacheControl  = value;
    }
    /*HttpHeaderValueCollection<string>*/ get Connection()
    {
        return GeneralHeaders.Connection;
    }
    /*bool?*/ get ConnectionClose()
    {
        return HttpGeneralHeaders.GetConnectionClose(, _generalHeaders);
    }
    /*bool?*/ set ConnectionClose(value)
    {
        GeneralHeaders.ConnectionClose  = value;
    }
    /*DateTimeOffset?*/ get Date()
    {
        return GeneralHeaders.Date;
    }
    /*DateTimeOffset?*/ set Date(value)
    {
        GeneralHeaders.Date  = value;
    }
    /*HttpHeaderValueCollection<NameValueHeaderValue>*/ get Pragma()
    {
        return GeneralHeaders.Pragma;
    }
    /*HttpHeaderValueCollection<string>*/ get Trailer()
    {
        return GeneralHeaders.Trailer;
    }
    /*HttpHeaderValueCollection<TransferCodingHeaderValue>*/ get TransferEncoding()
    {
        return GeneralHeaders.TransferEncoding;
    }
    /*bool?*/ get TransferEncodingChunked()
    {
        return HttpGeneralHeaders.GetTransferEncodingChunked(, _generalHeaders);
    }
    /*bool?*/ set TransferEncodingChunked(value)
    {
        GeneralHeaders.TransferEncodingChunked  = value;
    }
    /*HttpHeaderValueCollection<ProductHeaderValue>*/ get Upgrade()
    {
        return GeneralHeaders.Upgrade;
    }
    /*HttpHeaderValueCollection<ViaHeaderValue>*/ get Via()
    {
        return GeneralHeaders.Via;
    }
    /*HttpHeaderValueCollection<WarningHeaderValue>*/ get Warning()
    {
        return GeneralHeaders.Warning;
    }
    constructor(/*bool*/ containsTrailingHeaders)
    {
        super(containsTrailingHeadersHttpHeaderType.All  ^ HttpHeaderType.Request HttpHeaderType.General  | HttpHeaderType.Response  | HttpHeaderType.Custom, HttpHeaderType.Request);
        _containsTrailingHeaders = containsTrailingHeaders;
    }
    /*bool*/ get ContainsTrailingHeaders()
    {
        return _containsTrailingHeaders;
    }
    /*void*/ AddHeaders(/*HttpHeaders*/ sourceHeaders)
    {
        super.AddHeaders(sourceHeaders);
        /*HttpResponseHeaders*/ let sourceResponseHeaders = sourceHeaders as HttpResponseHeaders;
        Debug.Assert(sourceResponseHeaders != null);
        if (sourceResponseHeaders._generalHeaders  != null)
        {
            GeneralHeaders.AddSpecialsFrom(sourceResponseHeaders._generalHeaders);
        }
    }
    /*bool*/ IsAllowedHeaderName(/*HeaderDescriptor*/ descriptor)
    {
        if (_containsTrailingHeaders)
        return true;
        /*KnownHeader*/ let knownHeader = KnownHeaders.TryGetKnownHeader(descriptor.Name);
        if (knownHeader == null)
        return true;
        return knownHeader.HeaderType  & HttpHeaderType.NonTrailing == 0;
    }
    /*HttpGeneralHeaders*/ get GeneralHeaders()
    {
        return _generalHeaders = _generalHeaders ?? new HttpGeneralHeaders();
    }
}

class System_Net_Http_Headers_Int32NumberHeaderParser extends System_Net_Http_Headers_BaseHeaderParser
{
    /*Int32NumberHeaderParser*/ Parser = new Int32NumberHeaderParser();
    constructor()
    {
        super(false);
    }
    /*string*/ ToString(/*object*/ value)
    {
        Debug.Assert(value is );
        return value.ToString();
    }
    /*int*/ GetParsedValueLength(/*string*/ value, /*int*/ startIndex, /*object*/ storeValue, /*object*/ parsedValue)
    {
        parsedValue = null;
        /*int*/ let numberLength = HttpRuleParser.GetNumberLength(value, startIndex, false);
        if (numberLength == 0 || numberLength > HttpRuleParser.MaxInt32Digits)
        {
            return 0;
        }
        /*int*/ let result;
        let $v = { value: set(value){ result = value; } };
        if (HeaderUtilities.TryParseInt32(value, startIndex, numberLength, $v))
        {
            return 0;
        }
        parsedValue = result;
        return numberLength;
    }
}

class System_Net_Http_Headers_Int64NumberHeaderParser extends System_Net_Http_Headers_BaseHeaderParser
{
    /*Int64NumberHeaderParser*/ Parser = new Int64NumberHeaderParser();
    constructor()
    {
        super(false);
    }
    /*string*/ ToString(/*object*/ value)
    {
        Debug.Assert(value is );
        return value.ToString();
    }
    /*int*/ GetParsedValueLength(/*string*/ value, /*int*/ startIndex, /*object*/ storeValue, /*object*/ parsedValue)
    {
        parsedValue = null;
        /*int*/ let numberLength = HttpRuleParser.GetNumberLength(value, startIndex, false);
        if (numberLength == 0 || numberLength > HttpRuleParser.MaxInt64Digits)
        {
            return 0;
        }
        /*long*/ let result;
        let $v = { value: set(value){ result = value; } };
        if (HeaderUtilities.TryParseInt64(value, startIndex, numberLength, $v))
        {
            return 0;
        }
        parsedValue = result;
        return numberLength;
    }
}

class System_Net_Http_Headers_KnownHeader extends object
{
    constructor(/*string*/ name, /*int?*/ http2StaticTableIndex, /*int?*/ http3StaticTableIndex)
    {
        super(name, HttpHeaderType.Custom, parser : null, knownValues : null, http2StaticTableIndex : http2StaticTableIndex, http3StaticTableIndex : http3StaticTableIndex);
        Debug.Assert(.IsNullOrEmpty(name));
        Debug.Assert(name0 == ':' || HttpRuleParser.IsToken(name.AsSpan()));
    }
    constructor(/*string*/ name, /*HttpHeaderType*/ headerType, /*HttpHeaderParser*/ parser, /*string[]*/ knownValues, /*int?*/ http2StaticTableIndex, /*int?*/ http3StaticTableIndex)
    {
        super();
        Debug.Assert(.IsNullOrEmpty(name));
        Debug.Assert(name0 == ':' || HttpRuleParser.IsToken(name.AsSpan()));
        Name = name;
        HeaderType = headerType;
        Parser = parser;
        KnownValues = knownValues;
        Initialize(http2StaticTableIndex, http3StaticTableIndex);
        //var asciiBytesWithColonSpace = new byte[name.Length + 2]; // + 2 for ':' and ' '
            //int asciiBytes = Encoding.ASCII.GetBytes(name, asciiBytesWithColonSpace);
            //Debug.Assert(asciiBytes == name.Length);
            //asciiBytesWithColonSpace[asciiBytesWithColonSpace.Length - 2] = (byte)':';
            //asciiBytesWithColonSpace[asciiBytesWithColonSpace.Length - 1] = (byte)' ';
            //AsciiBytesWithColonSpace = asciiBytesWithColonSpace;
            AsciiBytesWithColonSpace = Encoding.ASCII.GetBytes(name + ": ");
    }
    /*void*/ Initialize(/*int?*/ http2StaticTableIndex, /*int?*/ http3StaticTableIndex)
    /*string*/ _backingField_Name = null;
    /*string*/ get Name()
    {
        return _backingField_Name;
    }
    /*HttpHeaderParser*/ _backingField_Parser = null;
    /*HttpHeaderParser*/ get Parser()
    {
        return _backingField_Parser;
    }
    /*HttpHeaderType*/ _backingField_HeaderType = null;
    /*HttpHeaderType*/ get HeaderType()
    {
        return _backingField_HeaderType;
    }
    /*string[]*/ _backingField_KnownValues = null;
    /*string[]*/ get KnownValues()
    {
        return _backingField_KnownValues;
    }
    /*byte[]*/ _backingField_AsciiBytesWithColonSpace = null;
    /*byte[]*/ get AsciiBytesWithColonSpace()
    {
        return _backingField_AsciiBytesWithColonSpace;
    }
    /*HeaderDescriptor*/ get Descriptor()
    {
        return new HeaderDescriptor();
    }
}


class System_Net_Http_Headers_KnownHeaders extends object
{
    constructor()
    {
        super();
    }
    /*KnownHeader*/ PseudoStatus = new KnownHeader(":status", HttpHeaderType.Response, { parser : null });
    /*KnownHeader*/ Accept = new KnownHeader("Accept", HttpHeaderType.Request, MediaTypeHeaderParser.MultipleValuesParser, null);
    /*KnownHeader*/ AcceptCharset = new KnownHeader("Accept-Charset", HttpHeaderType.Request, GenericHeaderParser.MultipleValueStringWithQualityParser, null);
    /*KnownHeader*/ AcceptEncoding = new KnownHeader("Accept-Encoding", HttpHeaderType.Request, GenericHeaderParser.MultipleValueStringWithQualityParser, null);
    /*KnownHeader*/ AcceptLanguage = new KnownHeader("Accept-Language", HttpHeaderType.Request, GenericHeaderParser.MultipleValueStringWithQualityParser, null);
    /*KnownHeader*/ AcceptPatch = new KnownHeader("Accept-Patch");
    /*KnownHeader*/ AcceptRanges = new KnownHeader("Accept-Ranges", HttpHeaderType.Response, GenericHeaderParser.TokenListParser, null);
    /*KnownHeader*/ AccessControlAllowCredentials = new KnownHeader("Access-Control-Allow-Credentials", HttpHeaderType.Response, { parser : null, knownValues : [ "true" ] });
    /*KnownHeader*/ AccessControlAllowHeaders = new KnownHeader("Access-Control-Allow-Headers", HttpHeaderType.Response, { parser : null, knownValues : [ "*" ] });
    /*KnownHeader*/ AccessControlAllowMethods = new KnownHeader("Access-Control-Allow-Methods", HttpHeaderType.Response, { parser : null, knownValues : [ "*" ] });
    /*KnownHeader*/ AccessControlAllowOrigin = new KnownHeader("Access-Control-Allow-Origin", HttpHeaderType.Response, { parser : null, knownValues : [ "*""null" ] });
    /*KnownHeader*/ AccessControlExposeHeaders = new KnownHeader("Access-Control-Expose-Headers", HttpHeaderType.Response, { parser : null, knownValues : [ "*" ] });
    /*KnownHeader*/ AccessControlMaxAge = new KnownHeader("Access-Control-Max-Age");
    /*KnownHeader*/ Age = new KnownHeader("Age", HttpHeaderType.Response  | HttpHeaderType.NonTrailing, TimeSpanHeaderParser.Parser, null);
    /*KnownHeader*/ Allow = new KnownHeader("Allow", HttpHeaderType.Content, GenericHeaderParser.TokenListParser, null);
    /*KnownHeader*/ AltSvc = new KnownHeader("Alt-Svc", HttpHeaderType.Response, GetAltSvcHeaderParser());
    /*KnownHeader*/ AltUsed = new KnownHeader("Alt-Used", HttpHeaderType.Request, { parser : null });
    /*KnownHeader*/ Authorization = new KnownHeader("Authorization", HttpHeaderType.Request  | HttpHeaderType.NonTrailing, GenericHeaderParser.SingleValueAuthenticationParser, null);
    /*KnownHeader*/ CacheControl = new KnownHeader("Cache-Control", HttpHeaderType.General  | HttpHeaderType.NonTrailing, CacheControlHeaderParser.Parser, [ "must-revalidate""no-cache""no-store""no-transform""private""proxy-revalidate""public" ]);
    /*KnownHeader*/ Connection = new KnownHeader("Connection", HttpHeaderType.General, GenericHeaderParser.TokenListParser, [ "close" ]);
    /*KnownHeader*/ ContentDisposition = new KnownHeader("Content-Disposition", HttpHeaderType.Content  | HttpHeaderType.NonTrailing, GenericHeaderParser.ContentDispositionParser, [ "inline""attachment" ]);
    /*KnownHeader*/ ContentEncoding = new KnownHeader("Content-Encoding", HttpHeaderType.Content  | HttpHeaderType.NonTrailing, GenericHeaderParser.TokenListParser, [ "gzip""deflate""br""compress""identity" ]);
    /*KnownHeader*/ ContentLanguage = new KnownHeader("Content-Language", HttpHeaderType.Content, GenericHeaderParser.TokenListParser, null);
    /*KnownHeader*/ ContentLength = new KnownHeader("Content-Length", HttpHeaderType.Content  | HttpHeaderType.NonTrailing, Int64NumberHeaderParser.Parser, null);
    /*KnownHeader*/ ContentLocation = new KnownHeader("Content-Location", HttpHeaderType.Content  | HttpHeaderType.NonTrailing, UriHeaderParser.RelativeOrAbsoluteUriParser, null);
    /*KnownHeader*/ ContentMD5 = new KnownHeader("Content-MD5", HttpHeaderType.Content, ByteArrayHeaderParser.Parser);
    /*KnownHeader*/ ContentRange = new KnownHeader("Content-Range", HttpHeaderType.Content  | HttpHeaderType.NonTrailing, GenericHeaderParser.ContentRangeParser, null);
    /*KnownHeader*/ ContentSecurityPolicy = new KnownHeader("Content-Security-Policy");
    /*KnownHeader*/ ContentType = new KnownHeader("Content-Type", HttpHeaderType.Content  | HttpHeaderType.NonTrailing, MediaTypeHeaderParser.SingleValueParser, null);
    /*KnownHeader*/ Cookie = new KnownHeader("Cookie", HttpHeaderType.Custom, CookieHeaderParser.Parser, null);
    /*KnownHeader*/ Cookie2 = new KnownHeader("Cookie2");
    /*KnownHeader*/ Date = new KnownHeader("Date", HttpHeaderType.General  | HttpHeaderType.NonTrailing, DateHeaderParser.Parser, null);
    /*KnownHeader*/ ETag = new KnownHeader("ETag", HttpHeaderType.Response, GenericHeaderParser.SingleValueEntityTagParser, null);
    /*KnownHeader*/ Expect = new KnownHeader("Expect", HttpHeaderType.Request  | HttpHeaderType.NonTrailing, GenericHeaderParser.MultipleValueNameValueWithParametersParser, [ "100-continue" ]);
    /*KnownHeader*/ ExpectCT = new KnownHeader("Expect-CT");
    /*KnownHeader*/ Expires = new KnownHeader("Expires", HttpHeaderType.Content  | HttpHeaderType.NonTrailing, DateHeaderParser.Parser, null);
    /*KnownHeader*/ From = new KnownHeader("From", HttpHeaderType.Request, GenericHeaderParser.SingleValueParserWithoutValidation, null);
    /*KnownHeader*/ GrpcEncoding = new KnownHeader("grpc-encoding", HttpHeaderType.Custom, null, [ "identity""gzip""deflate" ]);
    /*KnownHeader*/ GrpcMessage = new KnownHeader("grpc-message");
    /*KnownHeader*/ GrpcStatus = new KnownHeader("grpc-status", HttpHeaderType.Custom, null, [ "0" ]);
    /*KnownHeader*/ Host = new KnownHeader("Host", HttpHeaderType.Request  | HttpHeaderType.NonTrailing, GenericHeaderParser.HostParser, null);
    /*KnownHeader*/ IfMatch = new KnownHeader("If-Match", HttpHeaderType.Request  | HttpHeaderType.NonTrailing, GenericHeaderParser.MultipleValueEntityTagParser, null);
    /*KnownHeader*/ IfModifiedSince = new KnownHeader("If-Modified-Since", HttpHeaderType.Request  | HttpHeaderType.NonTrailing, DateHeaderParser.Parser, null);
    /*KnownHeader*/ IfNoneMatch = new KnownHeader("If-None-Match", HttpHeaderType.Request  | HttpHeaderType.NonTrailing, GenericHeaderParser.MultipleValueEntityTagParser, null);
    /*KnownHeader*/ IfRange = new KnownHeader("If-Range", HttpHeaderType.Request  | HttpHeaderType.NonTrailing, GenericHeaderParser.RangeConditionParser, null);
    /*KnownHeader*/ IfUnmodifiedSince = new KnownHeader("If-Unmodified-Since", HttpHeaderType.Request  | HttpHeaderType.NonTrailing, DateHeaderParser.Parser, null);
    /*KnownHeader*/ KeepAlive = new KnownHeader("Keep-Alive");
    /*KnownHeader*/ LastModified = new KnownHeader("Last-Modified", HttpHeaderType.Content, DateHeaderParser.Parser, null);
    /*KnownHeader*/ Link = new KnownHeader("Link");
    /*KnownHeader*/ Location = new KnownHeader("Location", HttpHeaderType.Response  | HttpHeaderType.NonTrailing, UriHeaderParser.RelativeOrAbsoluteUriParser, null);
    /*KnownHeader*/ MaxForwards = new KnownHeader("Max-Forwards", HttpHeaderType.Request  | HttpHeaderType.NonTrailing, Int32NumberHeaderParser.Parser, null);
    /*KnownHeader*/ Origin = new KnownHeader("Origin");
    /*KnownHeader*/ P3P = new KnownHeader("P3P");
    /*KnownHeader*/ Pragma = new KnownHeader("Pragma", HttpHeaderType.General  | HttpHeaderType.NonTrailing, GenericHeaderParser.MultipleValueNameValueParser, [ "no-cache" ]);
    /*KnownHeader*/ ProxyAuthenticate = new KnownHeader("Proxy-Authenticate", HttpHeaderType.Response  | HttpHeaderType.NonTrailing, GenericHeaderParser.MultipleValueAuthenticationParser, null);
    /*KnownHeader*/ ProxyAuthorization = new KnownHeader("Proxy-Authorization", HttpHeaderType.Request  | HttpHeaderType.NonTrailing, GenericHeaderParser.SingleValueAuthenticationParser, null);
    /*KnownHeader*/ ProxyConnection = new KnownHeader("Proxy-Connection");
    /*KnownHeader*/ ProxySupport = new KnownHeader("Proxy-Support");
    /*KnownHeader*/ PublicKeyPins = new KnownHeader("Public-Key-Pins");
    /*KnownHeader*/ Range = new KnownHeader("Range", HttpHeaderType.Request  | HttpHeaderType.NonTrailing, GenericHeaderParser.RangeParser, null);
    /*KnownHeader*/ Referer = new KnownHeader("Referer", HttpHeaderType.Request, UriHeaderParser.RelativeOrAbsoluteUriParser, null);
    /*KnownHeader*/ ReferrerPolicy = new KnownHeader("Referrer-Policy", HttpHeaderType.Custom, null, [ "strict-origin-when-cross-origin""origin-when-cross-origin""strict-origin""origin""same-origin""no-referrer-when-downgrade""no-referrer""unsafe-url" ]);
    /*KnownHeader*/ Refresh = new KnownHeader("Refresh");
    /*KnownHeader*/ RetryAfter = new KnownHeader("Retry-After", HttpHeaderType.Response  | HttpHeaderType.NonTrailing, GenericHeaderParser.RetryConditionParser, null);
    /*KnownHeader*/ SecWebSocketAccept = new KnownHeader("Sec-WebSocket-Accept");
    /*KnownHeader*/ SecWebSocketExtensions = new KnownHeader("Sec-WebSocket-Extensions");
    /*KnownHeader*/ SecWebSocketKey = new KnownHeader("Sec-WebSocket-Key");
    /*KnownHeader*/ SecWebSocketProtocol = new KnownHeader("Sec-WebSocket-Protocol");
    /*KnownHeader*/ SecWebSocketVersion = new KnownHeader("Sec-WebSocket-Version");
    /*KnownHeader*/ Server = new KnownHeader("Server", HttpHeaderType.Response, ProductInfoHeaderParser.MultipleValueParser, null);
    /*KnownHeader*/ ServerTiming = new KnownHeader("Server-Timing");
    /*KnownHeader*/ SetCookie = new KnownHeader("Set-Cookie", HttpHeaderType.Custom  | HttpHeaderType.NonTrailing, null, null);
    /*KnownHeader*/ SetCookie2 = new KnownHeader("Set-Cookie2", HttpHeaderType.Custom  | HttpHeaderType.NonTrailing, null, null);
    /*KnownHeader*/ StrictTransportSecurity = new KnownHeader("Strict-Transport-Security");
    /*KnownHeader*/ TE = new KnownHeader("TE", HttpHeaderType.Request  | HttpHeaderType.NonTrailing, TransferCodingHeaderParser.MultipleValueWithQualityParser, [ "trailers""compress""deflate""gzip" ]);
    /*KnownHeader*/ TSV = new KnownHeader("TSV");
    /*KnownHeader*/ Trailer = new KnownHeader("Trailer", HttpHeaderType.General  | HttpHeaderType.NonTrailing, GenericHeaderParser.TokenListParser);
    /*KnownHeader*/ TransferEncoding = new KnownHeader("Transfer-Encoding", HttpHeaderType.General  | HttpHeaderType.NonTrailing, TransferCodingHeaderParser.MultipleValueParser, [ "chunked""compress""deflate""gzip""identity" ]);
    /*KnownHeader*/ Upgrade = new KnownHeader("Upgrade", HttpHeaderType.General, GenericHeaderParser.MultipleValueProductParser);
    /*KnownHeader*/ UpgradeInsecureRequests = new KnownHeader("Upgrade-Insecure-Requests", HttpHeaderType.Custom, null, [ "1" ]);
    /*KnownHeader*/ UserAgent = new KnownHeader("User-Agent", HttpHeaderType.Request, ProductInfoHeaderParser.MultipleValueParser, null);
    /*KnownHeader*/ Vary = new KnownHeader("Vary", HttpHeaderType.Response  | HttpHeaderType.NonTrailing, GenericHeaderParser.TokenListParser, [ "*" ]);
    /*KnownHeader*/ Via = new KnownHeader("Via", HttpHeaderType.General, GenericHeaderParser.MultipleValueViaParser, null);
    /*KnownHeader*/ WWWAuthenticate = new KnownHeader("WWW-Authenticate", HttpHeaderType.Response  | HttpHeaderType.NonTrailing, GenericHeaderParser.MultipleValueAuthenticationParser, null);
    /*KnownHeader*/ Warning = new KnownHeader("Warning", HttpHeaderType.General  | HttpHeaderType.NonTrailing, GenericHeaderParser.MultipleValueWarningParser);
    /*KnownHeader*/ XAspNetVersion = new KnownHeader("X-AspNet-Version");
    /*KnownHeader*/ XCache = new KnownHeader("X-Cache");
    /*KnownHeader*/ XContentDuration = new KnownHeader("X-Content-Duration");
    /*KnownHeader*/ XContentTypeOptions = new KnownHeader("X-Content-Type-Options", HttpHeaderType.Custom, null, [ "nosniff" ]);
    /*KnownHeader*/ XFrameOptions = new KnownHeader("X-Frame-Options", HttpHeaderType.Custom, null, [ "DENY""SAMEORIGIN" ]);
    /*KnownHeader*/ XMSEdgeRef = new KnownHeader("X-MSEdge-Ref");
    /*KnownHeader*/ XPoweredBy = new KnownHeader("X-Powered-By");
    /*KnownHeader*/ XRequestID = new KnownHeader("X-Request-ID");
    /*KnownHeader*/ XUACompatible = new KnownHeader("X-UA-Compatible");
    /*KnownHeader*/ XXssProtection = new KnownHeader("X-XSS-Protection", HttpHeaderType.Custom, null, [ "0""1""1; mode=block" ]);
    /*AltSvcHeaderParser*/ GetAltSvcHeaderParser()
    {
        AltSvcHeaderParser.Parser;
    }
    const System_Net_Http_Headers_IHeaderNameAccessor = (Base) => class extends Base
    {
        /*int*/ _backingField_Length = null;
        /*int*/ get Length()
        {
            return _backingField_Length;
        }
    }
    class System_Net_Http_Headers_StringAccessor extends System_Net_Http_Headers_KnownHeaders_IHeaderNameAccessor(System_ValueType)
    {
        /*string*/ _string = null;
        constructor(/*string*/ s)
        {
            super();
            _string = s;
        }
        /*int*/ get Length()
        {
            return _string.Length;
        }
        _stringindex;
    }
    class System_Net_Http_Headers_BytePtrAccessor extends System_Net_Http_Headers_KnownHeaders_IHeaderNameAccessor(System_ValueType)
    {
        /*byte[]*/ _p = null;
        /*int*/ _length = null;
        constructor(/*byte[]*/ p, /*int*/ length)
        {
            super();
            _p = p;
            _length = length;
        }
        /*int*/ get Length()
        {
            return _length;
        }
        _pindex;
    }
    /*KnownHeader*/ GetCandidate(T, /*T*/ key)
    {
        /*// Lookup is performed by first switching on the header name's length, and then switching
            // on the most unique position in that length's string.

            int*/ let length = key.Length;
        switch(length)
        {
            case 2:
            {
                return TE;
            }
            case 3:
            {
                switch(key0 | 0x20)
                {
                    case 'a':
                    {
                        return Age;
                    }
                    case 'p':
                    {
                        return P3P;
                    }
                    case 't':
                    {
                        return TSV;
                    }
                    case 'v':
                    {
                        return Via;
                    }
                }
                break;
            }
            case 4:
            {
                switch(key0 | 0x20)
                {
                    case 'd':
                    {
                        return Date;
                    }
                    case 'e':
                    {
                        return ETag;
                    }
                    case 'f':
                    {
                        return From;
                    }
                    case 'h':
                    {
                        return Host;
                    }
                    case 'l':
                    {
                        return Link;
                    }
                    case 'v':
                    {
                        return Vary;
                    }
                }
                break;
            }
            case 5:
            {
                switch(key0 | 0x20)
                {
                    case 'a':
                    {
                        return Allow;
                    }
                    case 'r':
                    {
                        return Range;
                    }
                }
                break;
            }
            case 6:
            {
                switch(key0 | 0x20)
                {
                    case 'a':
                    {
                        return Accept;
                    }
                    case 'c':
                    {
                        return Cookie;
                    }
                    case 'e':
                    {
                        return Expect;
                    }
                    case 'o':
                    {
                        return Origin;
                    }
                    case 'p':
                    {
                        return Pragma;
                    }
                    case 's':
                    {
                        return Server;
                    }
                }
                break;
            }
            case 7:
            {
                switch(key0 | 0x20)
                {
                    case ':':
                    {
                        return PseudoStatus;
                    }
                    case 'a':
                    {
                        return AltSvc;
                    }
                    case 'c':
                    {
                        return Cookie2;
                    }
                    case 'e':
                    {
                        return Expires;
                    }
                    case 'r':
                    {
                        switch(key3 | 0x20)
                        {
                            case 'e':
                            {
                                return Referer;
                            }
                            case 'r':
                            {
                                return Refresh;
                            }
                        }
                        break;
                    }
                    case 't':
                    {
                        return Trailer;
                    }
                    case 'u':
                    {
                        return Upgrade;
                    }
                    case 'w':
                    {
                        return Warning;
                    }
                    case 'x':
                    {
                        return XCache;
                    }
                }
                break;
            }
            case 8:
            {
                switch(key3 | 0x20)
                {
                    case '-':
                    {
                        return AltUsed;
                    }
                    case 'a':
                    {
                        return Location;
                    }
                    case 'm':
                    {
                        return IfMatch;
                    }
                    case 'r':
                    {
                        return IfRange;
                    }
                }
                break;
            }
            case 9:
            {
                return ExpectCT;
            }
            case 10:
            {
                switch(key0 | 0x20)
                {
                    case 'c':
                    {
                        return Connection;
                    }
                    case 'k':
                    {
                        return KeepAlive;
                    }
                    case 's':
                    {
                        return SetCookie;
                    }
                    case 'u':
                    {
                        return UserAgent;
                    }
                }
                break;
            }
            case 11:
            {
                switch(key0 | 0x20)
                {
                    case 'c':
                    {
                        return ContentMD5;
                    }
                    case 'g':
                    {
                        return GrpcStatus;
                    }
                    case 'r':
                    {
                        return RetryAfter;
                    }
                    case 's':
                    {
                        return SetCookie2;
                    }
                }
                break;
            }
            case 12:
            {
                switch(key5 | 0x20)
                {
                    case 'd':
                    {
                        return XMSEdgeRef;
                    }
                    case 'e':
                    {
                        return XPoweredBy;
                    }
                    case 'm':
                    {
                        return GrpcMessage;
                    }
                    case 'n':
                    {
                        return ContentType;
                    }
                    case 'o':
                    {
                        return MaxForwards;
                    }
                    case 't':
                    {
                        return AcceptPatch;
                    }
                    case 'u':
                    {
                        return XRequestID;
                    }
                }
                break;
            }
            case 13:
            {
                switch(key12 | 0x20)
                {
                    case 'd':
                    {
                        return LastModified;
                    }
                    case 'e':
                    {
                        return ContentRange;
                    }
                    case 'g':
                    {
                        switch(key0 | 0x20)
                        {
                            case 's':
                            {
                                return ServerTiming;
                            }
                            case 'g':
                            {
                                return GrpcEncoding;
                            }
                        }
                        break;
                    }
                    case 'h':
                    {
                        return IfNoneMatch;
                    }
                    case 'l':
                    {
                        return CacheControl;
                    }
                    case 'n':
                    {
                        return Authorization;
                    }
                    case 's':
                    {
                        return AcceptRanges;
                    }
                    case 't':
                    {
                        return ProxySupport;
                    }
                }
                break;
            }
            case 14:
            {
                switch(key0 | 0x20)
                {
                    case 'a':
                    {
                        return AcceptCharset;
                    }
                    case 'c':
                    {
                        return ContentLength;
                    }
                }
                break;
            }
            case 15:
            {
                switch(key7 | 0x20)
                {
                    case '-':
                    {
                        return XFrameOptions;
                    }
                    case 'e':
                    {
                        return AcceptEncoding;
                    }
                    case 'k':
                    {
                        return PublicKeyPins;
                    }
                    case 'l':
                    {
                        return AcceptLanguage;
                    }
                    case 'm':
                    {
                        return XUACompatible;
                    }
                    case 'r':
                    {
                        return ReferrerPolicy;
                    }
                }
                break;
            }
            case 16:
            {
                switch(key11 | 0x20)
                {
                    case 'a':
                    {
                        return ContentLocation;
                    }
                    case 'c':
                    {
                        switch(key0 | 0x20)
                        {
                            case 'p':
                            {
                                return ProxyConnection;
                            }
                            case 'x':
                            {
                                return XXssProtection;
                            }
                        }
                        break;
                    }
                    case 'g':
                    {
                        return ContentLanguage;
                    }
                    case 'i':
                    {
                        return WWWAuthenticate;
                    }
                    case 'o':
                    {
                        return ContentEncoding;
                    }
                    case 'r':
                    {
                        return XAspNetVersion;
                    }
                }
                break;
            }
            case 17:
            {
                switch(key0 | 0x20)
                {
                    case 'i':
                    {
                        return IfModifiedSince;
                    }
                    case 's':
                    {
                        return SecWebSocketKey;
                    }
                    case 't':
                    {
                        return TransferEncoding;
                    }
                }
                break;
            }
            case 18:
            {
                switch(key0 | 0x20)
                {
                    case 'p':
                    {
                        return ProxyAuthenticate;
                    }
                    case 'x':
                    {
                        return XContentDuration;
                    }
                }
                break;
            }
            case 19:
            {
                switch(key0 | 0x20)
                {
                    case 'c':
                    {
                        return ContentDisposition;
                    }
                    case 'i':
                    {
                        return IfUnmodifiedSince;
                    }
                    case 'p':
                    {
                        return ProxyAuthorization;
                    }
                }
                break;
            }
            case 20:
            {
                return SecWebSocketAccept;
            }
            case 21:
            {
                return SecWebSocketVersion;
            }
            case 22:
            {
                switch(key0 | 0x20)
                {
                    case 'a':
                    {
                        return AccessControlMaxAge;
                    }
                    case 's':
                    {
                        return SecWebSocketProtocol;
                    }
                    case 'x':
                    {
                        return XContentTypeOptions;
                    }
                }
                break;
            }
            case 23:
            {
                return ContentSecurityPolicy;
            }
            case 24:
            {
                return SecWebSocketExtensions;
            }
            case 25:
            {
                switch(key0 | 0x20)
                {
                    case 's':
                    {
                        return StrictTransportSecurity;
                    }
                    case 'u':
                    {
                        return UpgradeInsecureRequests;
                    }
                }
                break;
            }
            case 27:
            {
                return AccessControlAllowOrigin;
            }
            case 28:
            {
                switch(key21 | 0x20)
                {
                    case 'h':
                    {
                        return AccessControlAllowHeaders;
                    }
                    case 'm':
                    {
                        return AccessControlAllowMethods;
                    }
                }
                break;
            }
            case 29:
            {
                return AccessControlExposeHeaders;
            }
            case 32:
            {
                return AccessControlAllowCredentials;
            }
        }
        return null;
    }
    /*KnownHeader*/ TryGetKnownHeader(/*string*/ name)
    {
        /*KnownHeader*/ let candidate = GetCandidate(new StringAccessor(name));
        if (candidate != null && StringComparer.OrdinalIgnoreCase.Equals(name, candidate.Name))
        {
            return candidate;
        }
        return null;
    }
    /*KnownHeader*/ TryGetKnownHeader(/*ReadOnlySpan<byte>*/ name)
    {
        /*var*/ let p = name.ToArray();
        /*KnownHeader*/ let candidate = GetCandidate(new BytePtrAccessor(p, name.Length));
        if (candidate != null && Ascii.EqualsIgnoreCase(name, candidate.Name))
        {
            return candidate;
        }
        return null;
    }
}

class System_Net_Http_Headers_MediaTypeHeaderParser extends System_Net_Http_Headers_BaseHeaderParser
{
    /*Func<MediaTypeHeaderValue>*/ _mediaTypeCreator = null;
    /*MediaTypeHeaderParser*/ SingleValueParser = new MediaTypeHeaderParser(false, CreateMediaType);
    /*MediaTypeHeaderParser*/ SingleValueWithQualityParser = new MediaTypeHeaderParser(false, CreateMediaTypeWithQuality);
    /*MediaTypeHeaderParser*/ MultipleValuesParser = new MediaTypeHeaderParser(true, CreateMediaTypeWithQuality);
    constructor(/*bool*/ supportsMultipleValues, /*Func<MediaTypeHeaderValue>*/ mediaTypeCreator)
    {
        super(supportsMultipleValues);
        Debug.Assert(mediaTypeCreator != null);
        _mediaTypeCreator = mediaTypeCreator;
    }
    /*int*/ GetParsedValueLength(/*string*/ value, /*int*/ startIndex, /*object*/ storeValue, /*object*/ parsedValue)
    {
        let temp = null;
        let $v = { value: set(value){ temp = value; } };
        /*int*/ let resultLength = MediaTypeHeaderValue.GetMediaTypeLength(value, startIndex, _mediaTypeCreator, $v);
        parsedValue = temp;
        return resultLength;
    }
    /*MediaTypeHeaderValue*/ CreateMediaType()
    {
        new MediaTypeHeaderValue();
    }
    /*MediaTypeWithQualityHeaderValue*/ CreateMediaTypeWithQuality()
    {
        new MediaTypeWithQualityHeaderValue();
    }
}

class System_Net_Http_Headers_MediaTypeHeaderValue extends H5_IH5Class(System_ICloneable(object))
{
    /*string*/ CharSetName = "charset";
    /*UnvalidatedObjectCollection<NameValueHeaderValue>*/ _parameters = null;
    /*string*/ _mediaType = null;
    /*string*/ get CharSet()
    {
        return NameValueHeaderValue.Find(_parameters, CharSetName)Value;
    }
    /*string*/ set CharSet(value)
    {
        /*// We don't prevent a user from setting whitespace-only charsets. Like we can't prevent a user from
                // setting a non-existing charset.
                NameValueHeaderValue*/ let charSetParameter = NameValueHeaderValue.Find(_parameters, CharSetName);
        if (.IsNullOrEmpty(value))
        {
            if (charSetParameter != null)
            {
                _parameters.Remove(charSetParameter);
            }
        }
        else 
        {
            if (charSetParameter != null)
            {
                charSetParameter.Value  = value;
            }
            else 
            {
                Parameters.Add(new NameValueHeaderValue(CharSetName, value));
            }
        }
    }
    /*ICollection<NameValueHeaderValue>*/ get Parameters()
    {
        return _parameters = _parameters ?? new UnvalidatedObjectCollection_$1(NameValueHeaderValue);
    }
    /*string*/ get MediaType()
    {
        return _mediaType;
    }
    /*string*/ set MediaType(value)
    {
        CheckMediaTypeFormat(value);
        _mediaType = value;
    }
    constructor()
    {
        super();
    }
    constructor(/*MediaTypeHeaderValue*/ source)
    {
        super();
        Debug.Assert(source != null);
        _mediaType = source._mediaType;
        _parameters = source._parameters.Clone();
    }
    constructor(/*string*/ mediaType)
    {
        super(mediaType, charSet : null);
    }
    constructor(/*string*/ mediaType, /*string*/ charSet)
    {
        super();
        CheckMediaTypeFormat(mediaType);
        _mediaType = mediaType;
        if (.IsNullOrEmpty(charSet))
        {
            CharSet = charSet;
        }
    }
    /*string*/ ToString()
    {
        if (_parameters || _parameters.Count  == 0)
        {
            return _mediaType ?? .Empty;
        }
        /*var*/ let sb = new StringBuilder();
        sb.Append(_mediaType);
        NameValueHeaderValue.ToString(_parameters, ';', true, sb);
        return sb.ToString();
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        obj instanceof MediaTypeHeaderValue, other = obj && .Equals(_mediaType, other._mediaType, StringComparison.OrdinalIgnoreCase) && HeaderUtilities.AreEqualCollections(_parameters, other._parameters);
    }
    /*int*/ GetHashCode()
    {
        return StringComparer.OrdinalIgnoreCase.GetHashCode(_mediaType) ^ NameValueHeaderValue.GetHashCode(_parameters);
    }
    /*MediaTypeHeaderValue*/ Parse(/*string*/ input)
    {
        /*int*/ let index = 0;
        let $v = { value: set(value){ index = value; } };
        return MediaTypeHeaderValueMediaTypeHeaderParser.SingleValueParser.ParseValue(input, null, $v);
    }
    /*bool*/ TryParse(/*string*/ input, /*MediaTypeHeaderValue*/ parsedValue)
    {
        /*int*/ let index = 0;
        parsedValue = null;
        let $v = { value: set(value){ index = value; } };
        let output = null;
        let $v = { value: set(value){ output = value; } };
        if (MediaTypeHeaderParser.SingleValueParser.TryParseValue(input, null, $v, $v))
        {
            parsedValue = MediaTypeHeaderValueoutput;
            return true;
        }
        return false;
    }
    /*int*/ GetMediaTypeLength(/*string*/ input, /*int*/ startIndex, /*Func<MediaTypeHeaderValue>*/ mediaTypeCreator, /*MediaTypeHeaderValue*/ parsedValue)
    {
        Debug.Assert(mediaTypeCreator != null);
        Debug.Assert(startIndex >= 0);
        parsedValue = null;
        if (.IsNullOrEmpty(input) || startIndex >= input.Length)
        {
            return 0;
        }
        /*// Caller must remove leading whitespace. If not, we'll return 0.
        let mediaType = null;
        let $v = { value: set(value){ mediaType = value; } };
            int*/ let mediaTypeLength = MediaTypeHeaderValue.GetMediaTypeExpressionLength(input, startIndex, $v);
        if (mediaTypeLength == 0)
        {
            return 0;
        }
        /*int*/ let current = startIndex + mediaTypeLength;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        /*MediaTypeHeaderValue*/ let mediaTypeHeader;
        if (current < input.Length && inputcurrent == ';')
        {
            mediaTypeHeader = mediaTypeCreator();
            mediaTypeHeader._mediaType  = mediaType;
            current++;
            /*int*/ let parameterLength = NameValueHeaderValue.GetNameValueListLength(input, current, ';', UnvalidatedObjectCollection_$1mediaTypeHeader.Parameters);
            if (parameterLength == 0)
            {
                return 0;
            }
            parsedValue = mediaTypeHeader;
            return current + parameterLength - startIndex;
        }
        // We have a media type without parameters.
            mediaTypeHeader = mediaTypeCreator();
        mediaTypeHeader._mediaType  = mediaType;
        parsedValue = mediaTypeHeader;
        return current - startIndex;
    }
    /*int*/ GetMediaTypeExpressionLength(/*string*/ input, /*int*/ startIndex, /*string*/ mediaType)
    {
        Debug.Assert(input != null && input.Length  > 0 && startIndex < input.Length);
        // This method just parses the "type/subtype" string, it does not parse parameters.
            mediaType = null;
        /*// Parse the type, i.e. <type> in media type string "<type>/<subtype>; param1=value1; param2=value2"
            int*/ let typeLength = HttpRuleParser.GetTokenLength(input, startIndex);
        if (typeLength == 0)
        {
            return 0;
        }
        /*int*/ let current = startIndex + typeLength;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        if (current >= input.Length || inputcurrent != '/')
        {
            return 0;
        }
        current++;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        /*// Parse the subtype, i.e. <subtype> in media type string "<type>/<subtype>; param1=value1; param2=value2"
            int*/ let subtypeLength = HttpRuleParser.GetTokenLength(input, current);
        if (subtypeLength == 0)
        {
            return 0;
        }
        /*// If there is no whitespace between <type> and <subtype> in <type>/<subtype> get the media type using
            // one Substring call. Otherwise get substrings for <type> and <subtype> and combine them.
            int*/ let mediaTypeLength = current + subtypeLength - startIndex;
        if (typeLength + subtypeLength + 1 == mediaTypeLength)
        {
            mediaType = input.Substring(startIndex, mediaTypeLength);
        }
        else 
        {
            mediaType = .Concat(input.AsSpan(startIndex, typeLength), "/", input.AsSpan(current, subtypeLength));
        }
        return mediaTypeLength;
    }
    /*void*/ CheckMediaTypeFormat(/*string*/ mediaType, { /*string*/ parameterName = null})
    {
        if (.IsNullOrEmpty(mediaType))
        throw new ArgumentException(nameof(mediaType));
        /*// When adding values using strongly typed objects, no leading/trailing LWS (whitespace) are allowed.
            // Also no LWS between type and subtype are allowed.
        let tempMediaType = null;
        let $v = { value: set(value){ tempMediaType = value; } };
            int*/ let mediaTypeLength = GetMediaTypeExpressionLength(mediaType, 0, $v);
        if (mediaTypeLength == 0 || tempMediaType.Length  != mediaType.Length)
        {
            throw new FormatException("net_http_headers_invalid_value");
        }
    }
    /*// Implement ICloneable explicitly to allow derived types to "override" the implementation.
        object*/ Clone()
    {
        return new MediaTypeHeaderValue();
    }
}

class System_Net_Http_Headers_MediaTypeWithQualityHeaderValue extends H5_IH5Class(System_ICloneable(System_Net_Http_Headers_MediaTypeHeaderValue))
{
    /*double?*/ get Quality()
    {
        return HeaderUtilities.GetQuality(UnvalidatedObjectCollection_$1Parameters);
    }
    /*double?*/ set Quality(value)
    {
        HeaderUtilities.SetQuality(UnvalidatedObjectCollection_$1Parameters, value);
    }
    constructor()
    {
        super();
    }
    constructor(/*string*/ mediaType)
    {
        super(mediaType);
    }
    constructor(/*string*/ mediaType, /*double*/ quality)
    {
        super(mediaType);
        Quality = quality;
    }
    constructor(/*MediaTypeWithQualityHeaderValue*/ source)
    {
        super(source);
    }
    /*object*/ Clone()
    {
        return new MediaTypeWithQualityHeaderValue();
    }
    /*MediaTypeWithQualityHeaderValue*/ Parse(/*string*/ input)
    {
        /*int*/ let index = 0;
        let $v = { value: set(value){ index = value; } };
        return MediaTypeWithQualityHeaderValueMediaTypeHeaderParser.SingleValueWithQualityParser.ParseValue(input, null, $v);
    }
    /*bool*/ TryParse(/*string*/ input, /*MediaTypeWithQualityHeaderValue*/ parsedValue)
    {
        /*int*/ let index = 0;
        parsedValue = null;
        let $v = { value: set(value){ index = value; } };
        let output = null;
        let $v = { value: set(value){ output = value; } };
        if (MediaTypeHeaderParser.SingleValueWithQualityParser.TryParseValue(input, null, $v, $v))
        {
            parsedValue = MediaTypeWithQualityHeaderValueoutput;
            return true;
        }
        return false;
    }
}

class System_Net_Http_Headers_NameValueHeaderValue extends H5_IH5Class(System_ICloneable(object))
{
    /*Func<NameValueHeaderValue>*/ s_defaultNameValueCreator = CreateNameValue;
    /*string*/ _name = null;
    /*string*/ _value = null;
    /*string*/ get Name()
    {
        return _name;
    }
    /*string*/ get Value()
    {
        return _value;
    }
    /*string*/ set Value(value)
    {
        CheckValueFormat(value);
        _value = value;
    }
    constructor()
    {
        super();
    }
    constructor(/*string*/ name)
    {
        super(name, null);
    }
    constructor(/*string*/ name, /*string*/ value)
    {
        super();
        CheckNameValueFormat(name, value);
        _name = name;
        _value = value;
    }
    constructor(/*NameValueHeaderValue*/ source)
    {
        super();
        Debug.Assert(source != null);
        _name = source._name;
        _value = source._value;
    }
    /*int*/ GetHashCode()
    {
        Debug.Assert(_name != null);
        /*int*/ let nameHashCode = StringComparer.OrdinalIgnoreCase.GetHashCode(_name);
        if (.IsNullOrEmpty(_value))
        {
            if (_value0 == '"')
            {
                return nameHashCode ^ _value.GetHashCode();
            }
            return nameHashCode ^ StringComparer.OrdinalIgnoreCase.GetHashCode(_value);
        }
        return nameHashCode;
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        /*NameValueHeaderValue*/ let other = obj as NameValueHeaderValue;
        if (other == null)
        {
            return false;
        }
        if (.Equals(_name, other._name, StringComparison.OrdinalIgnoreCase))
        {
            return false;
        }
        if (.IsNullOrEmpty(_value))
        {
            return .IsNullOrEmpty(other._value);
        }
        if (_value0 == '"')
        {
            return .Equals(_value, other._value, StringComparison.Ordinal);
        }
        else 
        {
            return .Equals(_value, other._value, StringComparison.OrdinalIgnoreCase);
        }
    }
    /*NameValueHeaderValue*/ Parse(/*string*/ input)
    {
        /*int*/ let index = 0;
        let $v = { value: set(value){ index = value; } };
        return NameValueHeaderValueGenericHeaderParser.SingleValueNameValueParser.ParseValue(input, null, $v);
    }
    /*bool*/ TryParse(/*string*/ input, /*NameValueHeaderValue*/ parsedValue)
    {
        /*int*/ let index = 0;
        parsedValue = null;
        let $v = { value: set(value){ index = value; } };
        let output = null;
        let $v = { value: set(value){ output = value; } };
        if (GenericHeaderParser.SingleValueNameValueParser.TryParseValue(input, null, $v, $v))
        {
            parsedValue = NameValueHeaderValueoutput;
            return true;
        }
        return false;
    }
    /*string*/ ToString()
    {
        if (.IsNullOrEmpty(_value))
        {
            return _name + "=" + _value;
        }
        return _name;
    }
    /*void*/ AddToStringBuilder(/*StringBuilder*/ sb)
    {
        if (GetType() != NameValueHeaderValue)
        {
            // If this is a derived instance, we need to give its
                // ToString a chance.
                sb.Append(ToString());
        }
        else 
        {
            // Otherwise, we can use the base behavior and avoid
                // the string concatenation.
                sb.Append(_name);
            if (.IsNullOrEmpty(_value))
            {
                sb.Append('=');
                sb.Append(_value);
            }
        }
    }
    /*void*/ ToString(/*UnvalidatedObjectCollection<NameValueHeaderValue>*/ values, /*char*/ separator, /*bool*/ leadingSeparator, /*StringBuilder*/ destination)
    {
        Debug.Assert(destination != null);
        if (values == null || values.Count  == 0)
        {
            return ;
        }
        BlazorJs.forEach(values, function(value, $_i)
        {
            if (leadingSeparator || destination.Length  > 0)
            {
                destination.Append(separator);
                destination.Append(' ');
            }
            value.AddToStringBuilder(destination);
        });
    }
    /*int*/ GetHashCode(/*UnvalidatedObjectCollection<NameValueHeaderValue>*/ values)
    {
        if (values == null || values.Count  == 0)
        {
            return 0;
        }
        /*int*/ let result = 0;
        BlazorJs.forEach(values, function(value, $_i)
        {
            result ^= value.GetHashCode();
        });
        return result;
    }
    /*int*/ GetNameValueLength(/*string*/ input, /*int*/ startIndex, /*NameValueHeaderValue*/ parsedValue)
    {
        let $v = { value: set(value){ parsedValue = value; } };
        return GetNameValueLength(input, startIndex, s_defaultNameValueCreator, $v);
    }
    /*int*/ GetNameValueLength(/*string*/ input, /*int*/ startIndex, /*Func<NameValueHeaderValue>*/ nameValueCreator, /*NameValueHeaderValue*/ parsedValue)
    {
        Debug.Assert(input != null);
        Debug.Assert(startIndex >= 0);
        Debug.Assert(nameValueCreator != null);
        parsedValue = null;
        if (.IsNullOrEmpty(input) || startIndex >= input.Length)
        {
            return 0;
        }
        /*// Parse the name, i.e. <name> in name/value string "<name>=<value>". Caller must remove
            // leading whitespace.
            int*/ let nameLength = HttpRuleParser.GetTokenLength(input, startIndex);
        if (nameLength == 0)
        {
            return 0;
        }
        /*string*/ let name = input.Substring(startIndex, nameLength);
        /*int*/ let current = startIndex + nameLength;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        if (current == input.Length || inputcurrent != '=')
        {
            // We only have a name and that's OK. Return.
                parsedValue = nameValueCreator();
            parsedValue._name  = name;
            current += HttpRuleParser.GetWhitespaceLength(input, current);
            return current - startIndex;
        }
        current++;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        /*// Parse the value, i.e. <value> in name/value string "<name>=<value>"
            int*/ let valueLength = GetValueLength(input, current);
        if (valueLength == 0)
        {
            return 0;
        }
        // Use parameterless ctor to avoid double-parsing of name and value, i.e. skip public ctor validation.
            parsedValue = nameValueCreator();
        parsedValue._name  = name;
        parsedValue._value  = input.Substring(current, valueLength);
        current += valueLength;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        return current - startIndex;
    }
    /*int*/ GetNameValueListLength(/*string*/ input, /*int*/ startIndex, /*char*/ delimiter, /*UnvalidatedObjectCollection<NameValueHeaderValue>*/ nameValueCollection)
    {
        Debug.Assert(nameValueCollection != null);
        Debug.Assert(startIndex >= 0);
        if (.IsNullOrEmpty(input) || startIndex >= input.Length)
        {
            return 0;
        }
        /*int*/ let current = startIndex + HttpRuleParser.GetWhitespaceLength(input, startIndex);
        while(true)
        {
            /*NameValueHeaderValue*/ let parameter;
            let $v = { value: set(value){ parameter = value; } };
            /*int*/ let nameValueLength = NameValueHeaderValue.GetNameValueLength(input, current, s_defaultNameValueCreator, $v);
            if (nameValueLength == 0)
            {
                return 0;
            }
            nameValueCollection.Add(parameter);
            current += nameValueLength;
            current += HttpRuleParser.GetWhitespaceLength(input, current);
            if (current == input.Length || inputcurrent != delimiter)
            {
                return current - startIndex;
            }
            // input[current] is 'delimiter'. Skip the delimiter and whitespace and try to parse again.
                current++;
            current += HttpRuleParser.GetWhitespaceLength(input, current);
        }
    }
    /*NameValueHeaderValue*/ Find(/*UnvalidatedObjectCollection<NameValueHeaderValue>*/ values, /*string*/ name)
    {
        Debug.Assert(name != null && name.Length  > 0);
        if (values == null || values.Count  == 0)
        {
            return null;
        }
        BlazorJs.forEach(values, function(value, $_i)
        {
            if (.Equals(value.Name, name, StringComparison.OrdinalIgnoreCase))
            {
                return value;
            }
        });
        return null;
    }
    /*int*/ GetValueLength(/*string*/ input, /*int*/ startIndex)
    {
        Debug.Assert(input != null);
        if (startIndex >= input.Length)
        {
            return 0;
        }
        /*int*/ let valueLength = HttpRuleParser.GetTokenLength(input, startIndex);
        if (valueLength == 0)
        {
            let $v = { value: set(value){ valueLength = value; } };
            if (HttpRuleParser.GetQuotedStringLength(input, startIndex, $v) != HttpParseResult.Parsed)
            {
                return 0;
            }
        }
        return valueLength;
    }
    /*void*/ CheckNameValueFormat(/*string*/ name, /*string*/ value)
    {
        HeaderUtilities.CheckValidToken(name);
        CheckValueFormat(value);
    }
    /*void*/ CheckValueFormat(/*string*/ value)
    {
        if (.IsNullOrEmpty(value))
        {
            return ;
        }
        if (value.StartsWith(" ") || value.StartsWith("\t") || value.EndsWith(" ") || value.EndsWith("\t"))
        {
            throw new FormatException("net_http_headers_invalid_value");
        }
        if (value0 == '"')
        {
            let valueLength = null;
            let $v = { value: set(value){ valueLength = value; } };
            /*HttpParseResult*/ let parseResult = HttpRuleParser.GetQuotedStringLength(value, 0, $v);
            if (parseResult != HttpParseResult.Parsed  || valueLength != value.Length)
            {
                throw new FormatException("net_http_headers_invalid_value");
            }
        }
        else if (HttpRuleParser.ContainsNewLine(value))
        {
            throw new FormatException("net_http_headers_invalid_value");
        }
    }
    /*NameValueHeaderValue*/ CreateNameValue()
    {
        return new NameValueHeaderValue();
    }
    /*// Implement ICloneable explicitly to allow derived types to "override" the implementation.
        object*/ Clone()
    {
        return new NameValueHeaderValue();
    }
}

class System_Net_Http_Headers_NameValueWithParametersHeaderValue extends H5_IH5Class(System_ICloneable(System_Net_Http_Headers_NameValueHeaderValue))
{
    /*Func<NameValueHeaderValue>*/ s_nameValueCreator = CreateNameValue;
    /*UnvalidatedObjectCollection<NameValueHeaderValue>*/ _parameters = null;
    /*ICollection<NameValueHeaderValue>*/ get Parameters()
    {
        return _parameters = _parameters ?? new UnvalidatedObjectCollection_$1(NameValueHeaderValue);
    }
    constructor(/*string*/ name)
    {
        super(name);
    }
    constructor(/*string*/ name, /*string*/ value)
    {
        super(name, value);
    }
    constructor()
    {
        super();
    }
    constructor(/*NameValueWithParametersHeaderValue*/ source)
    {
        super(source);
        _parameters = source._parameters.Clone();
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        /*bool*/ let result = super.Equals(obj);
        if (result)
        {
            /*NameValueWithParametersHeaderValue*/ let other = obj as NameValueWithParametersHeaderValue;
            if (other == null)
            {
                return false;
            }
            return HeaderUtilities.AreEqualCollections(_parameters, other._parameters);
        }
        return false;
    }
    /*int*/ GetHashCode()
    {
        return super.GetHashCode() ^ NameValueHeaderValue.GetHashCode(_parameters);
    }
    /*string*/ ToString()
    {
        /*string*/ let baseString = super.ToString();
        /*StringBuilder*/ let sb = new StringBuilder();
        sb.Append(baseString);
        NameValueHeaderValue.ToString(_parameters, ';', true, sb);
        return sb.ToString();
    }
    /*NameValueWithParametersHeaderValue*/ Parse(/*string*/ input)
    {
        /*int*/ let index = 0;
        return NameValueWithParametersHeaderValueGenericHeaderParser.SingleValueNameValueWithParametersParser
        let $v = { value: set(value){ index = value; } };
.ParseValue(input, null, $v);
    }
    /*bool*/ TryParse(/*string*/ input, /*NameValueWithParametersHeaderValue*/ parsedValue)
    {
        /*int*/ let index = 0;
        parsedValue = null;
        let $v = { value: set(value){ index = value; } };
        let output = null;
        let $v = { value: set(value){ output = value; } };
        if (GenericHeaderParser.SingleValueNameValueWithParametersParser.TryParseValue(input, null, $v, $v))
        {
            parsedValue = NameValueWithParametersHeaderValueoutput;
            return true;
        }
        return false;
    }
    /*int*/ GetNameValueWithParametersLength(/*string*/ input, /*int*/ startIndex, /*object*/ parsedValue)
    {
        Debug.Assert(input != null);
        Debug.Assert(startIndex >= 0);
        parsedValue = null;
        if (.IsNullOrEmpty(input) || startIndex >= input.Length)
        {
            return 0;
        }
        let nameValue = null;
        let $v = { value: set(value){ nameValue = value; } };
        /*int*/ let nameValueLength = NameValueHeaderValue.GetNameValueLength(input, startIndex, s_nameValueCreator, $v);
        if (nameValueLength == 0)
        {
            return 0;
        }
        /*int*/ let current = startIndex + nameValueLength;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        /*NameValueWithParametersHeaderValue*/ let nameValueWithParameters = nameValue as NameValueWithParametersHeaderValue;
        Debug.Assert(nameValueWithParameters != null);
        if (current < input.Length && inputcurrent == ';')
        {
            current++;
            /*int*/ let parameterLength = NameValueHeaderValue.GetNameValueListLength(input, current, ';', UnvalidatedObjectCollection_$1nameValueWithParameters.Parameters);
            if (parameterLength == 0)
            {
                return 0;
            }
            parsedValue = nameValueWithParameters;
            return current + parameterLength - startIndex;
        }
        // We have a name/value pair without parameters.
            parsedValue = nameValueWithParameters;
        return current - startIndex;
    }
    /*NameValueHeaderValue*/ CreateNameValue()
    {
        return new NameValueWithParametersHeaderValue();
    }
    /*object*/ Clone()
    {
        return new NameValueWithParametersHeaderValue();
    }
}

const System_Net_Http_Headers_UnvalidatedObjectCollection$_1 = (T) => class extends System_Net_Http_Headers_ObjectCollection(T)
{
    constructor()
    {
        super();
        T = $_T;
    }
T    /*void*/ Validate(/*T*/ item)
    {
        if (item == null)
        throw new ArgumentNullException(nameof(item));
    }
}
const System_Net_Http_Headers_ObjectCollection$_1 = (T) => class extends H5_IH5Class(System_Collections_IEnumerable(System_Collections_Generic_IEnumerable<T>(System_Collections_Generic_ICollection<T>(object))))
{
T    /*int*/ DefaultSize = 4;
    /*object*/ _items = null;
    /*int*/ _size = null;
    constructor()
    {
        super();
    }
    /*int*/ get Count()
    {
        return _size;
    }
    /*bool*/ get IsReadOnly()
    {
        return false;
    }
    /*void*/ Add(/*T*/ item)
    {
        Validate(item);
        Debug.Assert(item != null);
        if (_items)
        {
            // The collection is empty. Just store the new item directly.
                _items = item;
            _size = 1;
        }
        else if (_items instanceof T, existingItem = _items)
        {
            // The collection has a single item stored directly.  Upgrade to
                // an array, and store both the existing and new items.
                Debug.Assert(_size == 1);
            /*T[]*/ let items = new Array(DefaultSize);
            items0 = existingItem;
            items1 = item;
            _items = items;
            _size = 2;
        }
        else 
        {
            /*T[]*/ let array = T_items;
            /*int*/ let size = _size;
            if (size < array.Length)
            {
                // There's room in the existing array.  Add the item.
                    arraysize = item;
            }
            else 
            {
                // We need to grow the array.  Do so, and store the new item.
                    Debug.Assert(_size > 0);
                Debug.Assert(_size == array.Length);
                /*var*/ let newItems = new Array(array.Length * 2);
                Array.Copy(array, newItems, size);
                _items = newItems;
                newItemssize = item;
            }
            _size = size + 1;
        }
    }
    /*void*/ Clear()
    {
        _items = null;
        _size = 0;
    }
    /*bool*/ Contains(/*T*/ item)
    {
        _size <= 0false_items instanceof T, o = _itemso.Equals(item)_items instanceof T, items = _items && Array.IndexOf(items, item, 0, _size) != 1;
    }
    /*void*/ CopyTo(/*T[]*/ array, /*int*/ arrayIndex)
    {
        if (_items instanceof T, items = _items)
        {
            Array.Copy(items, 0, array, arrayIndex, _size);
        }
        else 
        {
            Debug.Assert(_size == 0 || _size == 1);
            if (array || _size > array.Length  - arrayIndex)
            {
                [ T_items ].CopyTo(array, arrayIndex);
            }
            else if (_size == 1)
            {
                arrayarrayIndex = T_items;
            }
        }
    }
    /*bool*/ Remove(/*T*/ item)
    {
        if (_items instanceof T, o = _items)
        {
            if (o.Equals(item))
            {
                _items = null;
                _size = 0;
                return true;
            }
        }
        else if (_items instanceof T, items = _items)
        {
            /*int*/ let index = Array.IndexOf(items, item, 0, _size);
            if (index != 1)
            {
                _size--;
                if (index < _size)
                {
                    Array.Copy(items, index + 1, items, index, _size - index);
                }
                items_size = null;
                return true;
            }
        }
        return false;
    }
    /*Enumerator*/ GetEnumerator()
    {
        new Enumerator();
    }
    /*IEnumerator<T>*/ GetEnumerator()
    {
        GetEnumerator();
    }
    /*IEnumerator*/ GetEnumerator()
    {
        GetEnumerator();
    }
    class System_Net_Http_Headers_Enumerator extends System_Collections_IEnumerator(System_IDisposable(System_Collections_Generic_IEnumerator<T>(System_ValueType)))
    {
        /*ObjectCollection<T>*/ _list = null;
        /*int*/ _index = null;
        /*T*/ _current = null;
        constructor(/*ObjectCollection<T>*/ list)
        {
            super();
            _list = list;
            _index = 0;
            _current = default;
        }
        /*void*/ Dispose()
        {
        }
        /*bool*/ MoveNext()
        {
            /*ObjectCollection<T>*/ let list = _list;
            if (_index < list._size)
            {
                _current = list._items  instanceof Titems_indexTlist._items;
                _index++;
                return true;
            }
            _index = _list._size  + 1;
            _current = default;
            return false;
        }
        /*T*/ get Current()
        {
            return _current;
        }
        /*object*/ get Current()
        {
            return _current;
        }
        /*void*/ Reset()
        {
            _index = 0;
            _current = default;
        }
    }
    class System_Net_Http_Headers_DebugView extends object
    {
        /*ObjectCollection<T>*/ _collection = null;
        constructor(/*ObjectCollection<T>*/ collection)
        {
            super();
            if (collection == null)
            throw new ArgumentNullException(nameof(collection));
            _collection = collection;
        }
        /*T[]*/ get Items()
        {
            /*T[]*/ let items = new Array(_collection.Count);
            _collection.CopyTo(items, 0);
            return items;
        }
    }
}

class System_Net_Http_Headers_ProductHeaderValue extends H5_IH5Class(System_ICloneable(object))
{
    /*string*/ _name = null;
    /*string*/ _version = null;
    /*string*/ get Name()
    {
        return _name;
    }
    /*string*/ get Version()
    {
        return _version;
    }
    constructor(/*string*/ name)
    {
        super(name, null);
    }
    constructor(/*string*/ name, /*string*/ version)
    {
        super();
        HeaderUtilities.CheckValidToken(name);
        if (.IsNullOrEmpty(version))
        {
            HeaderUtilities.CheckValidToken(version);
            _version = version;
        }
        _name = name;
    }
    constructor(/*ProductHeaderValue*/ source)
    {
        super();
        Debug.Assert(source != null);
        _name = source._name;
        _version = source._version;
    }
    /*string*/ ToString()
    {
        if (.IsNullOrEmpty(_version))
        {
            return _name;
        }
        return _name + "/" + _version;
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        /*ProductHeaderValue*/ let other = obj as ProductHeaderValue;
        if (other == null)
        {
            return false;
        }
        return .Equals(_name, other._name, StringComparison.OrdinalIgnoreCase) && .Equals(_version, other._version, StringComparison.OrdinalIgnoreCase);
    }
    /*int*/ GetHashCode()
    {
        /*int*/ let result = StringComparer.OrdinalIgnoreCase.GetHashCode(_name);
        if (.IsNullOrEmpty(_version))
        {
            result ^= StringComparer.OrdinalIgnoreCase.GetHashCode(_version);
        }
        return result;
    }
    /*ProductHeaderValue*/ Parse(/*string*/ input)
    {
        /*int*/ let index = 0;
        let $v = { value: set(value){ index = value; } };
        return ProductHeaderValueGenericHeaderParser.SingleValueProductParser.ParseValue(input, null, $v);
    }
    /*bool*/ TryParse(/*string*/ input, /*ProductHeaderValue*/ parsedValue)
    {
        /*int*/ let index = 0;
        parsedValue = null;
        let $v = { value: set(value){ index = value; } };
        let output = null;
        let $v = { value: set(value){ output = value; } };
        if (GenericHeaderParser.SingleValueProductParser.TryParseValue(input, null, $v, $v))
        {
            parsedValue = ProductHeaderValueoutput;
            return true;
        }
        return false;
    }
    /*int*/ GetProductLength(/*string*/ input, /*int*/ startIndex, /*ProductHeaderValue*/ parsedValue)
    {
        Debug.Assert(startIndex >= 0);
        parsedValue = null;
        if (.IsNullOrEmpty(input) || startIndex >= input.Length)
        {
            return 0;
        }
        /*// Parse the name string: <name> in '<name>/<version>'.
            int*/ let nameLength = HttpRuleParser.GetTokenLength(input, startIndex);
        if (nameLength == 0)
        {
            return 0;
        }
        /*string*/ let name = input.Substring(startIndex, nameLength);
        /*int*/ let current = startIndex + nameLength;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        if (current == input.Length || inputcurrent != '/')
        {
            parsedValue = new ProductHeaderValue(name);
            return current - startIndex;
        }
        current++;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        /*// Parse the name string: <version> in '<name>/<version>'.
            int*/ let versionLength = HttpRuleParser.GetTokenLength(input, current);
        if (versionLength == 0)
        {
            return 0;
        }
        /*string*/ let version = input.Substring(current, versionLength);
        current += versionLength;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        parsedValue = new ProductHeaderValue(name, version);
        return current - startIndex;
    }
    /*object*/ Clone()
    {
        return new ProductHeaderValue();
    }
}

class System_Net_Http_Headers_ProductInfoHeaderParser extends System_Net_Http_Headers_HttpHeaderParser
{
    /*string*/ separator = " ";
    /*ProductInfoHeaderParser*/ SingleValueParser = new ProductInfoHeaderParser(false);
    /*ProductInfoHeaderParser*/ MultipleValueParser = new ProductInfoHeaderParser(true);
    constructor(/*bool*/ supportsMultipleValues)
    {
        super(supportsMultipleValues, separator);
    }
    /*bool*/ TryParseValue(/*string*/ value, /*object*/ storeValue, /*int*/ index, /*object*/ parsedValue)
    {
        parsedValue = null;
        if (.IsNullOrEmpty(value) || index == value.Length)
        {
            return false;
        }
        /*// Skip leading whitespace
            int*/ let current = index + HttpRuleParser.GetWhitespaceLength(value, index);
        if (current == value.Length)
        {
            return false;
        }
        let result = null;
        let $v = { value: set(value){ result = value; } };
        /*int*/ let length = ProductInfoHeaderValue.GetProductInfoLength(value, current, $v);
        if (length == 0)
        {
            return false;
        }
        // GetProductInfoLength() already skipped trailing whitespace. No need to do it here again.
            current += length;
        if (current < value.Length)
        {
            /*// Note that for \r\n to be a valid whitespace, it must be followed by a space/tab. I.e. it's enough if
                // we check whether the char before the next value is space/tab.
                char*/ let lastSeparatorChar = valuecurrent - 1;
            if (lastSeparatorChar != ' ' && lastSeparatorChar != '\t')
            {
                return false;
            }
        }
        // Separators for "User-Agent" and "Server" headers are whitespace. This is different from most other headers
            // where comma/semicolon is used as separator.
            index = current;
        parsedValue = result;
        return true;
    }
}

class System_Net_Http_Headers_ProductInfoHeaderValue extends H5_IH5Class(System_ICloneable(object))
{
    /*ProductHeaderValue*/ _product = null;
    /*string*/ _comment = null;
    /*ProductHeaderValue*/ get Product()
    {
        return _product;
    }
    /*string*/ get Comment()
    {
        return _comment;
    }
    constructor(/*string*/ productName, /*string*/ productVersion)
    {
        super(new ProductHeaderValue(productName, productVersion));
    }
    constructor(/*ProductHeaderValue*/ product)
    {
        super();
        if (product == null)
        throw new ArgumentNullException(nameof(product));
        _product = product;
    }
    constructor(/*string*/ comment)
    {
        super();
        HeaderUtilities.CheckValidComment(comment);
        _comment = comment;
    }
    constructor(/*ProductInfoHeaderValue*/ source)
    {
        super();
        Debug.Assert(source != null);
        _product = source._product;
        _comment = source._comment;
    }
    /*string*/ ToString()
    {
        if (_product == null)
        {
            Debug.Assert(_comment != null);
            return _comment;
        }
        return _product.ToString();
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        /*ProductInfoHeaderValue*/ let other = obj as ProductInfoHeaderValue;
        if (other == null)
        {
            return false;
        }
        if (_product == null)
        {
            return .Equals(_comment, other._comment, StringComparison.Ordinal);
        }
        return _product.Equals(other._product);
    }
    /*int*/ GetHashCode()
    {
        if (_product == null)
        {
            Debug.Assert(_comment != null);
            return _comment.GetHashCode();
        }
        return _product.GetHashCode();
    }
    /*ProductInfoHeaderValue*/ Parse(/*string*/ input)
    {
        /*int*/ let index = 0;
        let $v = { value: set(value){ index = value; } };
        /*object*/ let result = ProductInfoHeaderParser.SingleValueParser.ParseValue(input, null, $v);
        if (index < input.Length)
        {
            throw new FormatException("net_http_headers_invalid_value");
        }
        return ProductInfoHeaderValueresult;
    }
    /*bool*/ TryParse(/*string*/ input, /*ProductInfoHeaderValue*/ parsedValue)
    {
        /*int*/ let index = 0;
        parsedValue = null;
        let $v = { value: set(value){ index = value; } };
        let output = null;
        let $v = { value: set(value){ output = value; } };
        if (ProductInfoHeaderParser.SingleValueParser.TryParseValue(input, null, $v, $v))
        {
            if (index < input.Length)
            {
                return false;
            }
            parsedValue = ProductInfoHeaderValueoutput;
            return true;
        }
        return false;
    }
    /*int*/ GetProductInfoLength(/*string*/ input, /*int*/ startIndex, /*ProductInfoHeaderValue*/ parsedValue)
    {
        Debug.Assert(startIndex >= 0);
        parsedValue = null;
        if (.IsNullOrEmpty(input) || startIndex >= input.Length)
        {
            return 0;
        }
        /*int*/ let current = startIndex;
        /*// Caller must remove leading whitespace.
            string*/ let comment;
        /*ProductHeaderValue*/ let product;
        if (inputcurrent == '(')
        {
            /*int*/ let commentLength;
            let $v = { value: set(value){ commentLength = value; } };
            if (HttpRuleParser.GetCommentLength(input, current, $v) != HttpParseResult.Parsed)
            {
                return 0;
            }
            comment = input.Substring(current, commentLength);
            current += commentLength;
            current += HttpRuleParser.GetWhitespaceLength(input, current);
            parsedValue = new ProductInfoHeaderValue(comment);
        }
        else 
        {
            /*// Trailing whitespace is removed by GetProductLength().
            let $v = { value: set(value){ product = value; } };
                int*/ let productLength = ProductHeaderValue.GetProductLength(input, current, $v);
            if (productLength == 0)
            {
                return 0;
            }
            current += productLength;
            parsedValue = new ProductInfoHeaderValue(product);
        }
        return current - startIndex;
    }
    /*object*/ Clone()
    {
        return new ProductInfoHeaderValue();
    }
}

class System_Net_Http_Headers_QPackStaticTable extends object
{
    constructor()
    {
        super();
    }
    /*(HeaderDescriptor descriptor, string value)[]*/ _backingField_HeaderLookup = null;
    /*(HeaderDescriptor descriptor, string value)[]*/ get HeaderLookup()
    {
        return _backingField_HeaderLookup;
    }
}

class System_Net_Http_Headers_RangeConditionHeaderValue extends H5_IH5Class(System_ICloneable(object))
{
    /*DateTimeOffset*/ _date = null;
    /*EntityTagHeaderValue*/ _entityTag = null;
    /*DateTimeOffset?*/ get Date()
    {
        return _entityTag_dateDateTimeOffsetnull;
    }
    /*EntityTagHeaderValue*/ get EntityTag()
    {
        return _entityTag;
    }
    constructor(/*DateTimeOffset*/ date)
    {
        super();
        _date = date;
    }
    constructor(/*EntityTagHeaderValue*/ entityTag)
    {
        super();
        if (entityTag == null)
        throw new ArgumentNullException(nameof(entityTag));
        _entityTag = entityTag;
    }
    constructor(/*string*/ entityTag)
    {
        super(new EntityTagHeaderValue(entityTag));
    }
    constructor(/*RangeConditionHeaderValue*/ source)
    {
        super();
        Debug.Assert(source != null);
        _entityTag = source._entityTag;
        _date = source._date;
    }
    /*string*/ ToString()
    {
        _entityTagToString() ?? _date.ToString("r");
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        obj instanceof RangeConditionHeaderValue, other = obj && _entityTagother._entityTag _entityTag.Equals(other._entityTag) && _date == other._date;
    }
    /*int*/ GetHashCode()
    {
        _entityTagGetHashCode() ?? _date.GetHashCode();
    }
    /*RangeConditionHeaderValue*/ Parse(/*string*/ input)
    {
        /*int*/ let index = 0;
        let $v = { value: set(value){ index = value; } };
        return RangeConditionHeaderValueGenericHeaderParser.RangeConditionParser.ParseValue(input, null, $v);
    }
    /*bool*/ TryParse(/*string*/ input, /*RangeConditionHeaderValue*/ parsedValue)
    {
        /*int*/ let index = 0;
        parsedValue = null;
        let $v = { value: set(value){ index = value; } };
        let output = null;
        let $v = { value: set(value){ output = value; } };
        if (GenericHeaderParser.RangeConditionParser.TryParseValue(input, null, $v, $v))
        {
            parsedValue = RangeConditionHeaderValueoutput;
            return true;
        }
        return false;
    }
    /*int*/ GetRangeConditionLength(/*string*/ input, /*int*/ startIndex, /*object*/ parsedValue)
    {
        Debug.Assert(startIndex >= 0);
        parsedValue = null;
        if (.IsNullOrEmpty(input) || startIndex + 1 >= input.Length)
        {
            return 0;
        }
        /*int*/ let current = startIndex;
        /*// Caller must remove leading whitespace.
            DateTimeOffset*/ let date = DateTimeOffset.MinValue;
        /*EntityTagHeaderValue*/ let entityTag = null;
        /*// Entity tags are quoted strings optionally preceded by "W/". By looking at the first two character we
            // can determine whether the string is en entity tag or a date.
            char*/ let firstChar = inputcurrent;
        /*char*/ let secondChar = inputcurrent + 1;
        if (firstChar == '\"' || firstChar == 'w' || firstChar == 'W' && secondChar == '/')
        {
            /*// trailing whitespace is removed by GetEntityTagLength()
            let $v = { value: set(value){ entityTag = value; } };
                int*/ let entityTagLength = EntityTagHeaderValue.GetEntityTagLength(input, current, $v);
            if (entityTagLength == 0)
            {
                return 0;
            }
            current += entityTagLength;
            if (current != input.Length)
            {
                return 0;
            }
        }
        else 
        {
            let $v = { value: set(value){ date = value; } };
            if (DateTimeOffset.TryParse(input.AsSpan(current), $v))
            {
                return 0;
            }
            // If we got a valid date, then the parser consumed the whole string (incl. trailing whitespace).
                current = input.Length;
        }
        if (entityTag == null)
        {
            parsedValue = new RangeConditionHeaderValue(date);
        }
        else 
        {
            parsedValue = new RangeConditionHeaderValue(entityTag);
        }
        return current - startIndex;
    }
    /*object*/ Clone()
    {
        return new RangeConditionHeaderValue();
    }
}

class System_Net_Http_Headers_RangeHeaderValue extends H5_IH5Class(System_ICloneable(object))
{
    /*string*/ _unit = null;
    /*UnvalidatedObjectCollection<RangeItemHeaderValue>*/ _ranges = null;
    /*string*/ get Unit()
    {
        return _unit;
    }
    /*string*/ set Unit(value)
    {
        HeaderUtilities.CheckValidToken(value);
        _unit = value;
    }
    /*ICollection<RangeItemHeaderValue>*/ get Ranges()
    {
        return _ranges = _ranges ?? new UnvalidatedObjectCollection_$1(RangeItemHeaderValue);
    }
    constructor()
    {
        super();
        _unit = HeaderUtilities.BytesUnit;
    }
    constructor(/*long*/ from, /*long*/ to)
    {
        super();
        // convenience ctor: "Range: bytes=from-to"
            _unit = HeaderUtilities.BytesUnit;
        Ranges.Add(new RangeItemHeaderValue(from, to));
    }
    constructor(/*RangeHeaderValue*/ source)
    {
        super();
        Debug.Assert(source != null);
        _unit = source._unit;
        if (source._ranges  != null)
        {
            BlazorJs.forEach(source._ranges, function(range, $_i)
            {
                .Ranges.Add(new RangeItemHeaderValue(range));
            });
        }
    }
    /*string*/ ToString()
    {
        /*var*/ let sb = new StringBuilder(256);
        sb.Append(_unit);
        sb.Append('=');
        if (_ranges != null)
        {
            /*bool*/ let first = true;
            BlazorJs.forEach(_ranges, function(range, $_i)
            {
                if (first)
                {
                    first = false;
                }
                else 
                {
                    sb.Append(", ");
                }
                if (range.From.HasValue)
                sb.Append(range.From.GetValueOrDefault());
                sb.Append('-');
                if (range.To.HasValue)
                sb.Append(range.To.GetValueOrDefault());
            });
        }
        return sb.ToString();
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        /*RangeHeaderValue*/ let other = obj as RangeHeaderValue;
        if (other == null)
        {
            return false;
        }
        return .Equals(_unit, other._unit, StringComparison.OrdinalIgnoreCase) && HeaderUtilities.AreEqualCollections(_ranges, other._ranges);
    }
    /*int*/ GetHashCode()
    {
        /*int*/ let result = StringComparer.OrdinalIgnoreCase.GetHashCode(_unit);
        if (_ranges != null)
        {
            BlazorJs.forEach(_ranges, function(range, $_i)
            {
                result ^= range.GetHashCode();
            });
        }
        return result;
    }
    /*RangeHeaderValue*/ Parse(/*string*/ input)
    {
        /*int*/ let index = 0;
        let $v = { value: set(value){ index = value; } };
        return RangeHeaderValueGenericHeaderParser.RangeParser.ParseValue(input, null, $v);
    }
    /*bool*/ TryParse(/*string*/ input, /*RangeHeaderValue*/ parsedValue)
    {
        /*int*/ let index = 0;
        parsedValue = null;
        let $v = { value: set(value){ index = value; } };
        let output = null;
        let $v = { value: set(value){ output = value; } };
        if (GenericHeaderParser.RangeParser.TryParseValue(input, null, $v, $v))
        {
            parsedValue = RangeHeaderValueoutput;
            return true;
        }
        return false;
    }
    /*int*/ GetRangeLength(/*string*/ input, /*int*/ startIndex, /*object*/ parsedValue)
    {
        Debug.Assert(startIndex >= 0);
        parsedValue = null;
        if (.IsNullOrEmpty(input) || startIndex >= input.Length)
        {
            return 0;
        }
        /*// Parse the unit string: <unit> in '<unit>=<from1>-<to1>, <from2>-<to2>'
            int*/ let unitLength = HttpRuleParser.GetTokenLength(input, startIndex);
        if (unitLength == 0)
        {
            return 0;
        }
        /*RangeHeaderValue*/ let result = new RangeHeaderValue();
        result._unit  = input.Substring(startIndex, unitLength);
        /*int*/ let current = startIndex + unitLength;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        if (current == input.Length || inputcurrent != '=')
        {
            return 0;
        }
        current++;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        /*int*/ let rangesLength = RangeItemHeaderValue.GetRangeItemListLength(input, current, result.Ranges);
        if (rangesLength == 0)
        {
            return 0;
        }
        current += rangesLength;
        Debug.Assert(current == input.Length, "GetRangeItemListLength() should consume the whole string or fail.");
        parsedValue = result;
        return current - startIndex;
    }
    /*object*/ Clone()
    {
        return new RangeHeaderValue();
    }
}

class System_Net_Http_Headers_RangeItemHeaderValue extends H5_IH5Class(System_ICloneable(object))
{
    /*long*/ _from = null;
    /*long*/ _to = null;
    /*long?*/ get From()
    {
        return _from >= 0_fromnull;
    }
    /*long?*/ get To()
    {
        return _to >= 0_tonull;
    }
    constructor(/*long?*/ from, /*long?*/ to)
    {
        super();
        if (from.HasValue  && to.HasValue)
        {
            throw new ArgumentException("net_http_headers_invalid_range");
        }
        if (from.HasValue)
        {
            throw new ArgumentOutOfRangeException(nameof(from));
        }
        if (to.HasValue)
        {
            throw new ArgumentOutOfRangeException(nameof(to));
        }
        if (from.HasValue  && to.HasValue  && from.Value  > to.Value)
        {
            throw new ArgumentOutOfRangeException(nameof(from));
        }
        _from = from ?? 1;
        _to = to ?? 1;
    }
    constructor(/*RangeItemHeaderValue*/ source)
    {
        super();
        Debug.Assert(source != null);
        _from = source._from;
        _to = source._to;
    }
    /*string*/ ToString()
    {
        /*Span<char>*/ let stackBuffer = new Span_$1(char, 128);
        if (_from < 0)
        {
            return _to;
        }
        if (_to < 0)
        {
            return _from;
        }
        return _from_to;
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        obj instanceof RangeItemHeaderValue, other = obj && _from == other._from  && _to == other._to;
    }
    /*int*/ GetHashCode()
    {
        HashCode.Combine(_from, _to);
    }
    /*int*/ GetRangeItemListLength(/*string*/ input, /*int*/ startIndex, /*ICollection<RangeItemHeaderValue>*/ rangeCollection)
    {
        Debug.Assert(rangeCollection != null);
        Debug.Assert(startIndex >= 0);
        if (.IsNullOrEmpty(input) || startIndex >= input.Length)
        {
            return 0;
        }
        /*// Empty segments are allowed, so skip all delimiter-only segments (e.g. ", ,").
        let $v = { value: set(value){ _ = value; } };
            int*/ let current = HeaderUtilities.GetNextNonEmptyOrWhitespaceIndex(input, startIndex, true, $v);
        if (current == input.Length)
        {
            return 0;
        }
        while(true)
        {
            let range = null;
            let $v = { value: set(value){ range = value; } };
            /*int*/ let rangeLength = GetRangeItemLength(input, current, $v);
            if (rangeLength == 0)
            {
                return 0;
            }
            rangeCollection.Add(range);
            current += rangeLength;
            let separatorFound = null;
            let $v = { value: set(value){ separatorFound = value; } };
            current = HeaderUtilities.GetNextNonEmptyOrWhitespaceIndex(input, current, true, $v);
            if (current < input.Length && separatorFound)
            {
                return 0;
            }
            if (current == input.Length)
            {
                return current - startIndex;
            }
        }
    }
    /*int*/ GetRangeItemLength(/*string*/ input, /*int*/ startIndex, /*RangeItemHeaderValue*/ parsedValue)
    {
        Debug.Assert(startIndex >= 0);
        // This parser parses number ranges: e.g. '1-2', '1-', '-2'.
            parsedValue = null;
        if (.IsNullOrEmpty(input) || startIndex >= input.Length)
        {
            return 0;
        }
        /*// Caller must remove leading whitespace. If not, we'll return 0.
            int*/ let current = startIndex;
        /*// Try parse the first value of a value pair.
            int*/ let fromStartIndex = current;
        /*int*/ let fromLength = HttpRuleParser.GetNumberLength(input, current, false);
        if (fromLength > HttpRuleParser.MaxInt64Digits)
        {
            return 0;
        }
        current += fromLength;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        if (current == input.Length || inputcurrent != '-')
        {
            return 0;
        }
        current++;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        /*int*/ let toStartIndex = current;
        /*int*/ let toLength = 0;
        if (current < input.Length)
        {
            toLength = HttpRuleParser.GetNumberLength(input, current, false);
            if (toLength > HttpRuleParser.MaxInt64Digits)
            {
                return 0;
            }
            current += toLength;
            current += HttpRuleParser.GetWhitespaceLength(input, current);
        }
        if (fromLength == 0 && toLength == 0)
        {
            return 0;
        }
        /*// Try convert first value to int64
            long*/ let from = 0;
        let $v = { value: set(value){ from = value; } };
        if (fromLength > 0 && HeaderUtilities.TryParseInt64(input, fromStartIndex, fromLength, $v))
        {
            return 0;
        }
        /*// Try convert second value to int64
            long*/ let to = 0;
        let $v = { value: set(value){ to = value; } };
        if (toLength > 0 && HeaderUtilities.TryParseInt64(input, toStartIndex, toLength, $v))
        {
            return 0;
        }
        if (fromLength > 0 && toLength > 0 && from > to)
        {
            return 0;
        }
        parsedValue = new RangeItemHeaderValue(fromLength == 0nullfrom, toLength == 0nullto);
        return current - startIndex;
    }
    /*object*/ Clone()
    {
        return new RangeItemHeaderValue();
    }
}

class System_Net_Http_Headers_RetryConditionHeaderValue extends H5_IH5Class(System_ICloneable(object))
{
    /*long*/ DeltaNotSetTicksSentinel = .MaxValue;
    /*DateTimeOffset*/ _date = null;
    /*TimeSpan*/ _delta = null;
    /*DateTimeOffset?*/ get Date()
    {
        return _delta.Ticks  == DeltaNotSetTicksSentinel_dateDateTimeOffsetnull;
    }
    /*TimeSpan?*/ get Delta()
    {
        return _delta.Ticks  == DeltaNotSetTicksSentinelTimeSpannull_delta;
    }
    constructor(/*DateTimeOffset*/ date)
    {
        super();
        _date = date;
        _delta = new TimeSpan(DeltaNotSetTicksSentinel);
    }
    constructor(/*TimeSpan*/ delta)
    {
        super();
        if (delta.TotalSeconds > .MaxValue)
        throw new ArgumentOutOfRangeException();
        // The amount of seconds for 'delta' must be in the range 0..2^31
            //ArgumentOutOfRangeException.ThrowIfGreaterThan(delta.TotalSeconds, int.MaxValue);
            _delta = delta;
    }
    constructor(/*RetryConditionHeaderValue*/ source)
    {
        super();
        Debug.Assert(source != null);
        _delta = source._delta;
        _date = source._date;
    }
    /*string*/ ToString()
    {
        _delta.Ticks  != DeltaNotSetTicksSentinel_delta.TotalSeconds.ToString()_date.ToString("r");
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        obj instanceof RetryConditionHeaderValue, other = obj && _delta == other._delta  && _date == other._date;
    }
    /*int*/ GetHashCode()
    {
        HashCode.Combine(_delta, _date);
    }
    /*RetryConditionHeaderValue*/ Parse(/*string*/ input)
    {
        /*int*/ let index = 0;
        let $v = { value: set(value){ index = value; } };
        return RetryConditionHeaderValueGenericHeaderParser.RetryConditionParser.ParseValue(input, null, $v);
    }
    /*bool*/ TryParse(/*string*/ input, /*RetryConditionHeaderValue*/ parsedValue)
    {
        /*int*/ let index = 0;
        parsedValue = null;
        let $v = { value: set(value){ index = value; } };
        let output = null;
        let $v = { value: set(value){ output = value; } };
        if (GenericHeaderParser.RetryConditionParser.TryParseValue(input, null, $v, $v))
        {
            parsedValue = RetryConditionHeaderValueoutput;
            return true;
        }
        return false;
    }
    /*int*/ GetRetryConditionLength(/*string*/ input, /*int*/ startIndex, /*object*/ parsedValue)
    {
        Debug.Assert(startIndex >= 0);
        parsedValue = null;
        if (.IsNullOrEmpty(input) || startIndex >= input.Length)
        {
            return 0;
        }
        /*int*/ let current = startIndex;
        /*// Caller must remove leading whitespace.
            DateTimeOffset*/ let date = DateTimeOffset.MinValue;
        /*int*/ let deltaSeconds = 1;
        /*// We either have a timespan or a date/time value. Determine which one we have by looking at the first char.
            // If it is a number, we have a timespan, otherwise we assume we have a date.
            char*/ let firstChar = inputcurrent;
        if (.IsDigit(firstChar))
        {
            /*int*/ let deltaStartIndex = current;
            /*int*/ let deltaLength = HttpRuleParser.GetNumberLength(input, current, false);
            if (deltaLength == 0 || deltaLength > HttpRuleParser.MaxInt32Digits)
            {
                return 0;
            }
            current += deltaLength;
            current += HttpRuleParser.GetWhitespaceLength(input, current);
            if (current != input.Length)
            {
                return 0;
            }
            let $v = { value: set(value){ deltaSeconds = value; } };
            if (HeaderUtilities.TryParseInt32(input, deltaStartIndex, deltaLength, $v))
            {
                return 0;
            }
        }
        else 
        {
            let $v = { value: set(value){ date = value; } };
            if (DateTimeOffset.TryParse(input.AsSpan(current), $v))
            {
                return 0;
            }
            // If we got a valid date, then the parser consumed the whole string (incl. trailing whitespace).
                current = input.Length;
        }
        if (deltaSeconds == 1)
        {
            parsedValue = new RetryConditionHeaderValue(date);
        }
        else 
        {
            parsedValue = new RetryConditionHeaderValue(new TimeSpan(0, 0, deltaSeconds));
        }
        return current - startIndex;
    }
    /*object*/ Clone()
    {
        return new RetryConditionHeaderValue();
    }
}

class System_Net_Http_Headers_StringWithQualityHeaderValue extends H5_IH5Class(System_ICloneable(object))
{
    /*double*/ NotSetSentinel = .PositiveInfinity;
    /*string*/ _value = null;
    /*double*/ _quality = null;
    /*string*/ get Value()
    {
        return _value;
    }
    /*double?*/ get Quality()
    {
        return _quality == NotSetSentinelnull_quality;
    }
    constructor(/*string*/ value)
    {
        super();
        HeaderUtilities.CheckValidToken(value);
        _value = value;
        _quality = NotSetSentinel;
    }
    constructor(/*string*/ value, /*double*/ quality)
    {
        super();
        HeaderUtilities.CheckValidToken(value);
        if (quality < 0)
        throw new ArgumentOutOfRangeException(nameof(quality));
        if (quality > 1.0)
        throw new ArgumentOutOfRangeException(nameof(quality));
        _value = value;
        _quality = quality;
    }
    constructor(/*StringWithQualityHeaderValue*/ source)
    {
        super();
        Debug.Assert(source != null);
        _value = source._value;
        _quality = source._quality;
    }
    /*string*/ ToString()
    {
        _quality == NotSetSentinel_value_value_quality;
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        obj instanceof StringWithQualityHeaderValue, other = obj && .Equals(_value, other._value, StringComparison.OrdinalIgnoreCase) && // Note that we don't consider double.Epsilon here. We really consider two values equal if they're
            // actually equal. This makes sure that we also get the same hashcode for two values considered equal
            // by Equals().
            _quality == other._quality;
    }
    /*int*/ GetHashCode()
    {
        HashCode.Combine(StringComparer.OrdinalIgnoreCase.GetHashCode(_value), _quality);
    }
    /*StringWithQualityHeaderValue*/ Parse(/*string*/ input)
    {
        /*int*/ let index = 0;
        let $v = { value: set(value){ index = value; } };
        return StringWithQualityHeaderValueGenericHeaderParser.SingleValueStringWithQualityParser.ParseValue(input, null, $v);
    }
    /*bool*/ TryParse(/*string*/ input, /*StringWithQualityHeaderValue*/ parsedValue)
    {
        /*int*/ let index = 0;
        parsedValue = null;
        let $v = { value: set(value){ index = value; } };
        let output = null;
        let $v = { value: set(value){ output = value; } };
        if (GenericHeaderParser.SingleValueStringWithQualityParser.TryParseValue(input, null, $v, $v))
        {
            parsedValue = StringWithQualityHeaderValueoutput;
            return true;
        }
        return false;
    }
    /*int*/ GetStringWithQualityLength(/*string*/ input, /*int*/ startIndex, /*object*/ parsedValue)
    {
        Debug.Assert(startIndex >= 0);
        parsedValue = null;
        if (.IsNullOrEmpty(input) || startIndex >= input.Length)
        {
            return 0;
        }
        /*// Parse the value string: <value> in '<value>; q=<quality>'
            int*/ let valueLength = HttpRuleParser.GetTokenLength(input, startIndex);
        if (valueLength == 0)
        {
            return 0;
        }
        /*string*/ let value = input.Substring(startIndex, valueLength);
        /*int*/ let current = startIndex + valueLength;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        if (current == input.Length || inputcurrent != ';')
        {
            parsedValue = new StringWithQualityHeaderValue(value);
            return current - startIndex;
        }
        current++;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        let quality = null;
        let $v = { value: set(value){ quality = value; } };
        let $v = { value: set(value){ current = value; } };
        if (TryReadQuality(input, $v, $v))
        {
            return 0;
        }
        parsedValue = new StringWithQualityHeaderValue(value, quality);
        return current - startIndex;
    }
    /*bool*/ TryReadQuality(/*string*/ input, /*double*/ quality, /*int*/ index)
    {
        /*int*/ let current = index;
        quality = default;
        if (current == input.Length || inputcurrent != 'q' && inputcurrent != 'Q')
        {
            return false;
        }
        current++;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        if (current == input.Length || inputcurrent != '=')
        {
            return false;
        }
        current++;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        if (current == input.Length)
        {
            return false;
        }
        /*int*/ let qualityLength = HttpRuleParser.GetNumberLength(input, current, true);
        if (qualityLength == 0)
        {
            return false;
        }
        let $v = { value: set(value){ quality = value; } };
        if (.TryParse(input.AsSpan(current, qualityLength), $v))
        {
            return false;
        }
        if (quality < 0 || quality > 1)
        {
            return false;
        }
        current += qualityLength;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        index = current;
        return true;
    }
    /*object*/ Clone()
    {
        return new StringWithQualityHeaderValue();
    }
}

class System_Net_Http_Headers_TimeSpanHeaderParser extends System_Net_Http_Headers_BaseHeaderParser
{
    /*TimeSpanHeaderParser*/ Parser = new TimeSpanHeaderParser();
    constructor()
    {
        super(false);
    }
    /*string*/ ToString(/*object*/ value)
    {
        Debug.Assert(value is TimeSpan);
        return TimeSpanvalue.TotalSeconds.ToString();
    }
    /*int*/ GetParsedValueLength(/*string*/ value, /*int*/ startIndex, /*object*/ storeValue, /*object*/ parsedValue)
    {
        parsedValue = null;
        /*int*/ let numberLength = HttpRuleParser.GetNumberLength(value, startIndex, false);
        if (numberLength == 0 || numberLength > HttpRuleParser.MaxInt32Digits)
        {
            return 0;
        }
        /*int*/ let result;
        let $v = { value: set(value){ result = value; } };
        if (HeaderUtilities.TryParseInt32(value, startIndex, numberLength, $v))
        {
            return 0;
        }
        parsedValue = new TimeSpan(0, 0, result);
        return numberLength;
    }
}

class System_Net_Http_Headers_TransferCodingHeaderParser extends System_Net_Http_Headers_BaseHeaderParser
{
    /*Func<TransferCodingHeaderValue>*/ _transferCodingCreator = null;
    /*TransferCodingHeaderParser*/ SingleValueParser = new TransferCodingHeaderParser(false, CreateTransferCoding);
    /*TransferCodingHeaderParser*/ MultipleValueParser = new TransferCodingHeaderParser(true, CreateTransferCoding);
    /*TransferCodingHeaderParser*/ SingleValueWithQualityParser = new TransferCodingHeaderParser(false, CreateTransferCodingWithQuality);
    /*TransferCodingHeaderParser*/ MultipleValueWithQualityParser = new TransferCodingHeaderParser(true, CreateTransferCodingWithQuality);
    constructor(/*bool*/ supportsMultipleValues, /*Func<TransferCodingHeaderValue>*/ transferCodingCreator)
    {
        super(supportsMultipleValues);
        Debug.Assert(transferCodingCreator != null);
        _transferCodingCreator = transferCodingCreator;
    }
    /*int*/ GetParsedValueLength(/*string*/ value, /*int*/ startIndex, /*object*/ storeValue, /*object*/ parsedValue)
    {
        let temp = null;
        let $v = { value: set(value){ temp = value; } };
        /*int*/ let resultLength = TransferCodingHeaderValue.GetTransferCodingLength(value, startIndex, _transferCodingCreator, $v);
        parsedValue = temp;
        return resultLength;
    }
    /*TransferCodingHeaderValue*/ CreateTransferCoding()
    {
        new TransferCodingHeaderValue();
    }
    /*TransferCodingWithQualityHeaderValue*/ CreateTransferCodingWithQuality()
    {
        new TransferCodingWithQualityHeaderValue();
    }
}

class System_Net_Http_Headers_TransferCodingHeaderValue extends H5_IH5Class(System_ICloneable(object))
{
    /*UnvalidatedObjectCollection<NameValueHeaderValue>*/ _parameters = null;
    /*string*/ _value = null;
    /*string*/ get Value()
    {
        return _value;
    }
    /*ICollection<NameValueHeaderValue>*/ get Parameters()
    {
        return _parameters = _parameters = _parameters ?? new UnvalidatedObjectCollection_$1(NameValueHeaderValue);
    }
    constructor()
    {
        super();
    }
    constructor(/*TransferCodingHeaderValue*/ source)
    {
        super();
        Debug.Assert(source != null);
        _value = source._value;
        _parameters = source._parameters.Clone();
    }
    constructor(/*string*/ value)
    {
        super();
        HeaderUtilities.CheckValidToken(value);
        _value = value;
    }
    /*TransferCodingHeaderValue*/ Parse(/*string*/ input)
    {
        /*int*/ let index = 0;
        let $v = { value: set(value){ index = value; } };
        return TransferCodingHeaderValueTransferCodingHeaderParser.SingleValueParser.ParseValue(input, null, $v);
    }
    /*bool*/ TryParse(/*string*/ input, /*TransferCodingHeaderValue*/ parsedValue)
    {
        /*int*/ let index = 0;
        parsedValue = null;
        let $v = { value: set(value){ index = value; } };
        let output = null;
        let $v = { value: set(value){ output = value; } };
        if (TransferCodingHeaderParser.SingleValueParser.TryParseValue(input, null, $v, $v))
        {
            parsedValue = TransferCodingHeaderValueoutput;
            return true;
        }
        return false;
    }
    /*int*/ GetTransferCodingLength(/*string*/ input, /*int*/ startIndex, /*Func<TransferCodingHeaderValue>*/ transferCodingCreator, /*TransferCodingHeaderValue*/ parsedValue)
    {
        Debug.Assert(transferCodingCreator != null);
        Debug.Assert(startIndex >= 0);
        parsedValue = null;
        if (.IsNullOrEmpty(input) || startIndex >= input.Length)
        {
            return 0;
        }
        /*// Caller must remove leading whitespace. If not, we'll return 0.
            int*/ let valueLength = HttpRuleParser.GetTokenLength(input, startIndex);
        if (valueLength == 0)
        {
            return 0;
        }
        /*string*/ let value = input.Substring(startIndex, valueLength);
        /*int*/ let current = startIndex + valueLength;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        /*TransferCodingHeaderValue*/ let transferCodingHeader;
        if (current < input.Length && inputcurrent == ';')
        {
            transferCodingHeader = transferCodingCreator();
            transferCodingHeader._value  = value;
            current++;
            /*int*/ let parameterLength = NameValueHeaderValue.GetNameValueListLength(input, current, ';', UnvalidatedObjectCollection_$1transferCodingHeader.Parameters);
            if (parameterLength == 0)
            {
                return 0;
            }
            parsedValue = transferCodingHeader;
            return current + parameterLength - startIndex;
        }
        // We have a transfer coding without parameters.
            transferCodingHeader = transferCodingCreator();
        transferCodingHeader._value  = value;
        parsedValue = transferCodingHeader;
        return current - startIndex;
    }
    /*string*/ ToString()
    {
        /*StringBuilder*/ let sb = new StringBuilder();
        sb.Append(_value);
        NameValueHeaderValue.ToString(_parameters, ';', true, sb);
        return sb.ToString();
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        /*TransferCodingHeaderValue*/ let other = obj as TransferCodingHeaderValue;
        if (other == null)
        {
            return false;
        }
        return .Equals(_value, other._value, StringComparison.OrdinalIgnoreCase) && HeaderUtilities.AreEqualCollections(_parameters, other._parameters);
    }
    /*int*/ GetHashCode()
    {
        return StringComparer.OrdinalIgnoreCase.GetHashCode(_value) ^ NameValueHeaderValue.GetHashCode(_parameters);
    }
    /*// Implement ICloneable explicitly to allow derived types to "override" the implementation.
        object*/ Clone()
    {
        return new TransferCodingHeaderValue();
    }
}

class System_Net_Http_Headers_TransferCodingWithQualityHeaderValue extends H5_IH5Class(System_ICloneable(System_Net_Http_Headers_TransferCodingHeaderValue))
{
    /*double?*/ get Quality()
    {
        return HeaderUtilities.GetQuality(UnvalidatedObjectCollection_$1Parameters);
    }
    /*double?*/ set Quality(value)
    {
        HeaderUtilities.SetQuality(UnvalidatedObjectCollection_$1Parameters, value);
    }
    constructor()
    {
        super();
    }
    constructor(/*string*/ value)
    {
        super(value);
    }
    constructor(/*string*/ value, /*double*/ quality)
    {
        super(value);
        Quality = quality;
    }
    constructor(/*TransferCodingWithQualityHeaderValue*/ source)
    {
        super(source);
    }
    /*object*/ Clone()
    {
        return new TransferCodingWithQualityHeaderValue();
    }
    /*TransferCodingWithQualityHeaderValue*/ Parse(/*string*/ input)
    {
        /*int*/ let index = 0;
        return TransferCodingWithQualityHeaderValueTransferCodingHeaderParser.SingleValueWithQualityParser
        let $v = { value: set(value){ index = value; } };
.ParseValue(input, null, $v);
    }
    /*bool*/ TryParse(/*string*/ input, /*TransferCodingWithQualityHeaderValue*/ parsedValue)
    {
        /*int*/ let index = 0;
        parsedValue = null;
        let $v = { value: set(value){ index = value; } };
        let output = null;
        let $v = { value: set(value){ output = value; } };
        if (TransferCodingHeaderParser.SingleValueWithQualityParser.TryParseValue(input, null, $v, $v))
        {
            parsedValue = TransferCodingWithQualityHeaderValueoutput;
            return true;
        }
        return false;
    }
}

class System_Net_Http_Headers_UriHeaderParser extends System_Net_Http_Headers_HttpHeaderParser
{
    /*UriKind*/ _uriKind = null;
    /*UriHeaderParser*/ RelativeOrAbsoluteUriParser = new UriHeaderParser(UriKind.RelativeOrAbsolute);
    constructor(/*UriKind*/ uriKind)
    {
        super(false);
        _uriKind = uriKind;
    }
    /*bool*/ TryParseValue(/*string*/ value, /*object*/ storeValue, /*int*/ index, /*object*/ parsedValue)
    {
        parsedValue = null;
        if (.IsNullOrEmpty(value) || index == value.Length)
        {
            return false;
        }
        /*string*/ let uriString = value;
        if (index > 0)
        {
            uriString = value.Substring(index);
        }
        let uri = null;
        let $v = { value: set(value){ uri = value; } };
        if (UriExtension.TryCreate(uriString, _uriKind, $v))
        {
            // Some servers send the host names in Utf-8.
                uriString = DecodeUtf8FromString(uriString);
            let $v = { value: set(value){ uri = value; } };
            if (UriExtension.TryCreate(uriString, _uriKind, $v))
            {
                return false;
            }
        }
        index = value.Length;
        parsedValue = uri;
        return true;
    }
    /*string*/ DecodeUtf8FromString(/*string*/ input)
    {
        if (.IsNullOrWhiteSpace(input))
        {
            /*int*/ let possibleUtf8Pos = input.AsSpan().IndexOfAnyExceptInRange(0, 127);
            if (possibleUtf8Pos >= 0 && input.AsSpan(possibleUtf8Pos).ContainsAnyExceptInRange(0, 255))
            {
                /*Span<byte>*/ let rawBytes = new Array(input.Length);
                for(/*int*/ let i = 0; i < input.Length; i++)
                {
                    rawBytesi = inputi;
                });
                {
                    /*// We don't want '?' replacement characters, just fail.
                        Encoding*/ let decoder = Encoding.GetEncoding("utf-8");
                    return decoder.GetString(rawBytes.ToArray());
                }
ArgumentException                {
                }
            }
        }
        return input;
    }
    /*string*/ ToString(/*object*/ value)
    {
        Debug.Assert(value is Uri);
        /*Uri*/ let uri = Urivalue;
        if (uri.IsAbsoluteUri())
        {
            return uri.AbsoluteUri;
        }
        else 
        {
            return uri.ToString();
        }
    }
}

class System_Net_Http_Headers_ViaHeaderValue extends H5_IH5Class(System_ICloneable(object))
{
    /*string*/ _protocolName = null;
    /*string*/ _protocolVersion = null;
    /*string*/ _receivedBy = null;
    /*string*/ _comment = null;
    /*string*/ get ProtocolName()
    {
        return _protocolName;
    }
    /*string*/ get ProtocolVersion()
    {
        return _protocolVersion;
    }
    /*string*/ get ReceivedBy()
    {
        return _receivedBy;
    }
    /*string*/ get Comment()
    {
        return _comment;
    }
    constructor(/*string*/ protocolVersion, /*string*/ receivedBy, /*string*/ protocolName, /*string*/ comment, /*bool*/ _)
    {
        super();
        #if DEBUG
            // This constructor should only be used with already validated values.
            new ViaHeaderValue(protocolVersion, receivedBy, protocolName, comment);
#endif
            _protocolVersion = protocolVersion;
        _receivedBy = receivedBy;
        _protocolName = protocolName;
        _comment = comment;
    }
    constructor(/*string*/ protocolVersion, /*string*/ receivedBy)
    {
        super(protocolVersion, receivedBy, null, null);
    }
    constructor(/*string*/ protocolVersion, /*string*/ receivedBy, /*string*/ protocolName)
    {
        super(protocolVersion, receivedBy, protocolName, null);
    }
    constructor(/*string*/ protocolVersion, /*string*/ receivedBy, /*string*/ protocolName, /*string*/ comment)
    {
        super();
        HeaderUtilities.CheckValidToken(protocolVersion);
        CheckReceivedBy(receivedBy);
        if (.IsNullOrEmpty(protocolName))
        {
            HeaderUtilities.CheckValidToken(protocolName);
            _protocolName = protocolName;
        }
        if (.IsNullOrEmpty(comment))
        {
            HeaderUtilities.CheckValidComment(comment);
            _comment = comment;
        }
        _protocolVersion = protocolVersion;
        _receivedBy = receivedBy;
    }
    constructor(/*ViaHeaderValue*/ source)
    {
        super();
        Debug.Assert(source != null);
        _protocolName = source._protocolName;
        _protocolVersion = source._protocolVersion;
        _receivedBy = source._receivedBy;
        _comment = source._comment;
    }
    /*string*/ ToString()
    {
        /*var*/ let sb = new StringBuilder(256);
        if (.IsNullOrEmpty(_protocolName))
        {
            sb.Append(_protocolName);
            sb.Append('/');
        }
        sb.Append(_protocolVersion);
        sb.Append(' ');
        sb.Append(_receivedBy);
        if (.IsNullOrEmpty(_comment))
        {
            sb.Append(' ');
            sb.Append(_comment);
        }
        return sb.ToString();
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        obj instanceof ViaHeaderValue, other = obj && .Equals(_protocolVersion, other._protocolVersion, StringComparison.OrdinalIgnoreCase) && .Equals(_receivedBy, other._receivedBy, StringComparison.OrdinalIgnoreCase) && .Equals(_protocolName, other._protocolName, StringComparison.OrdinalIgnoreCase) && .Equals(_comment, other._comment, StringComparison.Ordinal);
    }
    /*int*/ GetHashCode()
    {
        HashCode.Combine(StringComparer.OrdinalIgnoreCase.GetHashCode(_protocolVersion), StringComparer.OrdinalIgnoreCase.GetHashCode(_receivedBy), _protocolName0StringComparer.OrdinalIgnoreCase.GetHashCode(_protocolName), _comment);
    }
    /*ViaHeaderValue*/ Parse(/*string*/ input)
    {
        /*int*/ let index = 0;
        let $v = { value: set(value){ index = value; } };
        return ViaHeaderValueGenericHeaderParser.SingleValueViaParser.ParseValue(input, null, $v);
    }
    /*bool*/ TryParse(/*string*/ input, /*ViaHeaderValue*/ parsedValue)
    {
        /*int*/ let index = 0;
        parsedValue = null;
        let $v = { value: set(value){ index = value; } };
        let output = null;
        let $v = { value: set(value){ output = value; } };
        if (GenericHeaderParser.SingleValueViaParser.TryParseValue(input, null, $v, $v))
        {
            parsedValue = ViaHeaderValueoutput;
            return true;
        }
        return false;
    }
    /*int*/ GetViaLength(/*string*/ input, /*int*/ startIndex, /*object*/ parsedValue)
    {
        Debug.Assert(startIndex >= 0);
        parsedValue = null;
        if (.IsNullOrEmpty(input) || startIndex >= input.Length)
        {
            return 0;
        }
        /*// Read <protocolName> and <protocolVersion> in '[<protocolName>/]<protocolVersion> <receivedBy> [<comment>]'
        let protocolName = null;
        let $v = { value: set(value){ protocolName = value; } };
        let protocolVersion = null;
        let $v = { value: set(value){ protocolVersion = value; } };
            int*/ let current = GetProtocolEndIndex(input, startIndex, $v, $v);
        if (current == 0 || current == input.Length)
        {
            return 0;
        }
        Debug.Assert(protocolVersion != null);
        /*// Read <receivedBy> in '[<protocolName>/]<protocolVersion> <receivedBy> [<comment>]'
            int*/ let receivedByLength = HttpRuleParser.GetHostLength(input, current, true);
        if (receivedByLength == 0)
        {
            return 0;
        }
        /*string*/ let receivedBy = input.Substring(current, receivedByLength);
        current += receivedByLength;
        current += HttpRuleParser.GetWhitespaceLength(input, current);
        /*string*/ let comment = null;
        if (current < input.Length && inputcurrent == '(')
        {
            let commentLength = null;
            let $v = { value: set(value){ commentLength = value; } };
            if (HttpRuleParser.GetCommentLength(input, current, $v) != HttpParseResult.Parsed)
            {
                return 0;
            }
            comment = input.Substring(current, commentLength);
            current += commentLength;
            current += HttpRuleParser.GetWhitespaceLength(input, current);
        }
        parsedValue = new ViaHeaderValue(protocolVersion, receivedBy, protocolName, comment, false);
        return current - startIndex;
    }
    /*int*/ GetProtocolEndIndex(/*string*/ input, /*int*/ startIndex, /*string*/ protocolName, /*string*/ protocolVersion)
    {
        // We have a string of the form '[<protocolName>/]<protocolVersion> <receivedBy> [<comment>]'. The first
            // token may either be the protocol name or protocol version. We'll only find out after reading the token
            // and by looking at the following character: If it is a '/' we just parsed the protocol name, otherwise
            // the protocol version.
            protocolName = null;
        protocolVersion = null;
        /*int*/ let current = startIndex;
        /*int*/ let protocolVersionOrNameLength = HttpRuleParser.GetTokenLength(input, current);
        if (protocolVersionOrNameLength == 0)
        {
            return 0;
        }
        current = startIndex + protocolVersionOrNameLength;
        /*int*/ let whitespaceLength = HttpRuleParser.GetWhitespaceLength(input, current);
        current += whitespaceLength;
        if (current == input.Length)
        {
            return 0;
        }
        if (inputcurrent == '/')
        {
            // We parsed the protocol name
                protocolName = input.Substring(startIndex, protocolVersionOrNameLength);
            current++;
            current += HttpRuleParser.GetWhitespaceLength(input, current);
            protocolVersionOrNameLength = HttpRuleParser.GetTokenLength(input, current);
            if (protocolVersionOrNameLength == 0)
            {
                return 0;
            }
            protocolVersion = input.Substring(current, protocolVersionOrNameLength);
            current += protocolVersionOrNameLength;
            whitespaceLength = HttpRuleParser.GetWhitespaceLength(input, current);
            current += whitespaceLength;
        }
        else 
        {
            protocolVersion = input.Substring(startIndex, protocolVersionOrNameLength);
        }
        if (whitespaceLength == 0)
        {
            return 0;
        }
        return current;
    }
    /*object*/ Clone()
    {
        return new ViaHeaderValue();
    }
    /*void*/ CheckReceivedBy(/*string*/ receivedBy)
    {
        if (.IsNullOrEmpty(receivedBy))
        throw new ArgumentException(nameof(receivedBy));
        if (HttpRuleParser.GetHostLength(receivedBy, 0, true) != receivedBy.Length)
        {
            throw new FormatException("net_http_headers_invalid_value");
        }
    }
}

class System_Net_Http_Headers_WarningHeaderValue extends H5_IH5Class(System_ICloneable(object))
{
    /*int*/ _code = null;
    /*string*/ _agent = null;
    /*string*/ _text = null;
    /*DateTimeOffset*/ _date = null;
    /*bool*/ _dateHasValue = null;
    /*int*/ get Code()
    {
        return _code;
    }
    /*string*/ get Agent()
    {
        return _agent;
    }
    /*string*/ get Text()
    {
        return _text;
    }
    /*DateTimeOffset?*/ get Date()
    {
        return _dateHasValue_dateDateTimeOffsetnull;
    }
    constructor(/*int*/ code, /*string*/ agent, /*string*/ text, /*DateTimeOffset?*/ date)
    {
        super();
        #if DEBUG
            // This constructor should only be used with already validated values.
            new WarningHeaderValue(code, agent, text);
#endif
            _code = code;
        _agent = agent;
        _text = text;
        _date = date.GetValueOrDefault();
        _dateHasValue = date.HasValue;
    }
    constructor(/*int*/ code, /*string*/ agent, /*string*/ text)
    {
        super();
        CheckCode(code);
        CheckAgent(agent);
        HeaderUtilities.CheckValidQuotedString(text);
        _code = code;
        _agent = agent;
        _text = text;
    }
    constructor(/*int*/ code, /*string*/ agent, /*string*/ text, /*DateTimeOffset*/ date)
    {
        super();
        CheckCode(code);
        CheckAgent(agent);
        HeaderUtilities.CheckValidQuotedString(text);
        _code = code;
        _agent = agent;
        _text = text;
        _date = date;
        _dateHasValue = true;
    }
    constructor(/*WarningHeaderValue*/ source)
    {
        super();
        Debug.Assert(source != null);
        _code = source._code;
        _agent = source._agent;
        _text = source._text;
        _date = source._date;
        _dateHasValue = source._dateHasValue;
    }
    /*string*/ ToString()
    {
        /*var*/ let sb = new StringBuilder();
        // Warning codes are always 3 digits according to RFC2616
            sb.Append(_code.ToString("000"));
        sb.Append(' ');
        sb.Append(_agent);
        sb.Append(' ');
        sb.Append(_text);
        if (_dateHasValue)
        {
            sb.Append(" \"");
            sb.Append(_date.ToString("r"));
            sb.Append('\"');
        }
        return sb.ToString();
    }
    /*bool*/ Equals(/*object*/ obj)
    {
        obj instanceof WarningHeaderValue, other = obj && _code == other._code  && .Equals(_agent, other._agent, StringComparison.OrdinalIgnoreCase) && .Equals(_text, other._text, StringComparison.Ordinal) && _dateHasValue == other._dateHasValue  && _date == other._date;
    }
    /*int*/ GetHashCode()
    {
        HashCode.Combine(_code, StringComparer.OrdinalIgnoreCase.GetHashCode(_agent), _text, _dateHasValue, _date);
    }
    /*WarningHeaderValue*/ Parse(/*string*/ input)
    {
        /*int*/ let index = 0;
        let $v = { value: set(value){ index = value; } };
        return WarningHeaderValueGenericHeaderParser.SingleValueWarningParser.ParseValue(input, null, $v);
    }
    /*bool*/ TryParse(/*string*/ input, /*WarningHeaderValue*/ parsedValue)
    {
        /*int*/ let index = 0;
        parsedValue = null;
        let $v = { value: set(value){ index = value; } };
        let output = null;
        let $v = { value: set(value){ output = value; } };
        if (GenericHeaderParser.SingleValueWarningParser.TryParseValue(input, null, $v, $v))
        {
            parsedValue = WarningHeaderValueoutput;
            return true;
        }
        return false;
    }
    /*int*/ GetWarningLength(/*string*/ input, /*int*/ startIndex, /*object*/ parsedValue)
    {
        Debug.Assert(startIndex >= 0);
        parsedValue = null;
        if (.IsNullOrEmpty(input) || startIndex >= input.Length)
        {
            return 0;
        }
        /*// Read <code> in '<code> <agent> <text> ["<date>"]'
            int*/ let current = startIndex;
        let $v = { value: set(value){ current = value; } };
        let code = null;
        let $v = { value: set(value){ code = value; } };
        if (TryReadCode(input, $v, $v))
        {
            return 0;
        }
        let $v = { value: set(value){ current = value; } };
        let agent = null;
        let $v = { value: set(value){ agent = value; } };
        if (TryReadAgent(input, $v, $v))
        {
            return 0;
        }
        /*// Read <text> in '<code> <agent> <text> ["<date>"]'
            int*/ let textStartIndex = current;
        let textLength = null;
        let $v = { value: set(value){ textLength = value; } };
        if (HttpRuleParser.GetQuotedStringLength(input, current, $v) != HttpParseResult.Parsed)
        {
            return 0;
        }
        /*string*/ let text = input.Substring(textStartIndex, textLength);
        current += textLength;
        let $v = { value: set(value){ current = value; } };
        let date = null;
        let $v = { value: set(value){ date = value; } };
        if (TryReadDate(input, $v, $v))
        {
            return 0;
        }
        parsedValue = new WarningHeaderValue(code, agent, text, date);
        return current - startIndex;
    }
    /*bool*/ TryReadAgent(/*string*/ input, /*int*/ current, /*string*/ agent)
    {
        agent = null;
        /*int*/ let agentLength = HttpRuleParser.GetHostLength(input, current, true);
        if (agentLength == 0)
        {
            return false;
        }
        agent = input.Substring(current, agentLength);
        current += agentLength;
        /*int*/ let whitespaceLength = HttpRuleParser.GetWhitespaceLength(input, current);
        current += whitespaceLength;
        if (whitespaceLength == 0 || current == input.Length)
        {
            return false;
        }
        return true;
    }
    /*bool*/ TryReadCode(/*string*/ input, /*int*/ current, /*int*/ code)
    {
        code = 0;
        /*int*/ let codeLength = HttpRuleParser.GetNumberLength(input, current, false);
        if (codeLength == 0 || codeLength > 3)
        {
            return false;
        }
        let $v = { value: set(value){ code = value; } };
        if (HeaderUtilities.TryParseInt32(input, current, codeLength, $v))
        {
            Debug.Fail("Unable to parse value even though it was parsed as <=3 digits string. Input: '" + input + "', Current: " + current + ", CodeLength: " + codeLength);
            return false;
        }
        current += codeLength;
        /*int*/ let whitespaceLength = HttpRuleParser.GetWhitespaceLength(input, current);
        current += whitespaceLength;
        if (whitespaceLength == 0 || current == input.Length)
        {
            return false;
        }
        return true;
    }
    /*bool*/ TryReadDate(/*string*/ input, /*int*/ current, /*DateTimeOffset?*/ date)
    {
        date = null;
        /*// Make sure we have at least one whitespace between <text> and <date> (if we have <date>)
            int*/ let whitespaceLength = HttpRuleParser.GetWhitespaceLength(input, current);
        current += whitespaceLength;
        if (current < input.Length && inputcurrent == '"')
        {
            if (whitespaceLength == 0)
            {
                return false;
            }
            current++;
            /*// Find the closing '"'
                int*/ let dateStartIndex = current;
            /*int*/ let quote = input.AsSpan(current).IndexOf('"');
            if (quote <= 0)
            {
                return false;
            }
            current += quote;
            let temp = null;
            let $v = { value: set(value){ temp = value; } };
            if (DateTimeOffset.TryParse(input.AsSpan(dateStartIndex, current - dateStartIndex), $v))
            {
                return false;
            }
            date = temp;
            current++;
            current += HttpRuleParser.GetWhitespaceLength(input, current);
        }
        return true;
    }
    /*object*/ Clone()
    {
        return new WarningHeaderValue();
    }
    /*void*/ CheckCode(/*int*/ code)
    {
        if (code < 0 || code > 999)
        throw new ArgumentOutOfRangeException();
    }
    /*void*/ CheckAgent(/*string*/ agent)
    {
        if (.IsNullOrEmpty(agent))
        throw new ArgumentException();
        if (HttpRuleParser.GetHostLength(agent, 0, true) != agent.Length)
        {
            throw new FormatException("net_http_headers_invalid_value");
        }
    }
}

const Microsoft_AspNetCore_Components_CascadingValue$_1 = (TValue) => class extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
        TValue = $_TValue;
    }
}

class Microsoft_AspNetCore_Components_DynamicComponent extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
    }
}

class Microsoft_AspNetCore_Components_ErrorBoundaryBase extends Microsoft_AspNetCore_Components_IErrorBoundary(Microsoft_AspNetCore_Components_ComponentBase)
{
    constructor()
    {
        super();
    }
}

class Microsoft_AspNetCore_Components_LayoutComponentBase extends Microsoft_AspNetCore_Components_IComponent(Microsoft_AspNetCore_Components_ILayoutComponent(Microsoft_AspNetCore_Components_ComponentBase))
{
    constructor()
    {
        super();
    }
}

class Microsoft_AspNetCore_Components_LayoutView extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
    }
}

class Microsoft_AspNetCore_Components_PageTitle extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ __frame0, { /*object*/ __key = null})
    {
        titleWrapper = __frame0.Element("span", function(/*UIElementAttribute*/ __attribute)
        {
            __attribute.Set("style", "display:none");
        }, function(/**/ __frame1, /**/ __key1)
        {
            __frame1.Content(ChildContent, { key : __key1, sequenceNumber : 642790521 });
        }, { sequenceNumber : 642790522 });
    }
}

class Microsoft_AspNetCore_Components_RouteView extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
    }
    /*void*/ InjectServices(/*IServiceProvider*/ provider)
    {
        NavigationManager = provider.GetRequiredService(Microsoft.AspNetCore.Components.NavigationManager);
    }
}

class Microsoft_AspNetCore_Components_Authorization_AuthorizeRouteView extends Microsoft_AspNetCore_Components_RouteView
{
    constructor()
    {
        super();
    }
    /*void*/ CascadeParameters()
    {
        RequestCascadingParameter_$1(System.Threading.Tasks.Task<Microsoft.AspNetCore.Components.Authorization.AuthenticationState>, function(/**/ e)
        {
ExistingCascadedAuthenticationState = e        }, { cascadingParameterName : null });
        super.CascadeParameters();
    }
}

class Microsoft_AspNetCore_Components_Authorization_AuthorizeView extends Microsoft_AspNetCore_Components_Authorization_AuthorizeViewCore
{
    constructor()
    {
        super();
    }
}

class Microsoft_AspNetCore_Components_Authorization_AuthorizeViewCore extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
    }
    /*void*/ InjectServices(/*IServiceProvider*/ provider)
    {
        AuthorizationPolicyProvider = provider.GetRequiredService(Microsoft.AspNetCore.Authorization.IAuthorizationPolicyProvider);
        AuthorizationService = provider.GetRequiredService(Microsoft.AspNetCore.Authorization.IAuthorizationService);
    }
    /*void*/ CascadeParameters()
    {
        RequestCascadingParameter_$1(System.Threading.Tasks.Task<Microsoft.AspNetCore.Components.Authorization.AuthenticationState>, function(/**/ e)
        {
AuthenticationState = e        }, { cascadingParameterName : null });
        super.CascadeParameters();
    }
}

class Microsoft_AspNetCore_Components_Authorization_CascadingAuthenticationState extends System_IDisposable(Microsoft_AspNetCore_Components_ComponentBase)
{
    constructor()
    {
        super();
    }
    /*void*/ InjectServices(/*IServiceProvider*/ provider)
    {
        AuthenticationStateProvider = provider.GetRequiredService(Microsoft.AspNetCore.Components.Authorization.AuthenticationStateProvider);
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ __frame0, { /*object*/ __key = null})
    {
        __frame0.Component(CascadingValue<System.Threading.Tasks.Task<AuthenticationState>>, function(/**/ __component0)
        {
            __component0.Value  = _currentAuthenticationStateTask;
            __component0.ChildContent  = ChildContent;
        }, { sequenceNumber : 462571063 });
    }
}

class Microsoft_AspNetCore_Components_Forms_DataAnnotationsValidator extends System_IDisposable(Microsoft_AspNetCore_Components_ComponentBase)
{
    constructor()
    {
        super();
    }
    /*void*/ InjectServices(/*IServiceProvider*/ provider)
    {
        ServiceProvider = provider.GetRequiredService(System.IServiceProvider);
    }
    /*void*/ CascadeParameters()
    {
        RequestCascadingParameter_$1(Microsoft.AspNetCore.Components.Forms.EditContext, function(/**/ e)
        {
CurrentEditContext = e        }, { cascadingParameterName : null });
        super.CascadeParameters();
    }
}

class Microsoft_AspNetCore_Components_Routing_FocusOnNavigate extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
    }
}

class Microsoft_AspNetCore_Components_Routing_NavigationLock extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
    }
    /*void*/ InjectServices(/*IServiceProvider*/ provider)
    {
        NavigationManager = provider.GetRequiredService(Microsoft.AspNetCore.Components.NavigationManager);
    }
}

class Microsoft_AspNetCore_Components_Routing_NavLink extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
    }
    /*void*/ InjectServices(/*IServiceProvider*/ provider)
    {
        NavigationManager = provider.GetRequiredService(Microsoft.AspNetCore.Components.NavigationManager);
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ __frame0, { /*object*/ __key = null})
    {
        __frame0.Element("a", function(/*UIElementAttribute*/ __attribute)
        {
            __attribute.Set("href", "href");
            __attribute.Set("class", CssClass);
            __attribute.Set("aria-current", _isActive"page"null);
        }, function(/**/ __frame1, /**/ __key1)
        {
            __frame1.Content(ChildContent, { key : __key1, sequenceNumber : 2124730914 });
        }, { sequenceNumber : 2124730913 });
    }
}

class Microsoft_AspNetCore_Components_Routing_Router extends System_IDisposable(Microsoft_AspNetCore_Components_ComponentBase)
{
    constructor()
    {
        super();
    }
    /*void*/ InjectServices(/*IServiceProvider*/ provider)
    {
        NavigationManager = provider.GetRequiredService(Microsoft.AspNetCore.Components.NavigationManager);
        NavigationInterception = provider.GetRequiredService(Microsoft.AspNetCore.Components.Routing.INavigationInterception);
        ScrollToLocationHash = provider.GetService(Microsoft.AspNetCore.Components.Routing.IScrollToLocationHash);
        ServiceProvider = provider.GetRequiredService(System.IServiceProvider);
    }
}

class Microsoft_AspNetCore_Components_Web_ErrorBoundary extends Microsoft_AspNetCore_Components_ErrorBoundaryBase
{
    constructor()
    {
        super();
    }
    /*void*/ InjectServices(/*IServiceProvider*/ provider)
    {
        ErrorBoundaryLogger = provider.GetRequiredService(Microsoft.AspNetCore.Components.Web.IErrorBoundaryLogger);
    }
}

class Microsoft_AspNetCore_Components_Forms_AntiforgeryToken extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
    }
    /*void*/ InjectServices(/*IServiceProvider*/ provider)
    {
        Services = provider.GetRequiredService(System.IServiceProvider);
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ __frame0, { /*object*/ __key = null})
    {
        if (_requestToken != null)
        {
            __frame0.Element("input", function(/*UIElementAttribute*/ __attribute)
            {
                __attribute.Set("type", "hidden");
                __attribute.Set("name", _requestToken.FormFieldName);
                __attribute.Set("value", _requestToken.Value);
            }, null, { sequenceNumber : 849167930 });
        }
    }
}

class Microsoft_AspNetCore_Components_Forms_EditForm extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
    }
    /*void*/ CascadeParameters()
    {
        RequestCascadingParameter_$1(Microsoft.AspNetCore.Components.Forms.FormMappingContext, function(/**/ e)
        {
MappingContext = e        }, { cascadingParameterName : null });
        super.CascadeParameters();
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ __frame0, { /*object*/ __key = null})
    {
        __frame0.Element("form", function(/*UIElementAttribute*/ __attribute)
        {
            __attribute.Set("method", MappingContext != null"post"null);
            __attribute.Set("data-enhance", Enhance""null);
            __attribute.Set("@attributes", .As(IReadOnlyDictionary<string, object>));
            __attribute.Set("@onsubmit", EventCallback.Factory.Create(, _handleSubmitDelegate));
        }, null, { key : _editContext.GetHashCode(), sequenceNumber : 1156675293 });
        __frame0.Component(CascadingValue<EditContext>, function(/**/ __component0)
        {
            __component0.IsFixed  = true;
            __component0.Value  = _editContext;
            __component0.ChildContent  = function(/**/ __frame1, /**/ __key1)
            {
                __frame1.Content(ChildContentInvoke(_editContext), { key : __key1, sequenceNumber : 1156675292 });
            };
        }, { sequenceNumber : 1156675291 });
    }
}

const Microsoft_AspNetCore_Components_Forms_InputBase$_1 = (TValue) => class extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
        TValue = $_TValue;
    }
    /*void*/ CascadeParameters()
    {
        RequestCascadingParameter_$1(Microsoft.AspNetCore.Components.Forms.EditContext, function(/**/ e)
        {
CascadedEditContext = e        }, { cascadingParameterName : null });
        RequestCascadingParameter_$1(Microsoft.AspNetCore.Components.Forms.HtmlFieldPrefix, function(/**/ e)
        {
FieldPrefix = e        }, { cascadingParameterName : null });
        super.CascadeParameters();
    }
}

class Microsoft_AspNetCore_Components_Forms_InputCheckbox extends Microsoft_AspNetCore_Components_Forms_InputBase(bool)
{
    constructor()
    {
        super();
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ __frame0, { /*object*/ __key = null})
    {
        Element = __frame0.Element("input", function(/*UIElementAttribute*/ __attribute)
        {
            __attribute.Set("type", "checkbox");
            __attribute.Set("@attributes", .As(IDictionary<string, object>));
            __attribute.Set("name", NameAttributeValue);
            __attribute.Set("class", CssClass);
            __attribute.Set("checked", BindConverter.FormatValue(CurrentValue));
            __attribute.Set("value", .TrueString);
            /*var*/ let bindGetValue1 = CurrentValue;
            __attribute.Set("value", bindGetValue1);
            __attribute.Set("@onchange", EventCallback.Factory.CreateBinder(, function(/**/ __value)
            {
CurrentValue = __value            }, bindGetValue1));
        }, null, { sequenceNumber : 1710570564 });
    }
}

const Microsoft_AspNetCore_Components_Forms_InputDate$_1 = (TValue) => class extends Microsoft_AspNetCore_Components_Forms_InputBase(TValue)
{
    constructor()
    {
        super();
        TValue = $_TValue;
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ __frame0, { /*object*/ __key = null})
    {
        Element = __frame0.Element("input", function(/*UIElementAttribute*/ __attribute)
        {
            __attribute.Set("type", _typeAttributeValue);
            __attribute.Set("@attributes", .As(IDictionary<string, object>));
            __attribute.Set("name", NameAttributeValue);
            __attribute.Set("class", CssClass);
            /*var*/ let bindGetValue1 = CurrentValueAsString;
            __attribute.Set("value", bindGetValue1);
            __attribute.Set("@onchange", EventCallback.Factory.CreateBinder(, function(/**/ __value)
            {
CurrentValueAsString = __value            }, bindGetValue1));
        }, null, { sequenceNumber : 341615739 });
    }
}

class Microsoft_AspNetCore_Components_Forms_InputFile extends Microsoft_AspNetCore_Components_Forms_IInputFileJsCallbacks(Microsoft_AspNetCore_Components_ComponentBase)
{
    constructor()
    {
        super();
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ __frame0, { /*object*/ __key = null})
    {
        Element = __frame0.Element("input", function(/*UIElementAttribute*/ __attribute)
        {
            __attribute.Set("type", "file");
            __attribute.Set("@attributes", .As(IReadOnlyDictionary<string, object>));
        }, null, { sequenceNumber : 1435320626 });
    }
}

const Microsoft_AspNetCore_Components_Forms_InputNumber$_1 = (TValue) => class extends Microsoft_AspNetCore_Components_Forms_InputBase(TValue)
{
    constructor()
    {
        super();
        TValue = $_TValue;
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ __frame0, { /*object*/ __key = null})
    {
        Element = __frame0.Element("input", function(/*UIElementAttribute*/ __attribute)
        {
            __attribute.Set("type", "number");
            __attribute.Set("step", _stepAttributeValue);
            __attribute.Set("@attributes", .As(IReadOnlyDictionary<string, object>));
            __attribute.Set("name", NameAttributeValue);
            __attribute.Set("class", CssClass);
            /*var*/ let bindGetValue1 = CurrentValueAsString;
            __attribute.Set("value", bindGetValue1);
            __attribute.Set("@onchange", EventCallback.Factory.CreateBinder(, function(/**/ __value)
            {
CurrentValueAsString = __value            }, bindGetValue1));
        }, null, { sequenceNumber : 705009280 });
    }
}

const Microsoft_AspNetCore_Components_Forms_InputRadio$_1 = (TValue) => class extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
        TValue = $_TValue;
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ __frame0, { /*object*/ __key = null})
    {
        Debug.Assert(Context != null);
        Element = __frame0.Element("input", function(/*UIElementAttribute*/ __attribute)
        {
            __attribute.Set("type", "ratio");
            __attribute.Set("@attributes", .As(IReadOnlyDictionary<string, object>));
            __attribute.Set("checked", Context.CurrentValueEquals(Value) == trueGetToggledTrueValue()null);
            __attribute.Set("class", AttributeUtilities.CombineClassNames(, Context.FieldClass));
            __attribute.Set("value", BindConverter.FormatValue(ValueToString()));
            __attribute.Set("@onchange", EventCallback.Factory.Create(, Context.ChangeEventCallback));
        }, null, { sequenceNumber : 999634640 });
    }
}

const Microsoft_AspNetCore_Components_Forms_InputRadioGroup$_1 = (TValue) => class extends Microsoft_AspNetCore_Components_IInputRadioValueProvider(Microsoft_AspNetCore_Components_Forms_InputBase)
{
    constructor()
    {
        super();
        TValue = $_TValue;
    }
    /*void*/ CascadeParameters()
    {
        RequestCascadingParameter_$1(Microsoft.AspNetCore.Components.Forms.InputRadioContext, function(/**/ e)
        {
CascadedContext = e        }, { cascadingParameterName : null });
        super.CascadeParameters();
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ __frame0, { /*object*/ __key = null})
    {
        Debug.Assert(_context != null);
        __frame0.Component(CascadingValue<InputRadioContext>, function(/**/ __component0)
        {
            __component0.Value  = _context;
            __component0.ChildContent  = function(/**/ __frame1, /**/ __key1)
            {
                __frame1.Content(ChildContent, { key : __key1, sequenceNumber : 206106044 });
            };
        }, { sequenceNumber : 206106045 });
    }
}

const Microsoft_AspNetCore_Components_Forms_InputSelect$_1 = (TValue) => class extends Microsoft_AspNetCore_Components_Forms_InputBase(TValue)
{
    constructor()
    {
        super();
        TValue = $_TValue;
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ __frame0, { /*object*/ __key = null})
    {
        if (_isMultipleSelect)
        {
            Element = __frame0.Element("select", function(/*UIElementAttribute*/ __attribute)
            {
                __attribute.Set("@attributes", .As(IReadOnlyDictionary<string, object>));
                __attribute.Set("name", NameAttributeValue);
                __attribute.Set("class", CssClass);
                __attribute.Set("multiple", _isMultipleSelect);
                __attribute.Set("value", @BindConverter.FormatValue(CurrentValue)ToString());
                __attribute.Set("@onchange", EventCallback.Factory.CreateBinder(, Action_$1SetCurrentValueAsStringArray, default));
            }, null, { sequenceNumber : 1266772124 });
        }
        else 
        {
            Element = __frame0.Element("select", function(/*UIElementAttribute*/ __attribute)
            {
                __attribute.Set("@attributes", .As(IReadOnlyDictionary<string, object>));
                __attribute.Set("name", NameAttributeValue);
                __attribute.Set("class", CssClass);
                __attribute.Set("multiple", _isMultipleSelect);
                /*var*/ let bindGetValue1 = @CurrentValueAsString;
                __attribute.Set("value", bindGetValue1);
                __attribute.Set("@onchange", EventCallback.Factory.CreateBinder(, function(/**/ __value)
                {
@CurrentValueAsString = __value                }, bindGetValue1));
            }, null, { sequenceNumber : 1266772125 });
        }
    }
}

class Microsoft_AspNetCore_Components_Forms_InputText extends Microsoft_AspNetCore_Components_Forms_InputBase(string)
{
    constructor()
    {
        super();
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ __frame0, { /*object*/ __key = null})
    {
        Element = __frame0.Element("input", function(/*UIElementAttribute*/ __attribute)
        {
            __attribute.Set("@attributes", .As(IReadOnlyDictionary<string, object>));
            __attribute.Set("name", NameAttributeValue);
            __attribute.Set("class", CssClass);
            /*var*/ let bindGetValue1 = @CurrentValueAsString;
            __attribute.Set("value", bindGetValue1);
            __attribute.Set("@onchange", EventCallback.Factory.CreateBinder(, function(/**/ __value)
            {
@CurrentValueAsString = __value            }, bindGetValue1));
        }, null, { sequenceNumber : 102257638 });
    }
}

class Microsoft_AspNetCore_Components_Forms_InputTextArea extends Microsoft_AspNetCore_Components_Forms_InputBase(string)
{
    constructor()
    {
        super();
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ __frame0, { /*object*/ __key = null})
    {
        Element = __frame0.Element("textarea", function(/*UIElementAttribute*/ __attribute)
        {
            __attribute.Set("@attributes", .As(IReadOnlyDictionary<string, object>));
            __attribute.Set("name", NameAttributeValue);
            __attribute.Set("class", CssClass);
            /*var*/ let bindGetValue1 = @CurrentValueAsString;
            __attribute.Set("value", bindGetValue1);
            __attribute.Set("@onchange", EventCallback.Factory.CreateBinder(, function(/**/ __value)
            {
@CurrentValueAsString = __value            }, bindGetValue1));
        }, null, { sequenceNumber : 2024173545 });
    }
}

const Microsoft_AspNetCore_Components_Forms_ValidationMessage$_1 = (TValue) => class extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
        TValue = $_TValue;
    }
    /*void*/ CascadeParameters()
    {
        RequestCascadingParameter_$1(Microsoft.AspNetCore.Components.Forms.EditContext, function(/**/ e)
        {
CurrentEditContext = e        }, { cascadingParameterName : null });
        super.CascadeParameters();
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ __frame0, { /*object*/ __key = null})
    {
        BlazorJs.forEach(CurrentEditContext.GetValidationMessages(_fieldIdentifier), function(message, $_i)
        {
            __frame0.Element("div", function(/*UIElementAttribute*/ __attribute)
            {
                __attribute.Set("class", "validation-message");
                __attribute.Set("@attributes", .As(IReadOnlyDictionary<string, object>));
            }, function(/**/ __frame1, /**/ __key1)
            {
                __frame1.Content(message, { key : __key1, sequenceNumber : 1170966791 });
            }, { key : message, sequenceNumber : 1170966792 });
        });
    }
}

class Microsoft_AspNetCore_Components_Forms_ValidationSummary extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
    }
    /*void*/ CascadeParameters()
    {
        RequestCascadingParameter_$1(Microsoft.AspNetCore.Components.Forms.EditContext, function(/**/ e)
        {
CurrentEditContext = e        }, { cascadingParameterName : null });
        super.CascadeParameters();
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ __frame0, { /*object*/ __key = null})
    {
        /*var*/ let validationMessages = ModelCurrentEditContext.GetValidationMessages()CurrentEditContext.GetValidationMessages(new FieldIdentifier(Model, .Empty));
        if (validationMessages.Any())
        {
            __frame0.Element("ul", function(/*UIElementAttribute*/ __attribute)
            {
                __attribute.Set("class", "validation-errors");
                __attribute.Set("@attributes", .As(IReadOnlyDictionary<string, object>));
            }, function(/**/ __frame1, /**/ __key1)
            {
                BlazorJs.forEach(validationMessages, function(error, $_i)
                {
                    __frame1.Element("li", function(/*UIElementAttribute*/ __attribute)
                    {
                        __attribute.Set("class", "validation-message");
                    }, function(/**/ __frame2, /**/ __key2)
                    {
                        __frame2.Content(error, { key : __key2, sequenceNumber : 1069535702 });
                    }, { key : error, sequenceNumber : 1069535701 });
                });
            }, { sequenceNumber : 1069535700 });
        }
    }
}

const Microsoft_AspNetCore_Components_Web_Virtualization_Virtualize$_1 = (TItem) => class extends Microsoft_AspNetCore_Components_Web_Virtualization_IVirtualizeJsCallbacks(Microsoft_AspNetCore_Components_ComponentBase)
{
    constructor()
    {
        super();
        TItem = $_TItem;
    }
}













class BlazorJs_Core_Components_LiteRouting_LiteRouter extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
    }
    /*void*/ InjectServices(/*IServiceProvider*/ provider)
    {
        Navigation = provider.GetRequiredService(Microsoft.AspNetCore.Components.NavigationManager);
    }
    /*void*/ BuildRenderTree(/*IUIFrame*/ __frame0, { /*object*/ __key = null})
    {
        if (route != null)
        {
            __frame0.Content(Found(), { sequenceNumber : 1752383925 });
        }
        else 
        {
            __frame0.Content(NotFound, { sequenceNumber : 1752383926 });
        }
    }
}

class Microsoft_AspNetCore_Components_Sections_SectionContent extends System_IDisposable(Microsoft_AspNetCore_Components_IComponent(Microsoft_AspNetCore_Components_ComponentBase))
{
    constructor()
    {
        super();
    }
}

class Microsoft_AspNetCore_Components_Forms_Mapping_FormMappingValidator extends Microsoft_AspNetCore_Components_ComponentBase
{
    constructor()
    {
        super();
    }
    /*void*/ CascadeParameters()
    {
        RequestCascadingParameter_$1(Microsoft.AspNetCore.Components.Forms.FormMappingContext, function(/**/ e)
        {
MappingContext = e        }, { cascadingParameterName : null });
        super.CascadeParameters();
    }
}
